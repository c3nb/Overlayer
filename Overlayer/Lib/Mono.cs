// These should be defined as part of your build process,
// but if you want to test them quickly...
// #define MONOMOD_RUNTIMEDETOUR_NET_SCAN_MANUAL
// #define MONOMOD_RUNTIMEDETOUR_NET_SCAN_AUTO
// Default to automatic only.
#if !MONOMOD_RUNTIMEDETOUR_NET_SCAN_MANUAL && !MONOMOD_RUNTIMEDETOUR_NET_SCAN_AUTO
#define MONOMOD_RUNTIMEDETOUR_NET_SCAN_AUTO
#endif
#pragma warning disable
#pragma message disable
using System;
using System.Text;
using System.Threading;
using Mono.Collections.Generic;
using MD = Mono.Cecil.Metadata;
using System.IO;
using System.Globalization;
using System.Security.Cryptography;
using System.Collections.Generic;
using System.IO.Compression;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using RVA = System.UInt32; 
using RID = System.UInt32;
using CodedRID = System.UInt32;
using ModuleRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using TypeRefRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32>;
using TypeDefRow = Mono.Cecil.Metadata.Row<Mono.Cecil.TypeAttributes, System.UInt32, System.UInt32, System.UInt32, System.UInt32, System.UInt32>;
using FieldRow = Mono.Cecil.Metadata.Row<Mono.Cecil.FieldAttributes, System.UInt32, System.UInt32>;
using MethodRow = Mono.Cecil.Metadata.Row<System.UInt32, Mono.Cecil.MethodImplAttributes, Mono.Cecil.MethodAttributes, System.UInt32, System.UInt32, System.UInt32>;
using ParamRow = Mono.Cecil.Metadata.Row<Mono.Cecil.ParameterAttributes, System.UInt16, System.UInt32>;
using InterfaceImplRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using MemberRefRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32>;
using ConstantRow = Mono.Cecil.Metadata.Row<Mono.Cecil.Metadata.ElementType, System.UInt32, System.UInt32>;
using CustomAttributeRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32>;
using FieldMarshalRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using DeclSecurityRow = Mono.Cecil.Metadata.Row<Mono.Cecil.SecurityAction, System.UInt32, System.UInt32>;
using ClassLayoutRow = Mono.Cecil.Metadata.Row<System.UInt16, System.UInt32, System.UInt32>;
using FieldLayoutRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using EventMapRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using EventRow = Mono.Cecil.Metadata.Row<Mono.Cecil.EventAttributes, System.UInt32, System.UInt32>;
using PropertyMapRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using PropertyRow = Mono.Cecil.Metadata.Row<Mono.Cecil.PropertyAttributes, System.UInt32, System.UInt32>;
using MethodSemanticsRow = Mono.Cecil.Metadata.Row<Mono.Cecil.MethodSemanticsAttributes, System.UInt32, System.UInt32>;
using MethodImplRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32>;
using ImplMapRow = Mono.Cecil.Metadata.Row<Mono.Cecil.PInvokeAttributes, System.UInt32, System.UInt32, System.UInt32>;
using FieldRVARow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using AssemblyRow = Mono.Cecil.Metadata.Row<Mono.Cecil.AssemblyHashAlgorithm, System.UInt16, System.UInt16, System.UInt16, System.UInt16, Mono.Cecil.AssemblyAttributes, System.UInt32, System.UInt32, System.UInt32>;
using AssemblyRefRow = Mono.Cecil.Metadata.Row<System.UInt16, System.UInt16, System.UInt16, System.UInt16, Mono.Cecil.AssemblyAttributes, System.UInt32, System.UInt32, System.UInt32, System.UInt32>;
using FileRow = Mono.Cecil.Metadata.Row<Mono.Cecil.FileAttributes, System.UInt32, System.UInt32>;
using ExportedTypeRow = Mono.Cecil.Metadata.Row<Mono.Cecil.TypeAttributes, System.UInt32, System.UInt32, System.UInt32, System.UInt32>;
using ManifestResourceRow = Mono.Cecil.Metadata.Row<System.UInt32, Mono.Cecil.ManifestResourceAttributes, System.UInt32, System.UInt32>;
using NestedClassRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using GenericParamRow = Mono.Cecil.Metadata.Row<System.UInt16, Mono.Cecil.GenericParameterAttributes, System.UInt32, System.UInt32>;
using MethodSpecRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using GenericParamConstraintRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using DocumentRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32, System.UInt32>;
using MethodDebugInformationRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using LocalScopeRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32, System.UInt32, System.UInt32, System.UInt32>;
using LocalVariableRow = Mono.Cecil.Metadata.Row<Mono.Cecil.Cil.VariableAttributes, System.UInt16, System.UInt32>;
using LocalConstantRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using ImportScopeRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using StateMachineMethodRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32>;
using CustomDebugInformationRow = Mono.Cecil.Metadata.Row<System.UInt32, System.UInt32, System.UInt32>;
using System.Reflection;
using System.Linq;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using MCC = Mono.Cecil.Cil;
using SRE = System.Reflection.Emit;
using Mono.Cecil;
using OpCodes = Mono.Cecil.Cil.OpCodes;
using OpCode = Mono.Cecil.Cil.OpCode;
using ExceptionHandler = Mono.Cecil.Cil.ExceptionHandler;
using System.Collections;
using System.Runtime.Serialization;
using Mono.Security.Cryptography;
using System.Diagnostics;
using System.Linq.Expressions;
using MonoMod.Utils;
using MonoMod.RuntimeDetour.Platforms;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Collections.Concurrent;
using MC = Mono.Cecil;
using CIL = Mono.Cecil.Cil;
using System.Security;
using System.Diagnostics.SymbolStore;
using MonoMod.Utils.Cil;
using FieldAttributes = Mono.Cecil.FieldAttributes;
using MethodAttributes = Mono.Cecil.MethodAttributes;
using TypeAttributes = Mono.Cecil.TypeAttributes;
using SR = System.Reflection;
using System.Runtime.InteropServices.ComTypes;
using Mono.CompilerServices.SymbolWriter;
using Microsoft.Cci.Pdb;
using AssemblyHashAlgorithm = Mono.Cecil.AssemblyHashAlgorithm;
using SSP = System.Security.Permissions;
using Slot = Mono.Cecil.Metadata.Row<System.String, System.String>;
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Cecil
{

	public struct ArrayDimension
	{

		int? lower_bound;
		int? upper_bound;

		public int? LowerBound
		{
			get { return lower_bound; }
			set { lower_bound = value; }
		}

		public int? UpperBound
		{
			get { return upper_bound; }
			set { upper_bound = value; }
		}

		public bool IsSized
		{
			get { return lower_bound.HasValue || upper_bound.HasValue; }
		}

		public ArrayDimension(int? lowerBound, int? upperBound)
		{
			this.lower_bound = lowerBound;
			this.upper_bound = upperBound;
		}

		public override string ToString()
		{
			return !IsSized
				? string.Empty
				: lower_bound + "..." + upper_bound;
		}
	}

	public sealed class ArrayType : TypeSpecification
	{

		Collection<ArrayDimension> dimensions;

		public Collection<ArrayDimension> Dimensions
		{
			get
			{
				if (dimensions != null)
					return dimensions;

				var empty_dimensions = new Collection<ArrayDimension>();
				empty_dimensions.Add(new ArrayDimension());

				Interlocked.CompareExchange(ref dimensions, empty_dimensions, null);

				return dimensions;
			}
		}

		public int Rank
		{
			get { return dimensions == null ? 1 : dimensions.Count; }
		}

		public bool IsVector
		{
			get
			{
				if (dimensions == null)
					return true;

				if (dimensions.Count > 1)
					return false;

				var dimension = dimensions[0];

				return !dimension.IsSized;
			}
		}

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override string Name
		{
			get { return base.Name + Suffix; }
		}

		public override string FullName
		{
			get { return base.FullName + Suffix; }
		}

		string Suffix
		{
			get
			{
				if (IsVector)
					return "[]";

				var suffix = new StringBuilder();
				suffix.Append("[");
				for (int i = 0; i < dimensions.Count; i++)
				{
					if (i > 0)
						suffix.Append(",");

					suffix.Append(dimensions[i].ToString());
				}
				suffix.Append("]");

				return suffix.ToString();
			}
		}

		public override bool IsArray
		{
			get { return true; }
		}

		public ArrayType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			this.etype = MD.ElementType.Array;
		}

		public ArrayType(TypeReference type, int rank)
			: this(type)
		{
			Mixin.CheckType(type);

			if (rank == 1)
				return;

			dimensions = new Collection<ArrayDimension>(rank);
			for (int i = 0; i < rank; i++)
				dimensions.Add(new ArrayDimension());
			this.etype = MD.ElementType.Array;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public sealed class AssemblyDefinition : ICustomAttributeProvider, ISecurityDeclarationProvider, IDisposable
	{

		AssemblyNameDefinition name;

		internal ModuleDefinition main_module;
		Collection<ModuleDefinition> modules;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		public AssemblyNameDefinition Name
		{
			get { return name; }
			set { name = value; }
		}

		public string FullName
		{
			get { return name != null ? name.FullName : string.Empty; }
		}

		public MetadataToken MetadataToken
		{
			get { return new MetadataToken(TokenType.Assembly, 1); }
			set { }
		}

		public Collection<ModuleDefinition> Modules
		{
			get
			{
				if (modules != null)
					return modules;

				if (main_module.HasImage)
					return main_module.Read(ref modules, this, (_, reader) => reader.ReadModules());

				Interlocked.CompareExchange(ref modules, new Collection<ModuleDefinition>(1) { main_module }, null);
				return modules;
			}
		}

		public ModuleDefinition MainModule
		{
			get { return main_module; }
		}

		public MethodDefinition EntryPoint
		{
			get { return main_module.EntryPoint; }
			set { main_module.EntryPoint = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(main_module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, main_module)); }
		}

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations(main_module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations
		{
			get { return security_declarations ?? (this.GetSecurityDeclarations(ref security_declarations, main_module)); }
		}

		internal AssemblyDefinition()
		{
		}

		public void Dispose()
		{
			if (this.modules == null)
			{
				main_module.Dispose();
				return;
			}

			var modules = this.Modules;
			for (int i = 0; i < modules.Count; i++)
				modules[i].Dispose();
		}
		public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
		{
			return CreateAssembly(assemblyName, moduleName, new ModuleParameters { Kind = kind });
		}

		public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
		{
			if (assemblyName == null)
				throw new ArgumentNullException("assemblyName");
			if (moduleName == null)
				throw new ArgumentNullException("moduleName");
			Mixin.CheckParameters(parameters);
			if (parameters.Kind == ModuleKind.NetModule)
				throw new ArgumentException("kind");

			var assembly = ModuleDefinition.CreateModule(moduleName, parameters).Assembly;
			assembly.Name = assemblyName;

			return assembly;
		}

		public static AssemblyDefinition ReadAssembly(string fileName)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(fileName));
		}

		public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(fileName, parameters));
		}

		public static AssemblyDefinition ReadAssembly(Stream stream)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(stream));
		}

		public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(stream, parameters));
		}

		static AssemblyDefinition ReadAssembly(ModuleDefinition module)
		{
			var assembly = module.Assembly;
			if (assembly == null)
				throw new ArgumentException();

			return assembly;
		}

		public void Write(string fileName)
		{
			Write(fileName, new WriterParameters());
		}

		public void Write(string fileName, WriterParameters parameters)
		{
			main_module.Write(fileName, parameters);
		}

		public void Write()
		{
			main_module.Write();
		}

		public void Write(WriterParameters parameters)
		{
			main_module.Write(parameters);
		}

		public void Write(Stream stream)
		{
			Write(stream, new WriterParameters());
		}

		public void Write(Stream stream, WriterParameters parameters)
		{
			main_module.Write(stream, parameters);
		}

		public override string ToString()
		{
			return this.FullName;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum AssemblyAttributes : uint
	{
		PublicKey = 0x0001,
		SideBySideCompatible = 0x0000,
		Retargetable = 0x0100,
		WindowsRuntime = 0x0200,
		DisableJITCompileOptimizer = 0x4000,
		EnableJITCompileTracking = 0x8000,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum AssemblyHashAlgorithm : uint
	{
		None = 0x0000,
		MD5 = 0x8003,
		SHA1 = 0x8004,
		SHA256 = 0x800C,
		SHA384 = 0x800D,
		SHA512 = 0x800E,
		Reserved = 0x8003, // MD5
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public sealed class AssemblyLinkedResource : Resource
	{

		AssemblyNameReference reference;

		public AssemblyNameReference Assembly
		{
			get { return reference; }
			set { reference = value; }
		}

		public override ResourceType ResourceType
		{
			get { return ResourceType.AssemblyLinked; }
		}

		public AssemblyLinkedResource(string name, ManifestResourceAttributes flags)
			: base(name, flags)
		{
		}

		public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
			: base(name, flags)
		{
			this.reference = reference;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public sealed class AssemblyNameDefinition : AssemblyNameReference
	{

		public override byte[] Hash
		{
			get { return Empty<byte>.Array; }
		}

		internal AssemblyNameDefinition()
		{
			this.token = new MetadataToken(TokenType.Assembly, 1);
		}

		public AssemblyNameDefinition(string name, Version version)
			: base(name, version)
		{
			this.token = new MetadataToken(TokenType.Assembly, 1);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Cecil
{

	public class AssemblyNameReference : IMetadataScope
	{

		string name;
		string culture;
		Version version;
		uint attributes;
		byte[] public_key;
		byte[] public_key_token;
		AssemblyHashAlgorithm hash_algorithm;
		byte[] hash;

		internal MetadataToken token;

		string full_name;

		public string Name
		{
			get { return name; }
			set
			{
				name = value;
				full_name = null;
			}
		}

		public string Culture
		{
			get { return culture; }
			set
			{
				culture = value;
				full_name = null;
			}
		}

		public Version Version
		{
			get { return version; }
			set
			{
				version = Mixin.CheckVersion(value);
				full_name = null;
			}
		}

		public AssemblyAttributes Attributes
		{
			get { return (AssemblyAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public bool HasPublicKey
		{
			get { return attributes.GetAttributes((uint)AssemblyAttributes.PublicKey); }
			set { attributes = attributes.SetAttributes((uint)AssemblyAttributes.PublicKey, value); }
		}

		public bool IsSideBySideCompatible
		{
			get { return attributes.GetAttributes((uint)AssemblyAttributes.SideBySideCompatible); }
			set { attributes = attributes.SetAttributes((uint)AssemblyAttributes.SideBySideCompatible, value); }
		}

		public bool IsRetargetable
		{
			get { return attributes.GetAttributes((uint)AssemblyAttributes.Retargetable); }
			set { attributes = attributes.SetAttributes((uint)AssemblyAttributes.Retargetable, value); }
		}

		public bool IsWindowsRuntime
		{
			get { return attributes.GetAttributes((uint)AssemblyAttributes.WindowsRuntime); }
			set { attributes = attributes.SetAttributes((uint)AssemblyAttributes.WindowsRuntime, value); }
		}

		public byte[] PublicKey
		{
			get { return public_key ?? Empty<byte>.Array; }
			set
			{
				public_key = value;
				HasPublicKey = !public_key.IsNullOrEmpty();
				public_key_token = null;
				full_name = null;
			}
		}

		public byte[] PublicKeyToken
		{
			get
			{
				if (public_key_token == null && !public_key.IsNullOrEmpty())
				{
					var hash = HashPublicKey();
					// we need the last 8 bytes in reverse order
					var local_public_key_token = new byte[8];
					Array.Copy(hash, (hash.Length - 8), local_public_key_token, 0, 8);
					Array.Reverse(local_public_key_token, 0, 8);
					Interlocked.CompareExchange(ref public_key_token, local_public_key_token, null); // publish only once finished (required for thread-safety)
				}
				return public_key_token ?? Empty<byte>.Array;
			}
			set
			{
				public_key_token = value;
				full_name = null;
			}
		}

		byte[] HashPublicKey()
		{
			HashAlgorithm algorithm;

			switch (hash_algorithm)
			{
				case AssemblyHashAlgorithm.Reserved:
					algorithm = MD5.Create();
					break;
				default:
					// None default to SHA1
					algorithm = SHA1.Create();
					break;
			}

			using (algorithm)
				return algorithm.ComputeHash(public_key);
		}

		public virtual MetadataScopeType MetadataScopeType
		{
			get { return MetadataScopeType.AssemblyNameReference; }
		}

		public string FullName
		{
			get
			{
				if (full_name != null)
					return full_name;

				const string sep = ", ";

				var builder = new StringBuilder();
				builder.Append(name);
				builder.Append(sep);
				builder.Append("Version=");
				builder.Append(version.ToString(fieldCount: 4));
				builder.Append(sep);
				builder.Append("Culture=");
				builder.Append(string.IsNullOrEmpty(culture) ? "neutral" : culture);
				builder.Append(sep);
				builder.Append("PublicKeyToken=");

				var pk_token = PublicKeyToken;
				if (!pk_token.IsNullOrEmpty() && pk_token.Length > 0)
				{
					for (int i = 0; i < pk_token.Length; i++)
					{
						builder.Append(pk_token[i].ToString("x2"));
					}
				}
				else
					builder.Append("null");

				if (IsRetargetable)
				{
					builder.Append(sep);
					builder.Append("Retargetable=Yes");
				}

				Interlocked.CompareExchange(ref full_name, builder.ToString(), null);

				return full_name;
			}
		}

		public static AssemblyNameReference Parse(string fullName)
		{
			if (fullName == null)
				throw new ArgumentNullException("fullName");
			if (fullName.Length == 0)
				throw new ArgumentException("Name can not be empty");

			var name = new AssemblyNameReference();
			var tokens = fullName.Split(',');
			for (int i = 0; i < tokens.Length; i++)
			{
				var token = tokens[i].Trim();

				if (i == 0)
				{
					name.Name = token;
					continue;
				}

				var parts = token.Split('=');
				if (parts.Length != 2)
					throw new ArgumentException("Malformed name");

				switch (parts[0].ToLowerInvariant())
				{
					case "version":
						name.Version = new Version(parts[1]);
						break;
					case "culture":
						name.Culture = parts[1] == "neutral" ? "" : parts[1];
						break;
					case "publickeytoken":
						var pk_token = parts[1];
						if (pk_token == "null")
							break;

						name.PublicKeyToken = new byte[pk_token.Length / 2];
						for (int j = 0; j < name.PublicKeyToken.Length; j++)
							name.PublicKeyToken[j] = Byte.Parse(pk_token.Substring(j * 2, 2), NumberStyles.HexNumber);

						break;
				}
			}

			return name;
		}

		public AssemblyHashAlgorithm HashAlgorithm
		{
			get { return hash_algorithm; }
			set { hash_algorithm = value; }
		}

		public virtual byte[] Hash
		{
			get { return hash; }
			set { hash = value; }
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		internal AssemblyNameReference()
		{
			this.version = Mixin.ZeroVersion;
			this.token = new MetadataToken(TokenType.AssemblyRef);
		}

		public AssemblyNameReference(string name, Version version)
		{
			Mixin.CheckName(name);

			this.name = name;
			this.version = Mixin.CheckVersion(version);
			this.hash_algorithm = AssemblyHashAlgorithm.None;
			this.token = new MetadataToken(TokenType.AssemblyRef);
		}

		public override string ToString()
		{
			return this.FullName;
		}
	}

	partial class Mixin
	{

		public static Version ZeroVersion = new Version(0, 0, 0, 0);

		public static Version CheckVersion(Version version)
		{
			if (version == null)
				return ZeroVersion;

			if (version.Build == -1)
				return new Version(version.Major, version.Minor, 0, 0);

			if (version.Revision == -1)
				return new Version(version.Major, version.Minor, version.Build, 0);

			return version;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//














namespace Mono.Cecil
{

	abstract class ModuleReader
	{

		readonly protected ModuleDefinition module;

		protected ModuleReader(Image image, ReadingMode mode)
		{
			this.module = new ModuleDefinition(image);
			this.module.ReadingMode = mode;
		}

		protected abstract void ReadModule();
		public abstract void ReadSymbols(ModuleDefinition module);

		protected void ReadModuleManifest(MetadataReader reader)
		{
			reader.Populate(module);

			ReadAssembly(reader);
		}

		void ReadAssembly(MetadataReader reader)
		{
			var name = reader.ReadAssemblyNameDefinition();
			if (name == null)
			{
				module.kind = ModuleKind.NetModule;
				return;
			}

			var assembly = new AssemblyDefinition();
			assembly.Name = name;

			module.assembly = assembly;
			assembly.main_module = module;
		}

		public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters)
		{
			var reader = CreateModuleReader(image, parameters.ReadingMode);
			var module = reader.module;

			if (parameters.assembly_resolver != null)
				module.assembly_resolver = Disposable.NotOwned(parameters.assembly_resolver);

			if (parameters.metadata_resolver != null)
				module.metadata_resolver = parameters.metadata_resolver;

			if (parameters.metadata_importer_provider != null)
				module.metadata_importer = parameters.metadata_importer_provider.GetMetadataImporter(module);

			if (parameters.reflection_importer_provider != null)
				module.reflection_importer = parameters.reflection_importer_provider.GetReflectionImporter(module);

			GetMetadataKind(module, parameters);

			reader.ReadModule();

			ReadSymbols(module, parameters);

			reader.ReadSymbols(module);

			if (parameters.ReadingMode == ReadingMode.Immediate)
				module.MetadataSystem.Clear();

			return module;
		}

		static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
		{
			var symbol_reader_provider = parameters.SymbolReaderProvider;

			if (symbol_reader_provider == null && parameters.ReadSymbols)
				symbol_reader_provider = new DefaultSymbolReaderProvider();

			if (symbol_reader_provider != null)
			{
				module.SymbolReaderProvider = symbol_reader_provider;

				var reader = parameters.SymbolStream != null
					? symbol_reader_provider.GetSymbolReader(module, parameters.SymbolStream)
					: symbol_reader_provider.GetSymbolReader(module, module.FileName);

				if (reader != null)
				{
					try
					{
						module.ReadSymbols(reader, parameters.ThrowIfSymbolsAreNotMatching);
					}
					catch (Exception)
					{
						reader.Dispose();
						throw;
					}
				}
			}

			if (module.Image.HasDebugTables())
				module.ReadSymbols(new PortablePdbReader(module.Image, module));
		}

		static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters)
		{
			if (!parameters.ApplyWindowsRuntimeProjections)
			{
				module.MetadataKind = MetadataKind.Ecma335;
				return;
			}

			var runtime_version = module.RuntimeVersion;

			if (!runtime_version.Contains("WindowsRuntime"))
				module.MetadataKind = MetadataKind.Ecma335;
			else if (runtime_version.Contains("CLR"))
				module.MetadataKind = MetadataKind.ManagedWindowsMetadata;
			else
				module.MetadataKind = MetadataKind.WindowsMetadata;
		}

		static ModuleReader CreateModuleReader(Image image, ReadingMode mode)
		{
			switch (mode)
			{
				case ReadingMode.Immediate:
					return new ImmediateModuleReader(image);
				case ReadingMode.Deferred:
					return new DeferredModuleReader(image);
				default:
					throw new ArgumentException();
			}
		}
	}

	sealed class ImmediateModuleReader : ModuleReader
	{

		bool resolve_attributes;

		public ImmediateModuleReader(Image image)
			: base(image, ReadingMode.Immediate)
		{
		}

		protected override void ReadModule()
		{
			this.module.Read(this.module, (module, reader) => {
				ReadModuleManifest(reader);
				ReadModule(module, resolve_attributes: true);
			});
		}

		public void ReadModule(ModuleDefinition module, bool resolve_attributes)
		{
			this.resolve_attributes = resolve_attributes;

			if (module.HasAssemblyReferences)
				Mixin.Read(module.AssemblyReferences);
			if (module.HasResources)
				Mixin.Read(module.Resources);
			if (module.HasModuleReferences)
				Mixin.Read(module.ModuleReferences);
			if (module.HasTypes)
				ReadTypes(module.Types);
			if (module.HasExportedTypes)
				Mixin.Read(module.ExportedTypes);

			ReadCustomAttributes(module);

			var assembly = module.Assembly;
			if (module.kind == ModuleKind.NetModule || assembly == null)
				return;

			ReadCustomAttributes(assembly);
			ReadSecurityDeclarations(assembly);
		}

		void ReadTypes(Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++)
				ReadType(types[i]);
		}

		void ReadType(TypeDefinition type)
		{
			ReadGenericParameters(type);

			if (type.HasInterfaces)
				ReadInterfaces(type);

			if (type.HasNestedTypes)
				ReadTypes(type.NestedTypes);

			if (type.HasLayoutInfo)
				Mixin.Read(type.ClassSize);

			if (type.HasFields)
				ReadFields(type);

			if (type.HasMethods)
				ReadMethods(type);

			if (type.HasProperties)
				ReadProperties(type);

			if (type.HasEvents)
				ReadEvents(type);

			ReadSecurityDeclarations(type);
			ReadCustomAttributes(type);
		}

		void ReadInterfaces(TypeDefinition type)
		{
			var interfaces = type.Interfaces;

			for (int i = 0; i < interfaces.Count; i++)
				ReadCustomAttributes(interfaces[i]);
		}

		void ReadGenericParameters(IGenericParameterProvider provider)
		{
			if (!provider.HasGenericParameters)
				return;

			var parameters = provider.GenericParameters;

			for (int i = 0; i < parameters.Count; i++)
			{
				var parameter = parameters[i];

				if (parameter.HasConstraints)
					ReadGenericParameterConstraints(parameter);

				ReadCustomAttributes(parameter);
			}
		}

		void ReadGenericParameterConstraints(GenericParameter parameter)
		{
			var constraints = parameter.Constraints;

			for (int i = 0; i < constraints.Count; i++)
				ReadCustomAttributes(constraints[i]);
		}

		void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
		{
			if (!provider.HasSecurityDeclarations)
				return;

			var security_declarations = provider.SecurityDeclarations;

			if (!resolve_attributes)
				return;

			for (int i = 0; i < security_declarations.Count; i++)
			{
				var security_declaration = security_declarations[i];

				Mixin.Read(security_declaration.SecurityAttributes);
			}
		}

		void ReadCustomAttributes(ICustomAttributeProvider provider)
		{
			if (!provider.HasCustomAttributes)
				return;

			var custom_attributes = provider.CustomAttributes;

			if (!resolve_attributes)
				return;

			for (int i = 0; i < custom_attributes.Count; i++)
			{
				var custom_attribute = custom_attributes[i];

				Mixin.Read(custom_attribute.ConstructorArguments);
			}
		}

		void ReadFields(TypeDefinition type)
		{
			var fields = type.Fields;

			for (int i = 0; i < fields.Count; i++)
			{
				var field = fields[i];

				if (field.HasConstant)
					Mixin.Read(field.Constant);

				if (field.HasLayoutInfo)
					Mixin.Read(field.Offset);

				if (field.RVA > 0)
					Mixin.Read(field.InitialValue);

				if (field.HasMarshalInfo)
					Mixin.Read(field.MarshalInfo);

				ReadCustomAttributes(field);
			}
		}

		void ReadMethods(TypeDefinition type)
		{
			var methods = type.Methods;

			for (int i = 0; i < methods.Count; i++)
			{
				var method = methods[i];

				ReadGenericParameters(method);

				if (method.HasParameters)
					ReadParameters(method);

				if (method.HasOverrides)
					Mixin.Read(method.Overrides);

				if (method.IsPInvokeImpl)
					Mixin.Read(method.PInvokeInfo);

				ReadSecurityDeclarations(method);
				ReadCustomAttributes(method);

				var return_type = method.MethodReturnType;
				if (return_type.HasConstant)
					Mixin.Read(return_type.Constant);

				if (return_type.HasMarshalInfo)
					Mixin.Read(return_type.MarshalInfo);

				ReadCustomAttributes(return_type);
			}
		}

		void ReadParameters(MethodDefinition method)
		{
			var parameters = method.Parameters;

			for (int i = 0; i < parameters.Count; i++)
			{
				var parameter = parameters[i];

				if (parameter.HasConstant)
					Mixin.Read(parameter.Constant);

				if (parameter.HasMarshalInfo)
					Mixin.Read(parameter.MarshalInfo);

				ReadCustomAttributes(parameter);
			}
		}

		void ReadProperties(TypeDefinition type)
		{
			var properties = type.Properties;

			for (int i = 0; i < properties.Count; i++)
			{
				var property = properties[i];

				Mixin.Read(property.GetMethod);

				if (property.HasConstant)
					Mixin.Read(property.Constant);

				ReadCustomAttributes(property);
			}
		}

		void ReadEvents(TypeDefinition type)
		{
			var events = type.Events;

			for (int i = 0; i < events.Count; i++)
			{
				var @event = events[i];

				Mixin.Read(@event.AddMethod);

				ReadCustomAttributes(@event);
			}
		}

		public override void ReadSymbols(ModuleDefinition module)
		{
			if (module.symbol_reader == null)
				return;

			ReadTypesSymbols(module.Types, module.symbol_reader);
		}

		void ReadTypesSymbols(Collection<TypeDefinition> types, Mono.Cecil.Cil.ISymbolReader symbol_reader)
		{
			for (int i = 0; i < types.Count; i++)
			{
				var type = types[i];

				if (type.HasNestedTypes)
					ReadTypesSymbols(type.NestedTypes, symbol_reader);

				if (type.HasMethods)
					ReadMethodsSymbols(type, symbol_reader);
			}
		}

		void ReadMethodsSymbols(TypeDefinition type, Mono.Cecil.Cil.ISymbolReader symbol_reader)
		{
			var methods = type.Methods;
			for (int i = 0; i < methods.Count; i++)
			{
				var method = methods[i];

				if (method.HasBody && method.token.RID != 0 && method.debug_info == null)
					method.debug_info = symbol_reader.Read(method);
			}
		}
	}

	sealed class DeferredModuleReader : ModuleReader
	{

		public DeferredModuleReader(Image image)
			: base(image, ReadingMode.Deferred)
		{
		}

		protected override void ReadModule()
		{
			this.module.Read(this.module, (_, reader) => ReadModuleManifest(reader));
		}

		public override void ReadSymbols(ModuleDefinition module)
		{
		}
	}

	sealed class MetadataReader : ByteBuffer
	{

		readonly internal Image image;
		readonly internal ModuleDefinition module;
		readonly internal MetadataSystem metadata;

		internal CodeReader code;
		internal IGenericContext context;

		readonly MetadataReader metadata_reader;

		public MetadataReader(ModuleDefinition module)
			: base(module.Image.TableHeap.data)
		{
			this.image = module.Image;
			this.module = module;
			this.metadata = module.MetadataSystem;
			this.code = new CodeReader(this);
		}

		public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader)
			: base(image.TableHeap.data)
		{
			this.image = image;
			this.module = module;
			this.metadata = module.MetadataSystem;
			this.metadata_reader = metadata_reader;
		}

		int GetCodedIndexSize(CodedIndex index)
		{
			return image.GetCodedIndexSize(index);
		}

		uint ReadByIndexSize(int size)
		{
			if (size == 4)
				return ReadUInt32();
			else
				return ReadUInt16();
		}

		byte[] ReadBlob()
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null)
			{
				position += 2;
				return Empty<byte>.Array;
			}

			return blob_heap.Read(ReadBlobIndex());
		}

		byte[] ReadBlob(uint signature)
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null)
				return Empty<byte>.Array;

			return blob_heap.Read(signature);
		}

		uint ReadBlobIndex()
		{
			var blob_heap = image.BlobHeap;
			return ReadByIndexSize(blob_heap != null ? blob_heap.IndexSize : 2);
		}

		void GetBlobView(uint signature, out byte[] blob, out int index, out int count)
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null)
			{
				blob = null;
				index = count = 0;
				return;
			}

			blob_heap.GetView(signature, out blob, out index, out count);
		}

		string ReadString()
		{
			return image.StringHeap.Read(ReadByIndexSize(image.StringHeap.IndexSize));
		}

		uint ReadStringIndex()
		{
			return ReadByIndexSize(image.StringHeap.IndexSize);
		}

		Guid ReadGuid()
		{
			return image.GuidHeap.Read(ReadByIndexSize(image.GuidHeap.IndexSize));
		}

		uint ReadTableIndex(Table table)
		{
			return ReadByIndexSize(image.GetTableIndexSize(table));
		}

		MetadataToken ReadMetadataToken(CodedIndex index)
		{
			return index.GetMetadataToken(ReadByIndexSize(GetCodedIndexSize(index)));
		}

		int MoveTo(Table table)
		{
			var info = image.TableHeap[table];
			if (info.Length != 0)
				this.position = (int)info.Offset;

			return (int)info.Length;
		}

		bool MoveTo(Table table, uint row)
		{
			var info = image.TableHeap[table];
			var length = info.Length;
			if (length == 0 || row > length)
				return false;

			this.position = (int)(info.Offset + (info.RowSize * (row - 1)));
			return true;
		}

		public AssemblyNameDefinition ReadAssemblyNameDefinition()
		{
			if (MoveTo(Table.Assembly) == 0)
				return null;

			var name = new AssemblyNameDefinition();

			name.HashAlgorithm = (AssemblyHashAlgorithm)ReadUInt32();

			PopulateVersionAndFlags(name);

			name.PublicKey = ReadBlob();

			PopulateNameAndCulture(name);

			return name;
		}

		public ModuleDefinition Populate(ModuleDefinition module)
		{
			if (MoveTo(Table.Module) == 0)
				return module;

			Advance(2); // Generation

			module.Name = ReadString();
			module.Mvid = ReadGuid();

			return module;
		}

		void InitializeAssemblyReferences()
		{
			if (metadata.AssemblyReferences != null)
				return;

			int length = MoveTo(Table.AssemblyRef);
			var references = metadata.AssemblyReferences = new AssemblyNameReference[length];

			for (uint i = 0; i < length; i++)
			{
				var reference = new AssemblyNameReference();
				reference.token = new MetadataToken(TokenType.AssemblyRef, i + 1);

				PopulateVersionAndFlags(reference);

				var key_or_token = ReadBlob();

				if (reference.HasPublicKey)
					reference.PublicKey = key_or_token;
				else
					reference.PublicKeyToken = key_or_token;

				PopulateNameAndCulture(reference);

				reference.Hash = ReadBlob();

				references[i] = reference;
			}
		}

		public Collection<AssemblyNameReference> ReadAssemblyReferences()
		{
			InitializeAssemblyReferences();

			var references = new Collection<AssemblyNameReference>(metadata.AssemblyReferences);
			if (module.IsWindowsMetadata())
				module.Projections.AddVirtualReferences(references);

			return references;
		}

		public MethodDefinition ReadEntryPoint()
		{
			if (module.Image.EntryPointToken == 0)
				return null;

			var token = new MetadataToken(module.Image.EntryPointToken);
			return GetMethodDefinition(token.RID);
		}

		public Collection<ModuleDefinition> ReadModules()
		{
			var modules = new Collection<ModuleDefinition>(1);
			modules.Add(this.module);

			int length = MoveTo(Table.File);
			for (uint i = 1; i <= length; i++)
			{
				var attributes = (FileAttributes)ReadUInt32();
				var name = ReadString();
				ReadBlobIndex();

				if (attributes != FileAttributes.ContainsMetaData)
					continue;

				var parameters = new ReaderParameters
				{
					ReadingMode = module.ReadingMode,
					SymbolReaderProvider = module.SymbolReaderProvider,
					AssemblyResolver = module.AssemblyResolver
				};

				var netmodule = ModuleDefinition.ReadModule(GetModuleFileName(name), parameters);
				netmodule.assembly = this.module.assembly;

				modules.Add(netmodule);
			}

			return modules;
		}

		string GetModuleFileName(string name)
		{
			if (module.FileName == null)
				throw new NotSupportedException();

			var path = Path.GetDirectoryName(module.FileName);
			return Path.Combine(path, name);
		}

		void InitializeModuleReferences()
		{
			if (metadata.ModuleReferences != null)
				return;

			int length = MoveTo(Table.ModuleRef);
			var references = metadata.ModuleReferences = new ModuleReference[length];

			for (uint i = 0; i < length; i++)
			{
				var reference = new ModuleReference(ReadString());
				reference.token = new MetadataToken(TokenType.ModuleRef, i + 1);

				references[i] = reference;
			}
		}

		public Collection<ModuleReference> ReadModuleReferences()
		{
			InitializeModuleReferences();

			return new Collection<ModuleReference>(metadata.ModuleReferences);
		}

		public bool HasFileResource()
		{
			int length = MoveTo(Table.File);
			if (length == 0)
				return false;

			for (uint i = 1; i <= length; i++)
				if (ReadFileRecord(i).Col1 == FileAttributes.ContainsNoMetaData)
					return true;

			return false;
		}

		public Collection<Resource> ReadResources()
		{
			int length = MoveTo(Table.ManifestResource);
			var resources = new Collection<Resource>(length);

			for (int i = 1; i <= length; i++)
			{
				var offset = ReadUInt32();
				var flags = (ManifestResourceAttributes)ReadUInt32();
				var name = ReadString();
				var implementation = ReadMetadataToken(CodedIndex.Implementation);

				Resource resource;

				if (implementation.RID == 0)
				{
					resource = new EmbeddedResource(name, flags, offset, this);
				}
				else if (implementation.TokenType == TokenType.AssemblyRef)
				{
					resource = new AssemblyLinkedResource(name, flags)
					{
						Assembly = (AssemblyNameReference)GetTypeReferenceScope(implementation),
					};
				}
				else if (implementation.TokenType == TokenType.File)
				{
					var file_record = ReadFileRecord(implementation.RID);

					resource = new LinkedResource(name, flags)
					{
						File = file_record.Col2,
						hash = ReadBlob(file_record.Col3)
					};
				}
				else
					continue;

				resources.Add(resource);
			}

			return resources;
		}

		Row<FileAttributes, string, uint> ReadFileRecord(uint rid)
		{
			var position = this.position;

			if (!MoveTo(Table.File, rid))
				throw new ArgumentException();

			var record = new Row<FileAttributes, string, uint>(
				(FileAttributes)ReadUInt32(),
				ReadString(),
				ReadBlobIndex());

			this.position = position;

			return record;
		}

		public byte[] GetManagedResource(uint offset)
		{
			return image.GetReaderAt(image.Resources.VirtualAddress, offset, (o, reader) => {
				reader.Advance((int)o);
				return reader.ReadBytes(reader.ReadInt32());
			}) ?? Empty<byte>.Array;
		}

		void PopulateVersionAndFlags(AssemblyNameReference name)
		{
			name.Version = new Version(
				ReadUInt16(),
				ReadUInt16(),
				ReadUInt16(),
				ReadUInt16());

			name.Attributes = (AssemblyAttributes)ReadUInt32();
		}

		void PopulateNameAndCulture(AssemblyNameReference name)
		{
			name.Name = ReadString();
			name.Culture = ReadString();
		}

		public TypeDefinitionCollection ReadTypes()
		{
			InitializeTypeDefinitions();
			var mtypes = metadata.Types;
			var type_count = mtypes.Length - metadata.NestedTypes.Count;
			var types = new TypeDefinitionCollection(module, type_count);

			for (int i = 0; i < mtypes.Length; i++)
			{
				var type = mtypes[i];
				if (IsNested(type.Attributes))
					continue;

				types.Add(type);
			}

			if (image.HasTable(Table.MethodPtr) || image.HasTable(Table.FieldPtr))
				CompleteTypes();

			return types;
		}

		void CompleteTypes()
		{
			var types = metadata.Types;

			for (int i = 0; i < types.Length; i++)
			{
				var type = types[i];

				Mixin.Read(type.Fields);
				Mixin.Read(type.Methods);
			}
		}

		void InitializeTypeDefinitions()
		{
			if (metadata.Types != null)
				return;

			InitializeNestedTypes();
			InitializeFields();
			InitializeMethods();

			int length = MoveTo(Table.TypeDef);
			var types = metadata.Types = new TypeDefinition[length];

			for (uint i = 0; i < length; i++)
			{
				if (types[i] != null)
					continue;

				types[i] = ReadType(i + 1);
			}

			if (module.IsWindowsMetadata())
			{
				for (uint i = 0; i < length; i++)
				{
					WindowsRuntimeProjections.Project(types[i]);
				}
			}
		}

		static bool IsNested(TypeAttributes attributes)
		{
			switch (attributes & TypeAttributes.VisibilityMask)
			{
				case TypeAttributes.NestedAssembly:
				case TypeAttributes.NestedFamANDAssem:
				case TypeAttributes.NestedFamily:
				case TypeAttributes.NestedFamORAssem:
				case TypeAttributes.NestedPrivate:
				case TypeAttributes.NestedPublic:
					return true;
				default:
					return false;
			}
		}

		public bool HasNestedTypes(TypeDefinition type)
		{
			Collection<uint> mapping;
			InitializeNestedTypes();

			if (!metadata.TryGetNestedTypeMapping(type, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public Collection<TypeDefinition> ReadNestedTypes(TypeDefinition type)
		{
			InitializeNestedTypes();
			Collection<uint> mapping;
			if (!metadata.TryGetNestedTypeMapping(type, out mapping))
				return new MemberDefinitionCollection<TypeDefinition>(type);

			var nested_types = new MemberDefinitionCollection<TypeDefinition>(type, mapping.Count);

			for (int i = 0; i < mapping.Count; i++)
			{
				var nested_type = GetTypeDefinition(mapping[i]);

				if (nested_type != null)
					nested_types.Add(nested_type);
			}

			metadata.RemoveNestedTypeMapping(type);

			return nested_types;
		}

		void InitializeNestedTypes()
		{
			if (metadata.NestedTypes != null)
				return;

			var length = MoveTo(Table.NestedClass);

			metadata.NestedTypes = new Dictionary<uint, Collection<uint>>(length);
			metadata.ReverseNestedTypes = new Dictionary<uint, uint>(length);

			if (length == 0)
				return;

			for (int i = 1; i <= length; i++)
			{
				var nested = ReadTableIndex(Table.TypeDef);
				var declaring = ReadTableIndex(Table.TypeDef);

				AddNestedMapping(declaring, nested);
			}
		}

		void AddNestedMapping(uint declaring, uint nested)
		{
			metadata.SetNestedTypeMapping(declaring, AddMapping(metadata.NestedTypes, declaring, nested));
			metadata.SetReverseNestedTypeMapping(nested, declaring);
		}

		static Collection<TValue> AddMapping<TKey, TValue>(Dictionary<TKey, Collection<TValue>> cache, TKey key, TValue value)
		{
			Collection<TValue> mapped;
			if (!cache.TryGetValue(key, out mapped))
			{
				mapped = new Collection<TValue>();
			}
			mapped.Add(value);
			return mapped;
		}

		TypeDefinition ReadType(uint rid)
		{
			if (!MoveTo(Table.TypeDef, rid))
				return null;

			var attributes = (TypeAttributes)ReadUInt32();
			var name = ReadString();
			var @namespace = ReadString();
			var type = new TypeDefinition(@namespace, name, attributes);
			type.token = new MetadataToken(TokenType.TypeDef, rid);
			type.scope = module;
			type.module = module;

			metadata.AddTypeDefinition(type);

			this.context = type;

			type.BaseType = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));

			type.fields_range = ReadListRange(rid, Table.TypeDef, Table.Field);
			type.methods_range = ReadListRange(rid, Table.TypeDef, Table.Method);

			if (IsNested(attributes))
				type.DeclaringType = GetNestedTypeDeclaringType(type);

			return type;
		}

		TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
		{
			uint declaring_rid;
			if (!metadata.TryGetReverseNestedTypeMapping(type, out declaring_rid))
				return null;

			metadata.RemoveReverseNestedTypeMapping(type);
			return GetTypeDefinition(declaring_rid);
		}

		Range ReadListRange(uint current_index, Table current, Table target)
		{
			var list = new Range();

			var start = ReadTableIndex(target);
			if (start == 0)
				return list;

			uint next_index;
			var current_table = image.TableHeap[current];

			if (current_index == current_table.Length)
				next_index = image.TableHeap[target].Length + 1;
			else
			{
				var position = this.position;
				this.position += (int)(current_table.RowSize - image.GetTableIndexSize(target));
				next_index = ReadTableIndex(target);
				this.position = position;
			}

			list.Start = start;
			list.Length = next_index - start;

			return list;
		}

		public Row<short, int> ReadTypeLayout(TypeDefinition type)
		{
			InitializeTypeLayouts();
			Row<ushort, uint> class_layout;
			var rid = type.token.RID;
			if (!metadata.ClassLayouts.TryGetValue(rid, out class_layout))
				return new Row<short, int>(Mixin.NoDataMarker, Mixin.NoDataMarker);

			type.PackingSize = (short)class_layout.Col1;
			type.ClassSize = (int)class_layout.Col2;

			metadata.ClassLayouts.Remove(rid);

			return new Row<short, int>((short)class_layout.Col1, (int)class_layout.Col2);
		}

		void InitializeTypeLayouts()
		{
			if (metadata.ClassLayouts != null)
				return;

			int length = MoveTo(Table.ClassLayout);

			var class_layouts = metadata.ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(length);

			for (uint i = 0; i < length; i++)
			{
				var packing_size = ReadUInt16();
				var class_size = ReadUInt32();

				var parent = ReadTableIndex(Table.TypeDef);

				class_layouts.Add(parent, new Row<ushort, uint>(packing_size, class_size));
			}
		}

		public TypeReference GetTypeDefOrRef(MetadataToken token)
		{
			return (TypeReference)LookupToken(token);
		}

		public TypeDefinition GetTypeDefinition(uint rid)
		{
			InitializeTypeDefinitions();

			var type = metadata.GetTypeDefinition(rid);
			if (type != null)
				return type;

			type = ReadTypeDefinition(rid);

			if (module.IsWindowsMetadata())
				WindowsRuntimeProjections.Project(type);

			return type;
		}

		TypeDefinition ReadTypeDefinition(uint rid)
		{
			if (!MoveTo(Table.TypeDef, rid))
				return null;

			return ReadType(rid);
		}

		void InitializeTypeReferences()
		{
			if (metadata.TypeReferences != null)
				return;

			metadata.TypeReferences = new TypeReference[image.GetTableLength(Table.TypeRef)];
		}

		public TypeReference GetTypeReference(string scope, string full_name)
		{
			InitializeTypeReferences();

			var length = metadata.TypeReferences.Length;

			for (uint i = 1; i <= length; i++)
			{
				var type = GetTypeReference(i);

				if (type.FullName != full_name)
					continue;

				if (string.IsNullOrEmpty(scope))
					return type;

				if (type.Scope.Name == scope)
					return type;
			}

			return null;
		}

		TypeReference GetTypeReference(uint rid)
		{
			InitializeTypeReferences();

			var type = metadata.GetTypeReference(rid);
			if (type != null)
				return type;

			return ReadTypeReference(rid);
		}

		TypeReference ReadTypeReference(uint rid)
		{
			if (!MoveTo(Table.TypeRef, rid))
				return null;

			TypeReference declaring_type = null;
			IMetadataScope scope;

			var scope_token = ReadMetadataToken(CodedIndex.ResolutionScope);

			var name = ReadString();
			var @namespace = ReadString();

			var type = new TypeReference(
				@namespace,
				name,
				module,
				null);

			type.token = new MetadataToken(TokenType.TypeRef, rid);

			metadata.AddTypeReference(type);

			if (scope_token.TokenType == TokenType.TypeRef)
			{
				if (scope_token.RID != rid)
				{
					declaring_type = GetTypeDefOrRef(scope_token);

					scope = declaring_type != null
						? declaring_type.Scope
						: module;
				}
				else // obfuscated typeref row pointing to self
					scope = module;
			}
			else
				scope = GetTypeReferenceScope(scope_token);

			type.scope = scope;
			type.DeclaringType = declaring_type;

			MetadataSystem.TryProcessPrimitiveTypeReference(type);

			if (type.Module.IsWindowsMetadata())
				WindowsRuntimeProjections.Project(type);

			return type;
		}

		IMetadataScope GetTypeReferenceScope(MetadataToken scope)
		{
			if (scope.TokenType == TokenType.Module)
				return module;

			IMetadataScope[] scopes;

			switch (scope.TokenType)
			{
				case TokenType.AssemblyRef:
					InitializeAssemblyReferences();
					scopes = metadata.AssemblyReferences;
					break;
				case TokenType.ModuleRef:
					InitializeModuleReferences();
					scopes = metadata.ModuleReferences;
					break;
				default:
					throw new NotSupportedException();
			}

			var index = scope.RID - 1;
			if (index < 0 || index >= scopes.Length)
				return null;

			return scopes[index];
		}

		public IEnumerable<TypeReference> GetTypeReferences()
		{
			InitializeTypeReferences();

			var length = image.GetTableLength(Table.TypeRef);

			var type_references = new TypeReference[length];

			for (uint i = 1; i <= length; i++)
				type_references[i - 1] = GetTypeReference(i);

			return type_references;
		}

		TypeReference GetTypeSpecification(uint rid)
		{
			if (!MoveTo(Table.TypeSpec, rid))
				return null;

			var reader = ReadSignature(ReadBlobIndex());
			var type = reader.ReadTypeSignature();
			if (type.token.RID == 0)
				type.token = new MetadataToken(TokenType.TypeSpec, rid);

			return type;
		}

		SignatureReader ReadSignature(uint signature)
		{
			return new SignatureReader(signature, this);
		}

		public bool HasInterfaces(TypeDefinition type)
		{
			InitializeInterfaces();
			Collection<Row<uint, MetadataToken>> mapping;

			return metadata.TryGetInterfaceMapping(type, out mapping);
		}

		public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type)
		{
			InitializeInterfaces();
			Collection<Row<uint, MetadataToken>> mapping;

			if (!metadata.TryGetInterfaceMapping(type, out mapping))
				return new InterfaceImplementationCollection(type);

			var interfaces = new InterfaceImplementationCollection(type, mapping.Count);

			this.context = type;

			for (int i = 0; i < mapping.Count; i++)
			{
				interfaces.Add(
					new InterfaceImplementation(
						GetTypeDefOrRef(mapping[i].Col2),
						new MetadataToken(TokenType.InterfaceImpl, mapping[i].Col1)));
			}

			metadata.RemoveInterfaceMapping(type);

			return interfaces;
		}

		void InitializeInterfaces()
		{
			if (metadata.Interfaces != null)
				return;

			int length = MoveTo(Table.InterfaceImpl);

			metadata.Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(length);

			for (uint i = 1; i <= length; i++)
			{
				var type = ReadTableIndex(Table.TypeDef);
				var @interface = ReadMetadataToken(CodedIndex.TypeDefOrRef);

				AddInterfaceMapping(type, new Row<uint, MetadataToken>(i, @interface));
			}
		}

		void AddInterfaceMapping(uint type, Row<uint, MetadataToken> @interface)
		{
			metadata.SetInterfaceMapping(type, AddMapping(metadata.Interfaces, type, @interface));
		}

		public Collection<FieldDefinition> ReadFields(TypeDefinition type)
		{
			var fields_range = type.fields_range;
			if (fields_range.Length == 0)
				return new MemberDefinitionCollection<FieldDefinition>(type);

			var fields = new MemberDefinitionCollection<FieldDefinition>(type, (int)fields_range.Length);
			this.context = type;

			if (!MoveTo(Table.FieldPtr, fields_range.Start))
			{
				if (!MoveTo(Table.Field, fields_range.Start))
					return fields;

				for (uint i = 0; i < fields_range.Length; i++)
					ReadField(fields_range.Start + i, fields);
			}
			else
				ReadPointers(Table.FieldPtr, Table.Field, fields_range, fields, ReadField);

			return fields;
		}

		void ReadField(uint field_rid, Collection<FieldDefinition> fields)
		{
			var attributes = (FieldAttributes)ReadUInt16();
			var name = ReadString();
			var signature = ReadBlobIndex();

			var field = new FieldDefinition(name, attributes, ReadFieldType(signature));
			field.token = new MetadataToken(TokenType.Field, field_rid);
			metadata.AddFieldDefinition(field);

			if (IsDeleted(field))
				return;

			fields.Add(field);

			if (module.IsWindowsMetadata())
				WindowsRuntimeProjections.Project(field);
		}

		void InitializeFields()
		{
			if (metadata.Fields != null)
				return;

			metadata.Fields = new FieldDefinition[image.GetTableLength(Table.Field)];
		}

		TypeReference ReadFieldType(uint signature)
		{
			var reader = ReadSignature(signature);

			const byte field_sig = 0x6;

			if (reader.ReadByte() != field_sig)
				throw new NotSupportedException();

			return reader.ReadTypeSignature();
		}

		public int ReadFieldRVA(FieldDefinition field)
		{
			InitializeFieldRVAs();
			var rid = field.token.RID;

			RVA rva;
			if (!metadata.FieldRVAs.TryGetValue(rid, out rva))
				return 0;

			var size = GetFieldTypeSize(field.FieldType);

			if (size == 0 || rva == 0)
				return 0;

			metadata.FieldRVAs.Remove(rid);

			field.InitialValue = GetFieldInitializeValue(size, rva);

			return (int)rva;
		}

		byte[] GetFieldInitializeValue(int size, RVA rva)
		{
			return image.GetReaderAt(rva, size, (s, reader) => reader.ReadBytes(s)) ?? Empty<byte>.Array;
		}

		static int GetFieldTypeSize(TypeReference type)
		{
			int size = 0;

			switch (type.etype)
			{
				case ElementType.Boolean:
				case ElementType.U1:
				case ElementType.I1:
					size = 1;
					break;
				case ElementType.U2:
				case ElementType.I2:
				case ElementType.Char:
					size = 2;
					break;
				case ElementType.U4:
				case ElementType.I4:
				case ElementType.R4:
					size = 4;
					break;
				case ElementType.U8:
				case ElementType.I8:
				case ElementType.R8:
					size = 8;
					break;
				case ElementType.Ptr:
				case ElementType.FnPtr:
					size = IntPtr.Size;
					break;
				case ElementType.CModOpt:
				case ElementType.CModReqD:
					return GetFieldTypeSize(((IModifierType)type).ElementType);
				default:
					var field_type = type.Resolve();
					if (field_type != null && field_type.HasLayoutInfo)
						size = field_type.ClassSize;

					break;
			}

			return size;
		}

		void InitializeFieldRVAs()
		{
			if (metadata.FieldRVAs != null)
				return;

			int length = MoveTo(Table.FieldRVA);

			var field_rvas = metadata.FieldRVAs = new Dictionary<uint, uint>(length);

			for (int i = 0; i < length; i++)
			{
				var rva = ReadUInt32();
				var field = ReadTableIndex(Table.Field);

				field_rvas.Add(field, rva);
			}
		}

		public int ReadFieldLayout(FieldDefinition field)
		{
			InitializeFieldLayouts();
			var rid = field.token.RID;
			uint offset;
			if (!metadata.FieldLayouts.TryGetValue(rid, out offset))
				return Mixin.NoDataMarker;

			metadata.FieldLayouts.Remove(rid);

			return (int)offset;
		}

		void InitializeFieldLayouts()
		{
			if (metadata.FieldLayouts != null)
				return;

			int length = MoveTo(Table.FieldLayout);

			var field_layouts = metadata.FieldLayouts = new Dictionary<uint, uint>(length);

			for (int i = 0; i < length; i++)
			{
				var offset = ReadUInt32();
				var field = ReadTableIndex(Table.Field);

				field_layouts.Add(field, offset);
			}
		}

		public bool HasEvents(TypeDefinition type)
		{
			InitializeEvents();

			Range range;
			if (!metadata.TryGetEventsRange(type, out range))
				return false;

			return range.Length > 0;
		}

		public Collection<EventDefinition> ReadEvents(TypeDefinition type)
		{
			InitializeEvents();
			Range range;

			if (!metadata.TryGetEventsRange(type, out range))
				return new MemberDefinitionCollection<EventDefinition>(type);

			var events = new MemberDefinitionCollection<EventDefinition>(type, (int)range.Length);

			metadata.RemoveEventsRange(type);

			if (range.Length == 0)
				return events;

			this.context = type;

			if (!MoveTo(Table.EventPtr, range.Start))
			{
				if (!MoveTo(Table.Event, range.Start))
					return events;

				for (uint i = 0; i < range.Length; i++)
					ReadEvent(range.Start + i, events);
			}
			else
				ReadPointers(Table.EventPtr, Table.Event, range, events, ReadEvent);

			return events;
		}

		void ReadEvent(uint event_rid, Collection<EventDefinition> events)
		{
			var attributes = (EventAttributes)ReadUInt16();
			var name = ReadString();
			var event_type = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));

			var @event = new EventDefinition(name, attributes, event_type);
			@event.token = new MetadataToken(TokenType.Event, event_rid);

			if (IsDeleted(@event))
				return;

			events.Add(@event);
		}

		void InitializeEvents()
		{
			if (metadata.Events != null)
				return;

			int length = MoveTo(Table.EventMap);

			metadata.Events = new Dictionary<uint, Range>(length);

			for (uint i = 1; i <= length; i++)
			{
				var type_rid = ReadTableIndex(Table.TypeDef);
				Range events_range = ReadListRange(i, Table.EventMap, Table.Event);
				metadata.AddEventsRange(type_rid, events_range);
			}
		}

		public bool HasProperties(TypeDefinition type)
		{
			InitializeProperties();

			Range range;
			if (!metadata.TryGetPropertiesRange(type, out range))
				return false;

			return range.Length > 0;
		}

		public Collection<PropertyDefinition> ReadProperties(TypeDefinition type)
		{
			InitializeProperties();

			Range range;

			if (!metadata.TryGetPropertiesRange(type, out range))
				return new MemberDefinitionCollection<PropertyDefinition>(type);

			metadata.RemovePropertiesRange(type);

			var properties = new MemberDefinitionCollection<PropertyDefinition>(type, (int)range.Length);

			if (range.Length == 0)
				return properties;

			this.context = type;

			if (!MoveTo(Table.PropertyPtr, range.Start))
			{
				if (!MoveTo(Table.Property, range.Start))
					return properties;
				for (uint i = 0; i < range.Length; i++)
					ReadProperty(range.Start + i, properties);
			}
			else
				ReadPointers(Table.PropertyPtr, Table.Property, range, properties, ReadProperty);

			return properties;
		}

		void ReadProperty(uint property_rid, Collection<PropertyDefinition> properties)
		{
			var attributes = (PropertyAttributes)ReadUInt16();
			var name = ReadString();
			var signature = ReadBlobIndex();

			var reader = ReadSignature(signature);
			const byte property_signature = 0x8;

			var calling_convention = reader.ReadByte();

			if ((calling_convention & property_signature) == 0)
				throw new NotSupportedException();

			var has_this = (calling_convention & 0x20) != 0;

			reader.ReadCompressedUInt32(); // count

			var property = new PropertyDefinition(name, attributes, reader.ReadTypeSignature());
			property.HasThis = has_this;
			property.token = new MetadataToken(TokenType.Property, property_rid);

			if (IsDeleted(property))
				return;

			properties.Add(property);
		}

		void InitializeProperties()
		{
			if (metadata.Properties != null)
				return;

			int length = MoveTo(Table.PropertyMap);

			metadata.Properties = new Dictionary<uint, Range>(length);

			for (uint i = 1; i <= length; i++)
			{
				var type_rid = ReadTableIndex(Table.TypeDef);
				var properties_range = ReadListRange(i, Table.PropertyMap, Table.Property);
				metadata.AddPropertiesRange(type_rid, properties_range);
			}
		}

		MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
		{
			InitializeMethodSemantics();
			Row<MethodSemanticsAttributes, MetadataToken> row;
			if (!metadata.Semantics.TryGetValue(method.token.RID, out row))
				return MethodSemanticsAttributes.None;

			var type = method.DeclaringType;

			switch (row.Col1)
			{
				case MethodSemanticsAttributes.AddOn:
					GetEvent(type, row.Col2).add_method = method;
					break;
				case MethodSemanticsAttributes.Fire:
					GetEvent(type, row.Col2).invoke_method = method;
					break;
				case MethodSemanticsAttributes.RemoveOn:
					GetEvent(type, row.Col2).remove_method = method;
					break;
				case MethodSemanticsAttributes.Getter:
					GetProperty(type, row.Col2).get_method = method;
					break;
				case MethodSemanticsAttributes.Setter:
					GetProperty(type, row.Col2).set_method = method;
					break;
				case MethodSemanticsAttributes.Other:
					switch (row.Col2.TokenType)
					{
						case TokenType.Event:
							{
								var @event = GetEvent(type, row.Col2);
								if (@event.other_methods == null)
									@event.other_methods = new Collection<MethodDefinition>();

								@event.other_methods.Add(method);
								break;
							}
						case TokenType.Property:
							{
								var property = GetProperty(type, row.Col2);
								if (property.other_methods == null)
									property.other_methods = new Collection<MethodDefinition>();

								property.other_methods.Add(method);

								break;
							}
						default:
							throw new NotSupportedException();
					}
					break;
				default:
					throw new NotSupportedException();
			}

			metadata.Semantics.Remove(method.token.RID);

			return row.Col1;
		}

		static EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Event)
				throw new ArgumentException();

			return GetMember(type.Events, token);
		}

		static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Property)
				throw new ArgumentException();

			return GetMember(type.Properties, token);
		}

		static TMember GetMember<TMember>(Collection<TMember> members, MetadataToken token) where TMember : IMemberDefinition
		{
			for (int i = 0; i < members.Count; i++)
			{
				var member = members[i];
				if (member.MetadataToken == token)
					return member;
			}

			throw new ArgumentException();
		}

		void InitializeMethodSemantics()
		{
			if (metadata.Semantics != null)
				return;

			int length = MoveTo(Table.MethodSemantics);

			var semantics = metadata.Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(0);

			for (uint i = 0; i < length; i++)
			{
				var attributes = (MethodSemanticsAttributes)ReadUInt16();
				var method_rid = ReadTableIndex(Table.Method);
				var association = ReadMetadataToken(CodedIndex.HasSemantics);

				semantics[method_rid] = new Row<MethodSemanticsAttributes, MetadataToken>(attributes, association);
			}
		}

		public void ReadMethods(PropertyDefinition property)
		{
			ReadAllSemantics(property.DeclaringType);
		}

		public void ReadMethods(EventDefinition @event)
		{
			ReadAllSemantics(@event.DeclaringType);
		}

		public void ReadAllSemantics(MethodDefinition method)
		{
			ReadAllSemantics(method.DeclaringType);
		}

		void ReadAllSemantics(TypeDefinition type)
		{
			var methods = type.Methods;
			for (int i = 0; i < methods.Count; i++)
			{
				var method = methods[i];
				if (method.sem_attrs_ready)
					continue;

				method.sem_attrs = ReadMethodSemantics(method);
				method.sem_attrs_ready = true;
			}
		}

		public Collection<MethodDefinition> ReadMethods(TypeDefinition type)
		{
			var methods_range = type.methods_range;
			if (methods_range.Length == 0)
				return new MemberDefinitionCollection<MethodDefinition>(type);

			var methods = new MemberDefinitionCollection<MethodDefinition>(type, (int)methods_range.Length);
			if (!MoveTo(Table.MethodPtr, methods_range.Start))
			{
				if (!MoveTo(Table.Method, methods_range.Start))
					return methods;

				for (uint i = 0; i < methods_range.Length; i++)
					ReadMethod(methods_range.Start + i, methods);
			}
			else
				ReadPointers(Table.MethodPtr, Table.Method, methods_range, methods, ReadMethod);

			return methods;
		}

		void ReadPointers<TMember>(Table ptr, Table table, Range range, Collection<TMember> members, Action<uint, Collection<TMember>> reader)
			where TMember : IMemberDefinition
		{
			for (uint i = 0; i < range.Length; i++)
			{
				MoveTo(ptr, range.Start + i);

				var rid = ReadTableIndex(table);
				MoveTo(table, rid);

				reader(rid, members);
			}
		}

		static bool IsDeleted(IMemberDefinition member)
		{
			return member.IsSpecialName && member.Name == "_Deleted";
		}

		void InitializeMethods()
		{
			if (metadata.Methods != null)
				return;

			metadata.Methods = new MethodDefinition[image.GetTableLength(Table.Method)];
		}

		void ReadMethod(uint method_rid, Collection<MethodDefinition> methods)
		{
			var method = new MethodDefinition();
			method.rva = ReadUInt32();
			method.ImplAttributes = (MethodImplAttributes)ReadUInt16();
			method.Attributes = (MethodAttributes)ReadUInt16();
			method.Name = ReadString();
			method.token = new MetadataToken(TokenType.Method, method_rid);

			if (IsDeleted(method))
				return;

			methods.Add(method); // attach method

			var signature = ReadBlobIndex();
			var param_range = ReadListRange(method_rid, Table.Method, Table.Param);

			this.context = method;

			ReadMethodSignature(signature, method);
			metadata.AddMethodDefinition(method);

			if (param_range.Length != 0)
			{
				var position = base.position;
				ReadParameters(method, param_range);
				base.position = position;
			}

			if (module.IsWindowsMetadata())
				WindowsRuntimeProjections.Project(method);
		}

		void ReadParameters(MethodDefinition method, Range param_range)
		{
			if (!MoveTo(Table.ParamPtr, param_range.Start))
			{
				if (!MoveTo(Table.Param, param_range.Start))
					return;

				for (uint i = 0; i < param_range.Length; i++)
					ReadParameter(param_range.Start + i, method);
			}
			else
				ReadParameterPointers(method, param_range);
		}

		void ReadParameterPointers(MethodDefinition method, Range range)
		{
			for (uint i = 0; i < range.Length; i++)
			{
				MoveTo(Table.ParamPtr, range.Start + i);

				var rid = ReadTableIndex(Table.Param);

				MoveTo(Table.Param, rid);

				ReadParameter(rid, method);
			}
		}

		void ReadParameter(uint param_rid, MethodDefinition method)
		{
			var attributes = (ParameterAttributes)ReadUInt16();
			var sequence = ReadUInt16();
			var name = ReadString();

			var parameter = sequence == 0
				? method.MethodReturnType.Parameter
				: method.Parameters[sequence - 1];

			parameter.token = new MetadataToken(TokenType.Param, param_rid);
			parameter.Name = name;
			parameter.Attributes = attributes;
		}

		void ReadMethodSignature(uint signature, IMethodSignature method)
		{
			var reader = ReadSignature(signature);
			reader.ReadMethodSignature(method);
		}

		public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
		{
			InitializePInvokes();
			Row<PInvokeAttributes, uint, uint> row;

			var rid = method.token.RID;

			if (!metadata.PInvokes.TryGetValue(rid, out row))
				return null;

			metadata.PInvokes.Remove(rid);

			return new PInvokeInfo(
				row.Col1,
				image.StringHeap.Read(row.Col2),
				module.ModuleReferences[(int)row.Col3 - 1]);
		}

		void InitializePInvokes()
		{
			if (metadata.PInvokes != null)
				return;

			int length = MoveTo(Table.ImplMap);

			var pinvokes = metadata.PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(length);

			for (int i = 1; i <= length; i++)
			{
				var attributes = (PInvokeAttributes)ReadUInt16();
				var method = ReadMetadataToken(CodedIndex.MemberForwarded);
				var name = ReadStringIndex();
				var scope = ReadTableIndex(Table.File);

				if (method.TokenType != TokenType.Method)
					continue;

				pinvokes.Add(method.RID, new Row<PInvokeAttributes, uint, uint>(attributes, name, scope));
			}
		}

		public bool HasGenericParameters(IGenericParameterProvider provider)
		{
			InitializeGenericParameters();

			Range[] ranges;
			if (!metadata.TryGetGenericParameterRanges(provider, out ranges))
				return false;

			return RangesSize(ranges) > 0;
		}

		public Collection<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
		{
			InitializeGenericParameters();

			Range[] ranges;
			if (!metadata.TryGetGenericParameterRanges(provider, out ranges))
				return new GenericParameterCollection(provider);

			metadata.RemoveGenericParameterRange(provider);

			var generic_parameters = new GenericParameterCollection(provider, RangesSize(ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadGenericParametersRange(ranges[i], provider, generic_parameters);

			return generic_parameters;
		}

		void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
		{
			if (!MoveTo(Table.GenericParam, range.Start))
				return;

			for (uint i = 0; i < range.Length; i++)
			{
				ReadUInt16(); // index
				var flags = (GenericParameterAttributes)ReadUInt16();
				ReadMetadataToken(CodedIndex.TypeOrMethodDef);
				var name = ReadString();

				var parameter = new GenericParameter(name, provider);
				parameter.token = new MetadataToken(TokenType.GenericParam, range.Start + i);
				parameter.Attributes = flags;

				generic_parameters.Add(parameter);
			}
		}

		void InitializeGenericParameters()
		{
			if (metadata.GenericParameters != null)
				return;

			metadata.GenericParameters = InitializeRanges(
				Table.GenericParam, () => {
					Advance(4);
					var next = ReadMetadataToken(CodedIndex.TypeOrMethodDef);
					ReadStringIndex();
					return next;
				});
		}

		Dictionary<MetadataToken, Range[]> InitializeRanges(Table table, Func<MetadataToken> get_next)
		{
			int length = MoveTo(table);
			var ranges = new Dictionary<MetadataToken, Range[]>(length);

			if (length == 0)
				return ranges;

			MetadataToken owner = MetadataToken.Zero;
			Range range = new Range(1, 0);

			for (uint i = 1; i <= length; i++)
			{
				var next = get_next();

				if (i == 1)
				{
					owner = next;
					range.Length++;
				}
				else if (next != owner)
				{
					AddRange(ranges, owner, range);
					range = new Range(i, 1);
					owner = next;
				}
				else
					range.Length++;
			}

			AddRange(ranges, owner, range);

			return ranges;
		}

		static void AddRange(Dictionary<MetadataToken, Range[]> ranges, MetadataToken owner, Range range)
		{
			if (owner.RID == 0)
				return;

			Range[] slots;
			if (!ranges.TryGetValue(owner, out slots))
			{
				ranges.Add(owner, new[] { range });
				return;
			}

			ranges[owner] = slots.Add(range);
		}

		public bool HasGenericConstraints(GenericParameter generic_parameter)
		{
			InitializeGenericConstraints();

			Collection<Row<uint, MetadataToken>> mapping;
			if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter)
		{
			InitializeGenericConstraints();

			Collection<Row<uint, MetadataToken>> mapping;
			if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out mapping))
				return new GenericParameterConstraintCollection(generic_parameter);

			var constraints = new GenericParameterConstraintCollection(generic_parameter, mapping.Count);

			this.context = (IGenericContext)generic_parameter.Owner;

			for (int i = 0; i < mapping.Count; i++)
			{
				constraints.Add(
					new GenericParameterConstraint(
						GetTypeDefOrRef(mapping[i].Col2),
						new MetadataToken(TokenType.GenericParamConstraint, mapping[i].Col1)));
			}

			metadata.RemoveGenericConstraintMapping(generic_parameter);

			return constraints;
		}

		void InitializeGenericConstraints()
		{
			if (metadata.GenericConstraints != null)
				return;

			var length = MoveTo(Table.GenericParamConstraint);

			metadata.GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(length);

			for (uint i = 1; i <= length; i++)
			{
				AddGenericConstraintMapping(
					ReadTableIndex(Table.GenericParam),
					new Row<uint, MetadataToken>(i, ReadMetadataToken(CodedIndex.TypeDefOrRef)));
			}
		}

		void AddGenericConstraintMapping(uint generic_parameter, Row<uint, MetadataToken> constraint)
		{
			metadata.SetGenericConstraintMapping(
				generic_parameter,
				AddMapping(metadata.GenericConstraints, generic_parameter, constraint));
		}

		public bool HasOverrides(MethodDefinition method)
		{
			InitializeOverrides();
			Collection<MetadataToken> mapping;

			if (!metadata.TryGetOverrideMapping(method, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public Collection<MethodReference> ReadOverrides(MethodDefinition method)
		{
			InitializeOverrides();

			Collection<MetadataToken> mapping;
			if (!metadata.TryGetOverrideMapping(method, out mapping))
				return new Collection<MethodReference>();

			var overrides = new Collection<MethodReference>(mapping.Count);

			this.context = method;

			for (int i = 0; i < mapping.Count; i++)
				overrides.Add((MethodReference)LookupToken(mapping[i]));

			metadata.RemoveOverrideMapping(method);

			return overrides;
		}

		void InitializeOverrides()
		{
			if (metadata.Overrides != null)
				return;

			var length = MoveTo(Table.MethodImpl);

			metadata.Overrides = new Dictionary<uint, Collection<MetadataToken>>(length);

			for (int i = 1; i <= length; i++)
			{
				ReadTableIndex(Table.TypeDef);

				var method = ReadMetadataToken(CodedIndex.MethodDefOrRef);
				if (method.TokenType != TokenType.Method)
					throw new NotSupportedException();

				var @override = ReadMetadataToken(CodedIndex.MethodDefOrRef);

				AddOverrideMapping(method.RID, @override);
			}
		}

		void AddOverrideMapping(uint method_rid, MetadataToken @override)
		{
			metadata.SetOverrideMapping(
				method_rid,
				AddMapping(metadata.Overrides, method_rid, @override));
		}

		public Mono.Cecil.Cil.MethodBody ReadMethodBody(MethodDefinition method)
		{
			return code.ReadMethodBody(method);
		}

		public int ReadCodeSize(MethodDefinition method)
		{
			return code.ReadCodeSize(method);
		}

		public CallSite ReadCallSite(MetadataToken token)
		{
			if (!MoveTo(Table.StandAloneSig, token.RID))
				return null;

			var signature = ReadBlobIndex();

			var call_site = new CallSite();

			ReadMethodSignature(signature, call_site);

			call_site.MetadataToken = token;

			return call_site;
		}

		public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method = null)
		{
			if (!MoveTo(Table.StandAloneSig, local_var_token.RID))
				return null;

			var reader = ReadSignature(ReadBlobIndex());
			const byte local_sig = 0x7;

			if (reader.ReadByte() != local_sig)
				throw new NotSupportedException();

			var count = reader.ReadCompressedUInt32();
			if (count == 0)
				return null;

			var variables = new VariableDefinitionCollection(method, (int)count);

			for (int i = 0; i < count; i++)
				variables.Add(new VariableDefinition(reader.ReadTypeSignature()));

			return variables;
		}

		public IMetadataTokenProvider LookupToken(MetadataToken token)
		{
			var rid = token.RID;

			if (rid == 0)
				return null;

			if (metadata_reader != null)
				return metadata_reader.LookupToken(token);

			IMetadataTokenProvider element;
			var position = this.position;
			var context = this.context;

			switch (token.TokenType)
			{
				case TokenType.TypeDef:
					element = GetTypeDefinition(rid);
					break;
				case TokenType.TypeRef:
					element = GetTypeReference(rid);
					break;
				case TokenType.TypeSpec:
					element = GetTypeSpecification(rid);
					break;
				case TokenType.Field:
					element = GetFieldDefinition(rid);
					break;
				case TokenType.Method:
					element = GetMethodDefinition(rid);
					break;
				case TokenType.MemberRef:
					element = GetMemberReference(rid);
					break;
				case TokenType.MethodSpec:
					element = GetMethodSpecification(rid);
					break;
				default:
					return null;
			}

			this.position = position;
			this.context = context;

			return element;
		}

		public FieldDefinition GetFieldDefinition(uint rid)
		{
			InitializeTypeDefinitions();

			var field = metadata.GetFieldDefinition(rid);
			if (field != null)
				return field;

			return LookupField(rid);
		}

		FieldDefinition LookupField(uint rid)
		{
			var type = metadata.GetFieldDeclaringType(rid);
			if (type == null)
				return null;

			Mixin.Read(type.Fields);

			return metadata.GetFieldDefinition(rid);
		}

		public MethodDefinition GetMethodDefinition(uint rid)
		{
			InitializeTypeDefinitions();

			var method = metadata.GetMethodDefinition(rid);
			if (method != null)
				return method;

			return LookupMethod(rid);
		}

		MethodDefinition LookupMethod(uint rid)
		{
			var type = metadata.GetMethodDeclaringType(rid);
			if (type == null)
				return null;

			Mixin.Read(type.Methods);

			return metadata.GetMethodDefinition(rid);
		}

		MethodSpecification GetMethodSpecification(uint rid)
		{
			if (!MoveTo(Table.MethodSpec, rid))
				return null;

			var element_method = (MethodReference)LookupToken(
				ReadMetadataToken(CodedIndex.MethodDefOrRef));
			var signature = ReadBlobIndex();

			var method_spec = ReadMethodSpecSignature(signature, element_method);
			method_spec.token = new MetadataToken(TokenType.MethodSpec, rid);
			return method_spec;
		}

		MethodSpecification ReadMethodSpecSignature(uint signature, MethodReference method)
		{
			var reader = ReadSignature(signature);
			const byte methodspec_sig = 0x0a;

			var call_conv = reader.ReadByte();

			if (call_conv != methodspec_sig)
				throw new NotSupportedException();

			var arity = reader.ReadCompressedUInt32();

			var instance = new GenericInstanceMethod(method, (int)arity);

			reader.ReadGenericInstanceSignature(method, instance, arity);

			return instance;
		}

		MemberReference GetMemberReference(uint rid)
		{
			InitializeMemberReferences();

			var member = metadata.GetMemberReference(rid);
			if (member != null)
				return member;

			member = ReadMemberReference(rid);
			if (member != null && !member.ContainsGenericParameter)
				metadata.AddMemberReference(member);
			return member;
		}

		MemberReference ReadMemberReference(uint rid)
		{
			if (!MoveTo(Table.MemberRef, rid))
				return null;

			var token = ReadMetadataToken(CodedIndex.MemberRefParent);
			var name = ReadString();
			var signature = ReadBlobIndex();

			MemberReference member;

			switch (token.TokenType)
			{
				case TokenType.TypeDef:
				case TokenType.TypeRef:
				case TokenType.TypeSpec:
					member = ReadTypeMemberReference(token, name, signature);
					break;
				case TokenType.Method:
					member = ReadMethodMemberReference(token, name, signature);
					break;
				default:
					throw new NotSupportedException();
			}

			member.token = new MetadataToken(TokenType.MemberRef, rid);
			return member;
		}

		MemberReference ReadTypeMemberReference(MetadataToken type, string name, uint signature)
		{
			var declaring_type = GetTypeDefOrRef(type);

			if (!declaring_type.IsArray)
				this.context = declaring_type;

			var member = ReadMemberReferenceSignature(signature, declaring_type);
			member.Name = name;

			return member;
		}

		MemberReference ReadMemberReferenceSignature(uint signature, TypeReference declaring_type)
		{
			var reader = ReadSignature(signature);
			const byte field_sig = 0x6;

			if (reader.buffer[reader.position] == field_sig)
			{
				reader.position++;
				var field = new FieldReference();
				field.DeclaringType = declaring_type;
				field.FieldType = reader.ReadTypeSignature();
				return field;
			}
			else
			{
				var method = new MethodReference();
				method.DeclaringType = declaring_type;
				reader.ReadMethodSignature(method);
				return method;
			}
		}

		MemberReference ReadMethodMemberReference(MetadataToken token, string name, uint signature)
		{
			var method = GetMethodDefinition(token.RID);

			this.context = method;

			var member = ReadMemberReferenceSignature(signature, method.DeclaringType);
			member.Name = name;

			return member;
		}

		void InitializeMemberReferences()
		{
			if (metadata.MemberReferences != null)
				return;

			metadata.MemberReferences = new MemberReference[image.GetTableLength(Table.MemberRef)];
		}

		public IEnumerable<MemberReference> GetMemberReferences()
		{
			InitializeMemberReferences();

			var length = image.GetTableLength(Table.MemberRef);

			var type_system = module.TypeSystem;

			var context = new MethodDefinition(string.Empty, MethodAttributes.Static, type_system.Void);
			context.DeclaringType = new TypeDefinition(string.Empty, string.Empty, TypeAttributes.Public);

			var member_references = new MemberReference[length];

			for (uint i = 1; i <= length; i++)
			{
				this.context = context;
				member_references[i - 1] = GetMemberReference(i);
			}

			return member_references;
		}

		void InitializeConstants()
		{
			if (metadata.Constants != null)
				return;

			var length = MoveTo(Table.Constant);

			var constants = metadata.Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(length);

			for (uint i = 1; i <= length; i++)
			{
				var type = (ElementType)ReadUInt16();
				var owner = ReadMetadataToken(CodedIndex.HasConstant);
				var signature = ReadBlobIndex();

				constants.Add(owner, new Row<ElementType, uint>(type, signature));
			}
		}

		public TypeReference ReadConstantSignature(MetadataToken token)
		{
			if (token.TokenType != TokenType.Signature)
				throw new NotSupportedException();

			if (token.RID == 0)
				return null;

			if (!MoveTo(Table.StandAloneSig, token.RID))
				return null;

			return ReadFieldType(ReadBlobIndex());
		}

		public object ReadConstant(IConstantProvider owner)
		{
			InitializeConstants();

			Row<ElementType, uint> row;
			if (!metadata.Constants.TryGetValue(owner.MetadataToken, out row))
				return Mixin.NoValue;

			metadata.Constants.Remove(owner.MetadataToken);

			return ReadConstantValue(row.Col1, row.Col2);
		}

		object ReadConstantValue(ElementType etype, uint signature)
		{
			switch (etype)
			{
				case ElementType.Class:
				case ElementType.Object:
					return null;
				case ElementType.String:
					return ReadConstantString(signature);
				default:
					return ReadConstantPrimitive(etype, signature);
			}
		}

		string ReadConstantString(uint signature)
		{
			byte[] blob;
			int index, count;

			GetBlobView(signature, out blob, out index, out count);
			if (count == 0)
				return string.Empty;

			if ((count & 1) == 1)
				count--;

			return Encoding.Unicode.GetString(blob, index, count);
		}

		object ReadConstantPrimitive(ElementType type, uint signature)
		{
			var reader = ReadSignature(signature);
			return reader.ReadConstantSignature(type);
		}

		internal void InitializeCustomAttributes()
		{
			if (metadata.CustomAttributes != null)
				return;

			metadata.CustomAttributes = InitializeRanges(
				Table.CustomAttribute, () => {
					var next = ReadMetadataToken(CodedIndex.HasCustomAttribute);
					ReadMetadataToken(CodedIndex.CustomAttributeType);
					ReadBlobIndex();
					return next;
				});
		}

		public bool HasCustomAttributes(ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes();

			Range[] ranges;
			if (!metadata.TryGetCustomAttributeRanges(owner, out ranges))
				return false;

			return RangesSize(ranges) > 0;
		}

		public Collection<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes();

			Range[] ranges;
			if (!metadata.TryGetCustomAttributeRanges(owner, out ranges))
				return new Collection<CustomAttribute>();

			var custom_attributes = new Collection<CustomAttribute>(RangesSize(ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadCustomAttributeRange(ranges[i], custom_attributes);

			metadata.RemoveCustomAttributeRange(owner);

			if (module.IsWindowsMetadata())
				foreach (var custom_attribute in custom_attributes)
					WindowsRuntimeProjections.Project(owner, custom_attribute);

			return custom_attributes;
		}

		void ReadCustomAttributeRange(Range range, Collection<CustomAttribute> custom_attributes)
		{
			if (!MoveTo(Table.CustomAttribute, range.Start))
				return;

			for (var i = 0; i < range.Length; i++)
			{
				ReadMetadataToken(CodedIndex.HasCustomAttribute);

				var constructor = (MethodReference)LookupToken(
					ReadMetadataToken(CodedIndex.CustomAttributeType));

				var signature = ReadBlobIndex();

				custom_attributes.Add(new CustomAttribute(signature, constructor));
			}
		}

		static int RangesSize(Range[] ranges)
		{
			uint size = 0;
			for (int i = 0; i < ranges.Length; i++)
				size += ranges[i].Length;

			return (int)size;
		}

		public IEnumerable<CustomAttribute> GetCustomAttributes()
		{
			InitializeTypeDefinitions();

			var length = image.TableHeap[Table.CustomAttribute].Length;
			var custom_attributes = new Collection<CustomAttribute>((int)length);
			ReadCustomAttributeRange(new Range(1, length), custom_attributes);

			return custom_attributes;
		}

		public byte[] ReadCustomAttributeBlob(uint signature)
		{
			return ReadBlob(signature);
		}

		public void ReadCustomAttributeSignature(CustomAttribute attribute)
		{
			var reader = ReadSignature(attribute.signature);

			if (!reader.CanReadMore())
				return;

			if (reader.ReadUInt16() != 0x0001)
				throw new InvalidOperationException();

			var constructor = attribute.Constructor;
			if (constructor.HasParameters)
				reader.ReadCustomAttributeConstructorArguments(attribute, constructor.Parameters);

			if (!reader.CanReadMore())
				return;

			var named = reader.ReadUInt16();

			if (named == 0)
				return;

			reader.ReadCustomAttributeNamedArguments(named, ref attribute.fields, ref attribute.properties);
		}

		void InitializeMarshalInfos()
		{
			if (metadata.FieldMarshals != null)
				return;

			var length = MoveTo(Table.FieldMarshal);

			var marshals = metadata.FieldMarshals = new Dictionary<MetadataToken, uint>(length);

			for (int i = 0; i < length; i++)
			{
				var token = ReadMetadataToken(CodedIndex.HasFieldMarshal);
				var signature = ReadBlobIndex();
				if (token.RID == 0)
					continue;

				marshals.Add(token, signature);
			}
		}

		public bool HasMarshalInfo(IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos();

			return metadata.FieldMarshals.ContainsKey(owner.MetadataToken);
		}

		public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos();

			uint signature;
			if (!metadata.FieldMarshals.TryGetValue(owner.MetadataToken, out signature))
				return null;

			var reader = ReadSignature(signature);

			metadata.FieldMarshals.Remove(owner.MetadataToken);

			return reader.ReadMarshalInfo();
		}

		void InitializeSecurityDeclarations()
		{
			if (metadata.SecurityDeclarations != null)
				return;

			metadata.SecurityDeclarations = InitializeRanges(
				Table.DeclSecurity, () => {
					ReadUInt16();
					var next = ReadMetadataToken(CodedIndex.HasDeclSecurity);
					ReadBlobIndex();
					return next;
				});
		}

		public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations();

			Range[] ranges;
			if (!metadata.TryGetSecurityDeclarationRanges(owner, out ranges))
				return false;

			return RangesSize(ranges) > 0;
		}

		public Collection<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations();

			Range[] ranges;
			if (!metadata.TryGetSecurityDeclarationRanges(owner, out ranges))
				return new Collection<SecurityDeclaration>();

			var security_declarations = new Collection<SecurityDeclaration>(RangesSize(ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadSecurityDeclarationRange(ranges[i], security_declarations);

			metadata.RemoveSecurityDeclarationRange(owner);

			return security_declarations;
		}

		void ReadSecurityDeclarationRange(Range range, Collection<SecurityDeclaration> security_declarations)
		{
			if (!MoveTo(Table.DeclSecurity, range.Start))
				return;

			for (int i = 0; i < range.Length; i++)
			{
				var action = (SecurityAction)ReadUInt16();
				ReadMetadataToken(CodedIndex.HasDeclSecurity);
				var signature = ReadBlobIndex();

				security_declarations.Add(new SecurityDeclaration(action, signature, module));
			}
		}

		public byte[] ReadSecurityDeclarationBlob(uint signature)
		{
			return ReadBlob(signature);
		}

		public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
		{
			var signature = declaration.signature;
			var reader = ReadSignature(signature);

			if (reader.buffer[reader.position] != '.')
			{
				ReadXmlSecurityDeclaration(signature, declaration);
				return;
			}

			reader.position++;
			var count = reader.ReadCompressedUInt32();
			var attributes = new Collection<SecurityAttribute>((int)count);

			for (int i = 0; i < count; i++)
				attributes.Add(reader.ReadSecurityAttribute());

			declaration.security_attributes = attributes;
		}

		void ReadXmlSecurityDeclaration(uint signature, SecurityDeclaration declaration)
		{
			var attributes = new Collection<SecurityAttribute>(1);

			var attribute = new SecurityAttribute(
				module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"));

			attribute.properties = new Collection<CustomAttributeNamedArgument>(1);
			attribute.properties.Add(
				new CustomAttributeNamedArgument(
					"XML",
					new CustomAttributeArgument(
						module.TypeSystem.String,
						ReadUnicodeStringBlob(signature))));

			attributes.Add(attribute);

			declaration.security_attributes = attributes;
		}

		public Collection<ExportedType> ReadExportedTypes()
		{
			var length = MoveTo(Table.ExportedType);
			if (length == 0)
				return new Collection<ExportedType>();

			var exported_types = new Collection<ExportedType>(length);

			for (int i = 1; i <= length; i++)
			{
				var attributes = (TypeAttributes)ReadUInt32();
				var identifier = ReadUInt32();
				var name = ReadString();
				var @namespace = ReadString();
				var implementation = ReadMetadataToken(CodedIndex.Implementation);

				ExportedType declaring_type = null;
				IMetadataScope scope = null;

				switch (implementation.TokenType)
				{
					case TokenType.AssemblyRef:
					case TokenType.File:
						scope = GetExportedTypeScope(implementation);
						break;
					case TokenType.ExportedType:
						// FIXME: if the table is not properly sorted
						declaring_type = exported_types[(int)implementation.RID - 1];
						break;
				}

				var exported_type = new ExportedType(@namespace, name, module, scope)
				{
					Attributes = attributes,
					Identifier = (int)identifier,
					DeclaringType = declaring_type,
				};
				exported_type.token = new MetadataToken(TokenType.ExportedType, i);

				exported_types.Add(exported_type);
			}

			return exported_types;
		}

		IMetadataScope GetExportedTypeScope(MetadataToken token)
		{
			var position = this.position;
			IMetadataScope scope;

			switch (token.TokenType)
			{
				case TokenType.AssemblyRef:
					InitializeAssemblyReferences();
					scope = metadata.GetAssemblyNameReference(token.RID);
					break;
				case TokenType.File:
					InitializeModuleReferences();
					scope = GetModuleReferenceFromFile(token);
					break;
				default:
					throw new NotSupportedException();
			}

			this.position = position;
			return scope;
		}

		ModuleReference GetModuleReferenceFromFile(MetadataToken token)
		{
			if (!MoveTo(Table.File, token.RID))
				return null;

			ReadUInt32();
			var file_name = ReadString();
			var modules = module.ModuleReferences;

			ModuleReference reference;
			for (int i = 0; i < modules.Count; i++)
			{
				reference = modules[i];
				if (reference.Name == file_name)
					return reference;
			}

			reference = new ModuleReference(file_name);
			modules.Add(reference);
			return reference;
		}

		void InitializeDocuments()
		{
			if (metadata.Documents != null)
				return;

			int length = MoveTo(Table.Document);

			var documents = metadata.Documents = new Document[length];

			for (uint i = 1; i <= length; i++)
			{
				var name_index = ReadBlobIndex();
				var hash_algorithm = ReadGuid();
				var hash = ReadBlob();
				var language = ReadGuid();

				var signature = ReadSignature(name_index);
				var name = signature.ReadDocumentName();

				documents[i - 1] = new Document(name)
				{
					HashAlgorithmGuid = hash_algorithm,
					Hash = hash,
					LanguageGuid = language,
					token = new MetadataToken(TokenType.Document, i),
				};
			}
		}

		public Collection<SequencePoint> ReadSequencePoints(MethodDefinition method)
		{
			InitializeDocuments();

			if (!MoveTo(Table.MethodDebugInformation, method.MetadataToken.RID))
				return new Collection<SequencePoint>(0);

			var document_index = ReadTableIndex(Table.Document);
			var signature = ReadBlobIndex();
			if (signature == 0)
				return new Collection<SequencePoint>(0);

			var document = GetDocument(document_index);
			var reader = ReadSignature(signature);

			return reader.ReadSequencePoints(document);
		}

		public Document GetDocument(uint rid)
		{
			var document = metadata.GetDocument(rid);
			if (document == null)
				return null;

			document.custom_infos = GetCustomDebugInformation(document);
			return document;
		}

		void InitializeLocalScopes()
		{
			if (metadata.LocalScopes != null)
				return;

			InitializeMethods();

			int length = MoveTo(Table.LocalScope);

			metadata.LocalScopes = new Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>>();

			for (uint i = 1; i <= length; i++)
			{
				var method = ReadTableIndex(Table.Method);
				var import = ReadTableIndex(Table.ImportScope);
				var variables = ReadListRange(i, Table.LocalScope, Table.LocalVariable);
				var constants = ReadListRange(i, Table.LocalScope, Table.LocalConstant);
				var scope_start = ReadUInt32();
				var scope_length = ReadUInt32();

				metadata.SetLocalScopes(method, AddMapping(metadata.LocalScopes, method, new Row<uint, Range, Range, uint, uint, uint>(import, variables, constants, scope_start, scope_length, i)));
			}
		}

		public ScopeDebugInformation ReadScope(MethodDefinition method)
		{
			InitializeLocalScopes();
			InitializeImportScopes();

			Collection<Row<uint, Range, Range, uint, uint, uint>> records;
			if (!metadata.TryGetLocalScopes(method, out records))
				return null;

			var method_scope = null as ScopeDebugInformation;

			for (int i = 0; i < records.Count; i++)
			{
				var scope = ReadLocalScope(records[i]);

				if (i == 0)
				{
					method_scope = scope;
					continue;
				}

				if (!AddScope(method_scope.scopes, scope))
					method_scope.Scopes.Add(scope);
			}

			return method_scope;
		}

		static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
		{
			if (scopes.IsNullOrEmpty())
				return false;

			foreach (var sub_scope in scopes)
			{
				if (sub_scope.HasScopes && AddScope(sub_scope.Scopes, scope))
					return true;

				if (scope.Start.Offset >= sub_scope.Start.Offset && scope.End.Offset <= sub_scope.End.Offset)
				{
					sub_scope.Scopes.Add(scope);
					return true;
				}
			}

			return false;
		}

		ScopeDebugInformation ReadLocalScope(Row<uint, Range, Range, uint, uint, uint> record)
		{
			var scope = new ScopeDebugInformation
			{
				start = new InstructionOffset((int)record.Col4),
				end = new InstructionOffset((int)(record.Col4 + record.Col5)),
				token = new MetadataToken(TokenType.LocalScope, record.Col6),
			};

			if (record.Col1 > 0)
				scope.import = metadata.GetImportScope(record.Col1);

			if (record.Col2.Length > 0)
			{
				scope.variables = new Collection<VariableDebugInformation>((int)record.Col2.Length);
				for (uint i = 0; i < record.Col2.Length; i++)
				{
					var variable = ReadLocalVariable(record.Col2.Start + i);
					if (variable != null)
						scope.variables.Add(variable);
				}
			}

			if (record.Col3.Length > 0)
			{
				scope.constants = new Collection<ConstantDebugInformation>((int)record.Col3.Length);
				for (uint i = 0; i < record.Col3.Length; i++)
				{
					var constant = ReadLocalConstant(record.Col3.Start + i);
					if (constant != null)
						scope.constants.Add(constant);
				}
			}

			return scope;
		}

		VariableDebugInformation ReadLocalVariable(uint rid)
		{
			if (!MoveTo(Table.LocalVariable, rid))
				return null;

			var attributes = (VariableAttributes)ReadUInt16();
			var index = ReadUInt16();
			var name = ReadString();

			var variable = new VariableDebugInformation(index, name) { Attributes = attributes, token = new MetadataToken(TokenType.LocalVariable, rid) };
			variable.custom_infos = GetCustomDebugInformation(variable);
			return variable;
		}

		ConstantDebugInformation ReadLocalConstant(uint rid)
		{
			if (!MoveTo(Table.LocalConstant, rid))
				return null;

			var name = ReadString();
			var signature = ReadSignature(ReadBlobIndex());
			var type = signature.ReadTypeSignature();

			object value;
			if (type.etype == ElementType.String)
			{
				if (!signature.CanReadMore())
					value = "";
				else if (signature.buffer[signature.position] != 0xff)
				{
					var bytes = signature.ReadBytes((int)(signature.sig_length - (signature.position - signature.start)));
					value = Encoding.Unicode.GetString(bytes, 0, bytes.Length);
				}
				else
					value = null;
			}
			else if (type.IsTypeOf("System", "Decimal"))
			{
				var b = signature.ReadByte();
				value = new decimal(signature.ReadInt32(), signature.ReadInt32(), signature.ReadInt32(), (b & 0x80) != 0, (byte)(b & 0x7f));
			}
			else if (type.IsTypeOf("System", "DateTime"))
			{
				value = new DateTime(signature.ReadInt64());
			}
			else if (type.etype == ElementType.Object || type.etype == ElementType.None || type.etype == ElementType.Class || type.etype == ElementType.Array || type.etype == ElementType.GenericInst)
			{
				value = null;
			}
			else
				value = signature.ReadConstantSignature(type.etype);

			var constant = new ConstantDebugInformation(name, type, value) { token = new MetadataToken(TokenType.LocalConstant, rid) };
			constant.custom_infos = GetCustomDebugInformation(constant);
			return constant;
		}

		void InitializeImportScopes()
		{
			if (metadata.ImportScopes != null)
				return;

			var length = MoveTo(Table.ImportScope);

			metadata.ImportScopes = new ImportDebugInformation[length];

			for (int i = 1; i <= length; i++)
			{
				ReadTableIndex(Table.ImportScope);

				var import = new ImportDebugInformation();
				import.token = new MetadataToken(TokenType.ImportScope, i);

				var signature = ReadSignature(ReadBlobIndex());
				while (signature.CanReadMore())
					import.Targets.Add(ReadImportTarget(signature));

				metadata.ImportScopes[i - 1] = import;
			}

			MoveTo(Table.ImportScope);

			for (int i = 0; i < length; i++)
			{
				var parent = ReadTableIndex(Table.ImportScope);

				ReadBlobIndex();

				if (parent != 0)
					metadata.ImportScopes[i].Parent = metadata.GetImportScope(parent);
			}
		}

		public string ReadUTF8StringBlob(uint signature)
		{
			return ReadStringBlob(signature, Encoding.UTF8);
		}

		string ReadUnicodeStringBlob(uint signature)
		{
			return ReadStringBlob(signature, Encoding.Unicode);
		}

		string ReadStringBlob(uint signature, Encoding encoding)
		{
			byte[] blob;
			int index, count;

			GetBlobView(signature, out blob, out index, out count);
			if (count == 0)
				return string.Empty;

			return encoding.GetString(blob, index, count);
		}

		ImportTarget ReadImportTarget(SignatureReader signature)
		{
			AssemblyNameReference reference = null;
			string @namespace = null;
			string alias = null;
			TypeReference type = null;

			var kind = (ImportTargetKind)signature.ReadCompressedUInt32();
			switch (kind)
			{
				case ImportTargetKind.ImportNamespace:
					@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.ImportNamespaceInAssembly:
					reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
					@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.ImportType:
					type = signature.ReadTypeToken();
					break;
				case ImportTargetKind.ImportXmlNamespaceWithAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.ImportAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.DefineAssemblyAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.DefineNamespaceAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.DefineNamespaceInAssemblyAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
					@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					break;
				case ImportTargetKind.DefineTypeAlias:
					alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
					type = signature.ReadTypeToken();
					break;
			}

			return new ImportTarget(kind)
			{
				alias = alias,
				type = type,
				@namespace = @namespace,
				reference = reference,
			};
		}

		void InitializeStateMachineMethods()
		{
			if (metadata.StateMachineMethods != null)
				return;

			var length = MoveTo(Table.StateMachineMethod);

			metadata.StateMachineMethods = new Dictionary<uint, uint>(length);

			for (int i = 0; i < length; i++)
				metadata.StateMachineMethods.Add(ReadTableIndex(Table.Method), ReadTableIndex(Table.Method));
		}

		public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method)
		{
			InitializeStateMachineMethods();

			uint rid;
			if (!metadata.TryGetStateMachineKickOffMethod(method, out rid))
				return null;

			return GetMethodDefinition(rid);
		}

		void InitializeCustomDebugInformations()
		{
			if (metadata.CustomDebugInformations != null)
				return;

			var length = MoveTo(Table.CustomDebugInformation);

			metadata.CustomDebugInformations = new Dictionary<MetadataToken, Row<Guid, uint, uint>[]>();

			for (uint i = 1; i <= length; i++)
			{
				var token = ReadMetadataToken(CodedIndex.HasCustomDebugInformation);
				var info = new Row<Guid, uint, uint>(ReadGuid(), ReadBlobIndex(), i);

				Row<Guid, uint, uint>[] infos;
				metadata.CustomDebugInformations.TryGetValue(token, out infos);
				metadata.CustomDebugInformations[token] = infos.Add(info);
			}
		}

		public Collection<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider)
		{
			InitializeCustomDebugInformations();

			Row<Guid, uint, uint>[] rows;
			if (!metadata.CustomDebugInformations.TryGetValue(provider.MetadataToken, out rows))
				return null;

			var infos = new Collection<CustomDebugInformation>(rows.Length);

			for (int i = 0; i < rows.Length; i++)
			{
				if (rows[i].Col1 == StateMachineScopeDebugInformation.KindIdentifier)
				{
					var signature = ReadSignature(rows[i].Col2);
					var scopes = new Collection<StateMachineScope>();

					while (signature.CanReadMore())
					{
						var start = signature.ReadInt32();
						var end = start + signature.ReadInt32();
						scopes.Add(new StateMachineScope(start, end));
					}

					var state_machine = new StateMachineScopeDebugInformation();
					state_machine.scopes = scopes;

					infos.Add(state_machine);
				}
				else if (rows[i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier)
				{
					var signature = ReadSignature(rows[i].Col2);

					var catch_offset = signature.ReadInt32() - 1;
					var yields = new Collection<InstructionOffset>();
					var resumes = new Collection<InstructionOffset>();
					var resume_methods = new Collection<MethodDefinition>();

					while (signature.CanReadMore())
					{
						yields.Add(new InstructionOffset(signature.ReadInt32()));
						resumes.Add(new InstructionOffset(signature.ReadInt32()));
						resume_methods.Add(GetMethodDefinition(signature.ReadCompressedUInt32()));
					}

					var async_body = new AsyncMethodBodyDebugInformation(catch_offset);
					async_body.yields = yields;
					async_body.resumes = resumes;
					async_body.resume_methods = resume_methods;

					infos.Add(async_body);
				}
				else if (rows[i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier)
				{
					infos.Add(new EmbeddedSourceDebugInformation(rows[i].Col2, this));
				}
				else if (rows[i].Col1 == SourceLinkDebugInformation.KindIdentifier)
				{
					infos.Add(new SourceLinkDebugInformation(Encoding.UTF8.GetString(ReadBlob(rows[i].Col2))));
				}
				else
				{
					infos.Add(new BinaryCustomDebugInformation(rows[i].Col1, ReadBlob(rows[i].Col2)));
				}

				infos[i].token = new MetadataToken(TokenType.CustomDebugInformation, rows[i].Col3);
			}

			return infos;
		}

		public byte[] ReadRawEmbeddedSourceDebugInformation(uint index)
		{
			var signature = ReadSignature(index);
			return signature.ReadBytes((int)signature.sig_length);
		}

		public Row<byte[], bool> ReadEmbeddedSourceDebugInformation(uint index)
		{
			var signature = ReadSignature(index);
			var format = signature.ReadInt32();
			var length = signature.sig_length - 4;

			if (format == 0)
			{
				return new Row<byte[], bool>(signature.ReadBytes((int)length), false);
			}
			else if (format > 0)
			{
				var compressed_stream = new MemoryStream(signature.ReadBytes((int)length));
				var decompressed_document = new byte[format]; // if positive, format is the decompressed length of the document
				var decompressed_stream = new MemoryStream(decompressed_document);

				using (var deflate_stream = new DeflateStream(compressed_stream, CompressionMode.Decompress, leaveOpen: true))
					deflate_stream.CopyTo(decompressed_stream);

				return new Row<byte[], bool>(decompressed_document, true);
			}
			else
				throw new NotSupportedException();
		}
	}

	sealed class SignatureReader : ByteBuffer
	{

		readonly MetadataReader reader;
		readonly internal uint start, sig_length;

		TypeSystem TypeSystem
		{
			get { return reader.module.TypeSystem; }
		}

		public SignatureReader(uint blob, MetadataReader reader)
			: base(reader.image.BlobHeap.data)
		{
			this.reader = reader;
			this.position = (int)blob;
			this.sig_length = ReadCompressedUInt32();
			this.start = (uint)this.position;
		}

		MetadataToken ReadTypeTokenSignature()
		{
			return CodedIndex.TypeDefOrRef.GetMetadataToken(ReadCompressedUInt32());
		}

		GenericParameter GetGenericParameter(GenericParameterType type, uint var)
		{
			var context = reader.context;
			int index = (int)var;

			if (context == null)
				return GetUnboundGenericParameter(type, index);

			IGenericParameterProvider provider;

			switch (type)
			{
				case GenericParameterType.Type:
					provider = context.Type;
					break;
				case GenericParameterType.Method:
					provider = context.Method;
					break;
				default:
					throw new NotSupportedException();
			}

			if (!context.IsDefinition)
				CheckGenericContext(provider, index);

			if (index >= provider.GenericParameters.Count)
				return GetUnboundGenericParameter(type, index);

			return provider.GenericParameters[index];
		}

		GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
		{
			return new GenericParameter(index, type, reader.module);
		}

		static void CheckGenericContext(IGenericParameterProvider owner, int index)
		{
			var owner_parameters = owner.GenericParameters;

			for (int i = owner_parameters.Count; i <= index; i++)
				owner_parameters.Add(new GenericParameter(owner));
		}

		public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, uint arity)
		{
			if (!provider.IsDefinition)
				CheckGenericContext(provider, (int)arity - 1);

			var instance_arguments = instance.GenericArguments;

			for (int i = 0; i < arity; i++)
				instance_arguments.Add(ReadTypeSignature());
		}

		ArrayType ReadArrayTypeSignature()
		{
			var array = new ArrayType(ReadTypeSignature());

			var rank = ReadCompressedUInt32();

			var sizes = new uint[ReadCompressedUInt32()];
			for (int i = 0; i < sizes.Length; i++)
				sizes[i] = ReadCompressedUInt32();

			var low_bounds = new int[ReadCompressedUInt32()];
			for (int i = 0; i < low_bounds.Length; i++)
				low_bounds[i] = ReadCompressedInt32();

			array.Dimensions.Clear();

			for (int i = 0; i < rank; i++)
			{
				int? lower = null, upper = null;

				if (i < low_bounds.Length)
					lower = low_bounds[i];

				if (i < sizes.Length)
					upper = lower + (int)sizes[i] - 1;

				array.Dimensions.Add(new ArrayDimension(lower, upper));
			}

			return array;
		}

		TypeReference GetTypeDefOrRef(MetadataToken token)
		{
			return reader.GetTypeDefOrRef(token);
		}

		public TypeReference ReadTypeSignature()
		{
			return ReadTypeSignature((ElementType)ReadByte());
		}

		public TypeReference ReadTypeToken()
		{
			return GetTypeDefOrRef(ReadTypeTokenSignature());
		}

		TypeReference ReadTypeSignature(ElementType etype)
		{
			switch (etype)
			{
				case ElementType.ValueType:
					{
						var value_type = GetTypeDefOrRef(ReadTypeTokenSignature());
						value_type.KnownValueType();
						return value_type;
					}
				case ElementType.Class:
					return GetTypeDefOrRef(ReadTypeTokenSignature());
				case ElementType.Ptr:
					return new PointerType(ReadTypeSignature());
				case ElementType.FnPtr:
					{
						var fptr = new FunctionPointerType();
						ReadMethodSignature(fptr);
						return fptr;
					}
				case ElementType.ByRef:
					return new ByReferenceType(ReadTypeSignature());
				case ElementType.Pinned:
					return new PinnedType(ReadTypeSignature());
				case ElementType.SzArray:
					return new ArrayType(ReadTypeSignature());
				case ElementType.Array:
					return ReadArrayTypeSignature();
				case ElementType.CModOpt:
					return new OptionalModifierType(
						GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
				case ElementType.CModReqD:
					return new RequiredModifierType(
						GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
				case ElementType.Sentinel:
					return new SentinelType(ReadTypeSignature());
				case ElementType.Var:
					return GetGenericParameter(GenericParameterType.Type, ReadCompressedUInt32());
				case ElementType.MVar:
					return GetGenericParameter(GenericParameterType.Method, ReadCompressedUInt32());
				case ElementType.GenericInst:
					{
						var is_value_type = ReadByte() == (byte)ElementType.ValueType;
						var element_type = GetTypeDefOrRef(ReadTypeTokenSignature());

						var arity = ReadCompressedUInt32();
						var generic_instance = new GenericInstanceType(element_type, (int)arity);

						ReadGenericInstanceSignature(element_type, generic_instance, arity);

						if (is_value_type)
						{
							generic_instance.KnownValueType();
							element_type.GetElementType().KnownValueType();
						}

						return generic_instance;
					}
				case ElementType.Object: return TypeSystem.Object;
				case ElementType.Void: return TypeSystem.Void;
				case ElementType.TypedByRef: return TypeSystem.TypedReference;
				case ElementType.I: return TypeSystem.IntPtr;
				case ElementType.U: return TypeSystem.UIntPtr;
				default: return GetPrimitiveType(etype);
			}
		}

		public void ReadMethodSignature(IMethodSignature method)
		{
			var calling_convention = ReadByte();

			const byte has_this = 0x20;
			const byte explicit_this = 0x40;

			if ((calling_convention & has_this) != 0)
			{
				method.HasThis = true;
				calling_convention = (byte)(calling_convention & ~has_this);
			}

			if ((calling_convention & explicit_this) != 0)
			{
				method.ExplicitThis = true;
				calling_convention = (byte)(calling_convention & ~explicit_this);
			}

			method.CallingConvention = (MethodCallingConvention)calling_convention;

			var generic_context = method as MethodReference;
			if (generic_context != null && !generic_context.DeclaringType.IsArray)
				reader.context = generic_context;

			if ((calling_convention & 0x10) != 0)
			{
				var arity = ReadCompressedUInt32();

				if (generic_context != null && !generic_context.IsDefinition)
					CheckGenericContext(generic_context, (int)arity - 1);
			}

			var param_count = ReadCompressedUInt32();

			method.MethodReturnType.ReturnType = ReadTypeSignature();

			if (param_count == 0)
				return;

			Collection<ParameterDefinition> parameters;

			var method_ref = method as MethodReference;
			if (method_ref != null)
				parameters = method_ref.parameters = new ParameterDefinitionCollection(method, (int)param_count);
			else
				parameters = method.Parameters;

			for (int i = 0; i < param_count; i++)
				parameters.Add(new ParameterDefinition(ReadTypeSignature()));
		}

		public object ReadConstantSignature(ElementType type)
		{
			return ReadPrimitiveValue(type);
		}

		public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection<ParameterDefinition> parameters)
		{
			var count = parameters.Count;
			if (count == 0)
				return;

			attribute.arguments = new Collection<CustomAttributeArgument>(count);

			for (int i = 0; i < count; i++)
				attribute.arguments.Add(
					ReadCustomAttributeFixedArgument(parameters[i].ParameterType));
		}

		CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
		{
			if (type.IsArray)
				return ReadCustomAttributeFixedArrayArgument((ArrayType)type);

			return ReadCustomAttributeElement(type);
		}

		public void ReadCustomAttributeNamedArguments(ushort count, ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
		{
			for (int i = 0; i < count; i++)
			{
				if (!CanReadMore())
					return;
				ReadCustomAttributeNamedArgument(ref fields, ref properties);
			}
		}

		void ReadCustomAttributeNamedArgument(ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
		{
			var kind = ReadByte();
			var type = ReadCustomAttributeFieldOrPropType();
			var name = ReadUTF8String();

			Collection<CustomAttributeNamedArgument> container;
			switch (kind)
			{
				case 0x53:
					container = GetCustomAttributeNamedArgumentCollection(ref fields);
					break;
				case 0x54:
					container = GetCustomAttributeNamedArgumentCollection(ref properties);
					break;
				default:
					throw new NotSupportedException();
			}

			container.Add(new CustomAttributeNamedArgument(name, ReadCustomAttributeFixedArgument(type)));
		}

		static Collection<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(ref Collection<CustomAttributeNamedArgument> collection)
		{
			if (collection != null)
				return collection;

			return collection = new Collection<CustomAttributeNamedArgument>();
		}

		CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
		{
			var length = ReadUInt32();

			if (length == 0xffffffff)
				return new CustomAttributeArgument(type, null);

			if (length == 0)
				return new CustomAttributeArgument(type, Empty<CustomAttributeArgument>.Array);

			var arguments = new CustomAttributeArgument[length];
			var element_type = type.ElementType;

			for (int i = 0; i < length; i++)
				arguments[i] = ReadCustomAttributeElement(element_type);

			return new CustomAttributeArgument(type, arguments);
		}

		CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
		{
			if (type.IsArray)
				return ReadCustomAttributeFixedArrayArgument((ArrayType)type);

			return new CustomAttributeArgument(
				type,
				type.etype == ElementType.Object
					? ReadCustomAttributeElement(ReadCustomAttributeFieldOrPropType())
					: ReadCustomAttributeElementValue(type));
		}

		object ReadCustomAttributeElementValue(TypeReference type)
		{
			var etype = type.etype;

			switch (etype)
			{
				case ElementType.String:
					return ReadUTF8String();
				case ElementType.None:
					if (type.IsTypeOf("System", "Type"))
						return ReadTypeReference();

					return ReadCustomAttributeEnum(type);
				default:
					return ReadPrimitiveValue(etype);
			}
		}

		object ReadPrimitiveValue(ElementType type)
		{
			switch (type)
			{
				case ElementType.Boolean:
					return ReadByte() == 1;
				case ElementType.I1:
					return (sbyte)ReadByte();
				case ElementType.U1:
					return ReadByte();
				case ElementType.Char:
					return (char)ReadUInt16();
				case ElementType.I2:
					return ReadInt16();
				case ElementType.U2:
					return ReadUInt16();
				case ElementType.I4:
					return ReadInt32();
				case ElementType.U4:
					return ReadUInt32();
				case ElementType.I8:
					return ReadInt64();
				case ElementType.U8:
					return ReadUInt64();
				case ElementType.R4:
					return ReadSingle();
				case ElementType.R8:
					return ReadDouble();
				default:
					throw new NotImplementedException(type.ToString());
			}
		}

		TypeReference GetPrimitiveType(ElementType etype)
		{
			switch (etype)
			{
				case ElementType.Boolean:
					return TypeSystem.Boolean;
				case ElementType.Char:
					return TypeSystem.Char;
				case ElementType.I1:
					return TypeSystem.SByte;
				case ElementType.U1:
					return TypeSystem.Byte;
				case ElementType.I2:
					return TypeSystem.Int16;
				case ElementType.U2:
					return TypeSystem.UInt16;
				case ElementType.I4:
					return TypeSystem.Int32;
				case ElementType.U4:
					return TypeSystem.UInt32;
				case ElementType.I8:
					return TypeSystem.Int64;
				case ElementType.U8:
					return TypeSystem.UInt64;
				case ElementType.R4:
					return TypeSystem.Single;
				case ElementType.R8:
					return TypeSystem.Double;
				case ElementType.String:
					return TypeSystem.String;
				default:
					throw new NotImplementedException(etype.ToString());
			}
		}

		TypeReference ReadCustomAttributeFieldOrPropType()
		{
			var etype = (ElementType)ReadByte();

			switch (etype)
			{
				case ElementType.Boxed:
					return TypeSystem.Object;
				case ElementType.SzArray:
					return new ArrayType(ReadCustomAttributeFieldOrPropType());
				case ElementType.Enum:
					return ReadTypeReference();
				case ElementType.Type:
					return TypeSystem.LookupType("System", "Type");
				default:
					return GetPrimitiveType(etype);
			}
		}

		public TypeReference ReadTypeReference()
		{
			return TypeParser.ParseType(reader.module, ReadUTF8String());
		}

		object ReadCustomAttributeEnum(TypeReference enum_type)
		{
			var type = enum_type.CheckedResolve();
			if (!type.IsEnum)
				throw new ArgumentException();

			return ReadCustomAttributeElementValue(type.GetEnumUnderlyingType());
		}

		public SecurityAttribute ReadSecurityAttribute()
		{
			var attribute = new SecurityAttribute(ReadTypeReference());

			ReadCompressedUInt32();

			ReadCustomAttributeNamedArguments(
				(ushort)ReadCompressedUInt32(),
				ref attribute.fields,
				ref attribute.properties);

			return attribute;
		}

		public MarshalInfo ReadMarshalInfo()
		{
			var native = ReadNativeType();
			switch (native)
			{
				case NativeType.Array:
					{
						var array = new ArrayMarshalInfo();
						if (CanReadMore())
							array.element_type = ReadNativeType();
						if (CanReadMore())
							array.size_parameter_index = (int)ReadCompressedUInt32();
						if (CanReadMore())
							array.size = (int)ReadCompressedUInt32();
						if (CanReadMore())
							array.size_parameter_multiplier = (int)ReadCompressedUInt32();
						return array;
					}
				case NativeType.SafeArray:
					{
						var array = new SafeArrayMarshalInfo();
						if (CanReadMore())
							array.element_type = ReadVariantType();
						return array;
					}
				case NativeType.FixedArray:
					{
						var array = new FixedArrayMarshalInfo();
						if (CanReadMore())
							array.size = (int)ReadCompressedUInt32();
						if (CanReadMore())
							array.element_type = ReadNativeType();
						return array;
					}
				case NativeType.FixedSysString:
					{
						var sys_string = new FixedSysStringMarshalInfo();
						if (CanReadMore())
							sys_string.size = (int)ReadCompressedUInt32();
						return sys_string;
					}
				case NativeType.CustomMarshaler:
					{
						var marshaler = new CustomMarshalInfo();
						var guid_value = ReadUTF8String();
						marshaler.guid = !string.IsNullOrEmpty(guid_value) ? new Guid(guid_value) : Guid.Empty;
						marshaler.unmanaged_type = ReadUTF8String();
						marshaler.managed_type = ReadTypeReference();
						marshaler.cookie = ReadUTF8String();
						return marshaler;
					}
				default:
					return new MarshalInfo(native);
			}
		}

		NativeType ReadNativeType()
		{
			return (NativeType)ReadByte();
		}

		VariantType ReadVariantType()
		{
			return (VariantType)ReadByte();
		}

		string ReadUTF8String()
		{
			if (buffer[position] == 0xff)
			{
				position++;
				return null;
			}

			var length = (int)ReadCompressedUInt32();
			if (length == 0)
				return string.Empty;

			if (position + length > buffer.Length)
				return string.Empty;

			var @string = Encoding.UTF8.GetString(buffer, position, length);

			position += length;
			return @string;
		}

		public string ReadDocumentName()
		{
			var separator = (char)buffer[position];
			position++;

			var builder = new StringBuilder();
			for (int i = 0; CanReadMore(); i++)
			{
				if (i > 0 && separator != 0)
					builder.Append(separator);

				uint part = ReadCompressedUInt32();
				if (part != 0)
					builder.Append(reader.ReadUTF8StringBlob(part));
			}

			return builder.ToString();
		}

		public Collection<SequencePoint> ReadSequencePoints(Document document)
		{
			ReadCompressedUInt32(); // local_sig_token

			if (document == null)
				document = reader.GetDocument(ReadCompressedUInt32());

			var offset = 0;
			var start_line = 0;
			var start_column = 0;
			var first_non_hidden = true;

			//there's about 5 compressed int32's per sequenec points.  we don't know exactly how many
			//but let's take a conservative guess so we dont end up reallocating the sequence_points collection
			//as it grows.
			var bytes_remaining_for_sequencepoints = sig_length - (position - start);
			var estimated_sequencepoint_amount = (int)bytes_remaining_for_sequencepoints / 5;
			var sequence_points = new Collection<SequencePoint>(estimated_sequencepoint_amount);

			for (var i = 0; CanReadMore(); i++)
			{
				var delta_il = (int)ReadCompressedUInt32();
				if (i > 0 && delta_il == 0)
				{
					document = reader.GetDocument(ReadCompressedUInt32());
					continue;
				}

				offset += delta_il;

				var delta_lines = (int)ReadCompressedUInt32();
				var delta_columns = delta_lines == 0
					? (int)ReadCompressedUInt32()
					: ReadCompressedInt32();

				if (delta_lines == 0 && delta_columns == 0)
				{
					sequence_points.Add(new SequencePoint(offset, document)
					{
						StartLine = 0xfeefee,
						EndLine = 0xfeefee,
						StartColumn = 0,
						EndColumn = 0,
					});
					continue;
				}

				if (first_non_hidden)
				{
					start_line = (int)ReadCompressedUInt32();
					start_column = (int)ReadCompressedUInt32();
				}
				else
				{
					start_line += ReadCompressedInt32();
					start_column += ReadCompressedInt32();
				}

				sequence_points.Add(new SequencePoint(offset, document)
				{
					StartLine = start_line,
					StartColumn = start_column,
					EndLine = start_line + delta_lines,
					EndColumn = start_column + delta_columns,
				});
				first_non_hidden = false;
			}

			return sequence_points;
		}

		public bool CanReadMore()
		{
			return (position - start) < sig_length;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





















namespace Mono.Cecil
{









































	static class ModuleWriter
	{

		public static void WriteModule(ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
		{
			using (stream)
				Write(module, stream, parameters);
		}

		static void Write(ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
		{
			if ((module.Attributes & ModuleAttributes.ILOnly) == 0)
				throw new NotSupportedException("Writing mixed-mode assemblies is not supported");

			if (module.HasImage && module.ReadingMode == ReadingMode.Deferred)
			{
				var immediate_reader = new ImmediateModuleReader(module.Image);
				immediate_reader.ReadModule(module, resolve_attributes: false);
				immediate_reader.ReadSymbols(module);
			}

			module.MetadataSystem.Clear();

			if (module.symbol_reader != null)
				module.symbol_reader.Dispose();

			var name = module.assembly != null && module.kind != ModuleKind.NetModule ? module.assembly.Name : null;
			var fq_name = stream.value.GetFileName();
			var timestamp = parameters.Timestamp ?? module.timestamp;
			var symbol_writer_provider = parameters.SymbolWriterProvider;

			if (symbol_writer_provider == null && parameters.WriteSymbols)
				symbol_writer_provider = new DefaultSymbolWriterProvider();

			if (parameters.HasStrongNameKey && name != null)
			{
				name.PublicKey = CryptoService.GetPublicKey(parameters);
				module.Attributes |= ModuleAttributes.StrongNameSigned;
			}

			if (parameters.DeterministicMvid)
				module.Mvid = Guid.Empty;

			var metadata = new MetadataBuilder(module, fq_name, timestamp, symbol_writer_provider);
			try
			{
				module.metadata_builder = metadata;

				using (var symbol_writer = GetSymbolWriter(module, fq_name, symbol_writer_provider, parameters))
				{
					metadata.SetSymbolWriter(symbol_writer);
					BuildMetadata(module, metadata);

					if (parameters.DeterministicMvid)
						metadata.ComputeDeterministicMvid();

					var writer = ImageWriter.CreateWriter(module, metadata, stream);
					stream.value.SetLength(0);
					writer.WriteImage();

					if (parameters.HasStrongNameKey)
						CryptoService.StrongName(stream.value, writer, parameters);
				}
			}
			finally
			{
				module.metadata_builder = null;
			}
		}

		static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
		{
			if (!module.HasImage)
			{
				metadata.BuildMetadata();
				return;
			}

			module.Read(metadata, (builder, _) => {
				builder.BuildMetadata();
				return builder;
			});
		}

		static Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters)
		{
			if (symbol_writer_provider == null)
				return null;

			if (parameters.SymbolStream != null)
				return symbol_writer_provider.GetSymbolWriter(module, parameters.SymbolStream);

			return symbol_writer_provider.GetSymbolWriter(module, fq_name);
		}
	}

	abstract class MetadataTable
	{

		public abstract int Length { get; }

		public bool IsLarge
		{
			get { return Length > ushort.MaxValue; }
		}

		public abstract void Write(TableHeapBuffer buffer);
		public abstract void Sort();
	}

	abstract class OneRowTable<TRow> : MetadataTable where TRow : struct
	{

		internal TRow row;

		public sealed override int Length
		{
			get { return 1; }
		}

		public sealed override void Sort()
		{
		}
	}

	abstract class MetadataTable<TRow> : MetadataTable where TRow : struct
	{

		internal TRow[] rows = new TRow[2];
		internal int length;

		public sealed override int Length
		{
			get { return length; }
		}

		public int AddRow(TRow row)
		{
			if (rows.Length == length)
				Grow();

			rows[length++] = row;
			return length;
		}

		void Grow()
		{
			var rows = new TRow[this.rows.Length * 2];
			Array.Copy(this.rows, rows, this.rows.Length);
			this.rows = rows;
		}

		public override void Sort()
		{
		}
	}

	abstract class SortedTable<TRow> : MetadataTable<TRow>, IComparer<TRow> where TRow : struct
	{

		public sealed override void Sort()
		{
			MergeSort<TRow>.Sort(rows, 0, this.length, this);
		}

		protected static int Compare(uint x, uint y)
		{
			return x == y ? 0 : x > y ? 1 : -1;
		}

		public abstract int Compare(TRow x, TRow y);
	}

	sealed class ModuleTable : OneRowTable<ModuleRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			buffer.WriteUInt16(0);      // Generation
			buffer.WriteString(row.Col1);   // Name
			buffer.WriteGuid(row.Col2);     // Mvid
			buffer.WriteUInt16(0);      // EncId
			buffer.WriteUInt16(0);      // EncBaseId
		}
	}

	sealed class TypeRefTable : MetadataTable<TypeRefRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(
					rows[i].Col1, CodedIndex.ResolutionScope);  // Scope
				buffer.WriteString(rows[i].Col2);           // Name
				buffer.WriteString(rows[i].Col3);           // Namespace
			}
		}
	}

	sealed class TypeDefTable : MetadataTable<TypeDefRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1); // Attributes
				buffer.WriteString(rows[i].Col2);           // Name
				buffer.WriteString(rows[i].Col3);           // Namespace
				buffer.WriteCodedRID(
					rows[i].Col4, CodedIndex.TypeDefOrRef); // Extends
				buffer.WriteRID(rows[i].Col5, Table.Field); // FieldList
				buffer.WriteRID(rows[i].Col6, Table.Method);    // MethodList
			}
		}
	}

	sealed class FieldTable : MetadataTable<FieldRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Attributes
				buffer.WriteString(rows[i].Col2);           // Name
				buffer.WriteBlob(rows[i].Col3);         // Signature
			}
		}
	}

	sealed class MethodTable : MetadataTable<MethodRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);       // RVA
				buffer.WriteUInt16((ushort)rows[i].Col2);   // ImplFlags
				buffer.WriteUInt16((ushort)rows[i].Col3);   // Flags
				buffer.WriteString(rows[i].Col4);       // Name
				buffer.WriteBlob(rows[i].Col5);     // Signature
				buffer.WriteRID(rows[i].Col6, Table.Param); // ParamList
			}
		}
	}

	sealed class ParamTable : MetadataTable<ParamRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Attributes
				buffer.WriteUInt16(rows[i].Col2);       // Sequence
				buffer.WriteString(rows[i].Col3);       // Name
			}
		}
	}

	sealed class InterfaceImplTable : MetadataTable<InterfaceImplRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);       // Class
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);    // Interface
			}
		}

		/*public override int Compare (InterfaceImplRow x, InterfaceImplRow y)
		{
			return (int) (x.Col1 == y.Col1 ? y.Col2 - x.Col2 : x.Col1 - y.Col1);
		}*/
	}

	sealed class MemberRefTable : MetadataTable<MemberRefRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MemberRefParent);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}

	sealed class ConstantTable : SortedTable<ConstantRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasConstant);
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(ConstantRow x, ConstantRow y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}

	sealed class CustomAttributeTable : SortedTable<CustomAttributeRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomAttribute);  // Parent
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.CustomAttributeType); // Type
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(CustomAttributeRow x, CustomAttributeRow y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}

	sealed class FieldMarshalTable : SortedTable<FieldMarshalRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasFieldMarshal);
				buffer.WriteBlob(rows[i].Col2);
			}
		}

		public override int Compare(FieldMarshalRow x, FieldMarshalRow y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}

	sealed class DeclSecurityTable : SortedTable<DeclSecurityRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasDeclSecurity);
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(DeclSecurityRow x, DeclSecurityRow y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}

	sealed class ClassLayoutTable : SortedTable<ClassLayoutRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);       // PackingSize
				buffer.WriteUInt32(rows[i].Col2);       // ClassSize
				buffer.WriteRID(rows[i].Col3, Table.TypeDef);   // Parent
			}
		}

		public override int Compare(ClassLayoutRow x, ClassLayoutRow y)
		{
			return Compare(x.Col3, y.Col3);
		}
	}

	sealed class FieldLayoutTable : SortedTable<FieldLayoutRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);       // Offset
				buffer.WriteRID(rows[i].Col2, Table.Field); // Parent
			}
		}

		public override int Compare(FieldLayoutRow x, FieldLayoutRow y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}

	sealed class StandAloneSigTable : MetadataTable<uint>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteBlob(rows[i]);
		}
	}

	sealed class EventMapTable : MetadataTable<EventMapRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);       // Parent
				buffer.WriteRID(rows[i].Col2, Table.Event);     // EventList
			}
		}
	}

	sealed class EventTable : MetadataTable<EventRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Flags
				buffer.WriteString(rows[i].Col2);       // Name
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeDefOrRef);    // EventType
			}
		}
	}

	sealed class PropertyMapTable : MetadataTable<PropertyMapRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);       // Parent
				buffer.WriteRID(rows[i].Col2, Table.Property);  // PropertyList
			}
		}
	}

	sealed class PropertyTable : MetadataTable<PropertyRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Flags
				buffer.WriteString(rows[i].Col2);       // Name
				buffer.WriteBlob(rows[i].Col3);     // Type
			}
		}
	}

	sealed class MethodSemanticsTable : SortedTable<MethodSemanticsRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Flags
				buffer.WriteRID(rows[i].Col2, Table.Method);    // Method
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.HasSemantics);    // Association
			}
		}

		public override int Compare(MethodSemanticsRow x, MethodSemanticsRow y)
		{
			return Compare(x.Col3, y.Col3);
		}
	}

	sealed class MethodImplTable : MetadataTable<MethodImplRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);   // Class
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MethodDefOrRef);  // MethodBody
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.MethodDefOrRef);  // MethodDeclaration
			}
		}
	}

	sealed class ModuleRefTable : MetadataTable<uint>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteString(rows[i]);    // Name
		}
	}

	sealed class TypeSpecTable : MetadataTable<uint>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteBlob(rows[i]);  // Signature
		}
	}

	sealed class ImplMapTable : SortedTable<ImplMapRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Flags
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MemberForwarded); // MemberForwarded
				buffer.WriteString(rows[i].Col3);       // ImportName
				buffer.WriteRID(rows[i].Col4, Table.ModuleRef); // ImportScope
			}
		}

		public override int Compare(ImplMapRow x, ImplMapRow y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}

	sealed class FieldRVATable : SortedTable<FieldRVARow>
	{

		internal int position;

		public override void Write(TableHeapBuffer buffer)
		{
			position = buffer.position;
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);       // RVA
				buffer.WriteRID(rows[i].Col2, Table.Field); // Field
			}
		}

		public override int Compare(FieldRVARow x, FieldRVARow y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}

	sealed class AssemblyTable : OneRowTable<AssemblyRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			buffer.WriteUInt32((uint)row.Col1); // AssemblyHashAlgorithm
			buffer.WriteUInt16(row.Col2);           // MajorVersion
			buffer.WriteUInt16(row.Col3);           // MinorVersion
			buffer.WriteUInt16(row.Col4);           // Build
			buffer.WriteUInt16(row.Col5);           // Revision
			buffer.WriteUInt32((uint)row.Col6); // Flags
			buffer.WriteBlob(row.Col7);         // PublicKey
			buffer.WriteString(row.Col8);           // Name
			buffer.WriteString(row.Col9);           // Culture
		}
	}

	sealed class AssemblyRefTable : MetadataTable<AssemblyRefRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);       // MajorVersion
				buffer.WriteUInt16(rows[i].Col2);       // MinorVersion
				buffer.WriteUInt16(rows[i].Col3);       // Build
				buffer.WriteUInt16(rows[i].Col4);       // Revision
				buffer.WriteUInt32((uint)rows[i].Col5); // Flags
				buffer.WriteBlob(rows[i].Col6);     // PublicKeyOrToken
				buffer.WriteString(rows[i].Col7);       // Name
				buffer.WriteString(rows[i].Col8);       // Culture
				buffer.WriteBlob(rows[i].Col9);     // Hash
			}
		}
	}

	sealed class FileTable : MetadataTable<FileRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}

	sealed class ExportedTypeTable : MetadataTable<ExportedTypeRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1);
				buffer.WriteUInt32(rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteString(rows[i].Col4);
				buffer.WriteCodedRID(rows[i].Col5, CodedIndex.Implementation);
			}
		}
	}

	sealed class ManifestResourceTable : MetadataTable<ManifestResourceRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);
				buffer.WriteUInt32((uint)rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteCodedRID(rows[i].Col4, CodedIndex.Implementation);
			}
		}
	}

	sealed class NestedClassTable : SortedTable<NestedClassRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);       // NestedClass
				buffer.WriteRID(rows[i].Col2, Table.TypeDef);       // EnclosingClass
			}
		}

		public override int Compare(NestedClassRow x, NestedClassRow y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}

	sealed class GenericParamTable : MetadataTable<GenericParamRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);       // Number
				buffer.WriteUInt16((ushort)rows[i].Col2);   // Flags
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeOrMethodDef); // Owner
				buffer.WriteString(rows[i].Col4);       // Name
			}
		}
	}

	sealed class MethodSpecTable : MetadataTable<MethodSpecRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MethodDefOrRef);  // Method
				buffer.WriteBlob(rows[i].Col2); // Instantiation
			}
		}
	}

	sealed class GenericParamConstraintTable : MetadataTable<GenericParamConstraintRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.GenericParam);  // Owner
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);    // Constraint
			}
		}
	}

	sealed class DocumentTable : MetadataTable<DocumentRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteBlob(rows[i].Col1); // Name
				buffer.WriteGuid(rows[i].Col2); // HashAlgorithm
				buffer.WriteBlob(rows[i].Col3); // Hash
				buffer.WriteGuid(rows[i].Col4); // Language
			}
		}
	}

	sealed class MethodDebugInformationTable : MetadataTable<MethodDebugInformationRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.Document);  // Document
				buffer.WriteBlob(rows[i].Col2); // SequencePoints
			}
		}
	}

	sealed class LocalScopeTable : MetadataTable<LocalScopeRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.Method);    // Method
				buffer.WriteRID(rows[i].Col2, Table.ImportScope);   // ImportScope
				buffer.WriteRID(rows[i].Col3, Table.LocalVariable); // VariableList
				buffer.WriteRID(rows[i].Col4, Table.LocalConstant); // ConstantList
				buffer.WriteUInt32(rows[i].Col5); // StartOffset
				buffer.WriteUInt32(rows[i].Col6); // Length
			}
		}
	}

	sealed class LocalVariableTable : MetadataTable<LocalVariableRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);   // Attributes
				buffer.WriteUInt16(rows[i].Col2);   // Index
				buffer.WriteString(rows[i].Col3); // Name
			}
		}
	}

	sealed class LocalConstantTable : MetadataTable<LocalConstantRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteString(rows[i].Col1);   // Name
				buffer.WriteBlob(rows[i].Col2); // Signature
			}
		}
	}

	sealed class ImportScopeTable : MetadataTable<ImportScopeRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.ImportScope);   // Parent
				buffer.WriteBlob(rows[i].Col2); // Imports
			}
		}
	}

	sealed class StateMachineMethodTable : MetadataTable<StateMachineMethodRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.Method);    // MoveNextMethod
				buffer.WriteRID(rows[i].Col2, Table.Method);    // KickoffMethod
			}
		}
	}

	sealed class CustomDebugInformationTable : SortedTable<CustomDebugInformationRow>
	{

		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomDebugInformation);   // Parent
				buffer.WriteGuid(rows[i].Col2); // Kind
				buffer.WriteBlob(rows[i].Col3); // Value
			}
		}

		public override int Compare(CustomDebugInformationRow x, CustomDebugInformationRow y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}

	sealed class MetadataBuilder
	{

		readonly internal ModuleDefinition module;
		readonly internal ISymbolWriterProvider symbol_writer_provider;
		internal Mono.Cecil.Cil.ISymbolWriter symbol_writer;
		readonly internal TextMap text_map;
		readonly internal string fq_name;
		readonly internal uint timestamp;

		readonly Dictionary<TypeRefRow, MetadataToken> type_ref_map;
		readonly Dictionary<uint, MetadataToken> type_spec_map;
		readonly Dictionary<MemberRefRow, MetadataToken> member_ref_map;
		readonly Dictionary<MethodSpecRow, MetadataToken> method_spec_map;
		readonly Collection<GenericParameter> generic_parameters;

		readonly internal CodeWriter code;
		readonly internal DataBuffer data;
		readonly internal ResourceBuffer resources;
		readonly internal StringHeapBuffer string_heap;
		readonly internal GuidHeapBuffer guid_heap;
		readonly internal UserStringHeapBuffer user_string_heap;
		readonly internal BlobHeapBuffer blob_heap;
		readonly internal TableHeapBuffer table_heap;
		readonly internal PdbHeapBuffer pdb_heap;

		internal MetadataToken entry_point;

		internal RID type_rid = 1;
		internal RID field_rid = 1;
		internal RID method_rid = 1;
		internal RID param_rid = 1;
		internal RID property_rid = 1;
		internal RID event_rid = 1;
		internal RID local_variable_rid = 1;
		internal RID local_constant_rid = 1;

		readonly TypeRefTable type_ref_table;
		readonly TypeDefTable type_def_table;
		readonly FieldTable field_table;
		readonly MethodTable method_table;
		readonly ParamTable param_table;
		readonly InterfaceImplTable iface_impl_table;
		readonly MemberRefTable member_ref_table;
		readonly ConstantTable constant_table;
		readonly CustomAttributeTable custom_attribute_table;
		readonly DeclSecurityTable declsec_table;
		readonly StandAloneSigTable standalone_sig_table;
		readonly EventMapTable event_map_table;
		readonly EventTable event_table;
		readonly PropertyMapTable property_map_table;
		readonly PropertyTable property_table;
		readonly TypeSpecTable typespec_table;
		readonly MethodSpecTable method_spec_table;

		internal MetadataBuilder metadata_builder;

		readonly DocumentTable document_table;
		readonly MethodDebugInformationTable method_debug_information_table;
		readonly LocalScopeTable local_scope_table;
		readonly LocalVariableTable local_variable_table;
		readonly LocalConstantTable local_constant_table;
		readonly ImportScopeTable import_scope_table;
		readonly StateMachineMethodTable state_machine_method_table;
		readonly CustomDebugInformationTable custom_debug_information_table;

		readonly Dictionary<ImportScopeRow, MetadataToken> import_scope_map;
		readonly Dictionary<string, MetadataToken> document_map;

		public MetadataBuilder(ModuleDefinition module, string fq_name, uint timestamp, ISymbolWriterProvider symbol_writer_provider)
		{
			this.module = module;
			this.text_map = CreateTextMap();
			this.fq_name = fq_name;
			this.timestamp = timestamp;
			this.symbol_writer_provider = symbol_writer_provider;

			this.code = new CodeWriter(this);
			this.data = new DataBuffer();
			this.resources = new ResourceBuffer();
			this.string_heap = new StringHeapBuffer();
			this.guid_heap = new GuidHeapBuffer();
			this.user_string_heap = new UserStringHeapBuffer();
			this.blob_heap = new BlobHeapBuffer();
			this.table_heap = new TableHeapBuffer(module, this);

			this.type_ref_table = GetTable<TypeRefTable>(Table.TypeRef);
			this.type_def_table = GetTable<TypeDefTable>(Table.TypeDef);
			this.field_table = GetTable<FieldTable>(Table.Field);
			this.method_table = GetTable<MethodTable>(Table.Method);
			this.param_table = GetTable<ParamTable>(Table.Param);
			this.iface_impl_table = GetTable<InterfaceImplTable>(Table.InterfaceImpl);
			this.member_ref_table = GetTable<MemberRefTable>(Table.MemberRef);
			this.constant_table = GetTable<ConstantTable>(Table.Constant);
			this.custom_attribute_table = GetTable<CustomAttributeTable>(Table.CustomAttribute);
			this.declsec_table = GetTable<DeclSecurityTable>(Table.DeclSecurity);
			this.standalone_sig_table = GetTable<StandAloneSigTable>(Table.StandAloneSig);
			this.event_map_table = GetTable<EventMapTable>(Table.EventMap);
			this.event_table = GetTable<EventTable>(Table.Event);
			this.property_map_table = GetTable<PropertyMapTable>(Table.PropertyMap);
			this.property_table = GetTable<PropertyTable>(Table.Property);
			this.typespec_table = GetTable<TypeSpecTable>(Table.TypeSpec);
			this.method_spec_table = GetTable<MethodSpecTable>(Table.MethodSpec);

			var row_equality_comparer = new RowEqualityComparer();
			type_ref_map = new Dictionary<TypeRefRow, MetadataToken>(row_equality_comparer);
			type_spec_map = new Dictionary<uint, MetadataToken>();
			member_ref_map = new Dictionary<MemberRefRow, MetadataToken>(row_equality_comparer);
			method_spec_map = new Dictionary<MethodSpecRow, MetadataToken>(row_equality_comparer);
			generic_parameters = new Collection<GenericParameter>();

			this.document_table = GetTable<DocumentTable>(Table.Document);
			this.method_debug_information_table = GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
			this.local_scope_table = GetTable<LocalScopeTable>(Table.LocalScope);
			this.local_variable_table = GetTable<LocalVariableTable>(Table.LocalVariable);
			this.local_constant_table = GetTable<LocalConstantTable>(Table.LocalConstant);
			this.import_scope_table = GetTable<ImportScopeTable>(Table.ImportScope);
			this.state_machine_method_table = GetTable<StateMachineMethodTable>(Table.StateMachineMethod);
			this.custom_debug_information_table = GetTable<CustomDebugInformationTable>(Table.CustomDebugInformation);

			this.document_map = new Dictionary<string, MetadataToken>(StringComparer.Ordinal);
			this.import_scope_map = new Dictionary<ImportScopeRow, MetadataToken>(row_equality_comparer);
		}

		public MetadataBuilder(ModuleDefinition module, PortablePdbWriterProvider writer_provider)
		{
			this.module = module;
			this.text_map = new TextMap();
			this.symbol_writer_provider = writer_provider;

			this.string_heap = new StringHeapBuffer();
			this.guid_heap = new GuidHeapBuffer();
			this.user_string_heap = new UserStringHeapBuffer();
			this.blob_heap = new BlobHeapBuffer();
			this.table_heap = new TableHeapBuffer(module, this);
			this.pdb_heap = new PdbHeapBuffer();

			this.document_table = GetTable<DocumentTable>(Table.Document);
			this.method_debug_information_table = GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
			this.local_scope_table = GetTable<LocalScopeTable>(Table.LocalScope);
			this.local_variable_table = GetTable<LocalVariableTable>(Table.LocalVariable);
			this.local_constant_table = GetTable<LocalConstantTable>(Table.LocalConstant);
			this.import_scope_table = GetTable<ImportScopeTable>(Table.ImportScope);
			this.state_machine_method_table = GetTable<StateMachineMethodTable>(Table.StateMachineMethod);
			this.custom_debug_information_table = GetTable<CustomDebugInformationTable>(Table.CustomDebugInformation);

			var row_equality_comparer = new RowEqualityComparer();

			this.document_map = new Dictionary<string, MetadataToken>();
			this.import_scope_map = new Dictionary<ImportScopeRow, MetadataToken>(row_equality_comparer);
		}

		public void SetSymbolWriter(Mono.Cecil.Cil.ISymbolWriter writer)
		{
			symbol_writer = writer;

			if (symbol_writer == null && module.HasImage && module.Image.HasDebugTables())
				symbol_writer = new PortablePdbWriter(this, module);
		}

		TextMap CreateTextMap()
		{
			var map = new TextMap();
			map.AddMap(TextSegment.ImportAddressTable, module.Architecture == TargetArchitecture.I386 ? 8 : 0);
			map.AddMap(TextSegment.CLIHeader, 0x48, 8);
			return map;
		}

		TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
		{
			return table_heap.GetTable<TTable>(table);
		}

		uint GetStringIndex(string @string)
		{
			if (string.IsNullOrEmpty(@string))
				return 0;

			return string_heap.GetStringIndex(@string);
		}

		uint GetGuidIndex(Guid guid)
		{
			return guid_heap.GetGuidIndex(guid);
		}

		uint GetBlobIndex(ByteBuffer blob)
		{
			if (blob.length == 0)
				return 0;

			return blob_heap.GetBlobIndex(blob);
		}

		uint GetBlobIndex(byte[] blob)
		{
			if (blob.IsNullOrEmpty())
				return 0;

			return GetBlobIndex(new ByteBuffer(blob));
		}

		public void BuildMetadata()
		{
			BuildModule();

			table_heap.string_offsets = string_heap.WriteStrings();
			table_heap.ComputeTableInformations();
			table_heap.WriteTableHeap();
		}

		void BuildModule()
		{
			var table = GetTable<ModuleTable>(Table.Module);
			table.row.Col1 = GetStringIndex(module.Name);
			table.row.Col2 = GetGuidIndex(module.Mvid);

			var assembly = module.Assembly;

			if (module.kind != ModuleKind.NetModule && assembly != null)
				BuildAssembly();

			if (module.HasAssemblyReferences)
				AddAssemblyReferences();

			if (module.HasModuleReferences)
				AddModuleReferences();

			if (module.HasResources)
				AddResources();

			if (module.HasExportedTypes)
				AddExportedTypes();

			BuildTypes();

			if (module.kind != ModuleKind.NetModule && assembly != null)
			{
				if (assembly.HasCustomAttributes)
					AddCustomAttributes(assembly);

				if (assembly.HasSecurityDeclarations)
					AddSecurityDeclarations(assembly);
			}

			if (module.HasCustomAttributes)
				AddCustomAttributes(module);

			if (module.EntryPoint != null)
				entry_point = LookupToken(module.EntryPoint);
		}

		void BuildAssembly()
		{
			var assembly = module.Assembly;
			var name = assembly.Name;

			var table = GetTable<AssemblyTable>(Table.Assembly);

			table.row = new AssemblyRow(
				name.HashAlgorithm,
				(ushort)name.Version.Major,
				(ushort)name.Version.Minor,
				(ushort)name.Version.Build,
				(ushort)name.Version.Revision,
				name.Attributes,
				GetBlobIndex(name.PublicKey),
				GetStringIndex(name.Name),
				GetStringIndex(name.Culture));

			if (assembly.Modules.Count > 1)
				BuildModules();
		}

		void BuildModules()
		{
			var modules = this.module.Assembly.Modules;
			var table = GetTable<FileTable>(Table.File);

			for (int i = 0; i < modules.Count; i++)
			{
				var module = modules[i];
				if (module.IsMain)
					continue;

#if NET_CORE
				throw new NotSupportedException ();
#else
				var parameters = new WriterParameters
				{
					SymbolWriterProvider = symbol_writer_provider,
				};

				var file_name = GetModuleFileName(module.Name);
				module.Write(file_name, parameters);

				var hash = CryptoService.ComputeHash(file_name);

				table.AddRow(new FileRow(
					FileAttributes.ContainsMetaData,
					GetStringIndex(module.Name),
					GetBlobIndex(hash)));
#endif
			}
		}

#if !NET_CORE
		string GetModuleFileName(string name)
		{
			if (string.IsNullOrEmpty(name))
				throw new NotSupportedException();

			var path = Path.GetDirectoryName(fq_name);
			return Path.Combine(path, name);
		}
#endif

		void AddAssemblyReferences()
		{
			var references = module.AssemblyReferences;
			var table = GetTable<AssemblyRefTable>(Table.AssemblyRef);

			if (module.IsWindowsMetadata())
				module.Projections.RemoveVirtualReferences(references);

			for (int i = 0; i < references.Count; i++)
			{
				var reference = references[i];

				var key_or_token = reference.PublicKey.IsNullOrEmpty()
					? reference.PublicKeyToken
					: reference.PublicKey;

				var version = reference.Version;

				var rid = table.AddRow(new AssemblyRefRow(
					(ushort)version.Major,
					(ushort)version.Minor,
					(ushort)version.Build,
					(ushort)version.Revision,
					reference.Attributes,
					GetBlobIndex(key_or_token),
					GetStringIndex(reference.Name),
					GetStringIndex(reference.Culture),
					GetBlobIndex(reference.Hash)));

				reference.token = new MetadataToken(TokenType.AssemblyRef, rid);
			}

			if (module.IsWindowsMetadata())
				module.Projections.AddVirtualReferences(references);
		}

		void AddModuleReferences()
		{
			var references = module.ModuleReferences;
			var table = GetTable<ModuleRefTable>(Table.ModuleRef);

			for (int i = 0; i < references.Count; i++)
			{
				var reference = references[i];

				reference.token = new MetadataToken(
					TokenType.ModuleRef,
					table.AddRow(GetStringIndex(reference.Name)));
			}
		}

		void AddResources()
		{
			var resources = module.Resources;
			var table = GetTable<ManifestResourceTable>(Table.ManifestResource);

			for (int i = 0; i < resources.Count; i++)
			{
				var resource = resources[i];

				var row = new ManifestResourceRow(
					0,
					resource.Attributes,
					GetStringIndex(resource.Name),
					0);

				switch (resource.ResourceType)
				{
					case ResourceType.Embedded:
						row.Col1 = AddEmbeddedResource((EmbeddedResource)resource);
						break;
					case ResourceType.Linked:
						row.Col4 = CodedIndex.Implementation.CompressMetadataToken(
							new MetadataToken(
								TokenType.File,
								AddLinkedResource((LinkedResource)resource)));
						break;
					case ResourceType.AssemblyLinked:
						row.Col4 = CodedIndex.Implementation.CompressMetadataToken(
							((AssemblyLinkedResource)resource).Assembly.MetadataToken);
						break;
					default:
						throw new NotSupportedException();
				}

				table.AddRow(row);
			}
		}

		uint AddLinkedResource(LinkedResource resource)
		{
			var table = GetTable<FileTable>(Table.File);
			var hash = resource.Hash;

			if (hash.IsNullOrEmpty())
				hash = CryptoService.ComputeHash(resource.File);

			return (uint)table.AddRow(new FileRow(
				FileAttributes.ContainsNoMetaData,
				GetStringIndex(resource.File),
				GetBlobIndex(hash)));
		}

		uint AddEmbeddedResource(EmbeddedResource resource)
		{
			return resources.AddResource(resource.GetResourceData());
		}

		void AddExportedTypes()
		{
			var exported_types = module.ExportedTypes;
			var table = GetTable<ExportedTypeTable>(Table.ExportedType);

			for (int i = 0; i < exported_types.Count; i++)
			{
				var exported_type = exported_types[i];

				var rid = table.AddRow(new ExportedTypeRow(
					exported_type.Attributes,
					(uint)exported_type.Identifier,
					GetStringIndex(exported_type.Name),
					GetStringIndex(exported_type.Namespace),
					MakeCodedRID(GetExportedTypeScope(exported_type), CodedIndex.Implementation)));

				exported_type.token = new MetadataToken(TokenType.ExportedType, rid);
			}
		}

		MetadataToken GetExportedTypeScope(ExportedType exported_type)
		{
			if (exported_type.DeclaringType != null)
				return exported_type.DeclaringType.MetadataToken;

			var scope = exported_type.Scope;
			switch (scope.MetadataToken.TokenType)
			{
				case TokenType.AssemblyRef:
					return scope.MetadataToken;
				case TokenType.ModuleRef:
					var file_table = GetTable<FileTable>(Table.File);
					for (int i = 0; i < file_table.length; i++)
						if (file_table.rows[i].Col2 == GetStringIndex(scope.Name))
							return new MetadataToken(TokenType.File, i + 1);

					break;
			}

			throw new NotSupportedException();
		}

		void BuildTypes()
		{
			if (!module.HasTypes)
				return;

			AttachTokens();
			AddTypes();
			AddGenericParameters();
		}

		void AttachTokens()
		{
			var types = module.Types;

			for (int i = 0; i < types.Count; i++)
				AttachTypeToken(types[i]);
		}

		void AttachTypeToken(TypeDefinition type)
		{
			var treatment = WindowsRuntimeProjections.RemoveProjection(type);

			type.token = new MetadataToken(TokenType.TypeDef, type_rid++);
			type.fields_range.Start = field_rid;
			type.methods_range.Start = method_rid;

			if (type.HasFields)
				AttachFieldsToken(type);

			if (type.HasMethods)
				AttachMethodsToken(type);

			if (type.HasNestedTypes)
				AttachNestedTypesToken(type);

			WindowsRuntimeProjections.ApplyProjection(type, treatment);
		}

		void AttachNestedTypesToken(TypeDefinition type)
		{
			var nested_types = type.NestedTypes;
			for (int i = 0; i < nested_types.Count; i++)
				AttachTypeToken(nested_types[i]);
		}

		void AttachFieldsToken(TypeDefinition type)
		{
			var fields = type.Fields;
			type.fields_range.Length = (uint)fields.Count;
			for (int i = 0; i < fields.Count; i++)
				fields[i].token = new MetadataToken(TokenType.Field, field_rid++);
		}

		void AttachMethodsToken(TypeDefinition type)
		{
			var methods = type.Methods;
			type.methods_range.Length = (uint)methods.Count;
			for (int i = 0; i < methods.Count; i++)
				methods[i].token = new MetadataToken(TokenType.Method, method_rid++);
		}

		MetadataToken GetTypeToken(TypeReference type)
		{
			if (type == null)
				return MetadataToken.Zero;

			if (type.IsDefinition)
				return type.token;

			if (type.IsTypeSpecification())
				return GetTypeSpecToken(type);

			return GetTypeRefToken(type);
		}

		MetadataToken GetTypeSpecToken(TypeReference type)
		{
			var row = GetBlobIndex(GetTypeSpecSignature(type));

			MetadataToken token;
			if (type_spec_map.TryGetValue(row, out token))
				return token;

			return AddTypeSpecification(type, row);
		}

		MetadataToken AddTypeSpecification(TypeReference type, uint row)
		{
			type.token = new MetadataToken(TokenType.TypeSpec, typespec_table.AddRow(row));

			var token = type.token;
			type_spec_map.Add(row, token);
			return token;
		}

		MetadataToken GetTypeRefToken(TypeReference type)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection(type);

			var row = CreateTypeRefRow(type);

			MetadataToken token;
			if (!type_ref_map.TryGetValue(row, out token))
				token = AddTypeReference(type, row);

			WindowsRuntimeProjections.ApplyProjection(type, projection);

			return token;
		}

		TypeRefRow CreateTypeRefRow(TypeReference type)
		{
			var scope_token = GetScopeToken(type);

			return new TypeRefRow(
				MakeCodedRID(scope_token, CodedIndex.ResolutionScope),
				GetStringIndex(type.Name),
				GetStringIndex(type.Namespace));
		}

		MetadataToken GetScopeToken(TypeReference type)
		{
			if (type.IsNested)
				return GetTypeRefToken(type.DeclaringType);

			var scope = type.Scope;

			if (scope == null)
				return MetadataToken.Zero;

			return scope.MetadataToken;
		}

		static CodedRID MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
		{
			return MakeCodedRID(provider.MetadataToken, index);
		}

		static CodedRID MakeCodedRID(MetadataToken token, CodedIndex index)
		{
			return index.CompressMetadataToken(token);
		}

		MetadataToken AddTypeReference(TypeReference type, TypeRefRow row)
		{
			type.token = new MetadataToken(TokenType.TypeRef, type_ref_table.AddRow(row));

			var token = type.token;
			type_ref_map.Add(row, token);
			return token;
		}

		void AddTypes()
		{
			var types = module.Types;

			for (int i = 0; i < types.Count; i++)
				AddType(types[i]);
		}

		void AddType(TypeDefinition type)
		{
			var treatment = WindowsRuntimeProjections.RemoveProjection(type);

			type_def_table.AddRow(new TypeDefRow(
				type.Attributes,
				GetStringIndex(type.Name),
				GetStringIndex(type.Namespace),
				MakeCodedRID(GetTypeToken(type.BaseType), CodedIndex.TypeDefOrRef),
				type.fields_range.Start,
				type.methods_range.Start));

			if (type.HasGenericParameters)
				AddGenericParameters(type);

			if (type.HasInterfaces)
				AddInterfaces(type);

			if (type.HasLayoutInfo)
				AddLayoutInfo(type);

			if (type.HasFields)
				AddFields(type);

			if (type.HasMethods)
				AddMethods(type);

			if (type.HasProperties)
				AddProperties(type);

			if (type.HasEvents)
				AddEvents(type);

			if (type.HasCustomAttributes)
				AddCustomAttributes(type);

			if (type.HasSecurityDeclarations)
				AddSecurityDeclarations(type);

			if (type.HasNestedTypes)
				AddNestedTypes(type);

			WindowsRuntimeProjections.ApplyProjection(type, treatment);
		}

		void AddGenericParameters(IGenericParameterProvider owner)
		{
			var parameters = owner.GenericParameters;

			for (int i = 0; i < parameters.Count; i++)
				generic_parameters.Add(parameters[i]);
		}

		sealed class GenericParameterComparer : IComparer<GenericParameter>
		{

			public int Compare(GenericParameter a, GenericParameter b)
			{
				var a_owner = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
				var b_owner = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
				if (a_owner == b_owner)
				{
					var a_pos = a.Position;
					var b_pos = b.Position;
					return a_pos == b_pos ? 0 : a_pos > b_pos ? 1 : -1;
				}

				return a_owner > b_owner ? 1 : -1;
			}
		}

		void AddGenericParameters()
		{
			var items = this.generic_parameters.items;
			var size = this.generic_parameters.size;
			Array.Sort(items, 0, size, new GenericParameterComparer());

			var generic_param_table = GetTable<GenericParamTable>(Table.GenericParam);
			var generic_param_constraint_table = GetTable<GenericParamConstraintTable>(Table.GenericParamConstraint);

			for (int i = 0; i < size; i++)
			{
				var generic_parameter = items[i];

				var rid = generic_param_table.AddRow(new GenericParamRow(
					(ushort)generic_parameter.Position,
					generic_parameter.Attributes,
					MakeCodedRID(generic_parameter.Owner, CodedIndex.TypeOrMethodDef),
					GetStringIndex(generic_parameter.Name)));

				generic_parameter.token = new MetadataToken(TokenType.GenericParam, rid);

				if (generic_parameter.HasConstraints)
					AddConstraints(generic_parameter, generic_param_constraint_table);

				if (generic_parameter.HasCustomAttributes)
					AddCustomAttributes(generic_parameter);
			}
		}

		void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
		{
			var constraints = generic_parameter.Constraints;

			var gp_rid = generic_parameter.token.RID;

			for (int i = 0; i < constraints.Count; i++)
			{
				var constraint = constraints[i];

				var rid = table.AddRow(new GenericParamConstraintRow(
					gp_rid,
					MakeCodedRID(GetTypeToken(constraint.ConstraintType), CodedIndex.TypeDefOrRef)));

				constraint.token = new MetadataToken(TokenType.GenericParamConstraint, rid);

				if (constraint.HasCustomAttributes)
					AddCustomAttributes(constraint);
			}
		}

		void AddInterfaces(TypeDefinition type)
		{
			var interfaces = type.Interfaces;
			var type_rid = type.token.RID;

			for (int i = 0; i < interfaces.Count; i++)
			{
				var iface_impl = interfaces[i];

				var rid = iface_impl_table.AddRow(new InterfaceImplRow(
					type_rid,
					MakeCodedRID(GetTypeToken(iface_impl.InterfaceType), CodedIndex.TypeDefOrRef)));

				iface_impl.token = new MetadataToken(TokenType.InterfaceImpl, rid);

				if (iface_impl.HasCustomAttributes)
					AddCustomAttributes(iface_impl);
			}
		}

		void AddLayoutInfo(TypeDefinition type)
		{
			var table = GetTable<ClassLayoutTable>(Table.ClassLayout);

			table.AddRow(new ClassLayoutRow(
				(ushort)type.PackingSize,
				(uint)type.ClassSize,
				type.token.RID));
		}

		void AddNestedTypes(TypeDefinition type)
		{
			var nested_types = type.NestedTypes;
			var nested_table = GetTable<NestedClassTable>(Table.NestedClass);

			for (int i = 0; i < nested_types.Count; i++)
			{
				var nested = nested_types[i];
				AddType(nested);
				nested_table.AddRow(new NestedClassRow(nested.token.RID, type.token.RID));
			}
		}

		void AddFields(TypeDefinition type)
		{
			var fields = type.Fields;

			for (int i = 0; i < fields.Count; i++)
				AddField(fields[i]);
		}

		void AddField(FieldDefinition field)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection(field);

			field_table.AddRow(new FieldRow(
				field.Attributes,
				GetStringIndex(field.Name),
				GetBlobIndex(GetFieldSignature(field))));

			if (!field.InitialValue.IsNullOrEmpty())
				AddFieldRVA(field);

			if (field.HasLayoutInfo)
				AddFieldLayout(field);

			if (field.HasCustomAttributes)
				AddCustomAttributes(field);

			if (field.HasConstant)
				AddConstant(field, field.FieldType);

			if (field.HasMarshalInfo)
				AddMarshalInfo(field);

			WindowsRuntimeProjections.ApplyProjection(field, projection);
		}

		void AddFieldRVA(FieldDefinition field)
		{
			var table = GetTable<FieldRVATable>(Table.FieldRVA);
			table.AddRow(new FieldRVARow(
				data.AddData(field.InitialValue),
				field.token.RID));
		}

		void AddFieldLayout(FieldDefinition field)
		{
			var table = GetTable<FieldLayoutTable>(Table.FieldLayout);
			table.AddRow(new FieldLayoutRow((uint)field.Offset, field.token.RID));
		}

		void AddMethods(TypeDefinition type)
		{
			var methods = type.Methods;

			for (int i = 0; i < methods.Count; i++)
				AddMethod(methods[i]);
		}

		void AddMethod(MethodDefinition method)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection(method);

			method_table.AddRow(new MethodRow(
				method.HasBody ? code.WriteMethodBody(method) : 0,
				method.ImplAttributes,
				method.Attributes,
				GetStringIndex(method.Name),
				GetBlobIndex(GetMethodSignature(method)),
				param_rid));

			AddParameters(method);

			if (method.HasGenericParameters)
				AddGenericParameters(method);

			if (method.IsPInvokeImpl)
				AddPInvokeInfo(method);

			if (method.HasCustomAttributes)
				AddCustomAttributes(method);

			if (method.HasSecurityDeclarations)
				AddSecurityDeclarations(method);

			if (method.HasOverrides)
				AddOverrides(method);

			WindowsRuntimeProjections.ApplyProjection(method, projection);
		}

		void AddParameters(MethodDefinition method)
		{
			var return_parameter = method.MethodReturnType.parameter;

			if (return_parameter != null && RequiresParameterRow(return_parameter))
				AddParameter(0, return_parameter, param_table);

			if (!method.HasParameters)
				return;

			var parameters = method.Parameters;

			for (int i = 0; i < parameters.Count; i++)
			{
				var parameter = parameters[i];
				if (!RequiresParameterRow(parameter))
					continue;

				AddParameter((ushort)(i + 1), parameter, param_table);
			}
		}

		void AddPInvokeInfo(MethodDefinition method)
		{
			var pinvoke = method.PInvokeInfo;
			if (pinvoke == null)
				return;

			var table = GetTable<ImplMapTable>(Table.ImplMap);
			table.AddRow(new ImplMapRow(
				pinvoke.Attributes,
				MakeCodedRID(method, CodedIndex.MemberForwarded),
				GetStringIndex(pinvoke.EntryPoint),
				pinvoke.Module.MetadataToken.RID));
		}

		void AddOverrides(MethodDefinition method)
		{
			var overrides = method.Overrides;
			var table = GetTable<MethodImplTable>(Table.MethodImpl);

			for (int i = 0; i < overrides.Count; i++)
			{
				table.AddRow(new MethodImplRow(
					method.DeclaringType.token.RID,
					MakeCodedRID(method, CodedIndex.MethodDefOrRef),
					MakeCodedRID(LookupToken(overrides[i]), CodedIndex.MethodDefOrRef)));
			}
		}

		static bool RequiresParameterRow(ParameterDefinition parameter)
		{
			return !string.IsNullOrEmpty(parameter.Name)
				|| parameter.Attributes != ParameterAttributes.None
				|| parameter.HasMarshalInfo
				|| parameter.HasConstant
				|| parameter.HasCustomAttributes;
		}

		void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
		{
			table.AddRow(new ParamRow(
				parameter.Attributes,
				sequence,
				GetStringIndex(parameter.Name)));

			parameter.token = new MetadataToken(TokenType.Param, param_rid++);

			if (parameter.HasCustomAttributes)
				AddCustomAttributes(parameter);

			if (parameter.HasConstant)
				AddConstant(parameter, parameter.ParameterType);

			if (parameter.HasMarshalInfo)
				AddMarshalInfo(parameter);
		}

		void AddMarshalInfo(IMarshalInfoProvider owner)
		{
			var table = GetTable<FieldMarshalTable>(Table.FieldMarshal);

			table.AddRow(new FieldMarshalRow(
				MakeCodedRID(owner, CodedIndex.HasFieldMarshal),
				GetBlobIndex(GetMarshalInfoSignature(owner))));
		}

		void AddProperties(TypeDefinition type)
		{
			var properties = type.Properties;

			property_map_table.AddRow(new PropertyMapRow(type.token.RID, property_rid));

			for (int i = 0; i < properties.Count; i++)
				AddProperty(properties[i]);
		}

		void AddProperty(PropertyDefinition property)
		{
			property_table.AddRow(new PropertyRow(
				property.Attributes,
				GetStringIndex(property.Name),
				GetBlobIndex(GetPropertySignature(property))));
			property.token = new MetadataToken(TokenType.Property, property_rid++);

			var method = property.GetMethod;
			if (method != null)
				AddSemantic(MethodSemanticsAttributes.Getter, property, method);

			method = property.SetMethod;
			if (method != null)
				AddSemantic(MethodSemanticsAttributes.Setter, property, method);

			if (property.HasOtherMethods)
				AddOtherSemantic(property, property.OtherMethods);

			if (property.HasCustomAttributes)
				AddCustomAttributes(property);

			if (property.HasConstant)
				AddConstant(property, property.PropertyType);
		}

		void AddOtherSemantic(IMetadataTokenProvider owner, Collection<MethodDefinition> others)
		{
			for (int i = 0; i < others.Count; i++)
				AddSemantic(MethodSemanticsAttributes.Other, owner, others[i]);
		}

		void AddEvents(TypeDefinition type)
		{
			var events = type.Events;

			event_map_table.AddRow(new EventMapRow(type.token.RID, event_rid));

			for (int i = 0; i < events.Count; i++)
				AddEvent(events[i]);
		}

		void AddEvent(EventDefinition @event)
		{
			event_table.AddRow(new EventRow(
				@event.Attributes,
				GetStringIndex(@event.Name),
				MakeCodedRID(GetTypeToken(@event.EventType), CodedIndex.TypeDefOrRef)));
			@event.token = new MetadataToken(TokenType.Event, event_rid++);

			var method = @event.AddMethod;
			if (method != null)
				AddSemantic(MethodSemanticsAttributes.AddOn, @event, method);

			method = @event.InvokeMethod;
			if (method != null)
				AddSemantic(MethodSemanticsAttributes.Fire, @event, method);

			method = @event.RemoveMethod;
			if (method != null)
				AddSemantic(MethodSemanticsAttributes.RemoveOn, @event, method);

			if (@event.HasOtherMethods)
				AddOtherSemantic(@event, @event.OtherMethods);

			if (@event.HasCustomAttributes)
				AddCustomAttributes(@event);
		}

		void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
		{
			method.SemanticsAttributes = semantics;
			var table = GetTable<MethodSemanticsTable>(Table.MethodSemantics);

			table.AddRow(new MethodSemanticsRow(
				semantics,
				method.token.RID,
				MakeCodedRID(provider, CodedIndex.HasSemantics)));
		}

		void AddConstant(IConstantProvider owner, TypeReference type)
		{
			var constant = owner.Constant;
			var etype = GetConstantType(type, constant);

			constant_table.AddRow(new ConstantRow(
				etype,
				MakeCodedRID(owner.MetadataToken, CodedIndex.HasConstant),
				GetBlobIndex(GetConstantSignature(etype, constant))));
		}

		static ElementType GetConstantType(TypeReference constant_type, object constant)
		{
			if (constant == null)
				return ElementType.Class;

			var etype = constant_type.etype;
			switch (etype)
			{
				case ElementType.None:
					var type = constant_type.CheckedResolve();
					if (type.IsEnum)
						return GetConstantType(type.GetEnumUnderlyingType(), constant);

					return ElementType.Class;
				case ElementType.String:
					return ElementType.String;
				case ElementType.Object:
					return GetConstantType(constant.GetType());
				case ElementType.Array:
				case ElementType.SzArray:
				case ElementType.MVar:
				case ElementType.Var:
					return ElementType.Class;
				case ElementType.GenericInst:
					var generic_instance = (GenericInstanceType)constant_type;
					if (generic_instance.ElementType.IsTypeOf("System", "Nullable`1"))
						return GetConstantType(generic_instance.GenericArguments[0], constant);

					return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
				case ElementType.CModOpt:
				case ElementType.CModReqD:
				case ElementType.ByRef:
				case ElementType.Sentinel:
					return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I:
				case ElementType.I1:
				case ElementType.I2:
				case ElementType.I4:
				case ElementType.I8:
				case ElementType.U:
				case ElementType.U1:
				case ElementType.U2:
				case ElementType.U4:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
					return GetConstantType(constant.GetType());
				default:
					return etype;
			}
		}

		static ElementType GetConstantType(Type type)
		{
			switch (Type.GetTypeCode(type))
			{
				case TypeCode.Boolean:
					return ElementType.Boolean;
				case TypeCode.Byte:
					return ElementType.U1;
				case TypeCode.SByte:
					return ElementType.I1;
				case TypeCode.Char:
					return ElementType.Char;
				case TypeCode.Int16:
					return ElementType.I2;
				case TypeCode.UInt16:
					return ElementType.U2;
				case TypeCode.Int32:
					return ElementType.I4;
				case TypeCode.UInt32:
					return ElementType.U4;
				case TypeCode.Int64:
					return ElementType.I8;
				case TypeCode.UInt64:
					return ElementType.U8;
				case TypeCode.Single:
					return ElementType.R4;
				case TypeCode.Double:
					return ElementType.R8;
				case TypeCode.String:
					return ElementType.String;
				default:
					throw new NotSupportedException(type.FullName);
			}
		}

		void AddCustomAttributes(ICustomAttributeProvider owner)
		{
			var custom_attributes = owner.CustomAttributes;

			for (int i = 0; i < custom_attributes.Count; i++)
			{
				var attribute = custom_attributes[i];

				var projection = WindowsRuntimeProjections.RemoveProjection(attribute);

				custom_attribute_table.AddRow(new CustomAttributeRow(
					MakeCodedRID(owner, CodedIndex.HasCustomAttribute),
					MakeCodedRID(LookupToken(attribute.Constructor), CodedIndex.CustomAttributeType),
					GetBlobIndex(GetCustomAttributeSignature(attribute))));

				WindowsRuntimeProjections.ApplyProjection(attribute, projection);
			}
		}

		void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			var declarations = owner.SecurityDeclarations;

			for (int i = 0; i < declarations.Count; i++)
			{
				var declaration = declarations[i];

				declsec_table.AddRow(new DeclSecurityRow(
					declaration.Action,
					MakeCodedRID(owner, CodedIndex.HasDeclSecurity),
					GetBlobIndex(GetSecurityDeclarationSignature(declaration))));
			}
		}

		MetadataToken GetMemberRefToken(MemberReference member)
		{
			var row = CreateMemberRefRow(member);

			MetadataToken token;
			if (!member_ref_map.TryGetValue(row, out token))
				token = AddMemberReference(member, row);

			return token;
		}

		MemberRefRow CreateMemberRefRow(MemberReference member)
		{
			return new MemberRefRow(
				MakeCodedRID(GetTypeToken(member.DeclaringType), CodedIndex.MemberRefParent),
				GetStringIndex(member.Name),
				GetBlobIndex(GetMemberRefSignature(member)));
		}

		MetadataToken AddMemberReference(MemberReference member, MemberRefRow row)
		{
			member.token = new MetadataToken(TokenType.MemberRef, member_ref_table.AddRow(row));

			var token = member.token;
			member_ref_map.Add(row, token);
			return token;
		}

		MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
		{
			var row = CreateMethodSpecRow(method_spec);

			MetadataToken token;
			if (method_spec_map.TryGetValue(row, out token))
				return token;

			AddMethodSpecification(method_spec, row);

			return method_spec.token;
		}

		void AddMethodSpecification(MethodSpecification method_spec, MethodSpecRow row)
		{
			method_spec.token = new MetadataToken(TokenType.MethodSpec, method_spec_table.AddRow(row));
			method_spec_map.Add(row, method_spec.token);
		}

		MethodSpecRow CreateMethodSpecRow(MethodSpecification method_spec)
		{
			return new MethodSpecRow(
				MakeCodedRID(LookupToken(method_spec.ElementMethod), CodedIndex.MethodDefOrRef),
				GetBlobIndex(GetMethodSpecSignature(method_spec)));
		}

		SignatureWriter CreateSignatureWriter()
		{
			return new SignatureWriter(this);
		}

		SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
		{
			if (!method_spec.IsGenericInstance)
				throw new NotSupportedException();

			var generic_instance = (GenericInstanceMethod)method_spec;

			var signature = CreateSignatureWriter();
			signature.WriteByte(0x0a);

			signature.WriteGenericInstanceSignature(generic_instance);

			return signature;
		}

		public uint AddStandAloneSignature(uint signature)
		{
			return (uint)standalone_sig_table.AddRow(signature);
		}

		public uint GetLocalVariableBlobIndex(Collection<VariableDefinition> variables)
		{
			return GetBlobIndex(GetVariablesSignature(variables));
		}

		public uint GetCallSiteBlobIndex(CallSite call_site)
		{
			return GetBlobIndex(GetMethodSignature(call_site));
		}

		public uint GetConstantTypeBlobIndex(TypeReference constant_type)
		{
			return GetBlobIndex(GetConstantTypeSignature(constant_type));
		}

		SignatureWriter GetVariablesSignature(Collection<VariableDefinition> variables)
		{
			var signature = CreateSignatureWriter();
			signature.WriteByte(0x7);
			signature.WriteCompressedUInt32((uint)variables.Count);
			for (int i = 0; i < variables.Count; i++)
				signature.WriteTypeSignature(variables[i].VariableType);
			return signature;
		}

		SignatureWriter GetConstantTypeSignature(TypeReference constant_type)
		{
			var signature = CreateSignatureWriter();
			signature.WriteByte(0x6);
			signature.WriteTypeSignature(constant_type);
			return signature;
		}

		SignatureWriter GetFieldSignature(FieldReference field)
		{
			var signature = CreateSignatureWriter();
			signature.WriteByte(0x6);
			signature.WriteTypeSignature(field.FieldType);
			return signature;
		}

		SignatureWriter GetMethodSignature(IMethodSignature method)
		{
			var signature = CreateSignatureWriter();
			signature.WriteMethodSignature(method);
			return signature;
		}

		SignatureWriter GetMemberRefSignature(MemberReference member)
		{
			var field = member as FieldReference;
			if (field != null)
				return GetFieldSignature(field);

			var method = member as MethodReference;
			if (method != null)
				return GetMethodSignature(method);

			throw new NotSupportedException();
		}

		SignatureWriter GetPropertySignature(PropertyDefinition property)
		{
			var signature = CreateSignatureWriter();
			byte calling_convention = 0x8;
			if (property.HasThis)
				calling_convention |= 0x20;

			uint param_count = 0;
			Collection<ParameterDefinition> parameters = null;

			if (property.HasParameters)
			{
				parameters = property.Parameters;
				param_count = (uint)parameters.Count;
			}

			signature.WriteByte(calling_convention);
			signature.WriteCompressedUInt32(param_count);
			signature.WriteTypeSignature(property.PropertyType);

			if (param_count == 0)
				return signature;

			for (int i = 0; i < param_count; i++)
				signature.WriteTypeSignature(parameters[i].ParameterType);

			return signature;
		}

		SignatureWriter GetTypeSpecSignature(TypeReference type)
		{
			var signature = CreateSignatureWriter();
			signature.WriteTypeSignature(type);
			return signature;
		}

		SignatureWriter GetConstantSignature(ElementType type, object value)
		{
			var signature = CreateSignatureWriter();

			switch (type)
			{
				case ElementType.Array:
				case ElementType.SzArray:
				case ElementType.Class:
				case ElementType.Object:
				case ElementType.None:
				case ElementType.Var:
				case ElementType.MVar:
					signature.WriteInt32(0);
					break;
				case ElementType.String:
					signature.WriteConstantString((string)value);
					break;
				default:
					signature.WriteConstantPrimitive(value);
					break;
			}

			return signature;
		}

		SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
		{
			var signature = CreateSignatureWriter();
			if (!attribute.resolved)
			{
				signature.WriteBytes(attribute.GetBlob());
				return signature;
			}

			signature.WriteUInt16(0x0001);

			signature.WriteCustomAttributeConstructorArguments(attribute);

			signature.WriteCustomAttributeNamedArguments(attribute);

			return signature;
		}

		SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
		{
			var signature = CreateSignatureWriter();

			if (!declaration.resolved)
				signature.WriteBytes(declaration.GetBlob());
			else if (module.Runtime < TargetRuntime.Net_2_0)
				signature.WriteXmlSecurityDeclaration(declaration);
			else
				signature.WriteSecurityDeclaration(declaration);

			return signature;
		}

		SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
		{
			var signature = CreateSignatureWriter();

			signature.WriteMarshalInfo(owner.MarshalInfo);

			return signature;
		}

		static Exception CreateForeignMemberException(MemberReference member)
		{
			return new ArgumentException(string.Format("Member '{0}' is declared in another module and needs to be imported", member));
		}

		public MetadataToken LookupToken(IMetadataTokenProvider provider)
		{
			if (provider == null)
				throw new ArgumentNullException();

			if (metadata_builder != null)
				return metadata_builder.LookupToken(provider);

			var member = provider as MemberReference;
			if (member == null || member.Module != module)
				throw CreateForeignMemberException(member);

			var token = provider.MetadataToken;

			switch (token.TokenType)
			{
				case TokenType.TypeDef:
				case TokenType.Method:
				case TokenType.Field:
				case TokenType.Event:
				case TokenType.Property:
					return token;
				case TokenType.TypeRef:
				case TokenType.TypeSpec:
				case TokenType.GenericParam:
					return GetTypeToken((TypeReference)provider);
				case TokenType.MethodSpec:
					return GetMethodSpecToken((MethodSpecification)provider);
				case TokenType.MemberRef:
					return GetMemberRefToken(member);
				default:
					throw new NotSupportedException();
			}
		}

		public void AddMethodDebugInformation(MethodDebugInformation method_info)
		{
			if (method_info.HasSequencePoints)
				AddSequencePoints(method_info);

			if (method_info.Scope != null)
				AddLocalScope(method_info, method_info.Scope);

			if (method_info.StateMachineKickOffMethod != null)
				AddStateMachineMethod(method_info);

			AddCustomDebugInformations(method_info.Method);
		}

		void AddStateMachineMethod(MethodDebugInformation method_info)
		{
			state_machine_method_table.AddRow(new StateMachineMethodRow(method_info.Method.MetadataToken.RID, method_info.StateMachineKickOffMethod.MetadataToken.RID));
		}

		void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope)
		{
			var rid = local_scope_table.AddRow(new LocalScopeRow(
				method_info.Method.MetadataToken.RID,
				scope.import != null ? AddImportScope(scope.import) : 0,
				local_variable_rid,
				local_constant_rid,
				(uint)scope.Start.Offset,
				(uint)((scope.End.IsEndOfMethod ? method_info.code_size : scope.End.Offset) - scope.Start.Offset)));

			scope.token = new MetadataToken(TokenType.LocalScope, rid);

			AddCustomDebugInformations(scope);

			if (scope.HasVariables)
				AddLocalVariables(scope);

			if (scope.HasConstants)
				AddLocalConstants(scope);

			for (int i = 0; i < scope.Scopes.Count; i++)
				AddLocalScope(method_info, scope.Scopes[i]);
		}

		void AddLocalVariables(ScopeDebugInformation scope)
		{
			for (int i = 0; i < scope.Variables.Count; i++)
			{
				var variable = scope.Variables[i];
				local_variable_table.AddRow(new LocalVariableRow(variable.Attributes, (ushort)variable.Index, GetStringIndex(variable.Name)));
				variable.token = new MetadataToken(TokenType.LocalVariable, local_variable_rid);
				local_variable_rid++;

				AddCustomDebugInformations(variable);
			}
		}

		void AddLocalConstants(ScopeDebugInformation scope)
		{
			for (int i = 0; i < scope.Constants.Count; i++)
			{
				var constant = scope.Constants[i];
				local_constant_table.AddRow(new LocalConstantRow(GetStringIndex(constant.Name), GetBlobIndex(GetConstantSignature(constant))));
				constant.token = new MetadataToken(TokenType.LocalConstant, local_constant_rid);
				local_constant_rid++;
			}
		}

		SignatureWriter GetConstantSignature(ConstantDebugInformation constant)
		{
			var type = constant.ConstantType;

			var signature = CreateSignatureWriter();
			signature.WriteTypeSignature(type);

			if (type.IsTypeOf("System", "Decimal"))
			{
				var bits = decimal.GetBits((decimal)constant.Value);

				var low = (uint)bits[0];
				var mid = (uint)bits[1];
				var high = (uint)bits[2];

				var scale = (byte)(bits[3] >> 16);
				var negative = (bits[3] & 0x80000000) != 0;

				signature.WriteByte((byte)(scale | (negative ? 0x80 : 0x00)));
				signature.WriteUInt32(low);
				signature.WriteUInt32(mid);
				signature.WriteUInt32(high);

				return signature;
			}

			if (type.IsTypeOf("System", "DateTime"))
			{
				var date = (DateTime)constant.Value;
				signature.WriteInt64(date.Ticks);
				return signature;
			}

			signature.WriteBytes(GetConstantSignature(type.etype, constant.Value));

			return signature;
		}

		public void AddCustomDebugInformations(ICustomDebugInformationProvider provider)
		{
			if (!provider.HasCustomDebugInformations)
				return;

			var custom_infos = provider.CustomDebugInformations;

			for (int i = 0; i < custom_infos.Count; i++)
			{
				var custom_info = custom_infos[i];
				switch (custom_info.Kind)
				{
					case CustomDebugInformationKind.Binary:
						var binary_info = (BinaryCustomDebugInformation)custom_info;
						AddCustomDebugInformation(provider, binary_info, GetBlobIndex(binary_info.Data));
						break;
					case CustomDebugInformationKind.AsyncMethodBody:
						AddAsyncMethodBodyDebugInformation(provider, (AsyncMethodBodyDebugInformation)custom_info);
						break;
					case CustomDebugInformationKind.StateMachineScope:
						AddStateMachineScopeDebugInformation(provider, (StateMachineScopeDebugInformation)custom_info);
						break;
					case CustomDebugInformationKind.EmbeddedSource:
						AddEmbeddedSourceDebugInformation(provider, (EmbeddedSourceDebugInformation)custom_info);
						break;
					case CustomDebugInformationKind.SourceLink:
						AddSourceLinkDebugInformation(provider, (SourceLinkDebugInformation)custom_info);
						break;
					default:
						throw new NotImplementedException();
				}
			}
		}

		void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope)
		{
			var method_info = ((MethodDefinition)provider).DebugInformation;

			var signature = CreateSignatureWriter();

			var scopes = state_machine_scope.Scopes;

			for (int i = 0; i < scopes.Count; i++)
			{
				var scope = scopes[i];
				signature.WriteUInt32((uint)scope.Start.Offset);

				var end_offset = scope.End.IsEndOfMethod
					? method_info.code_size
					: scope.End.Offset;

				signature.WriteUInt32((uint)(end_offset - scope.Start.Offset));
			}

			AddCustomDebugInformation(provider, state_machine_scope, signature);
		}

		void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method)
		{
			var signature = CreateSignatureWriter();
			signature.WriteUInt32((uint)async_method.catch_handler.Offset + 1);

			if (!async_method.yields.IsNullOrEmpty())
			{
				for (int i = 0; i < async_method.yields.Count; i++)
				{
					signature.WriteUInt32((uint)async_method.yields[i].Offset);
					signature.WriteUInt32((uint)async_method.resumes[i].Offset);
					signature.WriteCompressedUInt32(async_method.resume_methods[i].MetadataToken.RID);
				}
			}

			AddCustomDebugInformation(provider, async_method, signature);
		}

		void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source)
		{
			var signature = CreateSignatureWriter();

			if (!embedded_source.resolved)
			{
				signature.WriteBytes(embedded_source.ReadRawEmbeddedSourceDebugInformation());
				AddCustomDebugInformation(provider, embedded_source, signature);
				return;
			}

			var content = embedded_source.content ?? Empty<byte>.Array;
			if (embedded_source.compress)
			{
				signature.WriteInt32(content.Length);

				var decompressed_stream = new MemoryStream(content);
				var content_stream = new MemoryStream();

				using (var compress_stream = new DeflateStream(content_stream, CompressionMode.Compress, leaveOpen: true))
					decompressed_stream.CopyTo(compress_stream);

				signature.WriteBytes(content_stream.ToArray());
			}
			else
			{
				signature.WriteInt32(0);
				signature.WriteBytes(content);
			}

			AddCustomDebugInformation(provider, embedded_source, signature);
		}

		void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link)
		{
			var signature = CreateSignatureWriter();
			signature.WriteBytes(Encoding.UTF8.GetBytes(source_link.content));

			AddCustomDebugInformation(provider, source_link, signature);
		}

		void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature)
		{
			AddCustomDebugInformation(provider, custom_info, GetBlobIndex(signature));
		}

		void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, uint blob_index)
		{
			var rid = custom_debug_information_table.AddRow(new CustomDebugInformationRow(
				MakeCodedRID(provider.MetadataToken, CodedIndex.HasCustomDebugInformation),
				GetGuidIndex(custom_info.Identifier),
				blob_index));

			custom_info.token = new MetadataToken(TokenType.CustomDebugInformation, rid);
		}

		uint AddImportScope(ImportDebugInformation import)
		{
			uint parent = 0;
			if (import.Parent != null)
				parent = AddImportScope(import.Parent);

			uint targets_index = 0;
			if (import.HasTargets)
			{
				var signature = CreateSignatureWriter();

				for (int i = 0; i < import.Targets.Count; i++)
					AddImportTarget(import.Targets[i], signature);

				targets_index = GetBlobIndex(signature);
			}

			var row = new ImportScopeRow(parent, targets_index);

			MetadataToken import_token;
			if (import_scope_map.TryGetValue(row, out import_token))
				return import_token.RID;

			import_token = new MetadataToken(TokenType.ImportScope, import_scope_table.AddRow(row));
			import_scope_map.Add(row, import_token);

			return import_token.RID;
		}

		void AddImportTarget(ImportTarget target, SignatureWriter signature)
		{
			signature.WriteCompressedUInt32((uint)target.kind);

			switch (target.kind)
			{
				case ImportTargetKind.ImportNamespace:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
					break;
				case ImportTargetKind.ImportNamespaceInAssembly:
					signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
					break;
				case ImportTargetKind.ImportType:
					signature.WriteTypeToken(target.type);
					break;
				case ImportTargetKind.ImportXmlNamespaceWithAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
					break;
				case ImportTargetKind.ImportAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					break;
				case ImportTargetKind.DefineAssemblyAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
					break;
				case ImportTargetKind.DefineNamespaceAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
					break;
				case ImportTargetKind.DefineNamespaceInAssemblyAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
					break;
				case ImportTargetKind.DefineTypeAlias:
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
					signature.WriteTypeToken(target.type);
					break;
			}
		}

		uint GetUTF8StringBlobIndex(string s)
		{
			return GetBlobIndex(Encoding.UTF8.GetBytes(s));
		}

		public MetadataToken GetDocumentToken(Document document)
		{
			MetadataToken token;
			if (document_map.TryGetValue(document.Url, out token))
				return token;

			token = new MetadataToken(TokenType.Document, document_table.AddRow(
				new DocumentRow(GetBlobIndex(GetDocumentNameSignature(document)),
				GetGuidIndex(document.HashAlgorithm.ToGuid()),
				GetBlobIndex(document.Hash),
				GetGuidIndex(document.Language.ToGuid()))));

			document.token = token;

			AddCustomDebugInformations(document);

			document_map.Add(document.Url, token);

			return token;
		}

		SignatureWriter GetDocumentNameSignature(Document document)
		{
			var name = document.Url;
			var signature = CreateSignatureWriter();

			char separator;
			if (!TryGetDocumentNameSeparator(name, out separator))
			{
				signature.WriteByte(0);
				signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(name));
				return signature;
			}

			signature.WriteByte((byte)separator);
			var parts = name.Split(new[] { separator });
			for (int i = 0; i < parts.Length; i++)
			{
				if (parts[i] == String.Empty)
					signature.WriteCompressedUInt32(0);
				else
					signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(parts[i]));
			}

			return signature;
		}

		static bool TryGetDocumentNameSeparator(string path, out char separator)
		{
			const char unix = '/';
			const char win = '\\';
			const char zero = (char)0;

			separator = zero;
			if (string.IsNullOrEmpty(path))
				return false;

			int unix_count = 0;
			int win_count = 0;

			for (int i = 0; i < path.Length; i++)
			{
				if (path[i] == unix)
					unix_count++;
				else if (path[i] == win)
					win_count++;
			}

			if (unix_count == 0 && win_count == 0)
				return false;

			if (unix_count >= win_count)
			{
				separator = unix;
				return true;
			}

			separator = win;
			return true;
		}

		void AddSequencePoints(MethodDebugInformation info)
		{
			var rid = info.Method.MetadataToken.RID;

			Document document;
			if (info.TryGetUniqueDocument(out document))
				method_debug_information_table.rows[rid - 1].Col1 = GetDocumentToken(document).RID;

			var signature = CreateSignatureWriter();
			signature.WriteSequencePoints(info);

			method_debug_information_table.rows[rid - 1].Col2 = GetBlobIndex(signature);
		}

		public void ComputeDeterministicMvid()
		{
			var guid = CryptoService.ComputeGuid(CryptoService.ComputeHash(
				data,
				resources,
				string_heap,
				user_string_heap,
				blob_heap,
				table_heap,
				code));

			var position = guid_heap.position;
			guid_heap.position = 0;
			guid_heap.WriteBytes(guid.ToByteArray());
			guid_heap.position = position;

			module.Mvid = guid;
		}
	}

	sealed class SignatureWriter : ByteBuffer
	{

		readonly MetadataBuilder metadata;

		public SignatureWriter(MetadataBuilder metadata)
			: base(6)
		{
			this.metadata = metadata;
		}

		public void WriteElementType(ElementType element_type)
		{
			WriteByte((byte)element_type);
		}

		public void WriteUTF8String(string @string)
		{
			if (@string == null)
			{
				WriteByte(0xff);
				return;
			}

			var bytes = Encoding.UTF8.GetBytes(@string);
			WriteCompressedUInt32((uint)bytes.Length);
			WriteBytes(bytes);
		}

		public void WriteMethodSignature(IMethodSignature method)
		{
			byte calling_convention = (byte)method.CallingConvention;
			if (method.HasThis)
				calling_convention |= 0x20;
			if (method.ExplicitThis)
				calling_convention |= 0x40;

			var generic_provider = method as IGenericParameterProvider;
			var generic_arity = generic_provider != null && generic_provider.HasGenericParameters
				? generic_provider.GenericParameters.Count
				: 0;

			if (generic_arity > 0)
				calling_convention |= 0x10;

			var param_count = method.HasParameters ? method.Parameters.Count : 0;

			WriteByte(calling_convention);

			if (generic_arity > 0)
				WriteCompressedUInt32((uint)generic_arity);

			WriteCompressedUInt32((uint)param_count);
			WriteTypeSignature(method.ReturnType);

			if (param_count == 0)
				return;

			var parameters = method.Parameters;

			for (int i = 0; i < param_count; i++)
				WriteTypeSignature(parameters[i].ParameterType);
		}

		uint MakeTypeDefOrRefCodedRID(TypeReference type)
		{
			return CodedIndex.TypeDefOrRef.CompressMetadataToken(metadata.LookupToken(type));
		}

		public void WriteTypeToken(TypeReference type)
		{
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
		}

		public void WriteTypeSignature(TypeReference type)
		{
			if (type == null)
				throw new ArgumentNullException();

			var etype = type.etype;

			switch (etype)
			{
				case ElementType.MVar:
				case ElementType.Var:
					{
						var generic_parameter = (GenericParameter)type;

						WriteElementType(etype);
						var position = generic_parameter.Position;
						if (position == -1)
							throw new NotSupportedException();

						WriteCompressedUInt32((uint)position);
						break;
					}

				case ElementType.GenericInst:
					{
						var generic_instance = (GenericInstanceType)type;
						WriteElementType(ElementType.GenericInst);
						WriteElementType(generic_instance.IsValueType ? ElementType.ValueType : ElementType.Class);
						WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(generic_instance.ElementType));

						WriteGenericInstanceSignature(generic_instance);
						break;
					}

				case ElementType.Ptr:
				case ElementType.ByRef:
				case ElementType.Pinned:
				case ElementType.Sentinel:
					{
						var type_spec = (TypeSpecification)type;
						WriteElementType(etype);
						WriteTypeSignature(type_spec.ElementType);
						break;
					}

				case ElementType.FnPtr:
					{
						var fptr = (FunctionPointerType)type;
						WriteElementType(ElementType.FnPtr);
						WriteMethodSignature(fptr);
						break;
					}

				case ElementType.CModOpt:
				case ElementType.CModReqD:
					{
						var modifier = (IModifierType)type;
						WriteModifierSignature(etype, modifier);
						break;
					}

				case ElementType.Array:
					{
						var array = (ArrayType)type;
						if (!array.IsVector)
						{
							WriteArrayTypeSignature(array);
							break;
						}

						WriteElementType(ElementType.SzArray);
						WriteTypeSignature(array.ElementType);
						break;
					}

				case ElementType.None:
					{
						WriteElementType(type.IsValueType ? ElementType.ValueType : ElementType.Class);
						WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
						break;
					}

				default:
					if (!TryWriteElementType(type))
						throw new NotSupportedException();

					break;

			}
		}

		void WriteArrayTypeSignature(ArrayType array)
		{
			WriteElementType(ElementType.Array);
			WriteTypeSignature(array.ElementType);

			var dimensions = array.Dimensions;
			var rank = dimensions.Count;

			WriteCompressedUInt32((uint)rank);

			var sized = 0;
			var lbounds = 0;

			for (int i = 0; i < rank; i++)
			{
				var dimension = dimensions[i];

				if (dimension.UpperBound.HasValue)
				{
					sized++;
					lbounds++;
				}
				else if (dimension.LowerBound.HasValue)
					lbounds++;
			}

			var sizes = new int[sized];
			var low_bounds = new int[lbounds];

			for (int i = 0; i < lbounds; i++)
			{
				var dimension = dimensions[i];
				low_bounds[i] = dimension.LowerBound.GetValueOrDefault();
				if (dimension.UpperBound.HasValue)
					sizes[i] = dimension.UpperBound.Value - low_bounds[i] + 1;
			}

			WriteCompressedUInt32((uint)sized);
			for (int i = 0; i < sized; i++)
				WriteCompressedUInt32((uint)sizes[i]);

			WriteCompressedUInt32((uint)lbounds);
			for (int i = 0; i < lbounds; i++)
				WriteCompressedInt32(low_bounds[i]);
		}

		public void WriteGenericInstanceSignature(IGenericInstance instance)
		{
			var generic_arguments = instance.GenericArguments;
			var arity = generic_arguments.Count;

			WriteCompressedUInt32((uint)arity);
			for (int i = 0; i < arity; i++)
				WriteTypeSignature(generic_arguments[i]);
		}

		void WriteModifierSignature(ElementType element_type, IModifierType type)
		{
			WriteElementType(element_type);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type.ModifierType));
			WriteTypeSignature(type.ElementType);
		}

		bool TryWriteElementType(TypeReference type)
		{
			var element = type.etype;

			if (element == ElementType.None)
				return false;

			WriteElementType(element);
			return true;
		}

		public void WriteConstantString(string value)
		{
			if (value != null)
				WriteBytes(Encoding.Unicode.GetBytes(value));
			else
				WriteByte(0xff);
		}

		public void WriteConstantPrimitive(object value)
		{
			WritePrimitiveValue(value);
		}

		public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
		{
			if (!attribute.HasConstructorArguments)
				return;

			var arguments = attribute.ConstructorArguments;
			var parameters = attribute.Constructor.Parameters;

			if (parameters.Count != arguments.Count)
				throw new InvalidOperationException();

			for (int i = 0; i < arguments.Count; i++)
				WriteCustomAttributeFixedArgument(parameters[i].ParameterType, arguments[i]);
		}

		void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray)
			{
				WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
				return;
			}

			WriteCustomAttributeElement(type, argument);
		}

		void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
		{
			var values = argument.Value as CustomAttributeArgument[];

			if (values == null)
			{
				WriteUInt32(0xffffffff);
				return;
			}

			WriteInt32(values.Length);

			if (values.Length == 0)
				return;

			var element_type = type.ElementType;

			for (int i = 0; i < values.Length; i++)
				WriteCustomAttributeElement(element_type, values[i]);
		}

		void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray)
			{
				WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
				return;
			}

			if (type.etype == ElementType.Object)
			{
				argument = (CustomAttributeArgument)argument.Value;
				type = argument.Type;

				WriteCustomAttributeFieldOrPropType(type);
				WriteCustomAttributeElement(type, argument);
				return;
			}

			WriteCustomAttributeValue(type, argument.Value);
		}

		void WriteCustomAttributeValue(TypeReference type, object value)
		{
			var etype = type.etype;

			switch (etype)
			{
				case ElementType.String:
					var @string = (string)value;
					if (@string == null)
						WriteByte(0xff);
					else
						WriteUTF8String(@string);
					break;
				case ElementType.None:
					if (type.IsTypeOf("System", "Type"))
						WriteCustomAttributeTypeValue((TypeReference)value);
					else
						WriteCustomAttributeEnumValue(type, value);
					break;
				default:
					WritePrimitiveValue(value);
					break;
			}
		}

		private void WriteCustomAttributeTypeValue(TypeReference value)
		{
			var typeDefinition = value as TypeDefinition;

			if (typeDefinition != null)
			{
				TypeDefinition outermostDeclaringType = typeDefinition;
				while (outermostDeclaringType.DeclaringType != null)
					outermostDeclaringType = outermostDeclaringType.DeclaringType;

				// In CLR .winmd files, custom attribute arguments reference unmangled type names (rather than <CLR>Name)
				if (WindowsRuntimeProjections.IsClrImplementationType(outermostDeclaringType))
				{
					WindowsRuntimeProjections.Project(outermostDeclaringType);
					WriteTypeReference(value);
					WindowsRuntimeProjections.RemoveProjection(outermostDeclaringType);
					return;
				}
			}

			WriteTypeReference(value);
		}

		void WritePrimitiveValue(object value)
		{
			if (value == null)
				throw new ArgumentNullException();

			switch (Type.GetTypeCode(value.GetType()))
			{
				case TypeCode.Boolean:
					WriteByte((byte)(((bool)value) ? 1 : 0));
					break;
				case TypeCode.Byte:
					WriteByte((byte)value);
					break;
				case TypeCode.SByte:
					WriteSByte((sbyte)value);
					break;
				case TypeCode.Int16:
					WriteInt16((short)value);
					break;
				case TypeCode.UInt16:
					WriteUInt16((ushort)value);
					break;
				case TypeCode.Char:
					WriteInt16((short)(char)value);
					break;
				case TypeCode.Int32:
					WriteInt32((int)value);
					break;
				case TypeCode.UInt32:
					WriteUInt32((uint)value);
					break;
				case TypeCode.Single:
					WriteSingle((float)value);
					break;
				case TypeCode.Int64:
					WriteInt64((long)value);
					break;
				case TypeCode.UInt64:
					WriteUInt64((ulong)value);
					break;
				case TypeCode.Double:
					WriteDouble((double)value);
					break;
				default:
					throw new NotSupportedException(value.GetType().FullName);
			}
		}

		void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
		{
			var type = enum_type.CheckedResolve();
			if (!type.IsEnum)
				throw new ArgumentException();

			WriteCustomAttributeValue(type.GetEnumUnderlyingType(), value);
		}

		void WriteCustomAttributeFieldOrPropType(TypeReference type)
		{
			if (type.IsArray)
			{
				var array = (ArrayType)type;
				WriteElementType(ElementType.SzArray);
				WriteCustomAttributeFieldOrPropType(array.ElementType);
				return;
			}

			var etype = type.etype;

			switch (etype)
			{
				case ElementType.Object:
					WriteElementType(ElementType.Boxed);
					return;
				case ElementType.None:
					if (type.IsTypeOf("System", "Type"))
						WriteElementType(ElementType.Type);
					else
					{
						WriteElementType(ElementType.Enum);
						WriteTypeReference(type);
					}
					return;
				default:
					WriteElementType(etype);
					return;
			}
		}

		public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
		{
			var count = GetNamedArgumentCount(attribute);

			WriteUInt16((ushort)count);

			if (count == 0)
				return;

			WriteICustomAttributeNamedArguments(attribute);
		}

		static int GetNamedArgumentCount(ICustomAttribute attribute)
		{
			int count = 0;

			if (attribute.HasFields)
				count += attribute.Fields.Count;

			if (attribute.HasProperties)
				count += attribute.Properties.Count;

			return count;
		}

		void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
		{
			if (attribute.HasFields)
				WriteCustomAttributeNamedArguments(0x53, attribute.Fields);

			if (attribute.HasProperties)
				WriteCustomAttributeNamedArguments(0x54, attribute.Properties);
		}

		void WriteCustomAttributeNamedArguments(byte kind, Collection<CustomAttributeNamedArgument> named_arguments)
		{
			for (int i = 0; i < named_arguments.Count; i++)
				WriteCustomAttributeNamedArgument(kind, named_arguments[i]);
		}

		void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
		{
			var argument = named_argument.Argument;

			WriteByte(kind);
			WriteCustomAttributeFieldOrPropType(argument.Type);
			WriteUTF8String(named_argument.Name);
			WriteCustomAttributeFixedArgument(argument.Type, argument);
		}

		void WriteSecurityAttribute(SecurityAttribute attribute)
		{
			WriteTypeReference(attribute.AttributeType);

			var count = GetNamedArgumentCount(attribute);

			if (count == 0)
			{
				WriteCompressedUInt32(1); // length
				WriteCompressedUInt32(0); // count
				return;
			}

			var buffer = new SignatureWriter(metadata);
			buffer.WriteCompressedUInt32((uint)count);
			buffer.WriteICustomAttributeNamedArguments(attribute);

			WriteCompressedUInt32((uint)buffer.length);
			WriteBytes(buffer);
		}

		public void WriteSecurityDeclaration(SecurityDeclaration declaration)
		{
			WriteByte((byte)'.');

			var attributes = declaration.security_attributes;
			if (attributes == null)
				throw new NotSupportedException();

			WriteCompressedUInt32((uint)attributes.Count);

			for (int i = 0; i < attributes.Count; i++)
				WriteSecurityAttribute(attributes[i]);
		}

		public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
		{
			var xml = GetXmlSecurityDeclaration(declaration);
			if (xml == null)
				throw new NotSupportedException();

			WriteBytes(Encoding.Unicode.GetBytes(xml));
		}

		static string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
		{
			if (declaration.security_attributes == null || declaration.security_attributes.Count != 1)
				return null;

			var attribute = declaration.security_attributes[0];

			if (!attribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
				return null;

			if (attribute.properties == null || attribute.properties.Count != 1)
				return null;

			var property = attribute.properties[0];
			if (property.Name != "XML")
				return null;

			return (string)property.Argument.Value;
		}

		void WriteTypeReference(TypeReference type)
		{
			WriteUTF8String(TypeParser.ToParseable(type, top_level: false));
		}

		public void WriteMarshalInfo(MarshalInfo marshal_info)
		{
			WriteNativeType(marshal_info.native);

			switch (marshal_info.native)
			{
				case NativeType.Array:
					{
						var array = (ArrayMarshalInfo)marshal_info;
						if (array.element_type != NativeType.None)
							WriteNativeType(array.element_type);
						if (array.size_parameter_index > -1)
							WriteCompressedUInt32((uint)array.size_parameter_index);
						if (array.size > -1)
							WriteCompressedUInt32((uint)array.size);
						if (array.size_parameter_multiplier > -1)
							WriteCompressedUInt32((uint)array.size_parameter_multiplier);
						return;
					}
				case NativeType.SafeArray:
					{
						var array = (SafeArrayMarshalInfo)marshal_info;
						if (array.element_type != VariantType.None)
							WriteVariantType(array.element_type);
						return;
					}
				case NativeType.FixedArray:
					{
						var array = (FixedArrayMarshalInfo)marshal_info;
						if (array.size > -1)
							WriteCompressedUInt32((uint)array.size);
						if (array.element_type != NativeType.None)
							WriteNativeType(array.element_type);
						return;
					}
				case NativeType.FixedSysString:
					var sys_string = (FixedSysStringMarshalInfo)marshal_info;
					if (sys_string.size > -1)
						WriteCompressedUInt32((uint)sys_string.size);
					return;
				case NativeType.CustomMarshaler:
					var marshaler = (CustomMarshalInfo)marshal_info;
					WriteUTF8String(marshaler.guid != Guid.Empty ? marshaler.guid.ToString() : string.Empty);
					WriteUTF8String(marshaler.unmanaged_type);
					WriteTypeReference(marshaler.managed_type);
					WriteUTF8String(marshaler.cookie);
					return;
			}
		}

		void WriteNativeType(NativeType native)
		{
			WriteByte((byte)native);
		}

		void WriteVariantType(VariantType variant)
		{
			WriteByte((byte)variant);
		}

		public void WriteSequencePoints(MethodDebugInformation info)
		{
			var start_line = -1;
			var start_column = -1;

			WriteCompressedUInt32(info.local_var_token.RID);

			Document previous_document;
			if (!info.TryGetUniqueDocument(out previous_document))
				previous_document = null;

			for (int i = 0; i < info.SequencePoints.Count; i++)
			{
				var sequence_point = info.SequencePoints[i];

				var document = sequence_point.Document;
				if (previous_document != document)
				{
					var document_token = metadata.GetDocumentToken(document);

					if (previous_document != null)
						WriteCompressedUInt32(0);

					WriteCompressedUInt32(document_token.RID);
					previous_document = document;
				}

				if (i > 0)
					WriteCompressedUInt32((uint)(sequence_point.Offset - info.SequencePoints[i - 1].Offset));
				else
					WriteCompressedUInt32((uint)sequence_point.Offset);

				if (sequence_point.IsHidden)
				{
					WriteInt16(0);
					continue;
				}

				var delta_lines = sequence_point.EndLine - sequence_point.StartLine;
				var delta_columns = sequence_point.EndColumn - sequence_point.StartColumn;

				WriteCompressedUInt32((uint)delta_lines);

				if (delta_lines == 0)
					WriteCompressedUInt32((uint)delta_columns);
				else
					WriteCompressedInt32(delta_columns);

				if (start_line < 0)
				{
					WriteCompressedUInt32((uint)sequence_point.StartLine);
					WriteCompressedUInt32((uint)sequence_point.StartColumn);
				}
				else
				{
					WriteCompressedInt32(sequence_point.StartLine - start_line);
					WriteCompressedInt32(sequence_point.StartColumn - start_column);
				}

				start_line = sequence_point.StartLine;
				start_column = sequence_point.StartColumn;
			}
		}
	}

	static partial class Mixin
	{

		public static bool TryGetUniqueDocument(this MethodDebugInformation info, out Document document)
		{
			document = info.SequencePoints[0].Document;

			for (int i = 1; i < info.SequencePoints.Count; i++)
			{
				var sequence_point = info.SequencePoints[i];
				if (sequence_point.Document != document)
					return false;
			}

			return true;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil
{

	public delegate AssemblyDefinition AssemblyResolveEventHandler(object sender, AssemblyNameReference reference);

	public sealed class AssemblyResolveEventArgs : EventArgs
	{

		readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference
		{
			get { return reference; }
		}

		public AssemblyResolveEventArgs(AssemblyNameReference reference)
		{
			this.reference = reference;
		}
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class AssemblyResolutionException : FileNotFoundException
	{

		readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference
		{
			get { return reference; }
		}

		public AssemblyResolutionException(AssemblyNameReference reference)
			: this(reference, null)
		{
		}

		public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException)
			: base(string.Format("Failed to resolve assembly: '{0}'", reference), innerException)
		{
			this.reference = reference;
		}

#if !NET_CORE
		AssemblyResolutionException(
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base(info, context)
		{
		}
#endif
	}

	public abstract class BaseAssemblyResolver : IAssemblyResolver
	{

		static readonly bool on_mono = Type.GetType("Mono.Runtime") != null;

		readonly Collection<string> directories;

#if NET_CORE
		// Maps file names of available trusted platform assemblies to their full paths.
		// Internal for testing.
		internal static readonly Lazy<Dictionary<string, string>> TrustedPlatformAssemblies = new Lazy<Dictionary<string, string>> (CreateTrustedPlatformAssemblyMap);
#else
		Collection<string> gac_paths;
#endif

		public void AddSearchDirectory(string directory)
		{
			directories.Add(directory);
		}

		public void RemoveSearchDirectory(string directory)
		{
			directories.Remove(directory);
		}

		public string[] GetSearchDirectories()
		{
			var directories = new string[this.directories.size];
			Array.Copy(this.directories.items, directories, directories.Length);
			return directories;
		}

		public event AssemblyResolveEventHandler ResolveFailure;

		protected BaseAssemblyResolver()
		{
			directories = new Collection<string>(2) { ".", "bin" };
		}

		AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
		{
			if (parameters.AssemblyResolver == null)
				parameters.AssemblyResolver = this;

			return ModuleDefinition.ReadModule(file, parameters).Assembly;
		}

		public virtual AssemblyDefinition Resolve(AssemblyNameReference name)
		{
			return Resolve(name, new ReaderParameters());
		}

		public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
		{
			Mixin.CheckName(name);
			Mixin.CheckParameters(parameters);

			var assembly = SearchDirectory(name, directories, parameters);
			if (assembly != null)
				return assembly;

			if (name.IsRetargetable)
			{
				// if the reference is retargetable, zero it
				name = new AssemblyNameReference(name.Name, Mixin.ZeroVersion)
				{
					PublicKeyToken = Empty<byte>.Array,
				};
			}

#if NET_CORE
			assembly = SearchTrustedPlatformAssemblies (name, parameters);
			if (assembly != null)
				return assembly;
#else
			var framework_dir = Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName);
			var framework_dirs = on_mono
				? new[] { framework_dir, Path.Combine(framework_dir, "Facades") }
				: new[] { framework_dir };

			if (IsZero(name.Version))
			{
				assembly = SearchDirectory(name, framework_dirs, parameters);
				if (assembly != null)
					return assembly;
			}

			if (name.Name == "mscorlib")
			{
				assembly = GetCorlib(name, parameters);
				if (assembly != null)
					return assembly;
			}

			assembly = GetAssemblyInGac(name, parameters);
			if (assembly != null)
				return assembly;

			assembly = SearchDirectory(name, framework_dirs, parameters);
			if (assembly != null)
				return assembly;
#endif
			if (ResolveFailure != null)
			{
				assembly = ResolveFailure(this, name);
				if (assembly != null)
					return assembly;
			}

			throw new AssemblyResolutionException(name);
		}

#if NET_CORE
		AssemblyDefinition SearchTrustedPlatformAssemblies (AssemblyNameReference name, ReaderParameters parameters)
		{
			if (name.IsWindowsRuntime)
				return null;

			if (TrustedPlatformAssemblies.Value.TryGetValue (name.Name, out string path))
				return GetAssembly (path, parameters);

			return null;
		}

		static Dictionary<string, string> CreateTrustedPlatformAssemblyMap ()
		{
			var result = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

			string paths;

			try {
				paths = (string) AppDomain.CurrentDomain.GetData ("TRUSTED_PLATFORM_ASSEMBLIES");
			} catch {
				paths = null;
			}

			if (paths == null)
				return result;

			foreach (var path in paths.Split (Path.PathSeparator))
				if (string.Equals (Path.GetExtension (path), ".dll", StringComparison.OrdinalIgnoreCase))
					result [Path.GetFileNameWithoutExtension (path)] = path;

			return result;
		}
#endif

		protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable<string> directories, ReaderParameters parameters)
		{
			var extensions = name.IsWindowsRuntime ? new[] { ".winmd", ".dll" } : new[] { ".exe", ".dll" };
			foreach (var directory in directories)
			{
				foreach (var extension in extensions)
				{
					string file = Path.Combine(directory, name.Name + extension);
					if (!File.Exists(file))
						continue;
					try
					{
						return GetAssembly(file, parameters);
					}
					catch (System.BadImageFormatException)
					{
						continue;
					}
				}
			}

			return null;
		}

		static bool IsZero(Version version)
		{
			return version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0;
		}

#if !NET_CORE
		AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
		{
			var version = reference.Version;
			var corlib = typeof(object).Assembly.GetName();
			if (corlib.Version == version || IsZero(version))
				return GetAssembly(typeof(object).Module.FullyQualifiedName, parameters);

			var path = Directory.GetParent(
				Directory.GetParent(
					typeof(object).Module.FullyQualifiedName).FullName
				).FullName;

			if (on_mono)
			{
				if (version.Major == 1)
					path = Path.Combine(path, "1.0");
				else if (version.Major == 2)
				{
					if (version.MajorRevision == 5)
						path = Path.Combine(path, "2.1");
					else
						path = Path.Combine(path, "2.0");
				}
				else if (version.Major == 4)
					path = Path.Combine(path, "4.0");
				else
					throw new NotSupportedException("Version not supported: " + version);
			}
			else
			{
				switch (version.Major)
				{
					case 1:
						if (version.MajorRevision == 3300)
							path = Path.Combine(path, "v1.0.3705");
						else
							path = Path.Combine(path, "v1.1.4322");
						break;
					case 2:
						path = Path.Combine(path, "v2.0.50727");
						break;
					case 4:
						path = Path.Combine(path, "v4.0.30319");
						break;
					default:
						throw new NotSupportedException("Version not supported: " + version);
				}
			}

			var file = Path.Combine(path, "mscorlib.dll");
			if (File.Exists(file))
				return GetAssembly(file, parameters);

			if (on_mono && Directory.Exists(path + "-api"))
			{
				file = Path.Combine(path + "-api", "mscorlib.dll");
				if (File.Exists(file))
					return GetAssembly(file, parameters);
			}

			return null;
		}

		static Collection<string> GetGacPaths()
		{
			if (on_mono)
				return GetDefaultMonoGacPaths();

			var paths = new Collection<string>(2);
			var windir = Environment.GetEnvironmentVariable("WINDIR");
			if (windir == null)
				return paths;

			paths.Add(Path.Combine(windir, "assembly"));
			paths.Add(Path.Combine(windir, Path.Combine("Microsoft.NET", "assembly")));
			return paths;
		}

		static Collection<string> GetDefaultMonoGacPaths()
		{
			var paths = new Collection<string>(1);
			var gac = GetCurrentMonoGac();
			if (gac != null)
				paths.Add(gac);

			var gac_paths_env = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
			if (string.IsNullOrEmpty(gac_paths_env))
				return paths;

			var prefixes = gac_paths_env.Split(Path.PathSeparator);
			foreach (var prefix in prefixes)
			{
				if (string.IsNullOrEmpty(prefix))
					continue;

				var gac_path = Path.Combine(Path.Combine(Path.Combine(prefix, "lib"), "mono"), "gac");
				if (Directory.Exists(gac_path) && !paths.Contains(gac))
					paths.Add(gac_path);
			}

			return paths;
		}

		static string GetCurrentMonoGac()
		{
			return Path.Combine(
				Directory.GetParent(
					Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName)).FullName,
				"gac");
		}

		AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
				return null;

			if (gac_paths == null)
				gac_paths = GetGacPaths();

			if (on_mono)
				return GetAssemblyInMonoGac(reference, parameters);

			return GetAssemblyInNetGac(reference, parameters);
		}

		AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			for (int i = 0; i < gac_paths.Count; i++)
			{
				var gac_path = gac_paths[i];
				var file = GetAssemblyFile(reference, string.Empty, gac_path);
				if (File.Exists(file))
					return GetAssembly(file, parameters);
			}

			return null;
		}

		AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			var gacs = new[] { "GAC_MSIL", "GAC_32", "GAC_64", "GAC" };
			var prefixes = new[] { string.Empty, "v4.0_" };

			for (int i = 0; i < gac_paths.Count; i++)
			{
				for (int j = 0; j < gacs.Length; j++)
				{
					var gac = Path.Combine(gac_paths[i], gacs[j]);
					var file = GetAssemblyFile(reference, prefixes[i], gac);
					if (Directory.Exists(gac) && File.Exists(file))
						return GetAssembly(file, parameters);
				}
			}

			return null;
		}

		static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
		{
			var gac_folder = new StringBuilder()
				.Append(prefix)
				.Append(reference.Version)
				.Append("__");

			for (int i = 0; i < reference.PublicKeyToken.Length; i++)
				gac_folder.Append(reference.PublicKeyToken[i].ToString("x2"));

			return Path.Combine(
				Path.Combine(
					Path.Combine(gac, reference.Name), gac_folder.ToString()),
				reference.Name + ".dll");
		}
#endif
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.PE
{

	class BinaryStreamReader : BinaryReader
	{

		public int Position
		{
			get { return (int)BaseStream.Position; }
			set { BaseStream.Position = value; }
		}

		public int Length
		{
			get { return (int)BaseStream.Length; }
		}

		public BinaryStreamReader(Stream stream)
			: base(stream)
		{
		}

		public void Advance(int bytes)
		{
			BaseStream.Seek(bytes, SeekOrigin.Current);
		}

		public void MoveTo(uint position)
		{
			BaseStream.Seek(position, SeekOrigin.Begin);
		}

		public void Align(int align)
		{
			align--;
			var position = Position;
			Advance(((position + align) & ~align) - position);
		}

		public DataDirectory ReadDataDirectory()
		{
			return new DataDirectory(ReadUInt32(), ReadUInt32());
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.PE
{

	class BinaryStreamWriter : BinaryWriter
	{

		public int Position
		{
			get { return (int)BaseStream.Position; }
			set { BaseStream.Position = value; }
		}

		public BinaryStreamWriter(Stream stream)
			: base(stream)
		{
		}

		public void WriteByte(byte value)
		{
			Write(value);
		}

		public void WriteUInt16(ushort value)
		{
			Write(value);
		}

		public void WriteInt16(short value)
		{
			Write(value);
		}

		public void WriteUInt32(uint value)
		{
			Write(value);
		}

		public void WriteInt32(int value)
		{
			Write(value);
		}

		public void WriteUInt64(ulong value)
		{
			Write(value);
		}

		public void WriteBytes(byte[] bytes)
		{
			Write(bytes);
		}

		public void WriteDataDirectory(DataDirectory directory)
		{
			Write(directory.VirtualAddress);
			Write(directory.Size);
		}

		public void WriteBuffer(ByteBuffer buffer)
		{
			Write(buffer.buffer, 0, buffer.length);
		}

		protected void Advance(int bytes)
		{
			BaseStream.Seek(bytes, SeekOrigin.Current);
		}

		public void Align(int align)
		{
			align--;
			var position = Position;
			var bytes = ((position + align) & ~align) - position;

			for (int i = 0; i < bytes; i++)
				WriteByte(0);
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.





namespace Microsoft.Cci.Pdb
{
	internal class BitAccess
	{

		internal BitAccess(int capacity)
		{
			this.buffer = new byte[capacity];
		}

		internal BitAccess(byte[] buffer)
		{
			this.buffer = buffer;
			offset = 0;
		}

		internal byte[] Buffer
		{
			get { return buffer; }
		}
		private byte[] buffer;

		internal void FillBuffer(Stream stream, int capacity)
		{
			MinCapacity(capacity);
			stream.Read(buffer, 0, capacity);
			offset = 0;
		}

		internal void Append(Stream stream, int count)
		{
			int newCapacity = offset + count;
			if (buffer.Length < newCapacity)
			{
				byte[] newBuffer = new byte[newCapacity];
				Array.Copy(buffer, newBuffer, buffer.Length);
				buffer = newBuffer;
			}
			stream.Read(buffer, offset, count);
			offset += count;
		}

		internal int Position
		{
			get { return offset; }
			set { offset = value; }
		}
		private int offset;

		//internal void WriteBuffer(Stream stream, int count) {
		//  stream.Write(buffer, 0, count);
		//}

		internal void MinCapacity(int capacity)
		{
			if (buffer.Length < capacity)
			{
				buffer = new byte[capacity];
			}
			offset = 0;
		}

		internal void Align(int alignment)
		{
			while ((offset % alignment) != 0)
			{
				offset++;
			}
		}

		//internal void WriteInt32(int value) {
		//  buffer[offset + 0] = (byte)value;
		//  buffer[offset + 1] = (byte)(value >> 8);
		//  buffer[offset + 2] = (byte)(value >> 16);
		//  buffer[offset + 3] = (byte)(value >> 24);
		//  offset += 4;
		//}

		//internal void WriteInt32(int[] values) {
		//  for (int i = 0; i < values.Length; i++) {
		//    WriteInt32(values[i]);
		//  }
		//}

		//internal void WriteBytes(byte[] bytes) {
		//  for (int i = 0; i < bytes.Length; i++) {
		//    buffer[offset++] = bytes[i];
		//  }
		//}

		internal void ReadInt16(out short value)
		{
			value = (short)((buffer[offset + 0] & 0xFF) |
								  (buffer[offset + 1] << 8));
			offset += 2;
		}

		internal void ReadInt8(out sbyte value)
		{
			value = (sbyte)buffer[offset];
			offset += 1;
		}

		internal void ReadInt32(out int value)
		{
			value = (int)((buffer[offset + 0] & 0xFF) |
								(buffer[offset + 1] << 8) |
								(buffer[offset + 2] << 16) |
								(buffer[offset + 3] << 24));
			offset += 4;
		}

		internal void ReadInt64(out long value)
		{
			value = (long)(((ulong)buffer[offset + 0] & 0xFF) |
								 ((ulong)buffer[offset + 1] << 8) |
								 ((ulong)buffer[offset + 2] << 16) |
								 ((ulong)buffer[offset + 3] << 24) |
								 ((ulong)buffer[offset + 4] << 32) |
								 ((ulong)buffer[offset + 5] << 40) |
								 ((ulong)buffer[offset + 6] << 48) |
								 ((ulong)buffer[offset + 7] << 56));
			offset += 8;
		}

		internal void ReadUInt16(out ushort value)
		{
			value = (ushort)((buffer[offset + 0] & 0xFF) |
								   (buffer[offset + 1] << 8));
			offset += 2;
		}

		internal void ReadUInt8(out byte value)
		{
			value = (byte)((buffer[offset + 0] & 0xFF));
			offset += 1;
		}

		internal void ReadUInt32(out uint value)
		{
			value = (uint)((buffer[offset + 0] & 0xFF) |
								 (buffer[offset + 1] << 8) |
								 (buffer[offset + 2] << 16) |
								 (buffer[offset + 3] << 24));
			offset += 4;
		}

		internal void ReadUInt64(out ulong value)
		{
			value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |
								 ((ulong)buffer[offset + 1] << 8) |
								 ((ulong)buffer[offset + 2] << 16) |
								 ((ulong)buffer[offset + 3] << 24) |
								 ((ulong)buffer[offset + 4] << 32) |
								 ((ulong)buffer[offset + 5] << 40) |
								 ((ulong)buffer[offset + 6] << 48) |
								 ((ulong)buffer[offset + 7] << 56));
			offset += 8;
		}

		internal void ReadInt32(int[] values)
		{
			for (int i = 0; i < values.Length; i++)
			{
				ReadInt32(out values[i]);
			}
		}

		internal void ReadUInt32(uint[] values)
		{
			for (int i = 0; i < values.Length; i++)
			{
				ReadUInt32(out values[i]);
			}
		}

		internal void ReadBytes(byte[] bytes)
		{
			for (int i = 0; i < bytes.Length; i++)
			{
				bytes[i] = buffer[offset++];
			}
		}

		internal float ReadFloat()
		{
			float result = BitConverter.ToSingle(buffer, offset);
			offset += 4;
			return result;
		}

		internal double ReadDouble()
		{
			double result = BitConverter.ToDouble(buffer, offset);
			offset += 8;
			return result;
		}

		internal decimal ReadDecimal()
		{
			int[] bits = new int[4];
			this.ReadInt32(bits);
			return new decimal(bits[2], bits[3], bits[1], bits[0] < 0, (byte)((bits[0] & 0x00FF0000) >> 16));
		}

		internal void ReadBString(out string value)
		{
			ushort len;
			this.ReadUInt16(out len);
			value = Encoding.UTF8.GetString(buffer, offset, len);
			offset += len;
		}

		internal string ReadBString(int len)
		{
			var result = Encoding.UTF8.GetString(buffer, offset, len);
			offset += len;
			return result;
		}

		internal void ReadCString(out string value)
		{
			int len = 0;
			while (offset + len < buffer.Length && buffer[offset + len] != 0)
			{
				len++;
			}
			value = Encoding.UTF8.GetString(buffer, offset, len);
			offset += len + 1;
		}

		internal void SkipCString(out string value)
		{
			int len = 0;
			while (offset + len < buffer.Length && buffer[offset + len] != 0)
			{
				len++;
			}
			offset += len + 1;
			value = null;
		}

		internal void ReadGuid(out Guid guid)
		{
			uint a;
			ushort b;
			ushort c;
			byte d;
			byte e;
			byte f;
			byte g;
			byte h;
			byte i;
			byte j;
			byte k;

			ReadUInt32(out a);
			ReadUInt16(out b);
			ReadUInt16(out c);
			ReadUInt8(out d);
			ReadUInt8(out e);
			ReadUInt8(out f);
			ReadUInt8(out g);
			ReadUInt8(out h);
			ReadUInt8(out i);
			ReadUInt8(out j);
			ReadUInt8(out k);

			guid = new Guid(a, b, c, d, e, f, g, h, i, j, k);
		}

		internal string ReadString()
		{
			int len = 0;
			while (offset + len < buffer.Length && buffer[offset + len] != 0)
			{
				len += 2;
			}
			string result = Encoding.Unicode.GetString(buffer, offset, len);
			offset += len + 2;
			return result;
		}

	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct BitSet
	{
		internal BitSet(BitAccess bits)
		{
			bits.ReadInt32(out size);    // 0..3 : Number of words
			words = new uint[size];
			bits.ReadUInt32(words);
		}

		//internal BitSet(int size) {
		//  this.size = size;
		//  words = new uint[size];
		//}

		internal bool IsSet(int index)
		{
			int word = index / 32;
			if (word >= this.size) return false;
			return ((words[word] & GetBit(index)) != 0);
		}

		//internal void Set(int index) {
		//  int word = index / 32;
		//  if (word >= this.size) return;
		//  words[word] |= GetBit(index);
		//}

		//internal void Clear(int index) {
		//  int word = index / 32;
		//  if (word >= this.size) return;
		//  words[word] &= ~GetBit(index);
		//}

		private static uint GetBit(int index)
		{
			return ((uint)1 << (index % 32));
		}

		//private static uint ReverseBits(uint value) {
		//  uint o = 0;
		//  for (int i = 0; i < 32; i++) {
		//    o = (o << 1) | (value & 1);
		//    value >>= 1;
		//  }
		//  return o;
		//}

		internal bool IsEmpty
		{
			get { return size == 0; }
		}

		//internal bool GetWord(int index, out uint word) {
		//  if (index < size) {
		//    word = ReverseBits(words[index]);
		//    return true;
		//  }
		//  word = 0;
		//  return false;
		//}

		private int size;
		private uint[] words;
	}

}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Metadata
{

	sealed class BlobHeap : Heap
	{

		public BlobHeap(byte[] data)
			: base(data)
		{
		}

		public byte[] Read(uint index)
		{
			if (index == 0 || index > this.data.Length - 1)
				return Empty<byte>.Array;

			int position = (int)index;
			int length = (int)data.ReadCompressedUInt32(ref position);

			if (length > data.Length - position)
				return Empty<byte>.Array;

			var buffer = new byte[length];

			Buffer.BlockCopy(data, position, buffer, 0, length);

			return buffer;
		}

		public void GetView(uint signature, out byte[] buffer, out int index, out int length)
		{
			if (signature == 0 || signature > data.Length - 1)
			{
				buffer = null;
				index = length = 0;
				return;
			}

			buffer = data;

			index = (int)signature;
			length = (int)buffer.ReadCompressedUInt32(ref index);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil.Metadata
{

	sealed class TableHeapBuffer : HeapBuffer
	{

		readonly ModuleDefinition module;
		readonly MetadataBuilder metadata;

		readonly internal TableInformation[] table_infos = new TableInformation[Mixin.TableCount];
		readonly internal MetadataTable[] tables = new MetadataTable[Mixin.TableCount];

		bool large_string;
		bool large_blob;
		bool large_guid;

		readonly int[] coded_index_sizes = new int[Mixin.CodedIndexCount];
		readonly Func<Table, int> counter;

		internal uint[] string_offsets;

		public override bool IsEmpty
		{
			get { return false; }
		}

		public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata)
			: base(24)
		{
			this.module = module;
			this.metadata = metadata;
			this.counter = GetTableLength;
		}

		int GetTableLength(Table table)
		{
			return (int)table_infos[(int)table].Length;
		}

		public TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
		{
			var md_table = (TTable)tables[(int)table];
			if (md_table != null)
				return md_table;

			md_table = new TTable();
			tables[(int)table] = md_table;
			return md_table;
		}

		public void WriteBySize(uint value, int size)
		{
			if (size == 4)
				WriteUInt32(value);
			else
				WriteUInt16((ushort)value);
		}

		public void WriteBySize(uint value, bool large)
		{
			if (large)
				WriteUInt32(value);
			else
				WriteUInt16((ushort)value);
		}

		public void WriteString(uint @string)
		{
			WriteBySize(string_offsets[@string], large_string);
		}

		public void WriteBlob(uint blob)
		{
			WriteBySize(blob, large_blob);
		}

		public void WriteGuid(uint guid)
		{
			WriteBySize(guid, large_guid);
		}

		public void WriteRID(uint rid, Table table)
		{
			WriteBySize(rid, table_infos[(int)table].IsLarge);
		}

		int GetCodedIndexSize(CodedIndex coded_index)
		{
			var index = (int)coded_index;
			var size = coded_index_sizes[index];
			if (size != 0)
				return size;

			return coded_index_sizes[index] = coded_index.GetSize(counter);
		}

		public void WriteCodedRID(uint rid, CodedIndex coded_index)
		{
			WriteBySize(rid, GetCodedIndexSize(coded_index));
		}

		public void WriteTableHeap()
		{
			WriteUInt32(0);                 // Reserved
			WriteByte(GetTableHeapVersion());   // MajorVersion
			WriteByte(0);                       // MinorVersion
			WriteByte(GetHeapSizes());      // HeapSizes
			WriteByte(10);                      // Reserved2
			WriteUInt64(GetValid());            // Valid
			WriteUInt64(0xc416003301fa00);      // Sorted

			WriteRowCount();
			WriteTables();
		}

		void WriteRowCount()
		{
			for (int i = 0; i < tables.Length; i++)
			{
				var table = tables[i];
				if (table == null || table.Length == 0)
					continue;

				WriteUInt32((uint)table.Length);
			}
		}

		void WriteTables()
		{
			for (int i = 0; i < tables.Length; i++)
			{
				var table = tables[i];
				if (table == null || table.Length == 0)
					continue;

				table.Write(this);
			}
		}

		ulong GetValid()
		{
			ulong valid = 0;

			for (int i = 0; i < tables.Length; i++)
			{
				var table = tables[i];
				if (table == null || table.Length == 0)
					continue;

				table.Sort();
				valid |= (1UL << i);
			}

			return valid;
		}

		public void ComputeTableInformations()
		{
			if (metadata.metadata_builder != null)
				ComputeTableInformations(metadata.metadata_builder.table_heap);

			ComputeTableInformations(metadata.table_heap);
		}

		void ComputeTableInformations(TableHeapBuffer table_heap)
		{
			var tables = table_heap.tables;
			for (int i = 0; i < tables.Length; i++)
			{
				var table = tables[i];
				if (table != null && table.Length > 0)
					table_infos[i].Length = (uint)table.Length;
			}
		}

		byte GetHeapSizes()
		{
			byte heap_sizes = 0;

			if (metadata.string_heap.IsLarge)
			{
				large_string = true;
				heap_sizes |= 0x01;
			}

			if (metadata.guid_heap.IsLarge)
			{
				large_guid = true;
				heap_sizes |= 0x02;
			}

			if (metadata.blob_heap.IsLarge)
			{
				large_blob = true;
				heap_sizes |= 0x04;
			}

			return heap_sizes;
		}

		byte GetTableHeapVersion()
		{
			switch (module.Runtime)
			{
				case TargetRuntime.Net_1_0:
				case TargetRuntime.Net_1_1:
					return 1;
				default:
					return 2;
			}
		}

		public void FixupData(RVA data_rva)
		{
			var table = GetTable<FieldRVATable>(Table.FieldRVA);
			if (table.length == 0)
				return;

			var field_idx_size = GetTable<FieldTable>(Table.Field).IsLarge ? 4 : 2;
			var previous = this.position;

			base.position = table.position;
			for (int i = 0; i < table.length; i++)
			{
				var rva = ReadUInt32();
				base.position -= 4;
				WriteUInt32(rva + data_rva);
				base.position += field_idx_size;
			}

			base.position = previous;
		}
	}

	sealed class ResourceBuffer : ByteBuffer
	{

		public ResourceBuffer()
			: base(0)
		{
		}

		public uint AddResource(byte[] resource)
		{
			var offset = (uint)this.position;
			WriteInt32(resource.Length);
			WriteBytes(resource);
			return offset;
		}
	}

	sealed class DataBuffer : ByteBuffer
	{

		public DataBuffer()
			: base(0)
		{
		}

		public RVA AddData(byte[] data)
		{
			var rva = (RVA)position;
			WriteBytes(data);
			return rva;
		}
	}

	abstract class HeapBuffer : ByteBuffer
	{

		public bool IsLarge
		{
			get { return base.length > 65535; }
		}

		public abstract bool IsEmpty { get; }

		protected HeapBuffer(int length)
			: base(length)
		{
		}
	}

	sealed class GuidHeapBuffer : HeapBuffer
	{

		readonly Dictionary<Guid, uint> guids = new Dictionary<Guid, uint>();

		public override bool IsEmpty
		{
			get { return length == 0; }
		}

		public GuidHeapBuffer()
			: base(16)
		{
		}

		public uint GetGuidIndex(Guid guid)
		{
			uint index;
			if (guids.TryGetValue(guid, out index))
				return index;

			index = (uint)guids.Count + 1;
			WriteGuid(guid);
			guids.Add(guid, index);
			return index;
		}

		void WriteGuid(Guid guid)
		{
			WriteBytes(guid.ToByteArray());
		}
	}

	class StringHeapBuffer : HeapBuffer
	{

		protected Dictionary<string, uint> strings = new Dictionary<string, uint>(StringComparer.Ordinal);

		public sealed override bool IsEmpty
		{
			get { return length <= 1; }
		}

		public StringHeapBuffer()
			: base(1)
		{
			WriteByte(0);
		}

		public virtual uint GetStringIndex(string @string)
		{
			uint index;
			if (strings.TryGetValue(@string, out index))
				return index;

			index = (uint)strings.Count + 1;
			strings.Add(@string, index);
			return index;
		}

		public uint[] WriteStrings()
		{
			var sorted = SortStrings(strings);
			strings = null;

			// Add 1 for empty string whose index and offset are both 0
			var string_offsets = new uint[sorted.Count + 1];
			string_offsets[0] = 0;

			// Find strings that can be folded
			var previous = string.Empty;
			foreach (var entry in sorted)
			{
				var @string = entry.Key;
				var index = entry.Value;
				var position = base.position;

				if (previous.EndsWith(@string, StringComparison.Ordinal) && !IsLowSurrogateChar(entry.Key[0]))
				{
					// Map over the tail of prev string. Watch for null-terminator of prev string.
					string_offsets[index] = (uint)(position - (Encoding.UTF8.GetByteCount(entry.Key) + 1));
				}
				else
				{
					string_offsets[index] = (uint)position;
					WriteString(@string);
				}

				previous = entry.Key;
			}

			return string_offsets;
		}

		static List<KeyValuePair<string, uint>> SortStrings(Dictionary<string, uint> strings)
		{
			var sorted = new List<KeyValuePair<string, uint>>(strings);
			sorted.Sort(new SuffixSort());
			return sorted;
		}

		static bool IsLowSurrogateChar(int c)
		{
			return unchecked((uint)(c - 0xDC00)) <= 0xDFFF - 0xDC00;
		}

		protected virtual void WriteString(string @string)
		{
			WriteBytes(Encoding.UTF8.GetBytes(@string));
			WriteByte(0);
		}

		// Sorts strings such that a string is followed immediately by all strings
		// that are a suffix of it.  
		private class SuffixSort : IComparer<KeyValuePair<string, uint>>
		{

			public int Compare(KeyValuePair<string, uint> xPair, KeyValuePair<string, uint> yPair)
			{
				var x = xPair.Key;
				var y = yPair.Key;

				for (int i = x.Length - 1, j = y.Length - 1; i >= 0 & j >= 0; i--, j--)
				{
					if (x[i] < y[j])
					{
						return -1;
					}

					if (x[i] > y[j])
					{
						return +1;
					}
				}

				return y.Length.CompareTo(x.Length);
			}
		}
	}

	sealed class BlobHeapBuffer : HeapBuffer
	{

		readonly Dictionary<ByteBuffer, uint> blobs = new Dictionary<ByteBuffer, uint>(new ByteBufferEqualityComparer());

		public override bool IsEmpty
		{
			get { return length <= 1; }
		}

		public BlobHeapBuffer()
			: base(1)
		{
			WriteByte(0);
		}

		public uint GetBlobIndex(ByteBuffer blob)
		{
			uint index;
			if (blobs.TryGetValue(blob, out index))
				return index;

			index = (uint)base.position;
			WriteBlob(blob);
			blobs.Add(blob, index);
			return index;
		}

		void WriteBlob(ByteBuffer blob)
		{
			WriteCompressedUInt32((uint)blob.length);
			WriteBytes(blob);
		}
	}

	sealed class UserStringHeapBuffer : StringHeapBuffer
	{

		public override uint GetStringIndex(string @string)
		{
			uint index;
			if (strings.TryGetValue(@string, out index))
				return index;

			index = (uint)base.position;
			WriteString(@string);
			strings.Add(@string, index);
			return index;
		}

		protected override void WriteString(string @string)
		{
			WriteCompressedUInt32((uint)@string.Length * 2 + 1);

			byte special = 0;

			for (int i = 0; i < @string.Length; i++)
			{
				var @char = @string[i];
				WriteUInt16(@char);

				if (special == 1)
					continue;

				if (@char < 0x20 || @char > 0x7e)
				{
					if (@char > 0x7e
						|| (@char >= 0x01 && @char <= 0x08)
						|| (@char >= 0x0e && @char <= 0x1f)
						|| @char == 0x27
						|| @char == 0x2d)
					{

						special = 1;
					}
				}
			}

			WriteByte(special);
		}
	}

	sealed class PdbHeapBuffer : HeapBuffer
	{

		public override bool IsEmpty
		{
			get { return false; }
		}

		public PdbHeapBuffer()
			: base(0)
		{
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.PE
{

	class ByteBuffer
	{

		internal byte[] buffer;
		internal int length;
		internal int position;

		public ByteBuffer()
		{
			this.buffer = Empty<byte>.Array;
		}

		public ByteBuffer(int length)
		{
			this.buffer = new byte[length];
		}

		public ByteBuffer(byte[] buffer)
		{
			this.buffer = buffer ?? Empty<byte>.Array;
			this.length = this.buffer.Length;
		}

		public void Advance(int length)
		{
			position += length;
		}

		public byte ReadByte()
		{
			return buffer[position++];
		}

		public sbyte ReadSByte()
		{
			return (sbyte)ReadByte();
		}

		public byte[] ReadBytes(int length)
		{
			var bytes = new byte[length];
			Buffer.BlockCopy(buffer, position, bytes, 0, length);
			position += length;
			return bytes;
		}

		public ushort ReadUInt16()
		{
			ushort value = (ushort)(buffer[position]
				| (buffer[position + 1] << 8));
			position += 2;
			return value;
		}

		public short ReadInt16()
		{
			return (short)ReadUInt16();
		}

		public uint ReadUInt32()
		{
			uint value = (uint)(buffer[position]
				| (buffer[position + 1] << 8)
				| (buffer[position + 2] << 16)
				| (buffer[position + 3] << 24));
			position += 4;
			return value;
		}

		public int ReadInt32()
		{
			return (int)ReadUInt32();
		}

		public ulong ReadUInt64()
		{
			uint low = ReadUInt32();
			uint high = ReadUInt32();

			return (((ulong)high) << 32) | low;
		}

		public long ReadInt64()
		{
			return (long)ReadUInt64();
		}

		public uint ReadCompressedUInt32()
		{
			byte first = ReadByte();
			if ((first & 0x80) == 0)
				return first;

			if ((first & 0x40) == 0)
				return ((uint)(first & ~0x80) << 8)
					| ReadByte();

			return ((uint)(first & ~0xc0) << 24)
				| (uint)ReadByte() << 16
				| (uint)ReadByte() << 8
				| ReadByte();
		}

		public int ReadCompressedInt32()
		{
			var b = buffer[position];
			var u = (int)ReadCompressedUInt32();
			var v = u >> 1;
			if ((u & 1) == 0)
				return v;

			switch (b & 0xc0)
			{
				case 0:
				case 0x40:
					return v - 0x40;
				case 0x80:
					return v - 0x2000;
				default:
					return v - 0x10000000;
			}
		}

		public float ReadSingle()
		{
			if (!BitConverter.IsLittleEndian)
			{
				var bytes = ReadBytes(4);
				Array.Reverse(bytes);
				return BitConverter.ToSingle(bytes, 0);
			}

			float value = BitConverter.ToSingle(buffer, position);
			position += 4;
			return value;
		}

		public double ReadDouble()
		{
			if (!BitConverter.IsLittleEndian)
			{
				var bytes = ReadBytes(8);
				Array.Reverse(bytes);
				return BitConverter.ToDouble(bytes, 0);
			}

			double value = BitConverter.ToDouble(buffer, position);
			position += 8;
			return value;
		}

		public void WriteByte(byte value)
		{
			if (position == buffer.Length)
				Grow(1);

			buffer[position++] = value;

			if (position > length)
				length = position;
		}

		public void WriteSByte(sbyte value)
		{
			WriteByte((byte)value);
		}

		public void WriteUInt16(ushort value)
		{
			if (position + 2 > buffer.Length)
				Grow(2);

			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);

			if (position > length)
				length = position;
		}

		public void WriteInt16(short value)
		{
			WriteUInt16((ushort)value);
		}

		public void WriteUInt32(uint value)
		{
			if (position + 4 > buffer.Length)
				Grow(4);

			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);
			buffer[position++] = (byte)(value >> 16);
			buffer[position++] = (byte)(value >> 24);

			if (position > length)
				length = position;
		}

		public void WriteInt32(int value)
		{
			WriteUInt32((uint)value);
		}

		public void WriteUInt64(ulong value)
		{
			if (position + 8 > buffer.Length)
				Grow(8);

			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);
			buffer[position++] = (byte)(value >> 16);
			buffer[position++] = (byte)(value >> 24);
			buffer[position++] = (byte)(value >> 32);
			buffer[position++] = (byte)(value >> 40);
			buffer[position++] = (byte)(value >> 48);
			buffer[position++] = (byte)(value >> 56);

			if (position > length)
				length = position;
		}

		public void WriteInt64(long value)
		{
			WriteUInt64((ulong)value);
		}

		public void WriteCompressedUInt32(uint value)
		{
			if (value < 0x80)
				WriteByte((byte)value);
			else if (value < 0x4000)
			{
				WriteByte((byte)(0x80 | (value >> 8)));
				WriteByte((byte)(value & 0xff));
			}
			else
			{
				WriteByte((byte)((value >> 24) | 0xc0));
				WriteByte((byte)((value >> 16) & 0xff));
				WriteByte((byte)((value >> 8) & 0xff));
				WriteByte((byte)(value & 0xff));
			}
		}

		public void WriteCompressedInt32(int value)
		{
			if (value >= 0)
			{
				WriteCompressedUInt32((uint)(value << 1));
				return;
			}

			if (value > -0x40)
				value = 0x40 + value;
			else if (value >= -0x2000)
				value = 0x2000 + value;
			else if (value >= -0x20000000)
				value = 0x20000000 + value;

			WriteCompressedUInt32((uint)((value << 1) | 1));
		}

		public void WriteBytes(byte[] bytes)
		{
			var length = bytes.Length;
			if (position + length > buffer.Length)
				Grow(length);

			Buffer.BlockCopy(bytes, 0, buffer, position, length);
			position += length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteBytes(int length)
		{
			if (position + length > buffer.Length)
				Grow(length);

			position += length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteBytes(ByteBuffer buffer)
		{
			if (position + buffer.length > this.buffer.Length)
				Grow(buffer.length);

			Buffer.BlockCopy(buffer.buffer, 0, this.buffer, position, buffer.length);
			position += buffer.length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteSingle(float value)
		{
			var bytes = BitConverter.GetBytes(value);

			if (!BitConverter.IsLittleEndian)
				Array.Reverse(bytes);

			WriteBytes(bytes);
		}

		public void WriteDouble(double value)
		{
			var bytes = BitConverter.GetBytes(value);

			if (!BitConverter.IsLittleEndian)
				Array.Reverse(bytes);

			WriteBytes(bytes);
		}

		void Grow(int desired)
		{
			var current = this.buffer;
			var current_length = current.Length;

			var buffer = new byte[System.Math.Max(current_length + desired, current_length * 2)];
			Buffer.BlockCopy(current, 0, buffer, 0, current_length);
			this.buffer = buffer;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.PE
{

	sealed class ByteBufferEqualityComparer : IEqualityComparer<ByteBuffer>
	{

		public bool Equals(ByteBuffer x, ByteBuffer y)
		{
			if (x.length != y.length)
				return false;

			var x_buffer = x.buffer;
			var y_buffer = y.buffer;

			for (int i = 0; i < x.length; i++)
				if (x_buffer[i] != y_buffer[i])
					return false;

			return true;
		}

		public int GetHashCode(ByteBuffer buffer)
		{
			// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
			const int fnv_offset_bias = unchecked((int)2166136261);
			const int fnv_prime = 16777619;

			var hash_code = fnv_offset_bias;
			var bytes = buffer.buffer;

			for (int i = 0; i < buffer.length; i++)
				hash_code = unchecked((hash_code ^ bytes[i]) * fnv_prime);

			return hash_code;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public sealed class CallSite : IMethodSignature
	{

		readonly MethodReference signature;

		public bool HasThis
		{
			get { return signature.HasThis; }
			set { signature.HasThis = value; }
		}

		public bool ExplicitThis
		{
			get { return signature.ExplicitThis; }
			set { signature.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention
		{
			get { return signature.CallingConvention; }
			set { signature.CallingConvention = value; }
		}

		public bool HasParameters
		{
			get { return signature.HasParameters; }
		}

		public Collection<ParameterDefinition> Parameters
		{
			get { return signature.Parameters; }
		}

		public TypeReference ReturnType
		{
			get { return signature.MethodReturnType.ReturnType; }
			set { signature.MethodReturnType.ReturnType = value; }
		}

		public MethodReturnType MethodReturnType
		{
			get { return signature.MethodReturnType; }
		}

		public string Name
		{
			get { return string.Empty; }
			set { throw new InvalidOperationException(); }
		}

		public string Namespace
		{
			get { return string.Empty; }
			set { throw new InvalidOperationException(); }
		}

		public ModuleDefinition Module
		{
			get { return ReturnType.Module; }
		}

		public IMetadataScope Scope
		{
			get { return signature.ReturnType.Scope; }
		}

		public MetadataToken MetadataToken
		{
			get { return signature.token; }
			set { signature.token = value; }
		}

		public string FullName
		{
			get
			{
				var signature = new StringBuilder();
				signature.Append(ReturnType.FullName);
				this.MethodSignatureFullName(signature);
				return signature.ToString();
			}
		}

		internal CallSite()
		{
			this.signature = new MethodReference();
			this.signature.token = new MetadataToken(TokenType.Signature, 0);
		}

		public CallSite(TypeReference returnType)
			: this()
		{
			if (returnType == null)
				throw new ArgumentNullException("returnType");

			this.signature.ReturnType = returnType;
		}

		public override string ToString()
		{
			return FullName;
		}
	}
}
















namespace MonoMod.Utils.Cil
{
	/// <summary>
	/// A variant of ILGenerator which uses Mono.Cecil under the hood.
	/// </summary>
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class CecilILGenerator : ILGeneratorShim
	{
		// https://github.com/Unity-Technologies/mono/blob/unity-5.6/mcs/class/corlib/System.Reflection.Emit/LocalBuilder.cs
		// https://github.com/Unity-Technologies/mono/blob/unity-2018.3-mbe/mcs/class/corlib/System.Reflection.Emit/LocalBuilder.cs
		// https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Reflection/Emit/LocalBuilder.cs
		// Mono: Type, ILGenerator
		// .NET Framework matches .NET Core: int, Type, MethodInfo(, bool)
		private static readonly ConstructorInfo c_LocalBuilder =
			typeof(LocalBuilder).GetConstructors(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance)
			.OrderByDescending(c => c.GetParameters().Length).First();
		private static readonly FieldInfo f_LocalBuilder_position =
			typeof(LocalBuilder).GetField("position", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly FieldInfo f_LocalBuilder_is_pinned =
			typeof(LocalBuilder).GetField("is_pinned", BindingFlags.NonPublic | BindingFlags.Instance);

		private static int c_LocalBuilder_params = c_LocalBuilder.GetParameters().Length;

		private static readonly Dictionary<short, OpCode> _MCCOpCodes = new Dictionary<short, OpCode>();

		private static Label NullLabel;

		static unsafe CecilILGenerator()
		{
			foreach (FieldInfo field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
			{
				OpCode cecilOpCode = (OpCode)field.GetValue(null);
				_MCCOpCodes[cecilOpCode.Value] = cecilOpCode;
			}

			Label l = default;
			*(int*)&l = -1;
			NullLabel = l;
		}

		/// <summary>
		/// The underlying Mono.Cecil.Cil.ILProcessor.
		/// </summary>
		public readonly ILProcessor IL;

		private readonly Dictionary<Label, LabelInfo> _LabelInfos = new Dictionary<Label, LabelInfo>();
		private readonly List<LabelInfo> _LabelsToMark = new List<LabelInfo>();
		private readonly List<LabelledExceptionHandler> _ExceptionHandlersToMark = new List<LabelledExceptionHandler>();

		private readonly Dictionary<LocalBuilder, VariableDefinition> _Variables =
			new Dictionary<LocalBuilder, VariableDefinition>();

		private readonly Stack<ExceptionHandlerChain> _ExceptionHandlers = new Stack<ExceptionHandlerChain>();

		private int labelCounter;

		public CecilILGenerator(ILProcessor il)
		{
			IL = il;
		}

		private OpCode _(SRE.OpCode opcode) => _MCCOpCodes[opcode.Value];

		private LabelInfo _(Label handle) =>
			_LabelInfos.TryGetValue(handle, out LabelInfo labelInfo) ? labelInfo : null;

		private VariableDefinition _(LocalBuilder handle) => _Variables[handle];

		private TypeReference _(Type info) => IL.Body.Method.Module.ImportReference(info);
		private FieldReference _(FieldInfo info) => IL.Body.Method.Module.ImportReference(info);
		private MethodReference _(MethodBase info) => IL.Body.Method.Module.ImportReference(info);

		private int _ILOffset;
		public override int ILOffset => _ILOffset;

		private Instruction ProcessLabels(Instruction ins)
		{
			if (_LabelsToMark.Count != 0)
			{
				foreach (LabelInfo labelInfo in _LabelsToMark)
				{
					foreach (Instruction insToFix in labelInfo.Branches)
					{
						switch (insToFix.Operand)
						{
							case Instruction insOperand:
								insToFix.Operand = ins;
								break;
							case Instruction[] instrsOperand:
								for (int i = 0; i < instrsOperand.Length; i++)
								{
									if (instrsOperand[i] == labelInfo.Instruction)
									{
										instrsOperand[i] = ins;
										break;
									}
								}
								break;
						}
					}

					labelInfo.Emitted = true;
					labelInfo.Instruction = ins;
				}

				_LabelsToMark.Clear();
			}

			if (_ExceptionHandlersToMark.Count != 0)
			{
				foreach (LabelledExceptionHandler exHandler in _ExceptionHandlersToMark)
					IL.Body.ExceptionHandlers.Add(new ExceptionHandler(exHandler.HandlerType)
					{
						TryStart = _(exHandler.TryStart)?.Instruction,
						TryEnd = _(exHandler.TryEnd)?.Instruction,
						HandlerStart = _(exHandler.HandlerStart)?.Instruction,
						HandlerEnd = _(exHandler.HandlerEnd)?.Instruction,
						FilterStart = _(exHandler.FilterStart)?.Instruction,
						CatchType = exHandler.ExceptionType
					});

				_ExceptionHandlersToMark.Clear();
			}

			return ins;
		}

		public override unsafe Label DefineLabel()
		{
			Label handle = default;
			// The label struct holds a single int field on .NET Framework, .NET Core and Mono.
			*(int*)&handle = labelCounter++;
			_LabelInfos[handle] = new LabelInfo();
			return handle;
		}

		public override void MarkLabel(Label loc)
		{
			if (!_LabelInfos.TryGetValue(loc, out LabelInfo labelInfo) || labelInfo.Emitted)
				return;
			_LabelsToMark.Add(labelInfo);
		}

		public override LocalBuilder DeclareLocal(Type type) => DeclareLocal(type, false);

		public override LocalBuilder DeclareLocal(Type type, bool pinned)
		{
			// The handle itself is out of sync with the "backing" VariableDefinition.
			int index = IL.Body.Variables.Count;
			LocalBuilder handle = (LocalBuilder)(
				c_LocalBuilder_params == 4 ? c_LocalBuilder.Invoke(new object[] { index, type, null, pinned }) :
				c_LocalBuilder_params == 3 ? c_LocalBuilder.Invoke(new object[] { index, type, null }) :
				c_LocalBuilder_params == 2 ? c_LocalBuilder.Invoke(new object[] { type, null }) :
				c_LocalBuilder_params == 0 ? c_LocalBuilder.Invoke(new object[] { }) :
				throw new NotSupportedException()
			);

			f_LocalBuilder_position?.SetValue(handle, (ushort)index);
			f_LocalBuilder_is_pinned?.SetValue(handle, pinned);

			TypeReference typeRef = _(type);
			if (pinned)
				typeRef = new PinnedType(typeRef);
			VariableDefinition def = new VariableDefinition(typeRef);
			IL.Body.Variables.Add(def);
			_Variables[handle] = def;

			return handle;
		}

		private void Emit(Instruction ins)
		{
			ins.Offset = _ILOffset;
			_ILOffset += ins.GetSize();
			IL.Append(ProcessLabels(ins));
		}

		public override void Emit(SRE.OpCode opcode) => Emit(IL.Create(_(opcode)));

		public override void Emit(SRE.OpCode opcode, byte arg)
		{
			if (opcode.OperandType == SRE.OperandType.ShortInlineVar ||
				opcode.OperandType == SRE.OperandType.InlineVar)
				_EmitInlineVar(_(opcode), arg);
			else
				Emit(IL.Create(_(opcode), arg));
		}

		public override void Emit(SRE.OpCode opcode, sbyte arg)
		{
			if (opcode.OperandType == SRE.OperandType.ShortInlineVar ||
				opcode.OperandType == SRE.OperandType.InlineVar)
				_EmitInlineVar(_(opcode), arg);
			else
				Emit(IL.Create(_(opcode), arg));
		}

		public override void Emit(SRE.OpCode opcode, short arg)
		{
			if (opcode.OperandType == SRE.OperandType.ShortInlineVar ||
				opcode.OperandType == SRE.OperandType.InlineVar)
				_EmitInlineVar(_(opcode), arg);
			else
				Emit(IL.Create(_(opcode), arg));
		}

		public override void Emit(SRE.OpCode opcode, int arg)
		{
			if (opcode.OperandType == SRE.OperandType.ShortInlineVar ||
				opcode.OperandType == SRE.OperandType.InlineVar)
				_EmitInlineVar(_(opcode), arg);
			else if (opcode.Name.EndsWith(".s", StringComparison.Ordinal))
				Emit(IL.Create(_(opcode), (sbyte)arg));
			else
				Emit(IL.Create(_(opcode), arg));
		}

		public override void Emit(SRE.OpCode opcode, long arg) => Emit(IL.Create(_(opcode), arg));
		public override void Emit(SRE.OpCode opcode, float arg) => Emit(IL.Create(_(opcode), arg));
		public override void Emit(SRE.OpCode opcode, double arg) => Emit(IL.Create(_(opcode), arg));
		public override void Emit(SRE.OpCode opcode, string arg) => Emit(IL.Create(_(opcode), arg));
		public override void Emit(SRE.OpCode opcode, Type arg) => Emit(IL.Create(_(opcode), _(arg)));
		public override void Emit(SRE.OpCode opcode, FieldInfo arg) => Emit(IL.Create(_(opcode), _(arg)));
		public override void Emit(SRE.OpCode opcode, ConstructorInfo arg) => Emit(IL.Create(_(opcode), _(arg)));
		public override void Emit(SRE.OpCode opcode, MethodInfo arg) => Emit(IL.Create(_(opcode), _(arg)));

		public override void Emit(SRE.OpCode opcode, Label label)
		{
			LabelInfo info = _(label);
			Instruction ins = IL.Create(_(opcode), _(label).Instruction);
			info.Branches.Add(ins);
			Emit(ProcessLabels(ins));
		}

		public override void Emit(SRE.OpCode opcode, Label[] labels)
		{
			IEnumerable<LabelInfo> labelInfos = labels.Distinct().Select(_);
			Instruction ins = IL.Create(_(opcode), labelInfos.Select(labelInfo => labelInfo.Instruction).ToArray());
			foreach (LabelInfo labelInfo in labelInfos)
				labelInfo.Branches.Add(ins);
			Emit(ProcessLabels(ins));
		}

		public override void Emit(SRE.OpCode opcode, LocalBuilder local) => Emit(IL.Create(_(opcode), _(local)));
		public override void Emit(SRE.OpCode opcode, SignatureHelper signature) => Emit(IL.Create(_(opcode), IL.Body.Method.Module.ImportCallSite(signature)));
		public void Emit(SRE.OpCode opcode, ICallSiteGenerator signature) => Emit(IL.Create(_(opcode), IL.Body.Method.Module.ImportCallSite(signature)));

		private void _EmitInlineVar(OpCode opcode, int index)
		{
			// System.Reflection.Emit has only got (Short)InlineVar and allows index refs.
			// Mono.Cecil has also got (Short)InlineArg and requires definition refs.
			switch (opcode.OperandType)
			{
				case MCC.OperandType.ShortInlineArg:
				case MCC.OperandType.InlineArg:
					Emit(IL.Create(opcode, IL.Body.Method.Parameters[index]));
					break;

				case MCC.OperandType.ShortInlineVar:
				case MCC.OperandType.InlineVar:
					Emit(IL.Create(opcode, IL.Body.Variables[index]));
					break;

				default:
					throw new NotSupportedException(
						$"Unsupported SRE InlineVar -> Cecil {opcode.OperandType} for {opcode} {index}");
			}
		}

		public override void EmitCall(SRE.OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes) =>
			Emit(IL.Create(_(opcode), _(methodInfo)));

		public override void EmitCalli(SRE.OpCode opcode, CallingConventions callingConvention, Type returnType,
			Type[] parameterTypes, Type[] optionalParameterTypes) => throw new NotSupportedException();

		public override void EmitCalli(SRE.OpCode opcode, CallingConvention unmanagedCallConv, Type returnType,
			Type[] parameterTypes) => throw new NotSupportedException();

		public override void EmitWriteLine(FieldInfo field)
		{
			if (field.IsStatic)
				Emit(IL.Create(OpCodes.Ldsfld, _(field)));
			else
			{
				Emit(IL.Create(OpCodes.Ldarg_0));
				Emit(IL.Create(OpCodes.Ldfld, _(field)));
			}

			Emit(IL.Create(OpCodes.Call, _(typeof(Console).GetMethod("WriteLine", new Type[1] { field.FieldType }))));
		}

		public override void EmitWriteLine(LocalBuilder localBuilder)
		{
			Emit(IL.Create(OpCodes.Ldloc, _(localBuilder)));
			Emit(IL.Create(OpCodes.Call,
				_(typeof(Console).GetMethod("WriteLine", new Type[1] { localBuilder.LocalType }))));
		}

		public override void EmitWriteLine(string value)
		{
			Emit(IL.Create(OpCodes.Ldstr, value));
			Emit(IL.Create(OpCodes.Call, _(typeof(Console).GetMethod("WriteLine", new Type[1] { typeof(string) }))));
		}

		public override void ThrowException(Type type)
		{
			Emit(IL.Create(OpCodes.Newobj, _(type.GetConstructor(Type.EmptyTypes))));
			Emit(IL.Create(OpCodes.Throw));
		}

		public override Label BeginExceptionBlock()
		{
			ExceptionHandlerChain chain = new ExceptionHandlerChain(this);
			_ExceptionHandlers.Push(chain);
			return chain.SkipAll;
		}

		public override void BeginCatchBlock(Type exceptionType)
		{
			LabelledExceptionHandler handler = _ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Catch);
			handler.ExceptionType = exceptionType == null ? null : _(exceptionType);
		}

		public override void BeginExceptFilterBlock()
		{
			_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Filter);
		}

		public override void BeginFaultBlock()
		{
			_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Fault);
		}

		public override void BeginFinallyBlock()
		{
			_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Finally);
		}

		public override void EndExceptionBlock()
		{
			_ExceptionHandlers.Pop().End();
		}

		public override void BeginScope()
		{
		}

		public override void EndScope()
		{
		}

		public override void UsingNamespace(string usingNamespace)
		{
		}

		private class LabelInfo
		{
			public bool Emitted;
			public Instruction Instruction = Instruction.Create(OpCodes.Nop);
			public readonly List<Instruction> Branches = new List<Instruction>();
		}

		private class LabelledExceptionHandler
		{
			public Label TryStart = NullLabel;
			public Label TryEnd = NullLabel;
			public Label HandlerStart = NullLabel;
			public Label HandlerEnd = NullLabel;
			public Label FilterStart = NullLabel;
			public ExceptionHandlerType HandlerType;
			public TypeReference ExceptionType;
		}

		private class ExceptionHandlerChain
		{
			private readonly CecilILGenerator IL;

			private readonly Label _Start;
			public readonly Label SkipAll;
			private Label _SkipHandler;

			private LabelledExceptionHandler _Prev;
			private LabelledExceptionHandler _Handler;

			public ExceptionHandlerChain(CecilILGenerator il)
			{
				IL = il;

				_Start = il.DefineLabel();
				il.MarkLabel(_Start);

				SkipAll = il.DefineLabel();
			}

			public LabelledExceptionHandler BeginHandler(ExceptionHandlerType type)
			{
				LabelledExceptionHandler prev = _Prev = _Handler;
				if (prev != null)
					EndHandler(prev);

				IL.Emit(SRE.OpCodes.Leave, _SkipHandler = IL.DefineLabel());

				Label handlerStart = IL.DefineLabel();
				IL.MarkLabel(handlerStart);

				LabelledExceptionHandler next = _Handler = new LabelledExceptionHandler
				{
					TryStart = _Start,
					TryEnd = handlerStart,
					HandlerType = type,
					HandlerEnd = _SkipHandler
				};
				if (type == ExceptionHandlerType.Filter)
					next.FilterStart = handlerStart;
				else
					next.HandlerStart = handlerStart;

				return next;
			}

			public void EndHandler(LabelledExceptionHandler handler)
			{
				Label skip = _SkipHandler;

				switch (handler.HandlerType)
				{
					case ExceptionHandlerType.Filter:
						IL.Emit(SRE.OpCodes.Endfilter);
						break;

					case ExceptionHandlerType.Finally:
						IL.Emit(SRE.OpCodes.Endfinally);
						break;

					default:
						IL.Emit(SRE.OpCodes.Leave, skip);
						break;
				}

				IL.MarkLabel(skip);
				IL._ExceptionHandlersToMark.Add(handler);
			}

			public void End()
			{
				EndHandler(_Handler);
				IL.MarkLabel(SkipAll);
			}
		}
	}
}//
 // Author:
 //   Jb Evain (jbevain@gmail.com)
 //
 // Copyright (c) 2008 - 2015 Jb Evain
 // Copyright (c) 2008 - 2011 Novell, Inc.
 //
 // Licensed under the MIT/X11 license.
 //

namespace Mono.Cecil.Cil
{

	public enum Code
	{
		Nop,
		Break,
		Ldarg_0,
		Ldarg_1,
		Ldarg_2,
		Ldarg_3,
		Ldloc_0,
		Ldloc_1,
		Ldloc_2,
		Ldloc_3,
		Stloc_0,
		Stloc_1,
		Stloc_2,
		Stloc_3,
		Ldarg_S,
		Ldarga_S,
		Starg_S,
		Ldloc_S,
		Ldloca_S,
		Stloc_S,
		Ldnull,
		Ldc_I4_M1,
		Ldc_I4_0,
		Ldc_I4_1,
		Ldc_I4_2,
		Ldc_I4_3,
		Ldc_I4_4,
		Ldc_I4_5,
		Ldc_I4_6,
		Ldc_I4_7,
		Ldc_I4_8,
		Ldc_I4_S,
		Ldc_I4,
		Ldc_I8,
		Ldc_R4,
		Ldc_R8,
		Dup,
		Pop,
		Jmp,
		Call,
		Calli,
		Ret,
		Br_S,
		Brfalse_S,
		Brtrue_S,
		Beq_S,
		Bge_S,
		Bgt_S,
		Ble_S,
		Blt_S,
		Bne_Un_S,
		Bge_Un_S,
		Bgt_Un_S,
		Ble_Un_S,
		Blt_Un_S,
		Br,
		Brfalse,
		Brtrue,
		Beq,
		Bge,
		Bgt,
		Ble,
		Blt,
		Bne_Un,
		Bge_Un,
		Bgt_Un,
		Ble_Un,
		Blt_Un,
		Switch,
		Ldind_I1,
		Ldind_U1,
		Ldind_I2,
		Ldind_U2,
		Ldind_I4,
		Ldind_U4,
		Ldind_I8,
		Ldind_I,
		Ldind_R4,
		Ldind_R8,
		Ldind_Ref,
		Stind_Ref,
		Stind_I1,
		Stind_I2,
		Stind_I4,
		Stind_I8,
		Stind_R4,
		Stind_R8,
		Add,
		Sub,
		Mul,
		Div,
		Div_Un,
		Rem,
		Rem_Un,
		And,
		Or,
		Xor,
		Shl,
		Shr,
		Shr_Un,
		Neg,
		Not,
		Conv_I1,
		Conv_I2,
		Conv_I4,
		Conv_I8,
		Conv_R4,
		Conv_R8,
		Conv_U4,
		Conv_U8,
		Callvirt,
		Cpobj,
		Ldobj,
		Ldstr,
		Newobj,
		Castclass,
		Isinst,
		Conv_R_Un,
		Unbox,
		Throw,
		Ldfld,
		Ldflda,
		Stfld,
		Ldsfld,
		Ldsflda,
		Stsfld,
		Stobj,
		Conv_Ovf_I1_Un,
		Conv_Ovf_I2_Un,
		Conv_Ovf_I4_Un,
		Conv_Ovf_I8_Un,
		Conv_Ovf_U1_Un,
		Conv_Ovf_U2_Un,
		Conv_Ovf_U4_Un,
		Conv_Ovf_U8_Un,
		Conv_Ovf_I_Un,
		Conv_Ovf_U_Un,
		Box,
		Newarr,
		Ldlen,
		Ldelema,
		Ldelem_I1,
		Ldelem_U1,
		Ldelem_I2,
		Ldelem_U2,
		Ldelem_I4,
		Ldelem_U4,
		Ldelem_I8,
		Ldelem_I,
		Ldelem_R4,
		Ldelem_R8,
		Ldelem_Ref,
		Stelem_I,
		Stelem_I1,
		Stelem_I2,
		Stelem_I4,
		Stelem_I8,
		Stelem_R4,
		Stelem_R8,
		Stelem_Ref,
		Ldelem_Any,
		Stelem_Any,
		Unbox_Any,
		Conv_Ovf_I1,
		Conv_Ovf_U1,
		Conv_Ovf_I2,
		Conv_Ovf_U2,
		Conv_Ovf_I4,
		Conv_Ovf_U4,
		Conv_Ovf_I8,
		Conv_Ovf_U8,
		Refanyval,
		Ckfinite,
		Mkrefany,
		Ldtoken,
		Conv_U2,
		Conv_U1,
		Conv_I,
		Conv_Ovf_I,
		Conv_Ovf_U,
		Add_Ovf,
		Add_Ovf_Un,
		Mul_Ovf,
		Mul_Ovf_Un,
		Sub_Ovf,
		Sub_Ovf_Un,
		Endfinally,
		Leave,
		Leave_S,
		Stind_I,
		Conv_U,
		Arglist,
		Ceq,
		Cgt,
		Cgt_Un,
		Clt,
		Clt_Un,
		Ldftn,
		Ldvirtftn,
		Ldarg,
		Ldarga,
		Starg,
		Ldloc,
		Ldloca,
		Stloc,
		Localloc,
		Endfilter,
		Unaligned,
		Volatile,
		Tail,
		Initobj,
		Constrained,
		Cpblk,
		Initblk,
		No,
		Rethrow,
		Sizeof,
		Refanytype,
		Readonly,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Metadata
{

	enum CodedIndex
	{
		TypeDefOrRef,
		HasConstant,
		HasCustomAttribute,
		HasFieldMarshal,
		HasDeclSecurity,
		MemberRefParent,
		HasSemantics,
		MethodDefOrRef,
		MemberForwarded,
		Implementation,
		CustomAttributeType,
		ResolutionScope,
		TypeOrMethodDef,
		HasCustomDebugInformation,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//








namespace Mono.Cecil.Cil
{

	sealed class CodeReader : BinaryStreamReader
	{

		readonly internal MetadataReader reader;

		int start;

		MethodDefinition method;
		Mono.Cecil.Cil.MethodBody body;

		int Offset
		{
			get { return Position - start; }
		}

		public CodeReader(MetadataReader reader)
			: base(reader.image.Stream.value)
		{
			this.reader = reader;
		}

		public int MoveTo(MethodDefinition method)
		{
			this.method = method;
			this.reader.context = method;
			var position = this.Position;
			this.Position = (int)reader.image.ResolveVirtualAddress((uint)method.RVA);
			return position;
		}

		public void MoveBackTo(int position)
		{
			this.reader.context = null;
			this.Position = position;
		}

		public MethodBody ReadMethodBody(MethodDefinition method)
		{
			var position = MoveTo(method);
			this.body = new MethodBody(method);

			ReadMethodBody();

			MoveBackTo(position);
			return this.body;
		}

		public int ReadCodeSize(MethodDefinition method)
		{
			var position = MoveTo(method);

			var code_size = ReadCodeSize();

			MoveBackTo(position);
			return code_size;
		}

		int ReadCodeSize()
		{
			var flags = ReadByte();
			switch (flags & 0x3)
			{
				case 0x2: // tiny
					return flags >> 2;
				case 0x3: // fat
					Advance(-1 + 2 + 2); // go back, 2 bytes flags, 2 bytes stack size
					return (int)ReadUInt32();
				default:
					throw new InvalidOperationException();
			}
		}

		void ReadMethodBody()
		{
			var flags = ReadByte();
			switch (flags & 0x3)
			{
				case 0x2: // tiny
					body.code_size = flags >> 2;
					body.MaxStackSize = 8;
					ReadCode();
					break;
				case 0x3: // fat
					Advance(-1);
					ReadFatMethod();
					break;
				default:
					throw new InvalidOperationException();
			}

			var symbol_reader = reader.module.symbol_reader;

			if (symbol_reader != null && method.debug_info == null)
				method.debug_info = symbol_reader.Read(method);

			if (method.debug_info != null)
				ReadDebugInfo();
		}

		void ReadFatMethod()
		{
			var flags = ReadUInt16();
			body.max_stack_size = ReadUInt16();
			body.code_size = (int)ReadUInt32();
			body.local_var_token = new MetadataToken(ReadUInt32());
			body.init_locals = (flags & 0x10) != 0;

			if (body.local_var_token.RID != 0)
				body.variables = ReadVariables(body.local_var_token);

			ReadCode();

			if ((flags & 0x8) != 0)
				ReadSection();
		}

		public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
		{
			var position = reader.position;
			var variables = reader.ReadVariables(local_var_token, method);
			reader.position = position;

			return variables;
		}

		void ReadCode()
		{
			start = Position;
			var code_size = body.code_size;

			if (code_size < 0 || Length <= (uint)(code_size + Position))
				code_size = 0;

			var end = start + code_size;
			var instructions = body.instructions = new InstructionCollection(method, (code_size + 1) / 2);

			while (Position < end)
			{
				var offset = Position - start;
				var opcode = ReadOpCode();
				var current = new Instruction(offset, opcode);

				if (opcode.OperandType != OperandType.InlineNone)
					current.operand = ReadOperand(current);

				instructions.Add(current);
			}

			ResolveBranches(instructions);
		}

		OpCode ReadOpCode()
		{
			var il_opcode = ReadByte();
			return il_opcode != 0xfe
				? OpCodes.OneByteOpCode[il_opcode]
				: OpCodes.TwoBytesOpCode[ReadByte()];
		}

		object ReadOperand(Instruction instruction)
		{
			switch (instruction.opcode.OperandType)
			{
				case OperandType.InlineSwitch:
					var length = ReadInt32();
					var base_offset = Offset + (4 * length);
					var branches = new int[length];
					for (int i = 0; i < length; i++)
						branches[i] = base_offset + ReadInt32();
					return branches;
				case OperandType.ShortInlineBrTarget:
					return ReadSByte() + Offset;
				case OperandType.InlineBrTarget:
					return ReadInt32() + Offset;
				case OperandType.ShortInlineI:
					if (instruction.opcode == OpCodes.Ldc_I4_S)
						return ReadSByte();

					return ReadByte();
				case OperandType.InlineI:
					return ReadInt32();
				case OperandType.ShortInlineR:
					return ReadSingle();
				case OperandType.InlineR:
					return ReadDouble();
				case OperandType.InlineI8:
					return ReadInt64();
				case OperandType.ShortInlineVar:
					return GetVariable(ReadByte());
				case OperandType.InlineVar:
					return GetVariable(ReadUInt16());
				case OperandType.ShortInlineArg:
					return GetParameter(ReadByte());
				case OperandType.InlineArg:
					return GetParameter(ReadUInt16());
				case OperandType.InlineSig:
					return GetCallSite(ReadToken());
				case OperandType.InlineString:
					return GetString(ReadToken());
				case OperandType.InlineTok:
				case OperandType.InlineType:
				case OperandType.InlineMethod:
				case OperandType.InlineField:
					return reader.LookupToken(ReadToken());
				default:
					throw new NotSupportedException();
			}
		}

		public string GetString(MetadataToken token)
		{
			return reader.image.UserStringHeap.Read(token.RID);
		}

		public ParameterDefinition GetParameter(int index)
		{
			return body.GetParameter(index);
		}

		public VariableDefinition GetVariable(int index)
		{
			return body.GetVariable(index);
		}

		public CallSite GetCallSite(MetadataToken token)
		{
			return reader.ReadCallSite(token);
		}

		void ResolveBranches(Collection<Instruction> instructions)
		{
			var items = instructions.items;
			var size = instructions.size;

			for (int i = 0; i < size; i++)
			{
				var instruction = items[i];
				switch (instruction.opcode.OperandType)
				{
					case OperandType.ShortInlineBrTarget:
					case OperandType.InlineBrTarget:
						instruction.operand = GetInstruction((int)instruction.operand);
						break;
					case OperandType.InlineSwitch:
						var offsets = (int[])instruction.operand;
						var branches = new Instruction[offsets.Length];
						for (int j = 0; j < offsets.Length; j++)
							branches[j] = GetInstruction(offsets[j]);

						instruction.operand = branches;
						break;
				}
			}
		}

		Instruction GetInstruction(int offset)
		{
			return GetInstruction(body.Instructions, offset);
		}

		static Instruction GetInstruction(Collection<Instruction> instructions, int offset)
		{
			var size = instructions.size;
			var items = instructions.items;
			if (offset < 0 || offset > items[size - 1].offset)
				return null;

			int min = 0;
			int max = size - 1;
			while (min <= max)
			{
				int mid = min + ((max - min) / 2);
				var instruction = items[mid];
				var instruction_offset = instruction.offset;

				if (offset == instruction_offset)
					return instruction;

				if (offset < instruction_offset)
					max = mid - 1;
				else
					min = mid + 1;
			}

			return null;
		}

		void ReadSection()
		{
			Align(4);

			const byte fat_format = 0x40;
			const byte more_sects = 0x80;

			var flags = ReadByte();
			if ((flags & fat_format) == 0)
				ReadSmallSection();
			else
				ReadFatSection();

			if ((flags & more_sects) != 0)
				ReadSection();
		}

		void ReadSmallSection()
		{
			var count = ReadByte() / 12;
			Advance(2);

			ReadExceptionHandlers(
				count,
				() => (int)ReadUInt16(),
				() => (int)ReadByte());
		}

		void ReadFatSection()
		{
			Advance(-1);
			var count = (ReadInt32() >> 8) / 24;

			ReadExceptionHandlers(
				count,
				ReadInt32,
				ReadInt32);
		}

		// inline ?
		void ReadExceptionHandlers(int count, Func<int> read_entry, Func<int> read_length)
		{
			for (int i = 0; i < count; i++)
			{
				var handler = new ExceptionHandler(
					(ExceptionHandlerType)(read_entry() & 0x7));

				handler.TryStart = GetInstruction(read_entry());
				handler.TryEnd = GetInstruction(handler.TryStart.Offset + read_length());

				handler.HandlerStart = GetInstruction(read_entry());
				handler.HandlerEnd = GetInstruction(handler.HandlerStart.Offset + read_length());

				ReadExceptionHandlerSpecific(handler);

				this.body.ExceptionHandlers.Add(handler);
			}
		}

		void ReadExceptionHandlerSpecific(ExceptionHandler handler)
		{
			switch (handler.HandlerType)
			{
				case ExceptionHandlerType.Catch:
					handler.CatchType = (TypeReference)reader.LookupToken(ReadToken());
					break;
				case ExceptionHandlerType.Filter:
					handler.FilterStart = GetInstruction(ReadInt32());
					break;
				default:
					Advance(4);
					break;
			}
		}

		public MetadataToken ReadToken()
		{
			return new MetadataToken(ReadUInt32());
		}

		void ReadDebugInfo()
		{
			if (method.debug_info.sequence_points != null)
				ReadSequencePoints();

			if (method.debug_info.scope != null)
				ReadScope(method.debug_info.scope);

			if (method.custom_infos != null)
				ReadCustomDebugInformations(method);
		}

		void ReadCustomDebugInformations(MethodDefinition method)
		{
			var custom_infos = method.custom_infos;

			for (int i = 0; i < custom_infos.Count; i++)
			{
				var state_machine_scope = custom_infos[i] as StateMachineScopeDebugInformation;
				if (state_machine_scope != null)
					ReadStateMachineScope(state_machine_scope);

				var async_method = custom_infos[i] as AsyncMethodBodyDebugInformation;
				if (async_method != null)
					ReadAsyncMethodBody(async_method);
			}
		}

		void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method)
		{
			if (async_method.catch_handler.Offset > -1)
				async_method.catch_handler = new InstructionOffset(GetInstruction(async_method.catch_handler.Offset));

			if (!async_method.yields.IsNullOrEmpty())
				for (int i = 0; i < async_method.yields.Count; i++)
					async_method.yields[i] = new InstructionOffset(GetInstruction(async_method.yields[i].Offset));

			if (!async_method.resumes.IsNullOrEmpty())
				for (int i = 0; i < async_method.resumes.Count; i++)
					async_method.resumes[i] = new InstructionOffset(GetInstruction(async_method.resumes[i].Offset));
		}

		void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope)
		{
			if (state_machine_scope.scopes.IsNullOrEmpty())
				return;

			foreach (var scope in state_machine_scope.scopes)
			{
				scope.start = new InstructionOffset(GetInstruction(scope.start.Offset));

				var end_instruction = GetInstruction(scope.end.Offset);
				scope.end = end_instruction == null
					? new InstructionOffset()
					: new InstructionOffset(end_instruction);
			}
		}

		void ReadSequencePoints()
		{
			var symbol = method.debug_info;

			for (int i = 0; i < symbol.sequence_points.Count; i++)
			{
				var sequence_point = symbol.sequence_points[i];
				var instruction = GetInstruction(sequence_point.Offset);
				if (instruction != null)
					sequence_point.offset = new InstructionOffset(instruction);
			}
		}

		void ReadScopes(Collection<ScopeDebugInformation> scopes)
		{
			for (int i = 0; i < scopes.Count; i++)
				ReadScope(scopes[i]);
		}

		void ReadScope(ScopeDebugInformation scope)
		{
			var start_instruction = GetInstruction(scope.Start.Offset);
			if (start_instruction != null)
				scope.Start = new InstructionOffset(start_instruction);

			var end_instruction = GetInstruction(scope.End.Offset);
			scope.End = end_instruction != null
				? new InstructionOffset(end_instruction)
				: new InstructionOffset();

			if (!scope.variables.IsNullOrEmpty())
			{
				for (int i = 0; i < scope.variables.Count; i++)
				{
					var variable_info = scope.variables[i];
					var variable = GetVariable(variable_info.Index);
					if (variable != null)
						variable_info.index = new VariableIndex(variable);
				}
			}

			if (!scope.scopes.IsNullOrEmpty())
				ReadScopes(scope.scopes);
		}

		public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
		{
			var position = MoveTo(method);

			var buffer = new ByteBuffer();

			var flags = ReadByte();

			switch (flags & 0x3)
			{
				case 0x2: // tiny
					buffer.WriteByte(flags);
					local_var_token = MetadataToken.Zero;
					code_size = flags >> 2;
					PatchRawCode(buffer, code_size, writer);
					break;
				case 0x3: // fat
					Advance(-1);
					PatchRawFatMethod(buffer, writer, out code_size, out local_var_token);
					break;
				default:
					throw new NotSupportedException();
			}

			MoveBackTo(position);

			return buffer;
		}

		void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
		{
			var flags = ReadUInt16();
			buffer.WriteUInt16(flags);
			buffer.WriteUInt16(ReadUInt16());
			code_size = ReadInt32();
			buffer.WriteInt32(code_size);
			local_var_token = ReadToken();

			if (local_var_token.RID > 0)
			{
				var variables = ReadVariables(local_var_token);
				buffer.WriteUInt32(variables != null
					? writer.GetStandAloneSignature(variables).ToUInt32()
					: 0);
			}
			else
				buffer.WriteUInt32(0);

			PatchRawCode(buffer, code_size, writer);

			if ((flags & 0x8) != 0)
				PatchRawSection(buffer, writer.metadata);
		}

		void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
		{
			var metadata = writer.metadata;
			buffer.WriteBytes(ReadBytes(code_size));
			var end = buffer.position;
			buffer.position -= code_size;

			while (buffer.position < end)
			{
				OpCode opcode;
				var il_opcode = buffer.ReadByte();
				if (il_opcode != 0xfe)
				{
					opcode = OpCodes.OneByteOpCode[il_opcode];
				}
				else
				{
					var il_opcode2 = buffer.ReadByte();
					opcode = OpCodes.TwoBytesOpCode[il_opcode2];
				}

				switch (opcode.OperandType)
				{
					case OperandType.ShortInlineI:
					case OperandType.ShortInlineBrTarget:
					case OperandType.ShortInlineVar:
					case OperandType.ShortInlineArg:
						buffer.position += 1;
						break;
					case OperandType.InlineVar:
					case OperandType.InlineArg:
						buffer.position += 2;
						break;
					case OperandType.InlineBrTarget:
					case OperandType.ShortInlineR:
					case OperandType.InlineI:
						buffer.position += 4;
						break;
					case OperandType.InlineI8:
					case OperandType.InlineR:
						buffer.position += 8;
						break;
					case OperandType.InlineSwitch:
						var length = buffer.ReadInt32();
						buffer.position += length * 4;
						break;
					case OperandType.InlineString:
						var @string = GetString(new MetadataToken(buffer.ReadUInt32()));
						buffer.position -= 4;
						buffer.WriteUInt32(
							new MetadataToken(
								TokenType.String,
								metadata.user_string_heap.GetStringIndex(@string)).ToUInt32());
						break;
					case OperandType.InlineSig:
						var call_site = GetCallSite(new MetadataToken(buffer.ReadUInt32()));
						buffer.position -= 4;
						buffer.WriteUInt32(writer.GetStandAloneSignature(call_site).ToUInt32());
						break;
					case OperandType.InlineTok:
					case OperandType.InlineType:
					case OperandType.InlineMethod:
					case OperandType.InlineField:
						var provider = reader.LookupToken(new MetadataToken(buffer.ReadUInt32()));
						buffer.position -= 4;
						buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
						break;
				}
			}
		}

		void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			var position = Position;
			Align(4);
			buffer.WriteBytes(Position - position);

			const byte fat_format = 0x40;
			const byte more_sects = 0x80;

			var flags = ReadByte();
			if ((flags & fat_format) == 0)
			{
				buffer.WriteByte(flags);
				PatchRawSmallSection(buffer, metadata);
			}
			else
				PatchRawFatSection(buffer, metadata);

			if ((flags & more_sects) != 0)
				PatchRawSection(buffer, metadata);
		}

		void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			var length = ReadByte();
			buffer.WriteByte(length);
			Advance(2);

			buffer.WriteUInt16(0);

			var count = length / 12;

			PatchRawExceptionHandlers(buffer, metadata, count, false);
		}

		void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			Advance(-1);
			var length = ReadInt32();
			buffer.WriteInt32(length);

			var count = (length >> 8) / 24;

			PatchRawExceptionHandlers(buffer, metadata, count, true);
		}

		void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
		{
			const int fat_entry_size = 16;
			const int small_entry_size = 6;

			for (int i = 0; i < count; i++)
			{
				ExceptionHandlerType handler_type;
				if (fat_entry)
				{
					var type = ReadUInt32();
					handler_type = (ExceptionHandlerType)(type & 0x7);
					buffer.WriteUInt32(type);
				}
				else
				{
					var type = ReadUInt16();
					handler_type = (ExceptionHandlerType)(type & 0x7);
					buffer.WriteUInt16(type);
				}

				buffer.WriteBytes(ReadBytes(fat_entry ? fat_entry_size : small_entry_size));

				switch (handler_type)
				{
					case ExceptionHandlerType.Catch:
						var exception = reader.LookupToken(ReadToken());
						buffer.WriteUInt32(metadata.LookupToken(exception).ToUInt32());
						break;
					default:
						buffer.WriteUInt32(ReadUInt32());
						break;
				}
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//











namespace Mono.Cecil.Cil
{

	sealed class CodeWriter : ByteBuffer
	{

		readonly RVA code_base;
		internal readonly MetadataBuilder metadata;
		readonly Dictionary<uint, MetadataToken> standalone_signatures;
		readonly Dictionary<ByteBuffer, RVA> tiny_method_bodies;

		MethodBody body;

		public CodeWriter(MetadataBuilder metadata)
			: base(0)
		{
			this.code_base = metadata.text_map.GetNextRVA(TextSegment.CLIHeader);
			this.metadata = metadata;
			this.standalone_signatures = new Dictionary<uint, MetadataToken>();
			this.tiny_method_bodies = new Dictionary<ByteBuffer, RVA>(new ByteBufferEqualityComparer());
		}

		public RVA WriteMethodBody(MethodDefinition method)
		{
			RVA rva;

			if (IsUnresolved(method))
			{
				if (method.rva == 0)
					return 0;

				rva = WriteUnresolvedMethodBody(method);
			}
			else
			{
				if (IsEmptyMethodBody(method.Body))
					return 0;

				rva = WriteResolvedMethodBody(method);
			}

			return rva;
		}

		static bool IsEmptyMethodBody(MethodBody body)
		{
			return body.instructions.IsNullOrEmpty()
				&& body.variables.IsNullOrEmpty();
		}

		static bool IsUnresolved(MethodDefinition method)
		{
			return method.HasBody && method.HasImage && method.body == null;
		}

		RVA WriteUnresolvedMethodBody(MethodDefinition method)
		{
			var code_reader = metadata.module.reader.code;

			int code_size;
			MetadataToken local_var_token;
			var raw_body = code_reader.PatchRawMethodBody(method, this, out code_size, out local_var_token);
			var fat_header = (raw_body.buffer[0] & 0x3) == 0x3;
			if (fat_header)
				Align(4);

			var rva = BeginMethod();

			if (fat_header || !GetOrMapTinyMethodBody(raw_body, ref rva))
			{
				WriteBytes(raw_body);
			}

			if (method.debug_info == null)
				return rva;

			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null)
			{
				method.debug_info.code_size = code_size;
				method.debug_info.local_var_token = local_var_token;
				symbol_writer.Write(method.debug_info);
			}

			return rva;
		}

		RVA WriteResolvedMethodBody(MethodDefinition method)
		{
			RVA rva;

			body = method.Body;
			ComputeHeader();
			if (RequiresFatHeader())
			{
				Align(4);
				rva = BeginMethod();
				WriteFatHeader();
				WriteInstructions();

				if (body.HasExceptionHandlers)
					WriteExceptionHandlers();
			}
			else
			{
				rva = BeginMethod();
				WriteByte((byte)(0x2 | (body.CodeSize << 2))); // tiny
				WriteInstructions();

				var start_position = (int)(rva - code_base);
				var body_size = position - start_position;
				var body_bytes = new byte[body_size];

				Array.Copy(buffer, start_position, body_bytes, 0, body_size);

				if (GetOrMapTinyMethodBody(new ByteBuffer(body_bytes), ref rva))
					position = start_position;
			}

			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null && method.debug_info != null)
			{
				method.debug_info.code_size = body.CodeSize;
				method.debug_info.local_var_token = body.local_var_token;
				symbol_writer.Write(method.debug_info);
			}

			return rva;
		}

		bool GetOrMapTinyMethodBody(ByteBuffer body, ref RVA rva)
		{
			RVA existing_rva;
			if (tiny_method_bodies.TryGetValue(body, out existing_rva))
			{
				rva = existing_rva;
				return true;
			}

			tiny_method_bodies.Add(body, rva);
			return false;
		}

		void WriteFatHeader()
		{
			var body = this.body;
			byte flags = 0x3;   // fat
			if (body.InitLocals)
				flags |= 0x10;  // init locals
			if (body.HasExceptionHandlers)
				flags |= 0x8;   // more sections

			WriteByte(flags);
			WriteByte(0x30);
			WriteInt16((short)body.max_stack_size);
			WriteInt32(body.code_size);
			body.local_var_token = body.HasVariables
				? GetStandAloneSignature(body.Variables)
				: MetadataToken.Zero;
			WriteMetadataToken(body.local_var_token);
		}

		void WriteInstructions()
		{
			var instructions = body.Instructions;
			var items = instructions.items;
			var size = instructions.size;

			for (int i = 0; i < size; i++)
			{
				var instruction = items[i];
				WriteOpCode(instruction.opcode);
				WriteOperand(instruction);
			}
		}

		void WriteOpCode(OpCode opcode)
		{
			if (opcode.Size == 1)
			{
				WriteByte(opcode.Op2);
			}
			else
			{
				WriteByte(opcode.Op1);
				WriteByte(opcode.Op2);
			}
		}

		void WriteOperand(Instruction instruction)
		{
			var opcode = instruction.opcode;
			var operand_type = opcode.OperandType;
			if (operand_type == OperandType.InlineNone)
				return;

			var operand = instruction.operand;
			if (operand == null && !(operand_type == OperandType.InlineBrTarget || operand_type == OperandType.ShortInlineBrTarget))
			{
				throw new ArgumentException();
			}

			switch (operand_type)
			{
				case OperandType.InlineSwitch:
					{
						var targets = (Instruction[])operand;
						WriteInt32(targets.Length);
						var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));
						for (int i = 0; i < targets.Length; i++)
							WriteInt32(GetTargetOffset(targets[i]) - diff);
						break;
					}
				case OperandType.ShortInlineBrTarget:
					{
						var target = (Instruction)operand;
						var offset = target != null ? GetTargetOffset(target) : body.code_size;
						WriteSByte((sbyte)(offset - (instruction.Offset + opcode.Size + 1)));
						break;
					}
				case OperandType.InlineBrTarget:
					{
						var target = (Instruction)operand;
						var offset = target != null ? GetTargetOffset(target) : body.code_size;
						WriteInt32(offset - (instruction.Offset + opcode.Size + 4));
						break;
					}
				case OperandType.ShortInlineVar:
					WriteByte((byte)GetVariableIndex((VariableDefinition)operand));
					break;
				case OperandType.ShortInlineArg:
					WriteByte((byte)GetParameterIndex((ParameterDefinition)operand));
					break;
				case OperandType.InlineVar:
					WriteInt16((short)GetVariableIndex((VariableDefinition)operand));
					break;
				case OperandType.InlineArg:
					WriteInt16((short)GetParameterIndex((ParameterDefinition)operand));
					break;
				case OperandType.InlineSig:
					WriteMetadataToken(GetStandAloneSignature((CallSite)operand));
					break;
				case OperandType.ShortInlineI:
					if (opcode == OpCodes.Ldc_I4_S)
						WriteSByte((sbyte)operand);
					else
						WriteByte((byte)operand);
					break;
				case OperandType.InlineI:
					WriteInt32((int)operand);
					break;
				case OperandType.InlineI8:
					WriteInt64((long)operand);
					break;
				case OperandType.ShortInlineR:
					WriteSingle((float)operand);
					break;
				case OperandType.InlineR:
					WriteDouble((double)operand);
					break;
				case OperandType.InlineString:
					WriteMetadataToken(
						new MetadataToken(
							TokenType.String,
							GetUserStringIndex((string)operand)));
					break;
				case OperandType.InlineType:
				case OperandType.InlineField:
				case OperandType.InlineMethod:
				case OperandType.InlineTok:
					WriteMetadataToken(metadata.LookupToken((IMetadataTokenProvider)operand));
					break;
				default:
					throw new ArgumentException();
			}
		}

		int GetTargetOffset(Instruction instruction)
		{
			if (instruction == null)
			{
				var last = body.instructions[body.instructions.size - 1];
				return last.offset + last.GetSize();
			}

			return instruction.offset;
		}

		uint GetUserStringIndex(string @string)
		{
			if (@string == null)
				return 0;

			return metadata.user_string_heap.GetStringIndex(@string);
		}

		static int GetVariableIndex(VariableDefinition variable)
		{
			return variable.Index;
		}

		int GetParameterIndex(ParameterDefinition parameter)
		{
			if (body.method.HasThis)
			{
				if (parameter == body.this_parameter)
					return 0;

				return parameter.Index + 1;
			}

			return parameter.Index;
		}

		bool RequiresFatHeader()
		{
			var body = this.body;
			return body.CodeSize >= 64
				|| body.InitLocals
				|| body.HasVariables
				|| body.HasExceptionHandlers
				|| body.MaxStackSize > 8;
		}

		void ComputeHeader()
		{
			int offset = 0;
			var instructions = body.instructions;
			var items = instructions.items;
			var count = instructions.size;
			var stack_size = 0;
			var max_stack = 0;
			Dictionary<Instruction, int> stack_sizes = null;

			if (body.HasExceptionHandlers)
				ComputeExceptionHandlerStackSize(ref stack_sizes);

			for (int i = 0; i < count; i++)
			{
				var instruction = items[i];
				instruction.offset = offset;
				offset += instruction.GetSize();

				ComputeStackSize(instruction, ref stack_sizes, ref stack_size, ref max_stack);
			}

			body.code_size = offset;
			body.max_stack_size = max_stack;
		}

		void ComputeExceptionHandlerStackSize(ref Dictionary<Instruction, int> stack_sizes)
		{
			var exception_handlers = body.ExceptionHandlers;

			for (int i = 0; i < exception_handlers.Count; i++)
			{
				var exception_handler = exception_handlers[i];

				switch (exception_handler.HandlerType)
				{
					case ExceptionHandlerType.Catch:
						AddExceptionStackSize(exception_handler.HandlerStart, ref stack_sizes);
						break;
					case ExceptionHandlerType.Filter:
						AddExceptionStackSize(exception_handler.FilterStart, ref stack_sizes);
						AddExceptionStackSize(exception_handler.HandlerStart, ref stack_sizes);
						break;
				}
			}
		}

		static void AddExceptionStackSize(Instruction handler_start, ref Dictionary<Instruction, int> stack_sizes)
		{
			if (handler_start == null)
				return;

			if (stack_sizes == null)
				stack_sizes = new Dictionary<Instruction, int>();

			stack_sizes[handler_start] = 1;
		}

		static void ComputeStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, ref int stack_size, ref int max_stack)
		{
			int computed_size;
			if (stack_sizes != null && stack_sizes.TryGetValue(instruction, out computed_size))
				stack_size = computed_size;

			max_stack = System.Math.Max(max_stack, stack_size);
			ComputeStackDelta(instruction, ref stack_size);
			max_stack = System.Math.Max(max_stack, stack_size);

			CopyBranchStackSize(instruction, ref stack_sizes, stack_size);
			ComputeStackSize(instruction, ref stack_size);
		}

		static void CopyBranchStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, int stack_size)
		{
			if (stack_size == 0)
				return;

			switch (instruction.opcode.OperandType)
			{
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					CopyBranchStackSize(ref stack_sizes, (Instruction)instruction.operand, stack_size);
					break;
				case OperandType.InlineSwitch:
					var targets = (Instruction[])instruction.operand;
					for (int i = 0; i < targets.Length; i++)
						CopyBranchStackSize(ref stack_sizes, targets[i], stack_size);
					break;
			}
		}

		static void CopyBranchStackSize(ref Dictionary<Instruction, int> stack_sizes, Instruction target, int stack_size)
		{
			if (stack_sizes == null)
				stack_sizes = new Dictionary<Instruction, int>();

			int branch_stack_size = stack_size;

			int computed_size;
			if (stack_sizes.TryGetValue(target, out computed_size))
				branch_stack_size = System.Math.Max(branch_stack_size, computed_size);

			stack_sizes[target] = branch_stack_size;
		}

		static void ComputeStackSize(Instruction instruction, ref int stack_size)
		{
			switch (instruction.opcode.FlowControl)
			{
				case FlowControl.Branch:
				case FlowControl.Throw:
				case FlowControl.Return:
					stack_size = 0;
					break;
			}
		}

		static void ComputeStackDelta(Instruction instruction, ref int stack_size)
		{
			switch (instruction.opcode.FlowControl)
			{
				case FlowControl.Call:
					{
						var method = (IMethodSignature)instruction.operand;
						// pop 'this' argument
						if (method.HasImplicitThis() && instruction.opcode.Code != Code.Newobj)
							stack_size--;
						// pop normal arguments
						if (method.HasParameters)
							stack_size -= method.Parameters.Count;
						// pop function pointer
						if (instruction.opcode.Code == Code.Calli)
							stack_size--;
						// push return value
						if (method.ReturnType.etype != ElementType.Void || instruction.opcode.Code == Code.Newobj)
							stack_size++;
						break;
					}
				default:
					ComputePopDelta(instruction.opcode.StackBehaviourPop, ref stack_size);
					ComputePushDelta(instruction.opcode.StackBehaviourPush, ref stack_size);
					break;
			}
		}

		static void ComputePopDelta(StackBehaviour pop_behavior, ref int stack_size)
		{
			switch (pop_behavior)
			{
				case StackBehaviour.Popi:
				case StackBehaviour.Popref:
				case StackBehaviour.Pop1:
					stack_size--;
					break;
				case StackBehaviour.Pop1_pop1:
				case StackBehaviour.Popi_pop1:
				case StackBehaviour.Popi_popi:
				case StackBehaviour.Popi_popi8:
				case StackBehaviour.Popi_popr4:
				case StackBehaviour.Popi_popr8:
				case StackBehaviour.Popref_pop1:
				case StackBehaviour.Popref_popi:
					stack_size -= 2;
					break;
				case StackBehaviour.Popi_popi_popi:
				case StackBehaviour.Popref_popi_popi:
				case StackBehaviour.Popref_popi_popi8:
				case StackBehaviour.Popref_popi_popr4:
				case StackBehaviour.Popref_popi_popr8:
				case StackBehaviour.Popref_popi_popref:
					stack_size -= 3;
					break;
				case StackBehaviour.PopAll:
					stack_size = 0;
					break;
			}
		}

		static void ComputePushDelta(StackBehaviour push_behaviour, ref int stack_size)
		{
			switch (push_behaviour)
			{
				case StackBehaviour.Push1:
				case StackBehaviour.Pushi:
				case StackBehaviour.Pushi8:
				case StackBehaviour.Pushr4:
				case StackBehaviour.Pushr8:
				case StackBehaviour.Pushref:
					stack_size++;
					break;
				case StackBehaviour.Push1_push1:
					stack_size += 2;
					break;
			}
		}

		void WriteExceptionHandlers()
		{
			Align(4);

			var handlers = body.ExceptionHandlers;

			if (handlers.Count < 0x15 && !RequiresFatSection(handlers))
				WriteSmallSection(handlers);
			else
				WriteFatSection(handlers);
		}

		static bool RequiresFatSection(Collection<ExceptionHandler> handlers)
		{
			for (int i = 0; i < handlers.Count; i++)
			{
				var handler = handlers[i];

				if (IsFatRange(handler.TryStart, handler.TryEnd))
					return true;

				if (IsFatRange(handler.HandlerStart, handler.HandlerEnd))
					return true;

				if (handler.HandlerType == ExceptionHandlerType.Filter
					&& IsFatRange(handler.FilterStart, handler.HandlerStart))
					return true;
			}

			return false;
		}

		static bool IsFatRange(Instruction start, Instruction end)
		{
			if (start == null)
				throw new ArgumentException();

			if (end == null)
				return true;

			return end.Offset - start.Offset > 255 || start.Offset > 65535;
		}

		void WriteSmallSection(Collection<ExceptionHandler> handlers)
		{
			const byte eh_table = 0x1;

			WriteByte(eh_table);
			WriteByte((byte)(handlers.Count * 12 + 4));
			WriteBytes(2);

			WriteExceptionHandlers(
				handlers,
				i => WriteUInt16((ushort)i),
				i => WriteByte((byte)i));
		}

		void WriteFatSection(Collection<ExceptionHandler> handlers)
		{
			const byte eh_table = 0x1;
			const byte fat_format = 0x40;

			WriteByte(eh_table | fat_format);

			int size = handlers.Count * 24 + 4;
			WriteByte((byte)(size & 0xff));
			WriteByte((byte)((size >> 8) & 0xff));
			WriteByte((byte)((size >> 16) & 0xff));

			WriteExceptionHandlers(handlers, WriteInt32, WriteInt32);
		}

		void WriteExceptionHandlers(Collection<ExceptionHandler> handlers, Action<int> write_entry, Action<int> write_length)
		{
			for (int i = 0; i < handlers.Count; i++)
			{
				var handler = handlers[i];

				write_entry((int)handler.HandlerType);

				write_entry(handler.TryStart.Offset);
				write_length(GetTargetOffset(handler.TryEnd) - handler.TryStart.Offset);

				write_entry(handler.HandlerStart.Offset);
				write_length(GetTargetOffset(handler.HandlerEnd) - handler.HandlerStart.Offset);

				WriteExceptionHandlerSpecific(handler);
			}
		}

		void WriteExceptionHandlerSpecific(ExceptionHandler handler)
		{
			switch (handler.HandlerType)
			{
				case ExceptionHandlerType.Catch:
					WriteMetadataToken(metadata.LookupToken(handler.CatchType));
					break;
				case ExceptionHandlerType.Filter:
					WriteInt32(handler.FilterStart.Offset);
					break;
				default:
					WriteInt32(0);
					break;
			}
		}

		public MetadataToken GetStandAloneSignature(Collection<VariableDefinition> variables)
		{
			var signature = metadata.GetLocalVariableBlobIndex(variables);

			return GetStandAloneSignatureToken(signature);
		}

		public MetadataToken GetStandAloneSignature(CallSite call_site)
		{
			var signature = metadata.GetCallSiteBlobIndex(call_site);
			var token = GetStandAloneSignatureToken(signature);
			call_site.MetadataToken = token;
			return token;
		}

		MetadataToken GetStandAloneSignatureToken(uint signature)
		{
			MetadataToken token;
			if (standalone_signatures.TryGetValue(signature, out token))
				return token;

			token = new MetadataToken(TokenType.Signature, metadata.AddStandAloneSignature(signature));
			standalone_signatures.Add(signature, token);
			return token;
		}

		RVA BeginMethod()
		{
			return (RVA)(code_base + position);
		}

		void WriteMetadataToken(MetadataToken token)
		{
			WriteUInt32(token.ToUInt32());
		}

		void Align(int align)
		{
			align--;
			WriteBytes(((position + align) & ~align) - position);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Collections.Generic
{

	public class Collection<T> : IList<T>, IList
	{

		internal T[] items;
		internal int size;
		int version;

		public int Count
		{
			get { return size; }
		}

		public T this[int index]
		{
			get
			{
				if (index >= size)
					throw new ArgumentOutOfRangeException();

				return items[index];
			}
			set
			{
				CheckIndex(index);
				if (index == size)
					throw new ArgumentOutOfRangeException();

				OnSet(value, index);

				items[index] = value;
			}
		}

		public int Capacity
		{
			get { return items.Length; }
			set
			{
				if (value < 0 || value < size)
					throw new ArgumentOutOfRangeException();

				Resize(value);
			}
		}

		bool ICollection<T>.IsReadOnly
		{
			get { return false; }
		}

		bool IList.IsFixedSize
		{
			get { return false; }
		}

		bool IList.IsReadOnly
		{
			get { return false; }
		}

		object IList.this[int index]
		{
			get { return this[index]; }
			set
			{
				CheckIndex(index);

				try
				{
					this[index] = (T)value;
					return;
				}
				catch (InvalidCastException)
				{
				}
				catch (NullReferenceException)
				{
				}

				throw new ArgumentException();
			}
		}

		int ICollection.Count
		{
			get { return Count; }
		}

		bool ICollection.IsSynchronized
		{
			get { return false; }
		}

		object ICollection.SyncRoot
		{
			get { return this; }
		}

		public Collection()
		{
			items = Empty<T>.Array;
		}

		public Collection(int capacity)
		{
			if (capacity < 0)
				throw new ArgumentOutOfRangeException();

			items = capacity == 0
				? Empty<T>.Array
				: new T[capacity];
		}

		public Collection(ICollection<T> items)
		{
			if (items == null)
				throw new ArgumentNullException("items");

			this.items = new T[items.Count];
			items.CopyTo(this.items, 0);
			this.size = this.items.Length;
		}

		public void Add(T item)
		{
			if (size == items.Length)
				Grow(1);

			OnAdd(item, size);

			items[size++] = item;
			version++;
		}

		public bool Contains(T item)
		{
			return IndexOf(item) != -1;
		}

		public int IndexOf(T item)
		{
			return Array.IndexOf(items, item, 0, size);
		}

		public void Insert(int index, T item)
		{
			CheckIndex(index);
			if (size == items.Length)
				Grow(1);

			OnInsert(item, index);

			Shift(index, 1);
			items[index] = item;
			version++;
		}

		public void RemoveAt(int index)
		{
			if (index < 0 || index >= size)
				throw new ArgumentOutOfRangeException();

			var item = items[index];

			OnRemove(item, index);

			Shift(index, -1);
			version++;
		}

		public bool Remove(T item)
		{
			var index = IndexOf(item);
			if (index == -1)
				return false;

			OnRemove(item, index);

			Shift(index, -1);
			version++;

			return true;
		}

		public void Clear()
		{
			OnClear();

			Array.Clear(items, 0, size);
			size = 0;
			version++;
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			Array.Copy(items, 0, array, arrayIndex, size);
		}

		public T[] ToArray()
		{
			var array = new T[size];
			Array.Copy(items, 0, array, 0, size);
			return array;
		}

		void CheckIndex(int index)
		{
			if (index < 0 || index > size)
				throw new ArgumentOutOfRangeException();
		}

		void Shift(int start, int delta)
		{
			if (delta < 0)
				start -= delta;

			if (start < size)
				Array.Copy(items, start, items, start + delta, size - start);

			size += delta;

			if (delta < 0)
				Array.Clear(items, size, -delta);
		}

		protected virtual void OnAdd(T item, int index)
		{
		}

		protected virtual void OnInsert(T item, int index)
		{
		}

		protected virtual void OnSet(T item, int index)
		{
		}

		protected virtual void OnRemove(T item, int index)
		{
		}

		protected virtual void OnClear()
		{
		}

		internal virtual void Grow(int desired)
		{
			int new_size = size + desired;
			if (new_size <= items.Length)
				return;

			const int default_capacity = 4;

			new_size = System.Math.Max(
				System.Math.Max(items.Length * 2, default_capacity),
				new_size);

			Resize(new_size);
		}

		protected void Resize(int new_size)
		{
			if (new_size == size)
				return;
			if (new_size < size)
				throw new ArgumentOutOfRangeException();

			items = items.Resize(new_size);
		}

		int IList.Add(object value)
		{
			try
			{
				Add((T)value);
				return size - 1;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}

			throw new ArgumentException();
		}

		void IList.Clear()
		{
			Clear();
		}

		bool IList.Contains(object value)
		{
			return ((IList)this).IndexOf(value) > -1;
		}

		int IList.IndexOf(object value)
		{
			try
			{
				return IndexOf((T)value);
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}

			return -1;
		}

		void IList.Insert(int index, object value)
		{
			CheckIndex(index);

			try
			{
				Insert(index, (T)value);
				return;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}

			throw new ArgumentException();
		}

		void IList.Remove(object value)
		{
			try
			{
				Remove((T)value);
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
		}

		void IList.RemoveAt(int index)
		{
			RemoveAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			Array.Copy(items, 0, array, index, size);
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new Enumerator(this);
		}

		public struct Enumerator : IEnumerator<T>, IDisposable
		{

			Collection<T> collection;
			T current;

			int next;
			readonly int version;

			public T Current
			{
				get { return current; }
			}

			object IEnumerator.Current
			{
				get
				{
					CheckState();

					if (next <= 0)
						throw new InvalidOperationException();

					return current;
				}
			}

			internal Enumerator(Collection<T> collection)
				: this()
			{
				this.collection = collection;
				this.version = collection.version;
			}

			public bool MoveNext()
			{
				CheckState();

				if (next < 0)
					return false;

				if (next < collection.size)
				{
					current = collection.items[next++];
					return true;
				}

				next = -1;
				return false;
			}

			public void Reset()
			{
				CheckState();

				next = 0;
			}

			void CheckState()
			{
				if (collection == null)
					throw new ObjectDisposedException(GetType().FullName);

				if (version != collection.version)
					throw new InvalidOperationException();
			}

			public void Dispose()
			{
				collection = null;
			}
		}
	}
}
static class Consts
{
	public const string AssemblyName = "Mono.Cecil";
	public const string PublicKey = "00240000048000009400000006020000002400005253413100040000010001002b5c9f7f04346c324a3176f8d3ee823bbf2d60efdbc35f86fd9e65ea3e6cd11bcdcba3a353e55133c8ac5c4caaba581b2c6dfff2cc2d0edc43959ddb86b973300a479a82419ef489c3225f1fe429a708507bd515835160e10bc743d20ca33ab9570cfd68d479fcf0bc797a763bec5d1000f0159ef619e709d915975e87beebaf";
}//
 // CryptoConvert.cs - Crypto Convertion Routines
 //
 // Author:
 //	Sebastien Pouliot  <sebastien@ximian.com>
 //
 // (C) 2003 Motus Technologies Inc. (http://www.motus.com)
 // Copyright (C) 2004-2006 Novell Inc. (http://www.novell.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
 // without limitation the rights to use, copy, modify, merge, publish,
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
 //
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
 //
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //




namespace Mono.Security.Cryptography
{

	static class CryptoConvert
	{

		static private int ToInt32LE(byte[] bytes, int offset)
		{
			return (bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset];
		}

		static private uint ToUInt32LE(byte[] bytes, int offset)
		{
			return (uint)((bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset]);
		}

		static private byte[] GetBytesLE(int val)
		{
			return new byte[] {
				(byte) (val & 0xff),
				(byte) ((val >> 8) & 0xff),
				(byte) ((val >> 16) & 0xff),
				(byte) ((val >> 24) & 0xff)
			};
		}

		static private byte[] Trim(byte[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != 0x00)
				{
					byte[] result = new byte[array.Length - i];
					Buffer.BlockCopy(array, i, result, 0, result.Length);
					return result;
				}
			}
			return null;
		}

		static RSA FromCapiPrivateKeyBlob(byte[] blob, int offset)
		{
			RSAParameters rsap = new RSAParameters();
			try
			{
				if ((blob[offset] != 0x07) ||               // PRIVATEKEYBLOB (0x07)
					(blob[offset + 1] != 0x02) ||               // Version (0x02)
					(blob[offset + 2] != 0x00) ||               // Reserved (word)
					(blob[offset + 3] != 0x00) ||
					(ToUInt32LE(blob, offset + 8) != 0x32415352))   // DWORD magic = RSA2
					throw new CryptographicException("Invalid blob header");

				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
				// int algId = ToInt32LE (blob, offset+4);

				// DWORD bitlen
				int bitLen = ToInt32LE(blob, offset + 12);

				// DWORD public exponent
				byte[] exp = new byte[4];
				Buffer.BlockCopy(blob, offset + 16, exp, 0, 4);
				Array.Reverse(exp);
				rsap.Exponent = Trim(exp);

				int pos = offset + 20;
				// BYTE modulus[rsapubkey.bitlen/8];
				int byteLen = (bitLen >> 3);
				rsap.Modulus = new byte[byteLen];
				Buffer.BlockCopy(blob, pos, rsap.Modulus, 0, byteLen);
				Array.Reverse(rsap.Modulus);
				pos += byteLen;

				// BYTE prime1[rsapubkey.bitlen/16];
				int byteHalfLen = (byteLen >> 1);
				rsap.P = new byte[byteHalfLen];
				Buffer.BlockCopy(blob, pos, rsap.P, 0, byteHalfLen);
				Array.Reverse(rsap.P);
				pos += byteHalfLen;

				// BYTE prime2[rsapubkey.bitlen/16];
				rsap.Q = new byte[byteHalfLen];
				Buffer.BlockCopy(blob, pos, rsap.Q, 0, byteHalfLen);
				Array.Reverse(rsap.Q);
				pos += byteHalfLen;

				// BYTE exponent1[rsapubkey.bitlen/16];
				rsap.DP = new byte[byteHalfLen];
				Buffer.BlockCopy(blob, pos, rsap.DP, 0, byteHalfLen);
				Array.Reverse(rsap.DP);
				pos += byteHalfLen;

				// BYTE exponent2[rsapubkey.bitlen/16];
				rsap.DQ = new byte[byteHalfLen];
				Buffer.BlockCopy(blob, pos, rsap.DQ, 0, byteHalfLen);
				Array.Reverse(rsap.DQ);
				pos += byteHalfLen;

				// BYTE coefficient[rsapubkey.bitlen/16];
				rsap.InverseQ = new byte[byteHalfLen];
				Buffer.BlockCopy(blob, pos, rsap.InverseQ, 0, byteHalfLen);
				Array.Reverse(rsap.InverseQ);
				pos += byteHalfLen;

				// ok, this is hackish but CryptoAPI support it so...
				// note: only works because CRT is used by default
				// http://bugzilla.ximian.com/show_bug.cgi?id=57941
				rsap.D = new byte[byteLen]; // must be allocated
				if (pos + byteLen + offset <= blob.Length)
				{
					// BYTE privateExponent[rsapubkey.bitlen/8];
					Buffer.BlockCopy(blob, pos, rsap.D, 0, byteLen);
					Array.Reverse(rsap.D);
				}
			}
			catch (Exception e)
			{
				throw new CryptographicException("Invalid blob.", e);
			}

			RSA rsa = null;
			try
			{
				rsa = RSA.Create();
				rsa.ImportParameters(rsap);
			}
			catch (CryptographicException)
			{
				// this may cause problem when this code is run under
				// the SYSTEM identity on Windows (e.g. ASP.NET). See
				// http://bugzilla.ximian.com/show_bug.cgi?id=77559
				bool throws = false;
				try
				{
					CspParameters csp = new CspParameters();
					csp.Flags = CspProviderFlags.UseMachineKeyStore;
					rsa = new RSACryptoServiceProvider(csp);
					rsa.ImportParameters(rsap);
				}
				catch
				{
					throws = true;
				}

				if (throws)
				{
					// rethrow original, not the latter, exception if this fails
					throw;
				}
			}
			return rsa;
		}

		static RSA FromCapiPublicKeyBlob(byte[] blob, int offset)
		{
			try
			{
				if ((blob[offset] != 0x06) ||               // PUBLICKEYBLOB (0x06)
					(blob[offset + 1] != 0x02) ||               // Version (0x02)
					(blob[offset + 2] != 0x00) ||               // Reserved (word)
					(blob[offset + 3] != 0x00) ||
					(ToUInt32LE(blob, offset + 8) != 0x31415352))   // DWORD magic = RSA1
					throw new CryptographicException("Invalid blob header");

				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
				// int algId = ToInt32LE (blob, offset+4);

				// DWORD bitlen
				int bitLen = ToInt32LE(blob, offset + 12);

				// DWORD public exponent
				RSAParameters rsap = new RSAParameters();
				rsap.Exponent = new byte[3];
				rsap.Exponent[0] = blob[offset + 18];
				rsap.Exponent[1] = blob[offset + 17];
				rsap.Exponent[2] = blob[offset + 16];

				int pos = offset + 20;
				// BYTE modulus[rsapubkey.bitlen/8];
				int byteLen = (bitLen >> 3);
				rsap.Modulus = new byte[byteLen];
				Buffer.BlockCopy(blob, pos, rsap.Modulus, 0, byteLen);
				Array.Reverse(rsap.Modulus);

				RSA rsa = null;
				try
				{
					rsa = RSA.Create();
					rsa.ImportParameters(rsap);
				}
				catch (CryptographicException)
				{
					// this may cause problem when this code is run under
					// the SYSTEM identity on Windows (e.g. ASP.NET). See
					// http://bugzilla.ximian.com/show_bug.cgi?id=77559
					CspParameters csp = new CspParameters();
					csp.Flags = CspProviderFlags.UseMachineKeyStore;
					rsa = new RSACryptoServiceProvider(csp);
					rsa.ImportParameters(rsap);
				}
				return rsa;
			}
			catch (Exception e)
			{
				throw new CryptographicException("Invalid blob.", e);
			}
		}

		// PRIVATEKEYBLOB
		// PUBLICKEYBLOB
		static public RSA FromCapiKeyBlob(byte[] blob)
		{
			return FromCapiKeyBlob(blob, 0);
		}

		static public RSA FromCapiKeyBlob(byte[] blob, int offset)
		{
			if (blob == null)
				throw new ArgumentNullException("blob");
			if (offset >= blob.Length)
				throw new ArgumentException("blob is too small.");

			switch (blob[offset])
			{
				case 0x00:
					// this could be a public key inside an header
					// like "sn -e" would produce
					if (blob[offset + 12] == 0x06)
					{
						return FromCapiPublicKeyBlob(blob, offset + 12);
					}
					break;
				case 0x06:
					return FromCapiPublicKeyBlob(blob, offset);
				case 0x07:
					return FromCapiPrivateKeyBlob(blob, offset);
			}
			throw new CryptographicException("Unknown blob format.");
		}

		static public byte[] ToCapiPublicKeyBlob(RSA rsa)
		{
			RSAParameters p = rsa.ExportParameters(false);
			int keyLength = p.Modulus.Length; // in bytes
			byte[] blob = new byte[20 + keyLength];

			blob[0] = 0x06; // Type - PUBLICKEYBLOB (0x06)
			blob[1] = 0x02; // Version - Always CUR_BLOB_VERSION (0x02)
							// [2], [3]		// RESERVED - Always 0
			blob[5] = 0x24; // ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
			blob[8] = 0x52; // Magic - RSA1 (ASCII in hex)
			blob[9] = 0x53;
			blob[10] = 0x41;
			blob[11] = 0x31;

			byte[] bitlen = GetBytesLE(keyLength << 3);
			blob[12] = bitlen[0];   // bitlen
			blob[13] = bitlen[1];
			blob[14] = bitlen[2];
			blob[15] = bitlen[3];

			// public exponent (DWORD)
			int pos = 16;
			int n = p.Exponent.Length;
			while (n > 0)
				blob[pos++] = p.Exponent[--n];
			// modulus
			pos = 20;
			byte[] part = p.Modulus;
			int len = part.Length;
			Array.Reverse(part, 0, len);
			Buffer.BlockCopy(part, 0, blob, pos, len);
			pos += len;
			return blob;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//











namespace Mono.Cecil
{

	// Most of this code has been adapted
	// from Jeroen Frijters' fantastic work
	// in IKVM.Reflection.Emit. Thanks!

	static class CryptoService
	{

		public static byte[] GetPublicKey(WriterParameters parameters)
		{
			using (var rsa = parameters.CreateRSA())
			{
				var cspBlob = CryptoConvert.ToCapiPublicKeyBlob(rsa);
				var publicKey = new byte[12 + cspBlob.Length];
				Buffer.BlockCopy(cspBlob, 0, publicKey, 12, cspBlob.Length);
				// The first 12 bytes are documented at:
				// http://msdn.microsoft.com/library/en-us/cprefadd/html/grfungethashfromfile.asp
				// ALG_ID - Signature
				publicKey[1] = 36;
				// ALG_ID - Hash
				publicKey[4] = 4;
				publicKey[5] = 128;
				// Length of Public Key (in bytes)
				publicKey[8] = (byte)(cspBlob.Length >> 0);
				publicKey[9] = (byte)(cspBlob.Length >> 8);
				publicKey[10] = (byte)(cspBlob.Length >> 16);
				publicKey[11] = (byte)(cspBlob.Length >> 24);
				return publicKey;
			}
		}

		public static void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters)
		{
			int strong_name_pointer;

			var strong_name = CreateStrongName(parameters, HashStream(stream, writer, out strong_name_pointer));
			PatchStrongName(stream, strong_name_pointer, strong_name);
		}

		static void PatchStrongName(Stream stream, int strong_name_pointer, byte[] strong_name)
		{
			stream.Seek(strong_name_pointer, SeekOrigin.Begin);
			stream.Write(strong_name, 0, strong_name.Length);
		}

		static byte[] CreateStrongName(WriterParameters parameters, byte[] hash)
		{
			const string hash_algo = "SHA1";

			using (var rsa = parameters.CreateRSA())
			{
				var formatter = new RSAPKCS1SignatureFormatter(rsa);
				formatter.SetHashAlgorithm(hash_algo);

				byte[] signature = formatter.CreateSignature(hash);
				Array.Reverse(signature);

				return signature;
			}
		}

		static byte[] HashStream(Stream stream, ImageWriter writer, out int strong_name_pointer)
		{
			const int buffer_size = 8192;

			var text = writer.text;
			var header_size = (int)writer.GetHeaderSize();
			var text_section_pointer = (int)text.PointerToRawData;
			var strong_name_directory = writer.GetStrongNameSignatureDirectory();

			if (strong_name_directory.Size == 0)
				throw new InvalidOperationException();

			strong_name_pointer = (int)(text_section_pointer
				+ (strong_name_directory.VirtualAddress - text.VirtualAddress));
			var strong_name_length = (int)strong_name_directory.Size;

			var sha1 = new SHA1Managed();
			var buffer = new byte[buffer_size];
			using (var crypto_stream = new CryptoStream(Stream.Null, sha1, CryptoStreamMode.Write))
			{
				stream.Seek(0, SeekOrigin.Begin);
				CopyStreamChunk(stream, crypto_stream, buffer, header_size);

				stream.Seek(text_section_pointer, SeekOrigin.Begin);
				CopyStreamChunk(stream, crypto_stream, buffer, (int)strong_name_pointer - text_section_pointer);

				stream.Seek(strong_name_length, SeekOrigin.Current);
				CopyStreamChunk(stream, crypto_stream, buffer, (int)(stream.Length - (strong_name_pointer + strong_name_length)));
			}

			return sha1.Hash;
		}

		static void CopyStreamChunk(Stream stream, Stream dest_stream, byte[] buffer, int length)
		{
			while (length > 0)
			{
				int read = stream.Read(buffer, 0, System.Math.Min(buffer.Length, length));
				dest_stream.Write(buffer, 0, read);
				length -= read;
			}
		}

		public static byte[] ComputeHash(string file)
		{
			if (!File.Exists(file))
				return Empty<byte>.Array;

			using (var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read))
				return ComputeHash(stream);
		}

		public static byte[] ComputeHash(Stream stream)
		{
			const int buffer_size = 8192;

			var sha1 = new SHA1Managed();
			var buffer = new byte[buffer_size];

			using (var crypto_stream = new CryptoStream(Stream.Null, sha1, CryptoStreamMode.Write))
				CopyStreamChunk(stream, crypto_stream, buffer, (int)stream.Length);

			return sha1.Hash;
		}

		public static byte[] ComputeHash(params ByteBuffer[] buffers)
		{
			var sha1 = new SHA1Managed();

			using (var crypto_stream = new CryptoStream(Stream.Null, sha1, CryptoStreamMode.Write))
			{
				for (int i = 0; i < buffers.Length; i++)
				{
					crypto_stream.Write(buffers[i].buffer, 0, buffers[i].length);
				}
			}

			return sha1.Hash;
		}

		public static Guid ComputeGuid(byte[] hash)
		{
			// From corefx/src/System.Reflection.Metadata/src/System/Reflection/Metadata/BlobContentId.cs
			var guid = new byte[16];
			Buffer.BlockCopy(hash, 0, guid, 0, 16);

			// modify the guid data so it decodes to the form of a "random" guid ala rfc4122
			guid[7] = (byte)((guid[7] & 0x0f) | (4 << 4));
			guid[8] = (byte)((guid[8] & 0x3f) | (2 << 6));

			return new Guid(guid);
		}
	}

	static partial class Mixin
	{

		public static RSA CreateRSA(this WriterParameters writer_parameters)
		{
			byte[] key;
			string key_container;

			if (writer_parameters.StrongNameKeyBlob != null)
				return CryptoConvert.FromCapiKeyBlob(writer_parameters.StrongNameKeyBlob);

			if (writer_parameters.StrongNameKeyContainer != null)
				key_container = writer_parameters.StrongNameKeyContainer;
			else if (!TryGetKeyContainer(writer_parameters.StrongNameKeyPair, out key, out key_container))
				return CryptoConvert.FromCapiKeyBlob(key);

			var parameters = new CspParameters
			{
				Flags = CspProviderFlags.UseMachineKeyStore,
				KeyContainerName = key_container,
				KeyNumber = 2,
			};

			return new RSACryptoServiceProvider(parameters);
		}

		static bool TryGetKeyContainer(ISerializable key_pair, out byte[] key, out string key_container)
		{
			var info = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
			key_pair.GetObjectData(info, new StreamingContext());

			key = (byte[])info.GetValue("_keyPairArray", typeof(byte[]));
			key_container = info.GetString("_keyPairContainer");
			return key_container != null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public struct CustomAttributeArgument
	{

		readonly TypeReference type;
		readonly object value;

		public TypeReference Type
		{
			get { return type; }
		}

		public object Value
		{
			get { return value; }
		}

		public CustomAttributeArgument(TypeReference type, object value)
		{
			Mixin.CheckType(type);
			this.type = type;
			this.value = value;
		}
	}

	public struct CustomAttributeNamedArgument
	{

		readonly string name;
		readonly CustomAttributeArgument argument;

		public string Name
		{
			get { return name; }
		}

		public CustomAttributeArgument Argument
		{
			get { return argument; }
		}

		public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument)
		{
			Mixin.CheckName(name);
			this.name = name;
			this.argument = argument;
		}
	}

	public interface ICustomAttribute
	{

		TypeReference AttributeType { get; }

		bool HasFields { get; }
		bool HasProperties { get; }
		bool HasConstructorArguments { get; }
		Collection<CustomAttributeNamedArgument> Fields { get; }
		Collection<CustomAttributeNamedArgument> Properties { get; }
		Collection<CustomAttributeArgument> ConstructorArguments { get; }
	}

	[DebuggerDisplay("{AttributeType}")]
	public sealed class CustomAttribute : ICustomAttribute
	{

		internal CustomAttributeValueProjection projection;
		readonly internal uint signature;
		internal bool resolved;
		MethodReference constructor;
		byte[] blob;
		internal Collection<CustomAttributeArgument> arguments;
		internal Collection<CustomAttributeNamedArgument> fields;
		internal Collection<CustomAttributeNamedArgument> properties;

		public MethodReference Constructor
		{
			get { return constructor; }
			set { constructor = value; }
		}

		public TypeReference AttributeType
		{
			get { return constructor.DeclaringType; }
		}

		public bool IsResolved
		{
			get { return resolved; }
		}

		public bool HasConstructorArguments
		{
			get
			{
				Resolve();

				return !arguments.IsNullOrEmpty();
			}
		}

		public Collection<CustomAttributeArgument> ConstructorArguments
		{
			get
			{
				Resolve();

				if (arguments == null)
					Interlocked.CompareExchange(ref arguments, new Collection<CustomAttributeArgument>(), null);

				return arguments;
			}
		}

		public bool HasFields
		{
			get
			{
				Resolve();

				return !fields.IsNullOrEmpty();
			}
		}

		public Collection<CustomAttributeNamedArgument> Fields
		{
			get
			{
				Resolve();

				if (fields == null)
					Interlocked.CompareExchange(ref fields, new Collection<CustomAttributeNamedArgument>(), null);

				return fields;
			}
		}

		public bool HasProperties
		{
			get
			{
				Resolve();

				return !properties.IsNullOrEmpty();
			}
		}

		public Collection<CustomAttributeNamedArgument> Properties
		{
			get
			{
				Resolve();

				if (properties == null)
					Interlocked.CompareExchange(ref properties, new Collection<CustomAttributeNamedArgument>(), null);

				return properties;
			}
		}

		internal bool HasImage
		{
			get { return constructor != null && constructor.HasImage; }
		}

		internal ModuleDefinition Module
		{
			get { return constructor.Module; }
		}

		internal CustomAttribute(uint signature, MethodReference constructor)
		{
			this.signature = signature;
			this.constructor = constructor;
			this.resolved = false;
		}

		public CustomAttribute(MethodReference constructor)
		{
			this.constructor = constructor;
			this.resolved = true;
		}

		public CustomAttribute(MethodReference constructor, byte[] blob)
		{
			this.constructor = constructor;
			this.resolved = false;
			this.blob = blob;
		}

		public byte[] GetBlob()
		{
			if (blob != null)
				return blob;

			if (!HasImage)
				throw new NotSupportedException();

			return Module.Read(ref blob, this, (attribute, reader) => reader.ReadCustomAttributeBlob(attribute.signature));
		}

		void Resolve()
		{
			if (resolved || !HasImage)
				return;

			lock (Module.SyncRoot)
			{
				if (resolved)
					return;

				Module.Read(this, (attribute, reader) => {
					try
					{
						reader.ReadCustomAttributeSignature(attribute);
						resolved = true;
					}
					catch (ResolutionException)
					{
						if (arguments != null)
							arguments.Clear();
						if (fields != null)
							fields.Clear();
						if (properties != null)
							properties.Clear();

						resolved = false;
					}
				});
			}
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct FLOAT10
	{
		internal byte Data_0;
		internal byte Data_1;
		internal byte Data_2;
		internal byte Data_3;
		internal byte Data_4;
		internal byte Data_5;
		internal byte Data_6;
		internal byte Data_7;
		internal byte Data_8;
		internal byte Data_9;
	};

	internal enum CV_SIGNATURE
	{
		C6 = 0,    // Actual signature is >64K
		C7 = 1,    // First explicit signature
		C11 = 2,    // C11 (vc5.x) 32-bit types
		C13 = 4,    // C13 (vc7.x) zero terminated names
		RESERVERD = 5,    // All signatures from 5 to 64K are reserved
	};

	//  CodeView Symbol and Type OMF type information is broken up into two
	//  ranges.  Type indices less than 0x1000 describe type information
	//  that is frequently used.  Type indices above 0x1000 are used to
	//  describe more complex features such as functions, arrays and
	//  structures.
	//

	//  Primitive types have predefined meaning that is encoded in the
	//  values of the various bit fields in the value.
	//
	//  A CodeView primitive type is defined as:
	//
	//  1 1
	//  1 089  7654  3  210
	//  r mode type  r  sub
	//
	//  Where
	//      mode is the pointer mode
	//      type is a type indicator
	//      sub  is a subtype enumeration
	//      r    is a reserved field
	//
	//  See Microsoft Symbol and Type OMF (Version 4.0) for more
	//  information.
	//

	//  pointer mode enumeration values

	internal enum CV_prmode
	{
		CV_TM_DIRECT = 0,        // mode is not a pointer
		CV_TM_NPTR32 = 4,        // mode is a 32 bit near pointer
		CV_TM_NPTR64 = 6,        // mode is a 64 bit near pointer
		CV_TM_NPTR128 = 7,        // mode is a 128 bit near pointer
	};

	//  type enumeration values

	internal enum CV_type
	{
		CV_SPECIAL = 0x00,     // special type size values
		CV_SIGNED = 0x01,     // signed integral size values
		CV_UNSIGNED = 0x02,     // unsigned integral size values
		CV_BOOLEAN = 0x03,     // Boolean size values
		CV_REAL = 0x04,     // real number size values
		CV_COMPLEX = 0x05,     // complex number size values
		CV_SPECIAL2 = 0x06,     // second set of special types
		CV_INT = 0x07,     // integral (int) values
		CV_CVRESERVED = 0x0f,
	};

	//  subtype enumeration values for CV_SPECIAL

	internal enum CV_special
	{
		CV_SP_NOTYPE = 0x00,
		CV_SP_ABS = 0x01,
		CV_SP_SEGMENT = 0x02,
		CV_SP_VOID = 0x03,
		CV_SP_CURRENCY = 0x04,
		CV_SP_NBASICSTR = 0x05,
		CV_SP_FBASICSTR = 0x06,
		CV_SP_NOTTRANS = 0x07,
		CV_SP_HRESULT = 0x08,
	};

	//  subtype enumeration values for CV_SPECIAL2

	internal enum CV_special2
	{
		CV_S2_BIT = 0x00,
		CV_S2_PASCHAR = 0x01,     // Pascal CHAR
	};

	//  subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN

	internal enum CV_integral
	{
		CV_IN_1BYTE = 0x00,
		CV_IN_2BYTE = 0x01,
		CV_IN_4BYTE = 0x02,
		CV_IN_8BYTE = 0x03,
		CV_IN_16BYTE = 0x04,
	};

	//  subtype enumeration values for CV_REAL and CV_COMPLEX

	internal enum CV_real
	{
		CV_RC_REAL32 = 0x00,
		CV_RC_REAL64 = 0x01,
		CV_RC_REAL80 = 0x02,
		CV_RC_REAL128 = 0x03,
	};

	//  subtype enumeration values for CV_INT (really int)

	internal enum CV_int
	{
		CV_RI_CHAR = 0x00,
		CV_RI_INT1 = 0x00,
		CV_RI_WCHAR = 0x01,
		CV_RI_UINT1 = 0x01,
		CV_RI_INT2 = 0x02,
		CV_RI_UINT2 = 0x03,
		CV_RI_INT4 = 0x04,
		CV_RI_UINT4 = 0x05,
		CV_RI_INT8 = 0x06,
		CV_RI_UINT8 = 0x07,
		CV_RI_INT16 = 0x08,
		CV_RI_UINT16 = 0x09,
	};

	internal struct CV_PRIMITIVE_TYPE
	{
		const uint CV_MMASK = 0x700;       // mode mask
		const uint CV_TMASK = 0x0f0;       // type mask
		const uint CV_SMASK = 0x00f;       // subtype mask

		const int CV_MSHIFT = 8;           // primitive mode right shift count
		const int CV_TSHIFT = 4;           // primitive type right shift count
		const int CV_SSHIFT = 0;           // primitive subtype right shift count

		// function to extract primitive mode, type and size

		//internal static CV_prmode CV_MODE(TYPE_ENUM typ) {
		//  return (CV_prmode)((((uint)typ) & CV_MMASK) >> CV_MSHIFT);
		//}

		//internal static CV_type CV_TYPE(TYPE_ENUM typ) {
		//  return (CV_type)((((uint)typ) & CV_TMASK) >> CV_TSHIFT);
		//}

		//internal static uint CV_SUBT(TYPE_ENUM typ) {
		//  return ((((uint)typ) & CV_SMASK) >> CV_SSHIFT);
		//}

		// functions to check the type of a primitive

		//internal static bool CV_TYP_IS_DIRECT(TYPE_ENUM typ) {
		//  return (CV_MODE(typ) == CV_prmode.CV_TM_DIRECT);
		//}

		//internal static bool CV_TYP_IS_PTR(TYPE_ENUM typ) {
		//  return (CV_MODE(typ) != CV_prmode.CV_TM_DIRECT);
		//}

		//internal static bool CV_TYP_IS_SIGNED(TYPE_ENUM typ) {
		//  return
		//      (((CV_TYPE(typ) == CV_type.CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) ||
		//             (typ == TYPE_ENUM.T_INT1)  ||
		//             (typ == TYPE_ENUM.T_INT2)  ||
		//             (typ == TYPE_ENUM.T_INT4)  ||
		//             (typ == TYPE_ENUM.T_INT8)  ||
		//             (typ == TYPE_ENUM.T_INT16) ||
		//             (typ == TYPE_ENUM.T_RCHAR));
		//}

		//internal static bool CV_TYP_IS_UNSIGNED(TYPE_ENUM typ) {
		//  return (((CV_TYPE(typ) == CV_type.CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) ||
		//                (typ == TYPE_ENUM.T_UINT1) ||
		//                (typ == TYPE_ENUM.T_UINT2) ||
		//                (typ == TYPE_ENUM.T_UINT4) ||
		//                (typ == TYPE_ENUM.T_UINT8) ||
		//                (typ == TYPE_ENUM.T_UINT16));
		//}

		//internal static bool CV_TYP_IS_REAL(TYPE_ENUM typ) {
		//  return ((CV_TYPE(typ) == CV_type.CV_REAL)  && CV_TYP_IS_DIRECT(typ));
		//}

		const uint CV_FIRST_NONPRIM = 0x1000;

		//internal static bool CV_IS_PRIMITIVE(TYPE_ENUM typ) {
		//  return ((uint)(typ) < CV_FIRST_NONPRIM);
		//}

		//internal static bool CV_TYP_IS_COMPLEX(TYPE_ENUM typ) {
		//  return ((CV_TYPE(typ) == CV_type.CV_COMPLEX) && CV_TYP_IS_DIRECT(typ));
		//}

		//internal static bool CV_IS_INTERNAL_PTR(TYPE_ENUM typ) {
		//  return (CV_IS_PRIMITIVE(typ) &&
		//                CV_TYPE(typ) == CV_type.CV_CVRESERVED &&
		//                CV_TYP_IS_PTR(typ));
		//}
	}

	// selected values for type_index - for a more complete definition, see
	// Microsoft Symbol and Type OMF document

	//  Special Types

	internal enum TYPE_ENUM
	{
		//  Special Types

		T_NOTYPE = 0x0000,   // uncharacterized type (no type)
		T_ABS = 0x0001,   // absolute symbol
		T_SEGMENT = 0x0002,   // segment type
		T_VOID = 0x0003,   // void
		T_HRESULT = 0x0008,   // OLE/COM HRESULT
		T_32PHRESULT = 0x0408,   // OLE/COM HRESULT __ptr32//
		T_64PHRESULT = 0x0608,   // OLE/COM HRESULT __ptr64//
		T_PVOID = 0x0103,   // near pointer to void
		T_PFVOID = 0x0203,   // far pointer to void
		T_PHVOID = 0x0303,   // huge pointer to void
		T_32PVOID = 0x0403,   // 32 bit pointer to void
		T_64PVOID = 0x0603,   // 64 bit pointer to void
		T_CURRENCY = 0x0004,   // BASIC 8 byte currency value
		T_NOTTRANS = 0x0007,   // type not translated by cvpack
		T_BIT = 0x0060,   // bit
		T_PASCHAR = 0x0061,   // Pascal CHAR

		//  Character types

		T_CHAR = 0x0010,   // 8 bit signed
		T_32PCHAR = 0x0410,   // 32 bit pointer to 8 bit signed
		T_64PCHAR = 0x0610,   // 64 bit pointer to 8 bit signed

		T_UCHAR = 0x0020,   // 8 bit unsigned
		T_32PUCHAR = 0x0420,   // 32 bit pointer to 8 bit unsigned
		T_64PUCHAR = 0x0620,   // 64 bit pointer to 8 bit unsigned

		//  really a character types

		T_RCHAR = 0x0070,   // really a char
		T_32PRCHAR = 0x0470,   // 32 bit pointer to a real char
		T_64PRCHAR = 0x0670,   // 64 bit pointer to a real char

		//  really a wide character types

		T_WCHAR = 0x0071,   // wide char
		T_32PWCHAR = 0x0471,   // 32 bit pointer to a wide char
		T_64PWCHAR = 0x0671,   // 64 bit pointer to a wide char

		//  8 bit int types

		T_INT1 = 0x0068,   // 8 bit signed int
		T_32PINT1 = 0x0468,   // 32 bit pointer to 8 bit signed int
		T_64PINT1 = 0x0668,   // 64 bit pointer to 8 bit signed int

		T_UINT1 = 0x0069,   // 8 bit unsigned int
		T_32PUINT1 = 0x0469,   // 32 bit pointer to 8 bit unsigned int
		T_64PUINT1 = 0x0669,   // 64 bit pointer to 8 bit unsigned int

		//  16 bit short types

		T_SHORT = 0x0011,   // 16 bit signed
		T_32PSHORT = 0x0411,   // 32 bit pointer to 16 bit signed
		T_64PSHORT = 0x0611,   // 64 bit pointer to 16 bit signed

		T_USHORT = 0x0021,   // 16 bit unsigned
		T_32PUSHORT = 0x0421,   // 32 bit pointer to 16 bit unsigned
		T_64PUSHORT = 0x0621,   // 64 bit pointer to 16 bit unsigned

		//  16 bit int types

		T_INT2 = 0x0072,   // 16 bit signed int
		T_32PINT2 = 0x0472,   // 32 bit pointer to 16 bit signed int
		T_64PINT2 = 0x0672,   // 64 bit pointer to 16 bit signed int

		T_UINT2 = 0x0073,   // 16 bit unsigned int
		T_32PUINT2 = 0x0473,   // 32 bit pointer to 16 bit unsigned int
		T_64PUINT2 = 0x0673,   // 64 bit pointer to 16 bit unsigned int

		//  32 bit long types

		T_LONG = 0x0012,   // 32 bit signed
		T_ULONG = 0x0022,   // 32 bit unsigned
		T_32PLONG = 0x0412,   // 32 bit pointer to 32 bit signed
		T_32PULONG = 0x0422,   // 32 bit pointer to 32 bit unsigned
		T_64PLONG = 0x0612,   // 64 bit pointer to 32 bit signed
		T_64PULONG = 0x0622,   // 64 bit pointer to 32 bit unsigned

		//  32 bit int types

		T_INT4 = 0x0074,   // 32 bit signed int
		T_32PINT4 = 0x0474,   // 32 bit pointer to 32 bit signed int
		T_64PINT4 = 0x0674,   // 64 bit pointer to 32 bit signed int

		T_UINT4 = 0x0075,   // 32 bit unsigned int
		T_32PUINT4 = 0x0475,   // 32 bit pointer to 32 bit unsigned int
		T_64PUINT4 = 0x0675,   // 64 bit pointer to 32 bit unsigned int

		//  64 bit quad types

		T_QUAD = 0x0013,   // 64 bit signed
		T_32PQUAD = 0x0413,   // 32 bit pointer to 64 bit signed
		T_64PQUAD = 0x0613,   // 64 bit pointer to 64 bit signed

		T_UQUAD = 0x0023,   // 64 bit unsigned
		T_32PUQUAD = 0x0423,   // 32 bit pointer to 64 bit unsigned
		T_64PUQUAD = 0x0623,   // 64 bit pointer to 64 bit unsigned

		//  64 bit int types

		T_INT8 = 0x0076,   // 64 bit signed int
		T_32PINT8 = 0x0476,   // 32 bit pointer to 64 bit signed int
		T_64PINT8 = 0x0676,   // 64 bit pointer to 64 bit signed int

		T_UINT8 = 0x0077,   // 64 bit unsigned int
		T_32PUINT8 = 0x0477,   // 32 bit pointer to 64 bit unsigned int
		T_64PUINT8 = 0x0677,   // 64 bit pointer to 64 bit unsigned int

		//  128 bit octet types

		T_OCT = 0x0014,   // 128 bit signed
		T_32POCT = 0x0414,   // 32 bit pointer to 128 bit signed
		T_64POCT = 0x0614,   // 64 bit pointer to 128 bit signed

		T_UOCT = 0x0024,   // 128 bit unsigned
		T_32PUOCT = 0x0424,   // 32 bit pointer to 128 bit unsigned
		T_64PUOCT = 0x0624,   // 64 bit pointer to 128 bit unsigned

		//  128 bit int types

		T_INT16 = 0x0078,   // 128 bit signed int
		T_32PINT16 = 0x0478,   // 32 bit pointer to 128 bit signed int
		T_64PINT16 = 0x0678,   // 64 bit pointer to 128 bit signed int

		T_UINT16 = 0x0079,   // 128 bit unsigned int
		T_32PUINT16 = 0x0479,   // 32 bit pointer to 128 bit unsigned int
		T_64PUINT16 = 0x0679,   // 64 bit pointer to 128 bit unsigned int

		//  32 bit real types

		T_REAL32 = 0x0040,   // 32 bit real
		T_32PREAL32 = 0x0440,   // 32 bit pointer to 32 bit real
		T_64PREAL32 = 0x0640,   // 64 bit pointer to 32 bit real

		//  64 bit real types

		T_REAL64 = 0x0041,   // 64 bit real
		T_32PREAL64 = 0x0441,   // 32 bit pointer to 64 bit real
		T_64PREAL64 = 0x0641,   // 64 bit pointer to 64 bit real

		//  80 bit real types

		T_REAL80 = 0x0042,   // 80 bit real
		T_32PREAL80 = 0x0442,   // 32 bit pointer to 80 bit real
		T_64PREAL80 = 0x0642,   // 64 bit pointer to 80 bit real

		//  128 bit real types

		T_REAL128 = 0x0043,   // 128 bit real
		T_32PREAL128 = 0x0443,   // 32 bit pointer to 128 bit real
		T_64PREAL128 = 0x0643,   // 64 bit pointer to 128 bit real

		//  32 bit complex types

		T_CPLX32 = 0x0050,   // 32 bit complex
		T_32PCPLX32 = 0x0450,   // 32 bit pointer to 32 bit complex
		T_64PCPLX32 = 0x0650,   // 64 bit pointer to 32 bit complex

		//  64 bit complex types

		T_CPLX64 = 0x0051,   // 64 bit complex
		T_32PCPLX64 = 0x0451,   // 32 bit pointer to 64 bit complex
		T_64PCPLX64 = 0x0651,   // 64 bit pointer to 64 bit complex

		//  80 bit complex types

		T_CPLX80 = 0x0052,   // 80 bit complex
		T_32PCPLX80 = 0x0452,   // 32 bit pointer to 80 bit complex
		T_64PCPLX80 = 0x0652,   // 64 bit pointer to 80 bit complex

		//  128 bit complex types

		T_CPLX128 = 0x0053,   // 128 bit complex
		T_32PCPLX128 = 0x0453,   // 32 bit pointer to 128 bit complex
		T_64PCPLX128 = 0x0653,   // 64 bit pointer to 128 bit complex

		//  boolean types

		T_BOOL08 = 0x0030,   // 8 bit boolean
		T_32PBOOL08 = 0x0430,   // 32 bit pointer to 8 bit boolean
		T_64PBOOL08 = 0x0630,   // 64 bit pointer to 8 bit boolean

		T_BOOL16 = 0x0031,   // 16 bit boolean
		T_32PBOOL16 = 0x0431,   // 32 bit pointer to 18 bit boolean
		T_64PBOOL16 = 0x0631,   // 64 bit pointer to 18 bit boolean

		T_BOOL32 = 0x0032,   // 32 bit boolean
		T_32PBOOL32 = 0x0432,   // 32 bit pointer to 32 bit boolean
		T_64PBOOL32 = 0x0632,   // 64 bit pointer to 32 bit boolean

		T_BOOL64 = 0x0033,   // 64 bit boolean
		T_32PBOOL64 = 0x0433,   // 32 bit pointer to 64 bit boolean
		T_64PBOOL64 = 0x0633,   // 64 bit pointer to 64 bit boolean
	};

	//  No leaf index can have a value of 0x0000.  The leaf indices are
	//  separated into ranges depending upon the use of the type record.
	//  The second range is for the type records that are directly referenced
	//  in symbols. The first range is for type records that are not
	//  referenced by symbols but instead are referenced by other type
	//  records.  All type records must have a starting leaf index in these
	//  first two ranges.  The third range of leaf indices are used to build
	//  up complex lists such as the field list of a class type record.  No
	//  type record can begin with one of the leaf indices. The fourth ranges
	//  of type indices are used to represent numeric data in a symbol or
	//  type record. These leaf indices are greater than 0x8000.  At the
	//  point that type or symbol processor is expecting a numeric field, the
	//  next two bytes in the type record are examined.  If the value is less
	//  than 0x8000, then the two bytes contain the numeric value.  If the
	//  value is greater than 0x8000, then the data follows the leaf index in
	//  a format specified by the leaf index. The final range of leaf indices
	//  are used to force alignment of subfields within a complex type record..
	//

	internal enum LEAF
	{
		// leaf indices starting records but referenced from symbol records

		LF_VTSHAPE = 0x000a,
		LF_COBOL1 = 0x000c,
		LF_LABEL = 0x000e,
		LF_NULL = 0x000f,
		LF_NOTTRAN = 0x0010,
		LF_ENDPRECOMP = 0x0014,       // not referenced from symbol
		LF_TYPESERVER_ST = 0x0016,       // not referenced from symbol

		// leaf indices starting records but referenced only from type records

		LF_LIST = 0x0203,
		LF_REFSYM = 0x020c,

		LF_ENUMERATE_ST = 0x0403,

		// 32-bit type index versions of leaves, all have the 0x1000 bit set
		//
		LF_TI16_MAX = 0x1000,

		LF_MODIFIER = 0x1001,
		LF_POINTER = 0x1002,
		LF_ARRAY_ST = 0x1003,
		LF_CLASS_ST = 0x1004,
		LF_STRUCTURE_ST = 0x1005,
		LF_UNION_ST = 0x1006,
		LF_ENUM_ST = 0x1007,
		LF_PROCEDURE = 0x1008,
		LF_MFUNCTION = 0x1009,
		LF_COBOL0 = 0x100a,
		LF_BARRAY = 0x100b,
		LF_DIMARRAY_ST = 0x100c,
		LF_VFTPATH = 0x100d,
		LF_PRECOMP_ST = 0x100e,       // not referenced from symbol
		LF_OEM = 0x100f,       // oem definable type string
		LF_ALIAS_ST = 0x1010,       // alias (typedef) type
		LF_OEM2 = 0x1011,       // oem definable type string

		// leaf indices starting records but referenced only from type records

		LF_SKIP = 0x1200,
		LF_ARGLIST = 0x1201,
		LF_DEFARG_ST = 0x1202,
		LF_FIELDLIST = 0x1203,
		LF_DERIVED = 0x1204,
		LF_BITFIELD = 0x1205,
		LF_METHODLIST = 0x1206,
		LF_DIMCONU = 0x1207,
		LF_DIMCONLU = 0x1208,
		LF_DIMVARU = 0x1209,
		LF_DIMVARLU = 0x120a,

		LF_BCLASS = 0x1400,
		LF_VBCLASS = 0x1401,
		LF_IVBCLASS = 0x1402,
		LF_FRIENDFCN_ST = 0x1403,
		LF_INDEX = 0x1404,
		LF_MEMBER_ST = 0x1405,
		LF_STMEMBER_ST = 0x1406,
		LF_METHOD_ST = 0x1407,
		LF_NESTTYPE_ST = 0x1408,
		LF_VFUNCTAB = 0x1409,
		LF_FRIENDCLS = 0x140a,
		LF_ONEMETHOD_ST = 0x140b,
		LF_VFUNCOFF = 0x140c,
		LF_NESTTYPEEX_ST = 0x140d,
		LF_MEMBERMODIFY_ST = 0x140e,
		LF_MANAGED_ST = 0x140f,

		// Types w/ SZ names

		LF_ST_MAX = 0x1500,

		LF_TYPESERVER = 0x1501,       // not referenced from symbol
		LF_ENUMERATE = 0x1502,
		LF_ARRAY = 0x1503,
		LF_CLASS = 0x1504,
		LF_STRUCTURE = 0x1505,
		LF_UNION = 0x1506,
		LF_ENUM = 0x1507,
		LF_DIMARRAY = 0x1508,
		LF_PRECOMP = 0x1509,       // not referenced from symbol
		LF_ALIAS = 0x150a,       // alias (typedef) type
		LF_DEFARG = 0x150b,
		LF_FRIENDFCN = 0x150c,
		LF_MEMBER = 0x150d,
		LF_STMEMBER = 0x150e,
		LF_METHOD = 0x150f,
		LF_NESTTYPE = 0x1510,
		LF_ONEMETHOD = 0x1511,
		LF_NESTTYPEEX = 0x1512,
		LF_MEMBERMODIFY = 0x1513,
		LF_MANAGED = 0x1514,
		LF_TYPESERVER2 = 0x1515,

		LF_NUMERIC = 0x8000,
		LF_CHAR = 0x8000,
		LF_SHORT = 0x8001,
		LF_USHORT = 0x8002,
		LF_LONG = 0x8003,
		LF_ULONG = 0x8004,
		LF_REAL32 = 0x8005,
		LF_REAL64 = 0x8006,
		LF_REAL80 = 0x8007,
		LF_REAL128 = 0x8008,
		LF_QUADWORD = 0x8009,
		LF_UQUADWORD = 0x800a,
		LF_COMPLEX32 = 0x800c,
		LF_COMPLEX64 = 0x800d,
		LF_COMPLEX80 = 0x800e,
		LF_COMPLEX128 = 0x800f,
		LF_VARSTRING = 0x8010,

		LF_OCTWORD = 0x8017,
		LF_UOCTWORD = 0x8018,

		LF_DECIMAL = 0x8019,
		LF_DATE = 0x801a,
		LF_UTF8STRING = 0x801b,

		LF_PAD0 = 0xf0,
		LF_PAD1 = 0xf1,
		LF_PAD2 = 0xf2,
		LF_PAD3 = 0xf3,
		LF_PAD4 = 0xf4,
		LF_PAD5 = 0xf5,
		LF_PAD6 = 0xf6,
		LF_PAD7 = 0xf7,
		LF_PAD8 = 0xf8,
		LF_PAD9 = 0xf9,
		LF_PAD10 = 0xfa,
		LF_PAD11 = 0xfb,
		LF_PAD12 = 0xfc,
		LF_PAD13 = 0xfd,
		LF_PAD14 = 0xfe,
		LF_PAD15 = 0xff,

	};

	// end of leaf indices

	//  Type enum for pointer records
	//  Pointers can be one of the following types

	internal enum CV_ptrtype
	{
		CV_PTR_BASE_SEG = 0x03, // based on segment
		CV_PTR_BASE_VAL = 0x04, // based on value of base
		CV_PTR_BASE_SEGVAL = 0x05, // based on segment value of base
		CV_PTR_BASE_ADDR = 0x06, // based on address of base
		CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
		CV_PTR_BASE_TYPE = 0x08, // based on type
		CV_PTR_BASE_SELF = 0x09, // based on self
		CV_PTR_NEAR32 = 0x0a, // 32 bit pointer
		CV_PTR_64 = 0x0c, // 64 bit pointer
		CV_PTR_UNUSEDPTR = 0x0d  // first unused pointer type
	};

	//  Mode enum for pointers
	//  Pointers can have one of the following modes

	internal enum CV_ptrmode
	{
		CV_PTR_MODE_PTR = 0x00, // "normal" pointer
		CV_PTR_MODE_REF = 0x01, // reference
		CV_PTR_MODE_PMEM = 0x02, // pointer to data member
		CV_PTR_MODE_PMFUNC = 0x03, // pointer to member function
		CV_PTR_MODE_RESERVED = 0x04  // first unused pointer mode
	};

	//  enumeration for pointer-to-member types

	internal enum CV_pmtype
	{
		CV_PMTYPE_Undef = 0x00, // not specified (pre VC8)
		CV_PMTYPE_D_Single = 0x01, // member data, single inheritance
		CV_PMTYPE_D_Multiple = 0x02, // member data, multiple inheritance
		CV_PMTYPE_D_Virtual = 0x03, // member data, virtual inheritance
		CV_PMTYPE_D_General = 0x04, // member data, most general
		CV_PMTYPE_F_Single = 0x05, // member function, single inheritance
		CV_PMTYPE_F_Multiple = 0x06, // member function, multiple inheritance
		CV_PMTYPE_F_Virtual = 0x07, // member function, virtual inheritance
		CV_PMTYPE_F_General = 0x08, // member function, most general
	};

	//  enumeration for method properties

	internal enum CV_methodprop
	{
		CV_MTvanilla = 0x00,
		CV_MTvirtual = 0x01,
		CV_MTstatic = 0x02,
		CV_MTfriend = 0x03,
		CV_MTintro = 0x04,
		CV_MTpurevirt = 0x05,
		CV_MTpureintro = 0x06
	};

	//  enumeration for virtual shape table entries

	internal enum CV_VTS_desc
	{
		CV_VTS_near = 0x00,
		CV_VTS_far = 0x01,
		CV_VTS_thin = 0x02,
		CV_VTS_outer = 0x03,
		CV_VTS_meta = 0x04,
		CV_VTS_near32 = 0x05,
		CV_VTS_far32 = 0x06,
		CV_VTS_unused = 0x07
	};

	//  enumeration for LF_LABEL address modes

	internal enum CV_LABEL_TYPE
	{
		CV_LABEL_NEAR = 0,       // near return
		CV_LABEL_FAR = 4        // far return
	};

	//  enumeration for LF_MODIFIER values

	[Flags]
	internal enum CV_modifier : ushort
	{
		MOD_const = 0x0001,
		MOD_volatile = 0x0002,
		MOD_unaligned = 0x0004,
	};

	//  bit field structure describing class/struct/union/enum properties

	[Flags]
	internal enum CV_prop : ushort
	{
		packed = 0x0001,   // true if structure is packed
		ctor = 0x0002,   // true if constructors or destructors present
		ovlops = 0x0004,   // true if overloaded operators present
		isnested = 0x0008,   // true if this is a nested class
		cnested = 0x0010,   // true if this class contains nested types
		opassign = 0x0020,   // true if overloaded assignment (=)
		opcast = 0x0040,   // true if casting methods
		fwdref = 0x0080,   // true if forward reference (incomplete defn)
		scoped = 0x0100,   // scoped definition
	}

	//  class field attribute

	[Flags]
	internal enum CV_fldattr
	{
		access = 0x0003,   // access protection CV_access_t
		mprop = 0x001c,   // method properties CV_methodprop_t
		pseudo = 0x0020,   // compiler generated fcn and does not exist
		noinherit = 0x0040,   // true if class cannot be inherited
		noconstruct = 0x0080,   // true if class cannot be constructed
		compgenx = 0x0100,   // compiler generated fcn and does exist
	}

	//  Structures to access to the type records

	internal struct TYPTYPE
	{
		internal ushort len;
		internal ushort leaf;
		// byte data[];

		//  char *NextType (char * pType) {
		//  return (pType + ((TYPTYPE *)pType)->len + sizeof(ushort));
		//  }
	};          // general types record

	//  memory representation of pointer to member.  These representations are
	//  indexed by the enumeration above in the LF_POINTER record

	//  representation of a 32 bit pointer to data for a class with
	//  or without virtual functions and no virtual bases

	internal struct CV_PDMR32_NVVFCN
	{
		internal int mdisp;      // displacement to data (NULL = 0x80000000)
	};

	//  representation of a 32 bit pointer to data for a class
	//  with virtual bases

	internal struct CV_PDMR32_VBASE
	{
		internal int mdisp;      // displacement to data
		internal int pdisp;      // this pointer displacement
		internal int vdisp;      // vbase table displacement
								 // NULL = (,,0xffffffff)
	};

	//  representation of a 32 bit pointer to member function for a
	//  class with no virtual bases and a single address point

	internal struct CV_PMFR32_NVSA
	{
		internal uint off;        // near address of function (NULL = 0L)
	};

	//  representation of a 32 bit pointer to member function for a
	//  class with no virtual bases and multiple address points

	internal struct CV_PMFR32_NVMA
	{
		internal uint off;        // near address of function (NULL = 0L,x)
		internal int disp;
	};

	//  representation of a 32 bit pointer to member function for a
	//  class with virtual bases

	internal struct CV_PMFR32_VBASE
	{
		internal uint off;        // near address of function (NULL = 0L,x,x,x)
		internal int mdisp;      // displacement to data
		internal int pdisp;      // this pointer displacement
		internal int vdisp;      // vbase table displacement
	};

	//////////////////////////////////////////////////////////////////////////////
	//
	//  The following type records are basically variant records of the
	//  above structure.  The "ushort leaf" of the above structure and
	//  the "ushort leaf" of the following type definitions are the same
	//  symbol.
	//

	//  Notes on alignment
	//  Alignment of the fields in most of the type records is done on the
	//  basis of the TYPTYPE record base.  That is why in most of the lf*
	//  records that the type is located on what appears to
	//  be a offset mod 4 == 2 boundary.  The exception to this rule are those
	//  records that are in a list (lfFieldList, lfMethodList), which are
	//  aligned to their own bases since they don't have the length field
	//

	//  Type record for LF_MODIFIER

	internal struct LeafModifier
	{
		// internal ushort leaf;      // LF_MODIFIER [TYPTYPE]
		internal uint type;       // (type index) modified type
		internal CV_modifier attr;    // modifier attribute modifier_t
	};

	//  type record for LF_POINTER

	[Flags]
	internal enum LeafPointerAttr : uint
	{
		ptrtype = 0x0000001f,   // ordinal specifying pointer type (CV_ptrtype)
		ptrmode = 0x000000e0,   // ordinal specifying pointer mode (CV_ptrmode)
		isflat32 = 0x00000100,   // true if 0:32 pointer
		isvolatile = 0x00000200,   // TRUE if volatile pointer
		isconst = 0x00000400,   // TRUE if const pointer
		isunaligned = 0x00000800,   // TRUE if unaligned pointer
		isrestrict = 0x00001000,   // TRUE if restricted pointer (allow agressive opts)
	};

	internal struct LeafPointer
	{
		internal struct LeafPointerBody
		{
			// internal ushort leaf;  // LF_POINTER [TYPTYPE]
			internal uint utype;  // (type index) type index of the underlying type
			internal LeafPointerAttr attr;
		};
#if false
        union {
            internal struct {
                uint    pmclass;    // (type index) index of containing class for pointer to member
                ushort  pmenum;     // enumeration specifying pm format (CV_pmtype)
            };
            ushort  bseg;           // base segment if PTR_BASE_SEG
            byte[]  Sym;            // copy of base symbol record (including length)
            internal struct  {
                uint    index;      // (type index) type index if CV_PTR_BASE_TYPE
                string  name;       // name of base type
            } btype;
        } pbase;
#endif
	}

	//  type record for LF_ARRAY

	internal struct LeafArray
	{
		// internal ushort leaf;      // LF_ARRAY [TYPTYPE]
		internal uint elemtype;   // (type index) type index of element type
		internal uint idxtype;    // (type index) type index of indexing type
		internal byte[] data;       // variable length data specifying size in bytes
		internal string name;
	};

	//  type record for LF_CLASS, LF_STRUCTURE

	internal struct LeafClass
	{
		// internal ushort leaf;      // LF_CLASS, LF_STRUCT [TYPTYPE]
		internal ushort count;      // count of number of elements in class
		internal ushort property;   // (CV_prop_t) property attribute field (prop_t)
		internal uint field;      // (type index) type index of LF_FIELD descriptor list
		internal uint derived;    // (type index) type index of derived from list if not zero
		internal uint vshape;     // (type index) type index of vshape table for this class
		internal byte[] data;       // data describing length of structure in bytes
		internal string name;
	};

	//  type record for LF_UNION

	internal struct LeafUnion
	{
		// internal ushort leaf;      // LF_UNION [TYPTYPE]
		internal ushort count;      // count of number of elements in class
		internal ushort property;   // (CV_prop_t) property attribute field
		internal uint field;      // (type index) type index of LF_FIELD descriptor list
		internal byte[] data;       // variable length data describing length of
		internal string name;
	};

	//  type record for LF_ALIAS

	internal struct LeafAlias
	{
		// internal ushort leaf;      // LF_ALIAS [TYPTYPE]
		internal uint utype;      // (type index) underlying type
		internal string name;       // alias name
	};

	//  type record for LF_MANAGED

	internal struct LeafManaged
	{
		// internal ushort leaf;      // LF_MANAGED [TYPTYPE]
		internal string name;       // utf8, zero terminated managed type name
	};

	//  type record for LF_ENUM

	internal struct LeafEnum
	{
		// internal ushort leaf;      // LF_ENUM [TYPTYPE]
		internal ushort count;      // count of number of elements in class
		internal ushort property;   // (CV_propt_t) property attribute field
		internal uint utype;      // (type index) underlying type of the enum
		internal uint field;      // (type index) type index of LF_FIELD descriptor list
		internal string name;       // length prefixed name of enum
	};

	//  Type record for LF_PROCEDURE

	internal struct LeafProc
	{
		// internal ushort leaf;      // LF_PROCEDURE [TYPTYPE]
		internal uint rvtype;     // (type index) type index of return value
		internal byte calltype;   // calling convention (CV_call_t)
		internal byte reserved;   // reserved for future use
		internal ushort parmcount;  // number of parameters
		internal uint arglist;    // (type index) type index of argument list
	};

	//  Type record for member function

	internal struct LeafMFunc
	{
		// internal ushort leaf;      // LF_MFUNCTION [TYPTYPE]
		internal uint rvtype;     // (type index) type index of return value
		internal uint classtype;  // (type index) type index of containing class
		internal uint thistype;   // (type index) type index of this pointer (model specific)
		internal byte calltype;   // calling convention (call_t)
		internal byte reserved;   // reserved for future use
		internal ushort parmcount;  // number of parameters
		internal uint arglist;    // (type index) type index of argument list
		internal int thisadjust; // this adjuster (long because pad required anyway)
	};

	//  type record for virtual function table shape

	internal struct LeafVTShape
	{
		// internal ushort leaf;      // LF_VTSHAPE [TYPTYPE]
		internal ushort count;      // number of entries in vfunctable
		internal byte[] desc;       // 4 bit (CV_VTS_desc) descriptors
	};

	//  type record for cobol0

	internal struct LeafCobol0
	{
		// internal ushort leaf;      // LF_COBOL0 [TYPTYPE]
		internal uint type;       // (type index) parent type record index
		internal byte[] data;
	};

	//  type record for cobol1

	internal struct LeafCobol1
	{
		// internal ushort leaf;      // LF_COBOL1 [TYPTYPE]
		internal byte[] data;
	};

	//  type record for basic array

	internal struct LeafBArray
	{
		// internal ushort leaf;      // LF_BARRAY [TYPTYPE]
		internal uint utype;      // (type index) type index of underlying type
	};

	//  type record for assembler labels

	internal struct LeafLabel
	{
		// internal ushort leaf;      // LF_LABEL [TYPTYPE]
		internal ushort mode;       // addressing mode of label
	};

	//  type record for dimensioned arrays

	internal struct LeafDimArray
	{
		// internal ushort leaf;      // LF_DIMARRAY [TYPTYPE]
		internal uint utype;      // (type index) underlying type of the array
		internal uint diminfo;    // (type index) dimension information
		internal string name;       // length prefixed name
	};

	//  type record describing path to virtual function table

	internal struct LeafVFTPath
	{
		// internal ushort leaf;      // LF_VFTPATH [TYPTYPE]
		internal uint count;      // count of number of bases in path
		internal uint[] bases;      // (type index) bases from root to leaf
	};

	//  type record describing inclusion of precompiled types

	internal struct LeafPreComp
	{
		// internal ushort leaf;      // LF_PRECOMP [TYPTYPE]
		internal uint start;      // starting type index included
		internal uint count;      // number of types in inclusion
		internal uint signature;  // signature
		internal string name;       // length prefixed name of included type file
	};

	//  type record describing end of precompiled types that can be
	//  included by another file

	internal struct LeafEndPreComp
	{
		// internal ushort leaf;      // LF_ENDPRECOMP [TYPTYPE]
		internal uint signature;  // signature
	};

	//  type record for OEM definable type strings

	internal struct LeafOEM
	{
		// internal ushort leaf;      // LF_OEM [TYPTYPE]
		internal ushort cvOEM;      // MS assigned OEM identified
		internal ushort recOEM;     // OEM assigned type identifier
		internal uint count;      // count of type indices to follow
		internal uint[] index;      // (type index) array of type indices followed
									// by OEM defined data
	};

	internal enum OEM_ID
	{
		OEM_MS_FORTRAN90 = 0xF090,
		OEM_ODI = 0x0010,
		OEM_THOMSON_SOFTWARE = 0x5453,
		OEM_ODI_REC_BASELIST = 0x0000,
	};

	internal struct LeafOEM2
	{
		// internal ushort leaf;      // LF_OEM2 [TYPTYPE]
		internal Guid idOem;      // an oem ID (Guid)
		internal uint count;      // count of type indices to follow
		internal uint[] index;      // (type index) array of type indices followed
									// by OEM defined data
	};

	//  type record describing using of a type server

	internal struct LeafTypeServer
	{
		// internal ushort leaf;      // LF_TYPESERVER [TYPTYPE]
		internal uint signature;  // signature
		internal uint age;        // age of database used by this module
		internal string name;       // length prefixed name of PDB
	};

	//  type record describing using of a type server with v7 (GUID) signatures

	internal struct LeafTypeServer2
	{
		// internal ushort leaf;      // LF_TYPESERVER2 [TYPTYPE]
		internal Guid sig70;      // guid signature
		internal uint age;        // age of database used by this module
		internal string name;       // length prefixed name of PDB
	};

	//  description of type records that can be referenced from
	//  type records referenced by symbols

	//  type record for skip record

	internal struct LeafSkip
	{
		// internal ushort leaf;      // LF_SKIP [TYPTYPE]
		internal uint type;       // (type index) next valid index
		internal byte[] data;       // pad data
	};

	//  argument list leaf

	internal struct LeafArgList
	{
		// internal ushort leaf;      // LF_ARGLIST [TYPTYPE]
		internal uint count;      // number of arguments
		internal uint[] arg;        // (type index) number of arguments
	};

	//  derived class list leaf

	internal struct LeafDerived
	{
		// internal ushort leaf;      // LF_DERIVED [TYPTYPE]
		internal uint count;      // number of arguments
		internal uint[] drvdcls;    // (type index) type indices of derived classes
	};

	//  leaf for default arguments

	internal struct LeafDefArg
	{
		// internal ushort leaf;      // LF_DEFARG [TYPTYPE]
		internal uint type;       // (type index) type of resulting expression
		internal byte[] expr;       // length prefixed expression string
	};

	//  list leaf
	//      This list should no longer be used because the utilities cannot
	//      verify the contents of the list without knowing what type of list
	//      it is.  New specific leaf indices should be used instead.

	internal struct LeafList
	{
		// internal ushort leaf;      // LF_LIST [TYPTYPE]
		internal byte[] data;       // data format specified by indexing type
	};

	//  field list leaf
	//  This is the header leaf for a complex list of class and structure
	//  subfields.

	internal struct LeafFieldList
	{
		// internal ushort leaf;      // LF_FIELDLIST [TYPTYPE]
		internal char[] data;       // field list sub lists
	};

	//  type record for non-static methods and friends in overloaded method list

	internal struct mlMethod
	{
		internal ushort attr;       // (CV_fldattr_t) method attribute
		internal ushort pad0;       // internal padding, must be 0
		internal uint index;      // (type index) index to type record for procedure
		internal uint[] vbaseoff;   // offset in vfunctable if intro virtual
	};

	internal struct LeafMethodList
	{
		// internal ushort leaf;      // LF_METHODLIST [TYPTYPE]
		internal byte[] mList;      // really a mlMethod type
	};

	//  type record for LF_BITFIELD

	internal struct LeafBitfield
	{
		// internal ushort leaf;      // LF_BITFIELD [TYPTYPE]
		internal uint type;       // (type index) type of bitfield
		internal byte length;
		internal byte position;
	};

	//  type record for dimensioned array with constant bounds

	internal struct LeafDimCon
	{
		// internal ushort leaf;      // LF_DIMCONU or LF_DIMCONLU [TYPTYPE]
		internal uint typ;        // (type index) type of index
		internal ushort rank;       // number of dimensions
		internal byte[] dim;        // array of dimension information with
									// either upper bounds or lower/upper bound
	};

	//  type record for dimensioned array with variable bounds

	internal struct LeafDimVar
	{
		// internal ushort leaf;      // LF_DIMVARU or LF_DIMVARLU [TYPTYPE]
		internal uint rank;       // number of dimensions
		internal uint typ;        // (type index) type of index
		internal uint[] dim;        // (type index) array of type indices for either
									// variable upper bound or variable
									// lower/upper bound.  The count of type
									// indices is rank or rank*2 depending on
									// whether it is LFDIMVARU or LF_DIMVARLU.
									// The referenced types must be
									// LF_REFSYM or T_VOID
	};

	//  type record for referenced symbol

	internal struct LeafRefSym
	{
		// internal ushort leaf;      // LF_REFSYM [TYPTYPE]
		internal byte[] Sym;        // copy of referenced symbol record
									// (including length)
	};

	//  the following are numeric leaves.  They are used to indicate the
	//  size of the following variable length data.  When the numeric
	//  data is a single byte less than 0x8000, then the data is output
	//  directly.  If the data is more the 0x8000 or is a negative value,
	//  then the data is preceeded by the proper index.
	//

	//  signed character leaf

	internal struct LeafChar
	{
		// internal ushort leaf;      // LF_CHAR [TYPTYPE]
		internal sbyte val;        // signed 8-bit value
	};

	//  signed short leaf

	internal struct LeafShort
	{
		// internal ushort leaf;      // LF_SHORT [TYPTYPE]
		internal short val;        // signed 16-bit value
	};

	//  ushort leaf

	internal struct LeafUShort
	{
		// internal ushort leaf;      // LF_ushort [TYPTYPE]
		internal ushort val;        // unsigned 16-bit value
	};

	//  signed (32-bit) long leaf

	internal struct LeafLong
	{
		// internal ushort leaf;      // LF_LONG [TYPTYPE]
		internal int val;        // signed 32-bit value
	};

	//  uint    leaf

	internal struct LeafULong
	{
		// internal ushort leaf;      // LF_ULONG [TYPTYPE]
		internal uint val;        // unsigned 32-bit value
	};

	//  signed quad leaf

	internal struct LeafQuad
	{
		// internal ushort leaf;      // LF_QUAD [TYPTYPE]
		internal long val;        // signed 64-bit value
	};

	//  unsigned quad leaf

	internal struct LeafUQuad
	{
		// internal ushort leaf;      // LF_UQUAD [TYPTYPE]
		internal ulong val;        // unsigned 64-bit value
	};

	//  signed int128 leaf

	internal struct LeafOct
	{
		// internal ushort leaf;      // LF_OCT [TYPTYPE]
		internal ulong val0;
		internal ulong val1;       // signed 128-bit value
	};

	//  unsigned int128 leaf

	internal struct LeafUOct
	{
		// internal ushort leaf;      // LF_UOCT [TYPTYPE]
		internal ulong val0;
		internal ulong val1;       // unsigned 128-bit value
	};

	//  real 32-bit leaf

	internal struct LeafReal32
	{
		// internal ushort leaf;      // LF_REAL32 [TYPTYPE]
		internal float val;        // 32-bit real value
	};

	//  real 64-bit leaf

	internal struct LeafReal64
	{
		// internal ushort leaf;      // LF_REAL64 [TYPTYPE]
		internal double val;        // 64-bit real value
	};

	//  real 80-bit leaf

	internal struct LeafReal80
	{
		// internal ushort leaf;      // LF_REAL80 [TYPTYPE]
		internal FLOAT10 val;        // real 80-bit value
	};

	//  real 128-bit leaf

	internal struct LeafReal128
	{
		// internal ushort leaf;      // LF_REAL128 [TYPTYPE]
		internal ulong val0;
		internal ulong val1;       // real 128-bit value
	};

	//  complex 32-bit leaf

	internal struct LeafCmplx32
	{
		// internal ushort leaf;      // LF_COMPLEX32 [TYPTYPE]
		internal float val_real;   // real component
		internal float val_imag;   // imaginary component
	};

	//  complex 64-bit leaf

	internal struct LeafCmplx64
	{
		// internal ushort leaf;      // LF_COMPLEX64 [TYPTYPE]
		internal double val_real;   // real component
		internal double val_imag;   // imaginary component
	};

	//  complex 80-bit leaf

	internal struct LeafCmplx80
	{
		// internal ushort leaf;      // LF_COMPLEX80 [TYPTYPE]
		internal FLOAT10 val_real;   // real component
		internal FLOAT10 val_imag;   // imaginary component
	};

	//  complex 128-bit leaf

	internal struct LeafCmplx128
	{
		// internal ushort leaf;      // LF_COMPLEX128 [TYPTYPE]
		internal ulong val0_real;
		internal ulong val1_real;  // real component
		internal ulong val0_imag;
		internal ulong val1_imag;  // imaginary component
	};

	//  variable length numeric field

	internal struct LeafVarString
	{
		// internal ushort leaf;      // LF_VARSTRING [TYPTYPE]
		internal ushort len;        // length of value in bytes
		internal byte[] value;      // value
	};

	//  index leaf - contains type index of another leaf
	//  a major use of this leaf is to allow the compilers to emit a
	//  long complex list (LF_FIELD) in smaller pieces.

	internal struct LeafIndex
	{
		// internal ushort leaf;      // LF_INDEX [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0
		internal uint index;      // (type index) type index of referenced leaf
	};

	//  subfield record for base class field

	internal struct LeafBClass
	{
		// internal ushort leaf;      // LF_BCLASS [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) attribute
		internal uint index;      // (type index) type index of base class
		internal byte[] offset;     // variable length offset of base within class
	};

	//  subfield record for direct and indirect virtual base class field

	internal struct LeafVBClass
	{
		// internal ushort leaf;      // LF_VBCLASS | LV_IVBCLASS [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) attribute
		internal uint index;      // (type index) type index of direct virtual base class
		internal uint vbptr;      // (type index) type index of virtual base pointer
		internal byte[] vbpoff;     // virtual base pointer offset from address point
									// followed by virtual base offset from vbtable
	};

	//  subfield record for friend class

	internal struct LeafFriendCls
	{
		// internal ushort leaf;      // LF_FRIENDCLS [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0
		internal uint index;      // (type index) index to type record of friend class
	};

	//  subfield record for friend function

	internal struct LeafFriendFcn
	{
		// internal ushort leaf;      // LF_FRIENDFCN [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0
		internal uint index;      // (type index) index to type record of friend function
		internal string name;       // name of friend function
	};

	//  subfield record for non-static data members

	internal struct LeafMember
	{
		// internal ushort leaf;      // LF_MEMBER [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t)attribute mask
		internal uint index;      // (type index) index of type record for field
		internal byte[] offset;     // variable length offset of field
		internal string name;       // length prefixed name of field
	};

	//  type record for static data members

	internal struct LeafSTMember
	{
		// internal ushort leaf;      // LF_STMEMBER [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) attribute mask
		internal uint index;      // (type index) index of type record for field
		internal string name;       // length prefixed name of field
	};

	//  subfield record for virtual function table pointer

	internal struct LeafVFuncTab
	{
		// internal ushort leaf;      // LF_VFUNCTAB [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0
		internal uint type;       // (type index) type index of pointer
	};

	//  subfield record for virtual function table pointer with offset

	internal struct LeafVFuncOff
	{
		// internal ushort leaf;      // LF_VFUNCOFF [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0.
		internal uint type;       // (type index) type index of pointer
		internal int offset;     // offset of virtual function table pointer
	};

	//  subfield record for overloaded method list

	internal struct LeafMethod
	{
		// internal ushort leaf;      // LF_METHOD [TYPTYPE]
		internal ushort count;      // number of occurrences of function
		internal uint mList;      // (type index) index to LF_METHODLIST record
		internal string name;       // length prefixed name of method
	};

	//  subfield record for nonoverloaded method

	internal struct LeafOneMethod
	{
		// internal ushort leaf;      // LF_ONEMETHOD [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) method attribute
		internal uint index;      // (type index) index to type record for procedure
		internal uint[] vbaseoff;   // offset in vfunctable if intro virtual
		internal string name;
	};

	//  subfield record for enumerate

	internal struct LeafEnumerate
	{
		// internal ushort leaf;      // LF_ENUMERATE [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) access
		internal byte[] value;      // variable length value field
		internal string name;
	};

	//  type record for nested (scoped) type definition

	internal struct LeafNestType
	{
		// internal ushort leaf;      // LF_NESTTYPE [TYPTYPE]
		internal ushort pad0;       // internal padding, must be 0
		internal uint index;      // (type index) index of nested type definition
		internal string name;       // length prefixed type name
	};

	//  type record for nested (scoped) type definition, with attributes
	//  new records for vC v5.0, no need to have 16-bit ti versions.

	internal struct LeafNestTypeEx
	{
		// internal ushort leaf;      // LF_NESTTYPEEX [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) member access
		internal uint index;      // (type index) index of nested type definition
		internal string name;       // length prefixed type name
	};

	//  type record for modifications to members

	internal struct LeafMemberModify
	{
		// internal ushort leaf;      // LF_MEMBERMODIFY [TYPTYPE]
		internal ushort attr;       // (CV_fldattr_t) the new attributes
		internal uint index;      // (type index) index of base class type definition
		internal string name;       // length prefixed member name
	};

	//  type record for pad leaf

	internal struct LeafPad
	{
		internal byte leaf;
	};

	//  Symbol definitions

	internal enum SYM
	{
		S_END = 0x0006,  // Block, procedure, "with" or thunk end
		S_OEM = 0x0404,  // OEM defined symbol

		S_REGISTER_ST = 0x1001,  // Register variable
		S_CONSTANT_ST = 0x1002,  // constant symbol
		S_UDT_ST = 0x1003,  // User defined type
		S_COBOLUDT_ST = 0x1004,  // special UDT for cobol that does not symbol pack
		S_MANYREG_ST = 0x1005,  // multiple register variable
		S_BPREL32_ST = 0x1006,  // BP-relative
		S_LDATA32_ST = 0x1007,  // Module-local symbol
		S_GDATA32_ST = 0x1008,  // Global data symbol
		S_PUB32_ST = 0x1009,  // a internal symbol (CV internal reserved)
		S_LPROC32_ST = 0x100a,  // Local procedure start
		S_GPROC32_ST = 0x100b,  // Global procedure start
		S_VFTABLE32 = 0x100c,  // address of virtual function table
		S_REGREL32_ST = 0x100d,  // register relative address
		S_LTHREAD32_ST = 0x100e,  // local thread storage
		S_GTHREAD32_ST = 0x100f,  // global thread storage

		S_LPROCMIPS_ST = 0x1010,  // Local procedure start
		S_GPROCMIPS_ST = 0x1011,  // Global procedure start

		// new symbol records for edit and continue information

		S_FRAMEPROC = 0x1012,  // extra frame and proc information
		S_COMPILE2_ST = 0x1013,  // extended compile flags and info

		// new symbols necessary for 16-bit enumerates of IA64 registers
		// and IA64 specific symbols

		S_MANYREG2_ST = 0x1014,  // multiple register variable
		S_LPROCIA64_ST = 0x1015,  // Local procedure start (IA64)
		S_GPROCIA64_ST = 0x1016,  // Global procedure start (IA64)

		// Local symbols for IL
		S_LOCALSLOT_ST = 0x1017,  // local IL sym with field for local slot index
		S_PARAMSLOT_ST = 0x1018,  // local IL sym with field for parameter slot index

		S_ANNOTATION = 0x1019,  // Annotation string literals

		// symbols to support managed code debugging
		S_GMANPROC_ST = 0x101a,  // Global proc
		S_LMANPROC_ST = 0x101b,  // Local proc
		S_RESERVED1 = 0x101c,  // reserved
		S_RESERVED2 = 0x101d,  // reserved
		S_RESERVED3 = 0x101e,  // reserved
		S_RESERVED4 = 0x101f,  // reserved
		S_LMANDATA_ST = 0x1020,
		S_GMANDATA_ST = 0x1021,
		S_MANFRAMEREL_ST = 0x1022,
		S_MANREGISTER_ST = 0x1023,
		S_MANSLOT_ST = 0x1024,
		S_MANMANYREG_ST = 0x1025,
		S_MANREGREL_ST = 0x1026,
		S_MANMANYREG2_ST = 0x1027,
		S_MANTYPREF = 0x1028,  // Index for type referenced by name from metadata
		S_UNAMESPACE_ST = 0x1029,  // Using namespace

		// Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
		S_ST_MAX = 0x1100,  // starting point for SZ name symbols

		S_OBJNAME = 0x1101,  // path to object file name
		S_THUNK32 = 0x1102,  // Thunk Start
		S_BLOCK32 = 0x1103,  // block start
		S_WITH32 = 0x1104,  // with start
		S_LABEL32 = 0x1105,  // code label
		S_REGISTER = 0x1106,  // Register variable
		S_CONSTANT = 0x1107,  // constant symbol
		S_UDT = 0x1108,  // User defined type
		S_COBOLUDT = 0x1109,  // special UDT for cobol that does not symbol pack
		S_MANYREG = 0x110a,  // multiple register variable
		S_BPREL32 = 0x110b,  // BP-relative
		S_LDATA32 = 0x110c,  // Module-local symbol
		S_GDATA32 = 0x110d,  // Global data symbol
		S_PUB32 = 0x110e,  // a internal symbol (CV internal reserved)
		S_LPROC32 = 0x110f,  // Local procedure start
		S_GPROC32 = 0x1110,  // Global procedure start
		S_REGREL32 = 0x1111,  // register relative address
		S_LTHREAD32 = 0x1112,  // local thread storage
		S_GTHREAD32 = 0x1113,  // global thread storage

		S_LPROCMIPS = 0x1114,  // Local procedure start
		S_GPROCMIPS = 0x1115,  // Global procedure start
		S_COMPILE2 = 0x1116,  // extended compile flags and info
		S_MANYREG2 = 0x1117,  // multiple register variable
		S_LPROCIA64 = 0x1118,  // Local procedure start (IA64)
		S_GPROCIA64 = 0x1119,  // Global procedure start (IA64)
		S_LOCALSLOT = 0x111a,  // local IL sym with field for local slot index
		S_SLOT = S_LOCALSLOT,  // alias for LOCALSLOT
		S_PARAMSLOT = 0x111b,  // local IL sym with field for parameter slot index

		// symbols to support managed code debugging
		S_LMANDATA = 0x111c,
		S_GMANDATA = 0x111d,
		S_MANFRAMEREL = 0x111e,
		S_MANREGISTER = 0x111f,
		S_MANSLOT = 0x1120,
		S_MANMANYREG = 0x1121,
		S_MANREGREL = 0x1122,
		S_MANMANYREG2 = 0x1123,
		S_UNAMESPACE = 0x1124,  // Using namespace

		// ref symbols with name fields
		S_PROCREF = 0x1125,  // Reference to a procedure
		S_DATAREF = 0x1126,  // Reference to data
		S_LPROCREF = 0x1127,  // Local Reference to a procedure
		S_ANNOTATIONREF = 0x1128,  // Reference to an S_ANNOTATION symbol
		S_TOKENREF = 0x1129,  // Reference to one of the many MANPROCSYM's

		// continuation of managed symbols
		S_GMANPROC = 0x112a,  // Global proc
		S_LMANPROC = 0x112b,  // Local proc

		// short, light-weight thunks
		S_TRAMPOLINE = 0x112c,  // trampoline thunks
		S_MANCONSTANT = 0x112d,  // constants with metadata type info

		// native attributed local/parms
		S_ATTR_FRAMEREL = 0x112e,  // relative to virtual frame ptr
		S_ATTR_REGISTER = 0x112f,  // stored in a register
		S_ATTR_REGREL = 0x1130,  // relative to register (alternate frame ptr)
		S_ATTR_MANYREG = 0x1131,  // stored in >1 register

		// Separated code (from the compiler) support
		S_SEPCODE = 0x1132,

		S_LOCAL = 0x1133,  // defines a local symbol in optimized code
		S_DEFRANGE = 0x1134,  // defines a single range of addresses in which symbol can be evaluated
		S_DEFRANGE2 = 0x1135,  // defines ranges of addresses in which symbol can be evaluated

		S_SECTION = 0x1136,  // A COFF section in a PE executable
		S_COFFGROUP = 0x1137,  // A COFF group
		S_EXPORT = 0x1138,  // A export

		S_CALLSITEINFO = 0x1139,  // Indirect call site information
		S_FRAMECOOKIE = 0x113a,  // Security cookie information

		S_DISCARDED = 0x113b,  // Discarded by LINK /OPT:REF (experimental, see richards)

		S_RECTYPE_MAX,              // one greater than last
		S_RECTYPE_LAST = S_RECTYPE_MAX - 1,

	};

	//  enum describing compile flag ambient data model

	internal enum CV_CFL_DATA
	{
		CV_CFL_DNEAR = 0x00,
		CV_CFL_DFAR = 0x01,
		CV_CFL_DHUGE = 0x02
	};

	//  enum describing compile flag ambiant code model

	internal enum CV_CFL_CODE
	{
		CV_CFL_CNEAR = 0x00,
		CV_CFL_CFAR = 0x01,
		CV_CFL_CHUGE = 0x02
	};

	//  enum describing compile flag target floating point package

	internal enum CV_CFL_FPKG
	{
		CV_CFL_NDP = 0x00,
		CV_CFL_EMU = 0x01,
		CV_CFL_ALT = 0x02
	};

	// enum describing function return method

	[Flags]
	internal enum CV_PROCFLAGS : byte
	{
		CV_PFLAG_NOFPO = 0x01, // frame pointer present
		CV_PFLAG_INT = 0x02, // interrupt return
		CV_PFLAG_FAR = 0x04, // far return
		CV_PFLAG_NEVER = 0x08, // function does not return
		CV_PFLAG_NOTREACHED = 0x10, // label isn't fallen into
		CV_PFLAG_CUST_CALL = 0x20, // custom calling convention
		CV_PFLAG_NOINLINE = 0x40, // function marked as noinline
		CV_PFLAG_OPTDBGINFO = 0x80, // function has debug information for optimized code
	};

	// Extended proc flags
	//
	internal struct CV_EXPROCFLAGS
	{
		internal byte flags;      // (CV_PROCFLAGS)
		internal byte reserved;   // must be zero
	};

	// local variable flags
	[Flags]
	internal enum CV_LVARFLAGS : ushort
	{
		fIsParam = 0x0001,   // variable is a parameter
		fAddrTaken = 0x0002,   // address is taken
		fCompGenx = 0x0004,   // variable is compiler generated
		fIsAggregate = 0x0008,   // the symbol is splitted in temporaries,
								 // which are treated by compiler as
								 // independent entities
		fIsAggregated = 0x0010,   // Counterpart of fIsAggregate - tells
								  // that it is a part of a fIsAggregate symbol
		fIsAliased = 0x0020,   // variable has multiple simultaneous lifetimes
		fIsAlias = 0x0040,   // represents one of the multiple simultaneous lifetimes
	};

	// represents an address range, used for optimized code debug info
	internal struct CV_lvar_addr_range
	{       // defines a range of addresses
		internal uint offStart;
		internal ushort isectStart;
		internal uint cbRange;
	};

	// enum describing function data return method

	internal enum CV_GENERIC_STYLE
	{
		CV_GENERIC_VOID = 0x00,   // void return type
		CV_GENERIC_REG = 0x01,   // return data is in registers
		CV_GENERIC_ICAN = 0x02,   // indirect caller allocated near
		CV_GENERIC_ICAF = 0x03,   // indirect caller allocated far
		CV_GENERIC_IRAN = 0x04,   // indirect returnee allocated near
		CV_GENERIC_IRAF = 0x05,   // indirect returnee allocated far
		CV_GENERIC_UNUSED = 0x06    // first unused
	};

	[Flags]
	internal enum CV_GENERIC_FLAG : ushort
	{
		cstyle = 0x0001,       // true push varargs right to left
		rsclean = 0x0002,       // true if returnee stack cleanup
	};

	// flag bitfields for separated code attributes

	[Flags]
	internal enum CV_SEPCODEFLAGS : uint
	{
		fIsLexicalScope = 0x00000001,   // S_SEPCODE doubles as lexical scope
		fReturnsToParent = 0x00000002,   // code frag returns to parent
	};

	// Generic layout for symbol records

	internal struct SYMTYPE
	{
		internal ushort reclen;     // Record length
		internal ushort rectyp;     // Record type
									// byte        data[CV_ZEROLEN];
									//  SYMTYPE *NextSym (SYMTYPE * pSym) {
									//  return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(ushort));
									//  }
	};

	//  non-model specific symbol types

	internal struct RegSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_REGISTER
		internal uint typind;     // (type index) Type index or Metadata token
		internal ushort reg;        // register enumerate
		internal string name;       // Length-prefixed name
	};

	internal struct AttrRegSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANREGISTER | S_ATTR_REGISTER
		internal uint typind;     // (type index) Type index or Metadata token
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal ushort reg;        // register enumerate
		internal string name;       // Length-prefixed name
	};

	internal struct ManyRegSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANYREG
		internal uint typind;     // (type index) Type index or metadata token
		internal byte count;      // count of number of registers
		internal byte[] reg;        // count register enumerates, most-sig first
		internal string name;       // length-prefixed name.
	};

	internal struct ManyRegSym2
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANYREG2
		internal uint typind;     // (type index) Type index or metadata token
		internal ushort count;      // count of number of registers,
		internal ushort[] reg;        // count register enumerates, most-sig first
		internal string name;       // length-prefixed name.
	};

	internal struct AttrManyRegSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANMANYREG
		internal uint typind;     // (type index) Type index or metadata token
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal byte count;      // count of number of registers
		internal byte[] reg;        // count register enumerates, most-sig first
		internal string name;       // utf-8 encoded zero terminate name
	};

	internal struct AttrManyRegSym2
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANMANYREG2 | S_ATTR_MANYREG
		internal uint typind;     // (type index) Type index or metadata token
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal ushort count;      // count of number of registers
		internal ushort[] reg;        // count register enumerates, most-sig first
		internal string name;       // utf-8 encoded zero terminate name
	};

	internal struct ConstSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_CONSTANT or S_MANCONSTANT
		internal uint typind;     // (type index) Type index (containing enum if enumerate) or metadata token
		internal ushort value;      // numeric leaf containing value
		internal string name;       // Length-prefixed name
	};

	internal struct UdtSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_UDT | S_COBOLUDT
		internal uint typind;     // (type index) Type index
		internal string name;       // Length-prefixed name
	};

	internal struct ManyTypRef
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANTYPREF
		internal uint typind;     // (type index) Type index
	};

	internal struct SearchSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_SSEARCH
		internal uint startsym;   // offset of the procedure
		internal ushort seg;        // segment of symbol
	};

	[Flags]
	internal enum CFLAGSYM_FLAGS : ushort
	{
		pcode = 0x0001,   // true if pcode present
		floatprec = 0x0006,   // floating precision
		floatpkg = 0x0018,   // float package
		ambdata = 0x00e0,   // ambient data model
		ambcode = 0x0700,   // ambient code model
		mode32 = 0x0800,   // true if compiled 32 bit mode
	};

	internal struct CFlagSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_COMPILE
		internal byte machine;    // target processor
		internal byte language;   // language index
		internal ushort flags;      // (CFLAGSYM_FLAGS)
		internal string ver;        // Length-prefixed compiler version string
	};

	[Flags]
	internal enum COMPILESYM_FLAGS : uint
	{
		iLanguage = 0x000000ff,   // language index
		fEC = 0x00000100,   // compiled for E/C
		fNoDbgInfo = 0x00000200,   // not compiled with debug info
		fLTCG = 0x00000400,   // compiled with LTCG
		fNoDataAlign = 0x00000800,   // compiled with -Bzalign
		fManagedPresent = 0x00001000,   // managed code/data present
		fSecurityChecks = 0x00002000,   // compiled with /GS
		fHotPatch = 0x00004000,   // compiled with /hotpatch
		fCVTCIL = 0x00008000,   // converted with CVTCIL
		fMSILModule = 0x00010000,   // MSIL netmodule
	};

	internal struct CompileSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_COMPILE2
		internal uint flags;      // (COMPILESYM_FLAGS)
		internal ushort machine;    // target processor
		internal ushort verFEMajor; // front end major version #
		internal ushort verFEMinor; // front end minor version #
		internal ushort verFEBuild; // front end build version #
		internal ushort verMajor;   // back end major version #
		internal ushort verMinor;   // back end minor version #
		internal ushort verBuild;   // back end build version #
		internal string verSt;      // Length-prefixed compiler version string, followed
		internal string[] verArgs;    // block of zero terminated strings, ended by double-zero.
	};

	internal struct ObjNameSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_OBJNAME
		internal uint signature;  // signature
		internal string name;       // Length-prefixed name
	};

	internal struct EndArgSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_ENDARG
	};

	internal struct ReturnSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_RETURN
		internal CV_GENERIC_FLAG flags; // flags
		internal byte style;      // CV_GENERIC_STYLE return style
								  // followed by return method data
	};

	internal struct EntryThisSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_ENTRYTHIS
		internal byte thissym;    // symbol describing this pointer on entry
	};

	internal struct BpRelSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_BPREL32
		internal int off;        // BP-relative offset
		internal uint typind;     // (type index) Type index or Metadata token
		internal string name;       // Length-prefixed name
	};

	internal struct FrameRelSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANFRAMEREL | S_ATTR_FRAMEREL
		internal int off;        // Frame relative offset
		internal uint typind;     // (type index) Type index or Metadata token
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal string name;       // Length-prefixed name
	};

	internal struct SlotSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_LOCALSLOT or S_PARAMSLOT
		internal uint index;      // slot index
		internal uint typind;     // (type index) Type index or Metadata token
		internal string name;       // Length-prefixed name
	};

	internal struct AttrSlotSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANSLOT
		internal uint index;      // slot index
		internal uint typind;     // (type index) Type index or Metadata token
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal string name;       // Length-prefixed name

	};

	internal struct AnnotationSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_ANNOTATION
		internal uint off;
		internal ushort seg;
		internal ushort csz;        // Count of zero terminated annotation strings
		internal string[] rgsz;       // Sequence of zero terminated annotation strings
	};

	internal struct DatasSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_LDATA32, S_GDATA32 or S_PUB32, S_LMANDATA, S_GMANDATA
		internal uint typind;     // (type index) Type index, or Metadata token if a managed symbol
		internal uint off;
		internal ushort seg;
		internal string name;       // Length-prefixed name
	};

	[Flags]
	internal enum CV_PUBSYMFLAGS : uint
	{
		fNone = 0,
		fCode = 0x00000001,     // set if internal symbol refers to a code address
		fFunction = 0x00000002,     // set if internal symbol is a function
		fManaged = 0x00000004,     // set if managed code (native or IL)
		fMSIL = 0x00000008,     // set if managed IL code
	};

	internal struct PubSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_PUB32
		internal uint flags;      // (CV_PUBSYMFLAGS)
		internal uint off;
		internal ushort seg;
		internal string name;       // Length-prefixed name
	};

	internal struct ProcSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_GPROC32 or S_LPROC32
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint len;        // Proc length
		internal uint dbgStart;   // Debug start offset
		internal uint dbgEnd;     // Debug end offset
		internal uint typind;     // (type index) Type index
		internal uint off;
		internal ushort seg;
		internal byte flags;      // (CV_PROCFLAGS) Proc flags
		internal string name;       // Length-prefixed name
	};

	internal struct ManProcSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_GMANPROC, S_LMANPROC, S_GMANPROCIA64 or S_LMANPROCIA64
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint len;        // Proc length
		internal uint dbgStart;   // Debug start offset
		internal uint dbgEnd;     // Debug end offset
		internal uint token;      // COM+ metadata token for method
		internal uint off;
		internal ushort seg;
		internal byte flags;      // (CV_PROCFLAGS) Proc flags
		internal ushort retReg;     // Register return value is in (may not be used for all archs)
		internal string name;       // optional name field
	};

	internal struct ManProcSymMips
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_GMANPROCMIPS or S_LMANPROCMIPS
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint len;        // Proc length
		internal uint dbgStart;   // Debug start offset
		internal uint dbgEnd;     // Debug end offset
		internal uint regSave;    // int register save mask
		internal uint fpSave;     // fp register save mask
		internal uint intOff;     // int register save offset
		internal uint fpOff;      // fp register save offset
		internal uint token;      // COM+ token type
		internal uint off;
		internal ushort seg;
		internal byte retReg;     // Register return value is in
		internal byte frameReg;   // Frame pointer register
		internal string name;       // optional name field
	};

	internal struct ThunkSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_THUNK32
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint off;
		internal ushort seg;
		internal ushort len;        // length of thunk
		internal byte ord;        // THUNK_ORDINAL specifying type of thunk
		internal string name;       // Length-prefixed name
		internal byte[] variant;    // variant portion of thunk
	};

	internal enum TRAMP
	{             // Trampoline subtype
		trampIncremental,           // incremental thunks
		trampBranchIsland,          // Branch island thunks
	};

	internal struct TrampolineSym
	{   // Trampoline thunk symbol
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_TRAMPOLINE
		internal ushort trampType;  // trampoline sym subtype
		internal ushort cbThunk;    // size of the thunk
		internal uint offThunk;   // offset of the thunk
		internal uint offTarget;  // offset of the target of the thunk
		internal ushort sectThunk;  // section index of the thunk
		internal ushort sectTarget; // section index of the target of the thunk
	};

	internal struct LabelSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_LABEL32
		internal uint off;
		internal ushort seg;
		internal byte flags;      // (CV_PROCFLAGS) flags
		internal string name;       // Length-prefixed name
	};

	internal struct BlockSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_BLOCK32
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint len;        // Block length
		internal uint off;        // Offset in code segment
		internal ushort seg;        // segment of label
		internal string name;       // Length-prefixed name
	};

	internal struct WithSym32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_WITH32
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint len;        // Block length
		internal uint off;        // Offset in code segment
		internal ushort seg;        // segment of label
		internal string expr;       // Length-prefixed expression string
	};

	internal struct VpathSym32
	{
		// internal ushort reclen;    // record length
		// internal ushort rectyp;    // S_VFTABLE32
		internal uint root;       // (type index) type index of the root of path
		internal uint path;       // (type index) type index of the path record
		internal uint off;        // offset of virtual function table
		internal ushort seg;        // segment of virtual function table
	};

	internal struct RegRel32
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_REGREL32
		internal uint off;        // offset of symbol
		internal uint typind;     // (type index) Type index or metadata token
		internal ushort reg;        // register index for symbol
		internal string name;       // Length-prefixed name
	};

	internal struct AttrRegRel
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_MANREGREL | S_ATTR_REGREL
		internal uint off;        // offset of symbol
		internal uint typind;     // (type index) Type index or metadata token
		internal ushort reg;        // register index for symbol
		internal uint offCod;     // first code address where var is live
		internal ushort segCod;
		internal ushort flags;      // (CV_LVARFLAGS)local var flags
		internal string name;       // Length-prefixed name
	};

	internal struct ThreadSym32
	{
		// internal ushort reclen;    // record length
		// internal ushort rectyp;    // S_LTHREAD32 | S_GTHREAD32
		internal uint typind;     // (type index) type index
		internal uint off;        // offset into thread storage
		internal ushort seg;        // segment of thread storage
		internal string name;       // length prefixed name
	};

	internal struct Slink32
	{
		// internal ushort reclen;    // record length
		// internal ushort rectyp;    // S_SLINK32
		internal uint framesize;  // frame size of parent procedure
		internal int off;        // signed offset where the static link was saved relative to the value of reg
		internal ushort reg;
	};

	internal struct ProcSymMips
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_GPROCMIPS or S_LPROCMIPS
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint len;        // Proc length
		internal uint dbgStart;   // Debug start offset
		internal uint dbgEnd;     // Debug end offset
		internal uint regSave;    // int register save mask
		internal uint fpSave;     // fp register save mask
		internal uint intOff;     // int register save offset
		internal uint fpOff;      // fp register save offset
		internal uint typind;     // (type index) Type index
		internal uint off;        // Symbol offset
		internal ushort seg;        // Symbol segment
		internal byte retReg;     // Register return value is in
		internal byte frameReg;   // Frame pointer register
		internal string name;       // Length-prefixed name
	};

	internal struct ProcSymIa64
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_GPROCIA64 or S_LPROCIA64
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this blocks end
		internal uint next;       // pointer to next symbol
		internal uint len;        // Proc length
		internal uint dbgStart;   // Debug start offset
		internal uint dbgEnd;     // Debug end offset
		internal uint typind;     // (type index) Type index
		internal uint off;        // Symbol offset
		internal ushort seg;        // Symbol segment
		internal ushort retReg;     // Register return value is in
		internal byte flags;      // (CV_PROCFLAGS) Proc flags
		internal string name;       // Length-prefixed name
	};

	internal struct RefSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_PROCREF_ST, S_DATAREF_ST, or S_LPROCREF_ST
		internal uint sumName;    // SUC of the name
		internal uint ibSym;      // Offset of actual symbol in $$Symbols
		internal ushort imod;       // Module containing the actual symbol
		internal ushort usFill;     // align this record
	};

	internal struct RefSym2
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_PROCREF, S_DATAREF, or S_LPROCREF
		internal uint sumName;    // SUC of the name
		internal uint ibSym;      // Offset of actual symbol in $$Symbols
		internal ushort imod;       // Module containing the actual symbol
		internal string name;       // hidden name made a first class member
	};

	internal struct AlignSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_ALIGN
	};

	internal struct OemSymbol
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_OEM
		internal Guid idOem;      // an oem ID (GUID)
		internal uint typind;     // (type index) Type index
		internal byte[] rgl;        // user data, force 4-byte alignment
	};

	[Flags]
	internal enum FRAMEPROCSYM_FLAGS : uint
	{
		fHasAlloca = 0x00000001,   // function uses _alloca()
		fHasSetJmp = 0x00000002,   // function uses setjmp()
		fHasLongJmp = 0x00000004,   // function uses longjmp()
		fHasInlAsm = 0x00000008,   // function uses inline asm
		fHasEH = 0x00000010,   // function has EH states
		fInlSpec = 0x00000020,   // function was speced as inline
		fHasSEH = 0x00000040,   // function has SEH
		fNaked = 0x00000080,   // function is __declspec(naked)
		fSecurityChecks = 0x00000100,   // function has buffer security check introduced by /GS.
		fAsyncEH = 0x00000200,   // function compiled with /EHa
		fGSNoStackOrdering = 0x00000400,   // function has /GS buffer checks, but stack ordering couldn't be done
		fWasInlined = 0x00000800,   // function was inlined within another function
	};

	internal struct FrameProcSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_FRAMEPROC
		internal uint cbFrame;    // count of bytes of total frame of procedure
		internal uint cbPad;      // count of bytes of padding in the frame
		internal uint offPad;     // offset (rel to frame) to where padding starts
		internal uint cbSaveRegs; // count of bytes of callee save registers
		internal uint offExHdlr;  // offset of exception handler
		internal ushort secExHdlr;  // section id of exception handler
		internal uint flags;      // (FRAMEPROCSYM_FLAGS)
	}

	internal struct UnamespaceSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_UNAMESPACE
		internal string name;       // name
	};

	internal struct SepCodSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_SEPCODE
		internal uint parent;     // pointer to the parent
		internal uint end;        // pointer to this block's end
		internal uint length;     // count of bytes of this block
		internal uint scf;        // (CV_SEPCODEFLAGS) flags
		internal uint off;        // sec:off of the separated code
		internal uint offParent;  // secParent:offParent of the enclosing scope
		internal ushort sec;        //  (proc, block, or sepcode)
		internal ushort secParent;
	};

	internal struct LocalSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_LOCAL
		internal uint id;         // id of the local
		internal uint typind;     // (type index) type index
		internal ushort flags;      // (CV_LVARFLAGS) local var flags
		internal uint idParent;   // This is is parent variable - fIsAggregated or fIsAlias
		internal uint offParent;  // Offset in parent variable - fIsAggregated

		internal uint expr;       // NI of expression that this temp holds
		internal uint pad0;       // pad, must be zero
		internal uint pad1;       // pad, must be zero

		internal string name;       // Name of this symbol.
	}

	internal struct DefRangeSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_DEFRANGE

		internal uint id;         // ID of the local symbol for which this formula holds
		internal uint program;    // program to evaluate the value of the symbol

		internal CV_lvar_addr_range range;   // Range of addresses where this program is valid
	};

	internal struct DefRangeSym2
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_DEFRANGE2

		internal uint id;         // ID of the local symbol for which this formula holds
		internal uint program;    // program to evaluate the value of the symbol

		internal ushort count;      // count of CV_lvar_addr_range records following
		internal CV_lvar_addr_range[] range;// Range of addresses where this program is valid
	};

	internal struct SectionSym
	{
		// internal ushort reclen     // Record length
		// internal ushort rectyp;    // S_SECTION

		internal ushort isec;       // Section number
		internal byte align;      // Alignment of this section (power of 2)
		internal byte bReserved;  // Reserved.  Must be zero.
		internal uint rva;
		internal uint cb;
		internal uint characteristics;
		internal string name;       // name
	};

	internal struct CoffGroupSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_COFFGROUP

		internal uint cb;
		internal uint characteristics;
		internal uint off;        // Symbol offset
		internal ushort seg;        // Symbol segment
		internal string name;       // name
	};

	[Flags]
	internal enum EXPORTSYM_FLAGS : ushort
	{
		fConstant = 0x0001,   // CONSTANT
		fData = 0x0002,   // DATA
		fPrivate = 0x0004,   // PRIVATE
		fNoName = 0x0008,   // NONAME
		fOrdinal = 0x0010,   // Ordinal was explicitly assigned
		fForwarder = 0x0020,   // This is a forwarder
	}

	internal struct ExportSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_EXPORT

		internal ushort ordinal;
		internal ushort flags;      // (EXPORTSYM_FLAGS)
		internal string name;       // name of
	};

	//
	// Symbol for describing indirect calls when they are using
	// a function pointer cast on some other type or temporary.
	// Typical content will be an LF_POINTER to an LF_PROCEDURE
	// type record that should mimic an actual variable with the
	// function pointer type in question.
	//
	// Since the compiler can sometimes tail-merge a function call
	// through a function pointer, there may be more than one
	// S_CALLSITEINFO record at an address.  This is similar to what
	// you could do in your own code by:
	//
	//  if (expr)
	//  pfn = &function1;
	//  else
	//  pfn = &function2;
	//
	//  (*pfn)(arg list);
	//

	internal struct CallsiteInfo
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_CALLSITEINFO
		internal int off;        // offset of call site
		internal ushort ect;        // section index of call site
		internal ushort pad0;       // alignment padding field, must be zero
		internal uint typind;     // (type index) type index describing function signature
	};

	// Frame cookie information

	internal enum CV_cookietype
	{
		CV_COOKIETYPE_COPY = 0,
		CV_COOKIETYPE_XOR_SP,
		CV_COOKIETYPE_XOR_BP,
		CV_COOKIETYPE_XOR_R13,
	};

	// Symbol for describing security cookie's position and type
	// (raw, xor'd with esp, xor'd with ebp).

	internal struct FrameCookie
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_FRAMECOOKIE
		internal int off;        // Frame relative offset
		internal ushort reg;        // Register index
		internal int cookietype; // (CV_cookietype) Type of the cookie
		internal byte flags;      // Flags describing this cookie
	};

	internal enum CV_DISCARDED : uint
	{
		CV_DISCARDED_UNKNOWN = 0,
		CV_DISCARDED_NOT_SELECTED = 1,
		CV_DISCARDED_NOT_REFERENCED = 2,
	};

	internal struct DiscardedSym
	{
		// internal ushort reclen;    // Record length [SYMTYPE]
		// internal ushort rectyp;    // S_DISCARDED
		internal CV_DISCARDED iscarded;
		internal uint fileid;     // First FILEID if line number info present
		internal uint linenum;    // First line number
		internal byte[] data;       // Original record(s) with invalid indices
	};

	//
	// V7 line number data types
	//

	internal enum DEBUG_S_SUBSECTION_TYPE : uint
	{
		DEBUG_S_IGNORE = 0x80000000,   // if this bit is set in a subsection type then ignore the subsection contents

		DEBUG_S_SYMBOLS = 0xf1,
		DEBUG_S_LINES = 0xf2,
		DEBUG_S_STRINGTABLE = 0xf3,
		DEBUG_S_FILECHKSMS = 0xf4,
		DEBUG_S_FRAMEDATA = 0xf5,
	};

	//
	// Line flags (data present)
	//
	internal enum CV_LINE_SUBSECTION_FLAGS : ushort
	{
		CV_LINES_HAVE_COLUMNS = 0x0001,
	}

	internal struct CV_LineSection
	{
		internal uint off;
		internal ushort sec;
		internal ushort flags;
		internal uint cod;
	}

	internal struct CV_SourceFile
	{
		internal uint index;          // Index to file in checksum section.
		internal uint count;          // Number of CV_Line records.
		internal uint linsiz;         // Size of CV_Line recods.
	}

	[Flags]
	internal enum CV_Line_Flags : uint
	{
		linenumStart = 0x00ffffff,   // line where statement/expression starts
		deltaLineEnd = 0x7f000000,   // delta to line where statement ends (optional)
		fStatement = 0x80000000,   // true if a statement linenumber, else an expression line num
	};

	internal struct CV_Line
	{
		internal uint offset;         // Offset to start of code bytes for line number
		internal uint flags;          // (CV_Line_Flags)
	};

	internal struct CV_Column
	{
		internal ushort offColumnStart;
		internal ushort offColumnEnd;
	};

	//  File information

	internal enum CV_FILE_CHECKSUM_TYPE : byte
	{
		None = 0,
		MD5 = 1,
	};

	internal struct CV_FileCheckSum
	{
		internal uint name;           // Index of name in name table.
		internal byte len;            // Hash length
		internal byte type;           // Hash type
	}

	[Flags]
	internal enum FRAMEDATA_FLAGS : uint
	{
		fHasSEH = 0x00000001,
		fHasEH = 0x00000002,
		fIsFunctionStart = 0x00000004,
	};

	internal struct FrameData
	{
		internal uint ulRvaStart;
		internal uint cbBlock;
		internal uint cbLocals;
		internal uint cbParams;
		internal uint cbStkMax;
		internal uint frameFunc;
		internal ushort cbProlog;
		internal ushort cbSavedRegs;
		internal uint flags;          // (FRAMEDATA_FLAGS)
	};

	internal struct XFixupData
	{
		internal ushort wType;
		internal ushort wExtra;
		internal uint rva;
		internal uint rvaTarget;
	};

	internal enum DEBUG_S_SUBSECTION
	{
		SYMBOLS = 0xF1,
		LINES = 0xF2,
		STRINGTABLE = 0xF3,
		FILECHKSMS = 0xF4,
		FRAMEDATA = 0xF5,
	}
}//
 // Author:
 //   Jb Evain (jbevain@gmail.com)
 //
 // Copyright (c) 2008 - 2015 Jb Evain
 // Copyright (c) 2008 - 2011 Novell, Inc.
 //
 // Licensed under the MIT/X11 license.
 //





namespace Mono.Cecil.PE
{

	struct DataDirectory
	{

		public readonly RVA VirtualAddress;
		public readonly uint Size;

		public bool IsZero
		{
			get { return VirtualAddress == 0 && Size == 0; }
		}

		public DataDirectory(RVA rva, uint size)
		{
			this.VirtualAddress = rva;
			this.Size = size;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	internal class DataStream
	{
		internal DataStream()
		{
		}

		internal DataStream(int contentSize, BitAccess bits, int count)
		{
			this.contentSize = contentSize;
			if (count > 0)
			{
				this.pages = new int[count];
				bits.ReadInt32(this.pages);
			}
		}

		internal void Read(PdbReader reader, BitAccess bits)
		{
			bits.MinCapacity(contentSize);
			Read(reader, 0, bits.Buffer, 0, contentSize);
		}

		internal void Read(PdbReader reader, int position,
						 byte[] bytes, int offset, int data)
		{
			if (position + data > contentSize)
			{
				throw new PdbException("DataStream can't read off end of stream. " +
											   "(pos={0},siz={1})",
									   position, data);
			}
			if (position == contentSize)
			{
				return;
			}

			int left = data;
			int page = position / reader.pageSize;
			int rema = position % reader.pageSize;

			// First get remained of first page.
			if (rema != 0)
			{
				int todo = reader.pageSize - rema;
				if (todo > left)
				{
					todo = left;
				}

				reader.Seek(pages[page], rema);
				reader.Read(bytes, offset, todo);

				offset += todo;
				left -= todo;
				page++;
			}

			// Now get the remaining pages.
			while (left > 0)
			{
				int todo = reader.pageSize;
				if (todo > left)
				{
					todo = left;
				}

				reader.Seek(pages[page], 0);
				reader.Read(bytes, offset, todo);

				offset += todo;
				left -= todo;
				page++;
			}
		}

		//private void AddPages(int page0, int count) {
		//  if (pages == null) {
		//    pages = new int[count];
		//    for (int i = 0; i < count; i++) {
		//      pages[i] = page0 + i;
		//    }
		//  } else {
		//    int[] old = pages;
		//    int used = old.Length;

		//    pages = new int[used + count];
		//    Array.Copy(old, pages, used);
		//    for (int i = 0; i < count; i++) {
		//      pages[used + i] = page0 + i;
		//    }
		//  }
		//}

		//internal int Pages {
		//  get { return pages == null ? 0 : pages.Length; }
		//}

		internal int Length
		{
			get { return contentSize; }
		}

		//internal int GetPage(int index) {
		//  return pages[index];
		//}

		internal int contentSize;
		internal int[] pages;
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct DbiDbgHdr
	{
		internal DbiDbgHdr(BitAccess bits)
		{
			bits.ReadUInt16(out snFPO);
			bits.ReadUInt16(out snException);
			bits.ReadUInt16(out snFixup);
			bits.ReadUInt16(out snOmapToSrc);
			bits.ReadUInt16(out snOmapFromSrc);
			bits.ReadUInt16(out snSectionHdr);
			bits.ReadUInt16(out snTokenRidMap);
			bits.ReadUInt16(out snXdata);
			bits.ReadUInt16(out snPdata);
			bits.ReadUInt16(out snNewFPO);
			bits.ReadUInt16(out snSectionHdrOrig);
		}

		internal ushort snFPO;                 // 0..1
		internal ushort snException;           // 2..3 (deprecated)
		internal ushort snFixup;               // 4..5
		internal ushort snOmapToSrc;           // 6..7
		internal ushort snOmapFromSrc;         // 8..9
		internal ushort snSectionHdr;          // 10..11
		internal ushort snTokenRidMap;         // 12..13
		internal ushort snXdata;               // 14..15
		internal ushort snPdata;               // 16..17
		internal ushort snNewFPO;              // 18..19
		internal ushort snSectionHdrOrig;      // 20..21
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct DbiHeader
	{
		internal DbiHeader(BitAccess bits)
		{
			bits.ReadInt32(out sig);
			bits.ReadInt32(out ver);
			bits.ReadInt32(out age);
			bits.ReadInt16(out gssymStream);
			bits.ReadUInt16(out vers);
			bits.ReadInt16(out pssymStream);
			bits.ReadUInt16(out pdbver);
			bits.ReadInt16(out symrecStream);
			bits.ReadUInt16(out pdbver2);
			bits.ReadInt32(out gpmodiSize);
			bits.ReadInt32(out secconSize);
			bits.ReadInt32(out secmapSize);
			bits.ReadInt32(out filinfSize);
			bits.ReadInt32(out tsmapSize);
			bits.ReadInt32(out mfcIndex);
			bits.ReadInt32(out dbghdrSize);
			bits.ReadInt32(out ecinfoSize);
			bits.ReadUInt16(out flags);
			bits.ReadUInt16(out machine);
			bits.ReadInt32(out reserved);
		}

		internal int sig;                        // 0..3
		internal int ver;                        // 4..7
		internal int age;                        // 8..11
		internal short gssymStream;                // 12..13
		internal ushort vers;                       // 14..15
		internal short pssymStream;                // 16..17
		internal ushort pdbver;                     // 18..19
		internal short symrecStream;               // 20..21
		internal ushort pdbver2;                    // 22..23
		internal int gpmodiSize;                 // 24..27
		internal int secconSize;                 // 28..31
		internal int secmapSize;                 // 32..35
		internal int filinfSize;                 // 36..39
		internal int tsmapSize;                  // 40..43
		internal int mfcIndex;                   // 44..47
		internal int dbghdrSize;                 // 48..51
		internal int ecinfoSize;                 // 52..55
		internal ushort flags;                      // 56..57
		internal ushort machine;                    // 58..59
		internal int reserved;                   // 60..63
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class DbiModuleInfo
	{
		internal DbiModuleInfo(BitAccess bits, bool readStrings)
		{
			bits.ReadInt32(out opened);
			new DbiSecCon(bits);
			bits.ReadUInt16(out flags);
			bits.ReadInt16(out stream);
			bits.ReadInt32(out cbSyms);
			bits.ReadInt32(out cbOldLines);
			bits.ReadInt32(out cbLines);
			bits.ReadInt16(out files);
			bits.ReadInt16(out pad1);
			bits.ReadUInt32(out offsets);
			bits.ReadInt32(out niSource);
			bits.ReadInt32(out niCompiler);
			if (readStrings)
			{
				bits.ReadCString(out moduleName);
				bits.ReadCString(out objectName);
			}
			else
			{
				bits.SkipCString(out moduleName);
				bits.SkipCString(out objectName);
			}
			bits.Align(4);
			//if (opened != 0 || pad1 != 0) {
			//  throw new PdbException("Invalid DBI module. "+
			//                                 "(opened={0}, pad={1})", opened, pad1);
			//}
		}

		internal int opened;                 //  0..3
											 //internal DbiSecCon section;                //  4..31
		internal ushort flags;                  // 32..33
		internal short stream;                 // 34..35
		internal int cbSyms;                 // 36..39
		internal int cbOldLines;             // 40..43
		internal int cbLines;                // 44..57
		internal short files;                  // 48..49
		internal short pad1;                   // 50..51
		internal uint offsets;
		internal int niSource;
		internal int niCompiler;
		internal string moduleName;
		internal string objectName;
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct DbiSecCon
	{
		internal DbiSecCon(BitAccess bits)
		{
			bits.ReadInt16(out section);
			bits.ReadInt16(out pad1);
			bits.ReadInt32(out offset);
			bits.ReadInt32(out size);
			bits.ReadUInt32(out flags);
			bits.ReadInt16(out module);
			bits.ReadInt16(out pad2);
			bits.ReadUInt32(out dataCrc);
			bits.ReadUInt32(out relocCrc);
			//if (pad1 != 0 || pad2 != 0) {
			//  throw new PdbException("Invalid DBI section. "+
			//                                 "(pad1={0}, pad2={1})",
			//                         pad1, pad2);
			//}
		}

		internal short section;                    // 0..1
		internal short pad1;                       // 2..3
		internal int offset;                     // 4..7
		internal int size;                       // 8..11
		internal uint flags;                      // 12..15
		internal short module;                     // 16..17
		internal short pad2;                       // 18..19
		internal uint dataCrc;                    // 20..23
		internal uint relocCrc;                   // 24..27
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil
{

	public class DefaultAssemblyResolver : BaseAssemblyResolver
	{

		readonly IDictionary<string, AssemblyDefinition> cache;

		public DefaultAssemblyResolver()
		{
			cache = new Dictionary<string, AssemblyDefinition>(StringComparer.Ordinal);
		}

		public override AssemblyDefinition Resolve(AssemblyNameReference name)
		{
			Mixin.CheckName(name);

			AssemblyDefinition assembly;
			if (cache.TryGetValue(name.FullName, out assembly))
				return assembly;

			assembly = base.Resolve(name);
			cache[name.FullName] = assembly;

			return assembly;
		}

		protected void RegisterAssembly(AssemblyDefinition assembly)
		{
			if (assembly == null)
				throw new ArgumentNullException("assembly");

			var name = assembly.Name.FullName;
			if (cache.ContainsKey(name))
				return;

			cache[name] = assembly;
		}

		protected override void Dispose(bool disposing)
		{
			foreach (var assembly in cache.Values)
				assembly.Dispose();

			cache.Clear();

			base.Dispose(disposing);
		}
	}
}











namespace MonoMod.RuntimeDetour
{
#if !MONOMOD_INTERNAL
	public
#endif
	static class DetourHelper
	{

		private static readonly object _RuntimeLock = new object();
		private static bool _RuntimeInit = false;
		private static IDetourRuntimePlatform _Runtime;
		public static IDetourRuntimePlatform Runtime
		{
			get
			{
				if (_Runtime != null)
					return _Runtime;

				lock (_RuntimeLock)
				{
					if (_Runtime != null)
						return _Runtime;

					if (_RuntimeInit)
						return null;
					_RuntimeInit = true;

					if (Type.GetType("Mono.Runtime") != null)
					{
						_Runtime = new DetourRuntimeMonoPlatform();
					}
					else if (typeof(object).Assembly.GetName().Name == "System.Private.CoreLib")
					{
						_Runtime = DetourRuntimeNETCorePlatform.Create();
					}
					else
					{
						_Runtime = new DetourRuntimeNETPlatform();
					}

					return _Runtime;
				}
			}
			set => _Runtime = value;
		}

		private static readonly object _NativeLock = new object();
		private static bool _NativeInit = false;
		private static IDetourNativePlatform _Native;
		public static IDetourNativePlatform Native
		{
			get
			{
				if (_Native != null)
					return _Native;

				lock (_NativeLock)
				{
					if (_Native != null)
						return _Native;

					if (_NativeInit)
						return null;
					_NativeInit = true;

					IDetourNativePlatform native;

					if (PlatformHelper.Is(MonoPlatform.ARM))
					{
						native = new DetourNativeARMPlatform();
					}
					else
					{
						native = new DetourNativeX86Platform();
					}

					if (PlatformHelper.Is(MonoPlatform.Windows))
					{
						return _Native = new DetourNativeWindowsPlatform(native);
					}

					if (Type.GetType("Mono.Runtime") != null)
					{
						try
						{
							// It's prefixed with lib on every platform.
							return _Native = new DetourNativeMonoPlatform(native, $"libmonosgen-2.0.{PlatformHelper.LibrarySuffix}");
						}
						catch
						{
							// Fall back to another native platform wrapper.
						}
					}
					else
					{
						// .NET Core currently doesn't contain any meaningful built-in wrappers.
					}

					// MonoPosixHelper is available outside of Unix and even outside of Mono.
					// ... yet the available version might be incompatible with the current runtime for unknown reasons.
					string isMonoPosixPreferred = Environment.GetEnvironmentVariable("MONOMOD_RUNTIMEDETOUR_MONOPOSIXHELPER");
					if ((Type.GetType("Mono.Runtime") != null && isMonoPosixPreferred != "0") || isMonoPosixPreferred == "1")
					{
						try
						{
							return _Native = new DetourNativeMonoPosixPlatform(native);
						}
						catch
						{
							// Good job, your copy of Mono doesn't ship with MonoPosixHelper.
							// https://www.youtube.com/watch?v=l60MnDJklnM (Michael Jordan: Stop It, Get Some Help)
						}
					}

					// Might as well try libc...
					try
					{
						return _Native = new DetourNativeLibcPlatform(native);
					}
					catch
					{
						// Oh well.
					}

					return native;
				}
			}
			set => _Native = value;
		}

		#region Interface extension methods

		public static void MakeWritable(this IDetourNativePlatform plat, NativeDetourData detour) => plat.MakeWritable(detour.Method, detour.Size);
		public static void MakeExecutable(this IDetourNativePlatform plat, NativeDetourData detour) => plat.MakeExecutable(detour.Method, detour.Size);
		public static void FlushICache(this IDetourNativePlatform plat, NativeDetourData detour) => plat.FlushICache(detour.Method, detour.Size);

		#endregion

		#region Native helpers

		/// <summary>
		/// Write the given value at the address to + offs, afterwards advancing offs by sizeof(byte).
		/// </summary>
		public static unsafe void Write(this IntPtr to, ref int offs, byte value)
		{
			*((byte*)((long)to + offs)) = value;
			offs += 1;
		}
		/// <summary>
		/// Write the given value at the address to + offs, afterwards advancing offs by sizeof(ushort).
		/// </summary>
		public static unsafe void Write(this IntPtr to, ref int offs, ushort value)
		{
			*((ushort*)((long)to + offs)) = value;
			offs += 2;
		}
		/// <summary>
		/// Write the given value at the address to + offs, afterwards advancing offs by sizeof(ushort).
		/// </summary>
		public static unsafe void Write(this IntPtr to, ref int offs, uint value)
		{
			*((uint*)((long)to + offs)) = value;
			offs += 4;
		}
		/// <summary>
		/// Write the given value at the address to + offs, afterwards advancing offs by sizeof(ulong).
		/// </summary>
		public static unsafe void Write(this IntPtr to, ref int offs, ulong value)
		{
			*((ulong*)((long)to + offs)) = value;
			offs += 8;
		}

		#endregion

		#region Method-related helpers

		public static MethodBase GetIdentifiable(this MethodBase method)
			=> Runtime.GetIdentifiable(method);

		public static IntPtr GetNativeStart(this MethodBase method)
			=> Runtime.GetNativeStart(method);
		public static IntPtr GetNativeStart(this Delegate method)
			=> method.Method.GetNativeStart();
		public static IntPtr GetNativeStart(this Expression method)
			=> ((MethodCallExpression)method).Method.GetNativeStart();

		public static MethodInfo CreateILCopy(this MethodBase method)
			=> Runtime.CreateCopy(method);
		public static bool TryCreateILCopy(this MethodBase method, out MethodInfo dm)
			=> Runtime.TryCreateCopy(method, out dm);

		public static T Pin<T>(this T method) where T : MethodBase
		{
			Runtime.Pin(method);
			return method;
		}

		public static T Unpin<T>(this T method) where T : MethodBase
		{
			Runtime.Unpin(method);
			return method;
		}

		#endregion

		#region DynamicMethod generation helpers

		/// <summary>
		/// Generate a DynamicMethod to easily call the given native function from another DynamicMethod.
		/// </summary>
		/// <param name="target">The pointer to the native function to call.</param>
		/// <param name="signature">A MethodBase with the target function's signature.</param>
		/// <returns>The detoured DynamicMethod.</returns>
		public static MethodInfo GenerateNativeProxy(IntPtr target, MethodBase signature)
		{
			Type returnType = (signature as MethodInfo)?.ReturnType ?? typeof(void);

			ParameterInfo[] args = signature.GetParameters();
			Type[] argTypes = new Type[args.Length];
			for (int i = 0; i < args.Length; i++)
				argTypes[i] = args[i].ParameterType;

			MethodInfo dm;
			using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
				$"Native<{((long)target).ToString("X16", CultureInfo.InvariantCulture)}>",
				returnType, argTypes
			))
				dm = dmd.StubCriticalDetour().Generate().Pin();

			// Detour the new DynamicMethod into the target.
			NativeDetourData detour = Native.Create(dm.GetNativeStart(), target);
			Native.MakeWritable(detour);
			Native.Apply(detour);
			Native.MakeExecutable(detour);
			Native.FlushICache(detour);
			Native.Free(detour);

			return dm;
		}

		// Used in EmitDetourApply.
		private static NativeDetourData ToNativeDetourData(IntPtr method, IntPtr target, uint size, byte type, IntPtr extra)
			=> new NativeDetourData
			{
				Method = method,
				Target = target,
				Size = size,
				Type = type,
				Extra = extra
			};

		private static readonly FieldInfo _f_Native = typeof(DetourHelper).GetField("_Native", BindingFlags.NonPublic | BindingFlags.Static);
		private static readonly MethodInfo _m_ToNativeDetourData = typeof(DetourHelper).GetMethod("ToNativeDetourData", BindingFlags.NonPublic | BindingFlags.Static);
		private static readonly MethodInfo _m_Copy = typeof(IDetourNativePlatform).GetMethod("Copy");
		private static readonly MethodInfo _m_Apply = typeof(IDetourNativePlatform).GetMethod("Apply");
		private static readonly ConstructorInfo _ctor_Exception = typeof(Exception).GetConstructor(new Type[] { typeof(string) });

		/// <summary>
		/// Fill the DynamicMethodDefinition with a throw.
		/// </summary>
		public static DynamicMethodDefinition StubCriticalDetour(this DynamicMethodDefinition dm)
		{
			ILProcessor il = dm.GetILProcessor();
			ModuleDefinition ilModule = il.Body.Method.Module;
			for (int i = 0; i < 32; i++)
			{
				// Prevent mono from inlining the DynamicMethod.
				il.Emit(OpCodes.Nop);
			}
			il.Emit(OpCodes.Ldstr, $"{dm.Definition.Name} should've been detoured!");
			il.Emit(OpCodes.Newobj, ilModule.ImportReference(_ctor_Exception));
			il.Emit(OpCodes.Throw);
			return dm;
		}

		/// <summary>
		/// Emit a call to DetourManager.Native.Copy using the given parameters.
		/// </summary>
		public static void EmitDetourCopy(this ILProcessor il, IntPtr src, IntPtr dst, byte type)
		{
			ModuleDefinition ilModule = il.Body.Method.Module;

			// Load NativePlatform instance.
			il.Emit(OpCodes.Ldsfld, ilModule.ImportReference(_f_Native));

			// Fill stack with src, dst, type
			il.Emit(OpCodes.Ldc_I8, (long)src);
			il.Emit(OpCodes.Conv_I);
			il.Emit(OpCodes.Ldc_I8, (long)dst);
			il.Emit(OpCodes.Conv_I);
			il.Emit(OpCodes.Ldc_I4, (int)type);
			il.Emit(OpCodes.Conv_U1);

			// Copy.
			il.Emit(OpCodes.Callvirt, ilModule.ImportReference(_m_Copy));
		}

		/// <summary>
		/// Emit a call to DetourManager.Native.Apply using a copy of the given data.
		/// </summary>
		public static void EmitDetourApply(this ILProcessor il, NativeDetourData data)
		{
			ModuleDefinition ilModule = il.Body.Method.Module;

			// Load NativePlatform instance.
			il.Emit(OpCodes.Ldsfld, ilModule.ImportReference(_f_Native));

			// Fill stack with data values.
			il.Emit(OpCodes.Ldc_I8, (long)data.Method);
			il.Emit(OpCodes.Conv_I);
			il.Emit(OpCodes.Ldc_I8, (long)data.Target);
			il.Emit(OpCodes.Conv_I);
			il.Emit(OpCodes.Ldc_I4, (int)data.Size);
			il.Emit(OpCodes.Ldc_I4, (int)data.Type);
			il.Emit(OpCodes.Conv_U1);
			il.Emit(OpCodes.Ldc_I8, (long)data.Extra);
			il.Emit(OpCodes.Conv_I);

			// Put values in stack into NativeDetourData.
			il.Emit(OpCodes.Call, ilModule.ImportReference(_m_ToNativeDetourData));

			// Apply.
			il.Emit(OpCodes.Callvirt, ilModule.ImportReference(_m_Apply));
		}

		#endregion

	}
}





namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeARMPlatform : IDetourNativePlatform
	{
		// TODO: Make use of possibly shorter near branches.
		public enum DetourType : byte
		{
			Thumb,
			ThumbBX,
			AArch32,
			AArch32BX,
			AArch64
		}
		private static readonly uint[] DetourSizes = {
			4 + 4,
			4 + 2 + 2 + 4,
			4 + 4,
			4 + 4 + 4,
			4 + 4 + 8
		};

		// Might be disabled manually when triggering access errors (especially on some armv7 chips).
		// Source: MonoMod Discord server, https://discordapp.com/channels/295566538981769216/295570965663055874/598536798666227712
		public bool ShouldFlushICache = true;

		private static DetourType GetDetourType(IntPtr from, IntPtr to)
		{
			if (IntPtr.Size >= 8)
				return DetourType.AArch64;

			// The lowest bit is set for Thumb, unset for ARM.
			bool fromThumb = ((long)from & 0x1) == 0x1;
			bool toThumb = ((long)to & 0x1) == 0x1;
			if (fromThumb)
			{
				if (toThumb)
				{
					return DetourType.Thumb;
				}
				else
				{
					return DetourType.ThumbBX;
				}
			}
			else
			{
				if (toThumb)
				{
					return DetourType.AArch32BX;
				}
				else
				{
					return DetourType.AArch32;
				}
			}
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			NativeDetourData detour = new NativeDetourData
			{
				Method = (IntPtr)((long)from & ~0x1),
				Target = (IntPtr)((long)to & ~0x1)
			};
			detour.Size = DetourSizes[detour.Type = type ?? (byte)GetDetourType(from, to)];
			// Console.WriteLine($"{nameof(DetourNativeARMPlatform)} create: {(DetourType) detour.Type} 0x{detour.Method.ToString("X16")} + 0x{detour.Size.ToString("X8")} -> 0x{detour.Target.ToString("X16")}");
			return detour;
		}

		public void Free(NativeDetourData detour)
		{
			// No extra data.
		}

		public void Apply(NativeDetourData detour)
		{
			int offs = 0;

			// Console.WriteLine($"{nameof(DetourNativeARMPlatform)} apply: {(DetourType) detour.Type} 0x{detour.Method.ToString("X16")} -> 0x{detour.Target.ToString("X16")}");
			switch ((DetourType)detour.Type)
			{
				case DetourType.Thumb:
					// Note: PC is 4 bytes ahead
					// LDR.W PC, [PC, #0]
					detour.Method.Write(ref offs, (byte)0xDF);
					detour.Method.Write(ref offs, (byte)0xF8);
					detour.Method.Write(ref offs, (byte)0x00);
					detour.Method.Write(ref offs, (byte)0xF0);
					// <to> | 0x1 (-> Thumb)
					detour.Method.Write(ref offs, (uint)detour.Target | 0x1);
					break;

				case DetourType.ThumbBX:
					// Burn a register to stay safe.
					// Note: PC is 4 bytes ahead
					// LDR.W R10, [PC, #4]
					detour.Method.Write(ref offs, (byte)0xDF);
					detour.Method.Write(ref offs, (byte)0xF8);
					detour.Method.Write(ref offs, (byte)0x04);
					detour.Method.Write(ref offs, (byte)0xA0);
					// BX R10
					detour.Method.Write(ref offs, (byte)0x50);
					detour.Method.Write(ref offs, (byte)0x47);
					// NOP
					detour.Method.Write(ref offs, (byte)0x00);
					detour.Method.Write(ref offs, (byte)0xBF);
					// <to> | 0x0 (-> ARM)
					detour.Method.Write(ref offs, (uint)detour.Target | 0x0);
					break;

				case DetourType.AArch32:
					// Note: PC is 8 bytes ahead
					// LDR PC, [PC, #-4]
					detour.Method.Write(ref offs, (byte)0x04);
					detour.Method.Write(ref offs, (byte)0xF0);
					detour.Method.Write(ref offs, (byte)0x1F);
					detour.Method.Write(ref offs, (byte)0xE5);
					// <to> | 0x0 (-> ARM)
					detour.Method.Write(ref offs, (uint)detour.Target | 0x0);
					break;

				case DetourType.AArch32BX:
					// Burn a register. Required to use BX to change state.
					// Note: PC is 4 bytes ahead
					// LDR R8, [PC, #0]
					detour.Method.Write(ref offs, (byte)0x00);
					detour.Method.Write(ref offs, (byte)0x80);
					detour.Method.Write(ref offs, (byte)0x9F);
					detour.Method.Write(ref offs, (byte)0xE5);
					// BX R8
					detour.Method.Write(ref offs, (byte)0x18);
					detour.Method.Write(ref offs, (byte)0xFF);
					detour.Method.Write(ref offs, (byte)0x2F);
					detour.Method.Write(ref offs, (byte)0xE1);
					// <to> | 0x1 (-> Thumb)
					detour.Method.Write(ref offs, (uint)detour.Target | 0x1);
					break;

				case DetourType.AArch64:
					// PC isn't available on arm64.
					// We need to burn a register and branch instead.
					// LDR X15, .+8
					detour.Method.Write(ref offs, (byte)0x4F);
					detour.Method.Write(ref offs, (byte)0x00);
					detour.Method.Write(ref offs, (byte)0x00);
					detour.Method.Write(ref offs, (byte)0x58);
					// BR X15
					detour.Method.Write(ref offs, (byte)0xE0);
					detour.Method.Write(ref offs, (byte)0x01);
					detour.Method.Write(ref offs, (byte)0x1F);
					detour.Method.Write(ref offs, (byte)0xD6);
					// <to>
					detour.Method.Write(ref offs, (ulong)detour.Target);
					break;

				default:
					throw new NotSupportedException($"Unknown detour type {detour.Type}");
			}
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			switch ((DetourType)type)
			{
				case DetourType.Thumb:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(uint*)((long)dst + 4) = *(uint*)((long)src + 4);
					break;

				case DetourType.ThumbBX:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(ushort*)((long)dst + 4) = *(ushort*)((long)src + 4);
					*(ushort*)((long)dst + 6) = *(ushort*)((long)src + 6);
					*(uint*)((long)dst + 8) = *(uint*)((long)src + 8);
					break;

				case DetourType.AArch32:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(uint*)((long)dst + 4) = *(uint*)((long)src + 4);
					break;

				case DetourType.AArch32BX:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(uint*)((long)dst + 4) = *(uint*)((long)src + 4);
					*(uint*)((long)dst + 8) = *(uint*)((long)src + 8);
					break;

				case DetourType.AArch64:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(uint*)((long)dst + 4) = *(uint*)((long)src + 4);
					*(ulong*)((long)dst + 8) = *(ulong*)((long)src + 8);
					break;

				default:
					throw new NotSupportedException($"Unknown detour type {type}");
			}
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// no-op.
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			// no-op.
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			// no-op.
		}

		public unsafe void FlushICache(IntPtr src, uint size)
		{
			// On ARM, we must flush the instruction cache.
			// Sadly, mono_arch_flush_icache isn't reliably exported.
			// This thus requires running native code to invoke the syscall.

			if (!ShouldFlushICache)
				return;

			// Emit a native delegate once. It lives as long as the application.
			// It'd be ironic if the flush function would need to be flushed itself...
			byte[] code = IntPtr.Size >= 8 ? _FlushCache64 : _FlushCache32;
			fixed (byte* ptr = code)
			{
				DetourHelper.Native.MakeExecutable((IntPtr)ptr, (uint)code.Length);
				(Marshal.GetDelegateForFunctionPointer((IntPtr)ptr, typeof(d_flushicache)) as d_flushicache)(src, size);
			}
		}

		public IntPtr MemAlloc(uint size)
		{
			return Marshal.AllocHGlobal((int)size);
		}

		public void MemFree(IntPtr ptr)
		{
			Marshal.FreeHGlobal(ptr);
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int d_flushicache(IntPtr code, ulong size);

		// The following tools were used to obtain the shellcode.
		// https://godbolt.org/ ARM(64) gcc 8.2
		// http://shell-storm.org/online/Online-Assembler-and-Disassembler/
		// http://alexaltea.github.io/keystone.js/ .map(x => "0x" + x.toString(16).padStart(2, "0")).join(", ")

		/* -O2 -fPIE -march=armv6
        // On ARM non-64, apparently SVC is the newer "Unified Assembler Language" (UAL) syntax.
        // In older versions of mono (before they fully switched to __clear_cache), it was only used for Android.
        // Adapted from mono's instruction flushing code.
        // https://github.com/mono/mono/blob/d2acc1d780d40f0a418347181c5adab533944d90/mono/mini/mini-arm.c#L1195
        void flushicache(void* code, unsigned long size) {
	        const int syscall = 0xf0002;
	        __asm __volatile (
		        "mov	 r0, %0\n"			
		        "mov	 r1, %1\n"
		        "mov	 r7, %2\n"
		        "mov     r2, #0x0\n"
		        "svc     0x00000000\n"
		        :
		        :   "r" (code), "r" (((long) code) + size), "r" (syscall)
		        :   "r0", "r1", "r7", "r2"
		    );
        }
        */
		private readonly byte[] _FlushCache32 = { 0x80, 0x40, 0x2d, 0xe9, 0x00, 0x30, 0xa0, 0xe1, 0x01, 0xc0, 0x80, 0xe0, 0x14, 0xe0, 0x9f, 0xe5, 0x03, 0x00, 0xa0, 0xe1, 0x0c, 0x10, 0xa0, 0xe1, 0x0e, 0x70, 0xa0, 0xe1, 0x00, 0x20, 0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef, 0x80, 0x80, 0xbd, 0xe8, 0x02, 0x00, 0x0f, 0x00 };

		/* -O2 -fPIE -march=armv8-a
        // Adapted from mono's instruction flushing code.
        // https://github.com/mono/mono/blob/cd5e14a3ccaa76e6ba6c58b26823863a2d0a0854/mono/mini/mini-arm64.c#L1997
        void flushicache(void* code, unsigned long size) {
	        unsigned long end = (unsigned long) (((unsigned long) code) + size);
	        unsigned long addr;
	        const unsigned int icache_line_size = 4;
	        const unsigned int dcache_line_size = 4;

	        addr = (unsigned long) code & ~(unsigned long) (dcache_line_size - 1);
	        for (; addr < end; addr += dcache_line_size)
		        asm volatile("dc civac, %0" : : "r" (addr) : "memory");
	        asm volatile("dsb ish" : : : "memory");

	        addr = (unsigned long) code & ~(unsigned long) (icache_line_size - 1);
	        for (; addr < end; addr += icache_line_size)
		        asm volatile("ic ivau, %0" : : "r" (addr) : "memory");

	        asm volatile ("dsb ish" : : : "memory");
	        asm volatile ("isb" : : : "memory");
        }
        */
		private readonly byte[] _FlushCache64 = { 0x01, 0x00, 0x01, 0x8b, 0x00, 0xf4, 0x7e, 0x92, 0x3f, 0x00, 0x00, 0xeb, 0xc9, 0x00, 0x00, 0x54, 0xe2, 0x03, 0x00, 0xaa, 0x22, 0x7e, 0x0b, 0xd5, 0x42, 0x10, 0x00, 0x91, 0x3f, 0x00, 0x02, 0xeb, 0xa8, 0xff, 0xff, 0x54, 0x9f, 0x3b, 0x03, 0xd5, 0x3f, 0x00, 0x00, 0xeb, 0xa9, 0x00, 0x00, 0x54, 0x20, 0x75, 0x0b, 0xd5, 0x00, 0x10, 0x00, 0x91, 0x3f, 0x00, 0x00, 0xeb, 0xa8, 0xff, 0xff, 0x54, 0x9f, 0x3b, 0x03, 0xd5, 0xdf, 0x3f, 0x03, 0xd5, 0xc0, 0x03, 0x5f, 0xd6 };

	}
}
#pragma warning disable IDE1006 // Naming Styles







namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeLibcPlatform : IDetourNativePlatform
	{
		private readonly IDetourNativePlatform Inner;

		private readonly long _Pagesize;

		public DetourNativeLibcPlatform(IDetourNativePlatform inner)
		{
			Inner = inner;

			// Environment.SystemPageSize is part of .NET Framework 4.0+ and .NET Standard 2.0+
#if NETSTANDARD
            _Pagesize = Environment.SystemPageSize;
#else
			PropertyInfo p_SystemPageSize = typeof(Environment).GetProperty("SystemPageSize");
			if (p_SystemPageSize == null)
				throw new NotSupportedException("Unsupported runtime");
			_Pagesize = (int)p_SystemPageSize.GetValue(null, new object[0]);
#endif
		}

		private unsafe void SetMemPerms(IntPtr start, ulong len, MmapProts prot)
		{
			long pagesize = _Pagesize;
			long startPage = ((long)start) & ~(pagesize - 1);
			long endPage = ((long)start + (long)len + pagesize - 1) & ~(pagesize - 1);

			if (mprotect((IntPtr)startPage, (IntPtr)(endPage - startPage), prot) != 0)
				throw new Win32Exception();
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// RWX for sanity.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			// RWX for sanity.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void FlushICache(IntPtr src, uint size)
		{
			// The cache would be flushed via a syscall, which isn't exposed by libc.
			Inner.FlushICache(src, size);
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			return Inner.Create(from, to, type);
		}

		public void Free(NativeDetourData detour)
		{
			Inner.Free(detour);
		}

		public void Apply(NativeDetourData detour)
		{
			Inner.Apply(detour);
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			Inner.Copy(src, dst, type);
		}

		public IntPtr MemAlloc(uint size)
		{
			return Inner.MemAlloc(size);
		}

		public void MemFree(IntPtr ptr)
		{
			Inner.MemFree(ptr);
		}

		[DllImport("libc", SetLastError = true, CallingConvention = CallingConvention.Cdecl)]
		private static extern int mprotect(IntPtr start, IntPtr len, MmapProts prot);

		[Flags]
		private enum MmapProts : int
		{
			PROT_READ = 0x1,
			PROT_WRITE = 0x2,
			PROT_EXEC = 0x4,
			PROT_NONE = 0x0,
			PROT_GROWSDOWN = 0x01000000,
			PROT_GROWSUP = 0x02000000,
		}
	}
}
#pragma warning disable IDE1006 // Naming Styles








namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeMonoPlatform : IDetourNativePlatform
	{
		private readonly IDetourNativePlatform Inner;

		private readonly long _Pagesize;

		public DetourNativeMonoPlatform(IDetourNativePlatform inner, string libmono)
		{
			Inner = inner;

			Dictionary<string, List<DynDllMapping>> mappings = new Dictionary<string, List<DynDllMapping>>();
			if (!string.IsNullOrEmpty(libmono))
				mappings.Add("mono", new List<DynDllMapping>() { libmono });
			DynDll.ResolveDynDllImports(this, mappings);

			_Pagesize = mono_pagesize();
		}

		private unsafe void SetMemPerms(IntPtr start, ulong len, MmapProts prot)
		{
			long pagesize = _Pagesize;
			long startPage = ((long)start) & ~(pagesize - 1);
			long endPage = ((long)start + (long)len + pagesize - 1) & ~(pagesize - 1);

			if (mono_mprotect((IntPtr)startPage, (IntPtr)(endPage - startPage), (int)prot) != 0)
			{
				int error = Marshal.GetLastWin32Error();
				if (error == 0)
				{
					// This can happen on some Android devices.
					// Let's hope for the best.
				}
				else
				{
					throw new Win32Exception();
				}
			}
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// RWX because old versions of mono always use RWX.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			// RWX because old versions of mono always use RWX.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void FlushICache(IntPtr src, uint size)
		{
			// mono_arch_flush_icache isn't reliably exported.
			Inner.FlushICache(src, size);
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			return Inner.Create(from, to, type);
		}

		public void Free(NativeDetourData detour)
		{
			Inner.Free(detour);
		}

		public void Apply(NativeDetourData detour)
		{
			Inner.Apply(detour);
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			Inner.Copy(src, dst, type);
		}

		public IntPtr MemAlloc(uint size)
		{
			return Inner.MemAlloc(size);
		}

		public void MemFree(IntPtr ptr)
		{
			Inner.MemFree(ptr);
		}

#pragma warning disable IDE0044 // Add readonly modifier
#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value null

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int d_mono_pagesize();
		[DynDllImport("mono")]
		private d_mono_pagesize mono_pagesize;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl, SetLastError = true)]
		private delegate int d_mono_mprotect(IntPtr addr, IntPtr length, int flags);
		[DynDllImport("mono")]
		private d_mono_mprotect mono_mprotect;

#pragma warning restore IDE0044 // Add readonly modifier
#pragma warning restore CS0649 // Field is never assigned to, and will always have its default value null

		[Flags]
		private enum MmapProts : int
		{
			PROT_READ = 0x1,
			PROT_WRITE = 0x2,
			PROT_EXEC = 0x4,
			PROT_NONE = 0x0,
			PROT_GROWSDOWN = 0x01000000,
			PROT_GROWSUP = 0x02000000,
		}
	}
}
#pragma warning disable IDE1006 // Naming Styles





namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeMonoPosixPlatform : IDetourNativePlatform
	{
		private readonly IDetourNativePlatform Inner;

		private readonly long _Pagesize;

		public DetourNativeMonoPosixPlatform(IDetourNativePlatform inner)
		{
			Inner = inner;

			_Pagesize = sysconf(SysconfName._SC_PAGESIZE, 0);
		}

		private static string GetLastError(string name)
		{
			int raw = _GetLastError();
			if (ToErrno(raw, out Errno errno) == 0)
			{
				return $"{name} returned {errno}";
			}
			return $"{name} returned 0x${raw:X8}";
		}

		private unsafe void SetMemPerms(IntPtr start, ulong len, MmapProts prot)
		{
			long pagesize = _Pagesize;
			long startPage = ((long)start) & ~(pagesize - 1);
			long endPage = ((long)start + (long)len + pagesize - 1) & ~(pagesize - 1);

			if (mprotect((IntPtr)startPage, (ulong)(endPage - startPage), prot) != 0)
				throw new Exception(GetLastError("mprotect"));
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// RWX because old versions of mono always use RWX.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			// RWX because old versions of mono always use RWX.
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			SetMemPerms(src, size, MmapProts.PROT_READ | MmapProts.PROT_WRITE | MmapProts.PROT_EXEC);
		}

		public void FlushICache(IntPtr src, uint size)
		{
			// There is no cache flushing function in MPH.
			Inner.FlushICache(src, size);
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			return Inner.Create(from, to, type);
		}

		public void Free(NativeDetourData detour)
		{
			Inner.Free(detour);
		}

		public void Apply(NativeDetourData detour)
		{
			Inner.Apply(detour);
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			Inner.Copy(src, dst, type);
		}

		public IntPtr MemAlloc(uint size)
		{
			return Inner.MemAlloc(size);
		}

		public void MemFree(IntPtr ptr)
		{
			Inner.MemFree(ptr);
		}

		// Good luck if your copy of Mono doesn't ship with MonoPosixHelper...
		[DllImport("MonoPosixHelper", SetLastError = true, EntryPoint = "Mono_Posix_Syscall_sysconf")]
		public static extern long sysconf(SysconfName name, Errno defaultError);

		[DllImport("MonoPosixHelper", SetLastError = true, EntryPoint = "Mono_Posix_Syscall_mprotect")]
		private static extern int mprotect(IntPtr start, ulong len, MmapProts prot);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_GetLastError")]
		private static extern int _GetLastError();
		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToErrno")]
		private static extern int ToErrno(int value, out Errno rval);

		[Flags]
		private enum MmapProts : int
		{
			PROT_READ = 0x1,
			PROT_WRITE = 0x2,
			PROT_EXEC = 0x4,
			PROT_NONE = 0x0,
			PROT_GROWSDOWN = 0x01000000,
			PROT_GROWSUP = 0x02000000,
		}

		public enum SysconfName : int
		{
			_SC_ARG_MAX,
			_SC_CHILD_MAX,
			_SC_CLK_TCK,
			_SC_NGROUPS_MAX,
			_SC_OPEN_MAX,
			_SC_STREAM_MAX,
			_SC_TZNAME_MAX,
			_SC_JOB_CONTROL,
			_SC_SAVED_IDS,
			_SC_REALTIME_SIGNALS,
			_SC_PRIORITY_SCHEDULING,
			_SC_TIMERS,
			_SC_ASYNCHRONOUS_IO,
			_SC_PRIORITIZED_IO,
			_SC_SYNCHRONIZED_IO,
			_SC_FSYNC,
			_SC_MAPPED_FILES,
			_SC_MEMLOCK,
			_SC_MEMLOCK_RANGE,
			_SC_MEMORY_PROTECTION,
			_SC_MESSAGE_PASSING,
			_SC_SEMAPHORES,
			_SC_SHARED_MEMORY_OBJECTS,
			_SC_AIO_LISTIO_MAX,
			_SC_AIO_MAX,
			_SC_AIO_PRIO_DELTA_MAX,
			_SC_DELAYTIMER_MAX,
			_SC_MQ_OPEN_MAX,
			_SC_MQ_PRIO_MAX,
			_SC_VERSION,
			_SC_PAGESIZE,
			_SC_RTSIG_MAX,
			_SC_SEM_NSEMS_MAX,
			_SC_SEM_VALUE_MAX,
			_SC_SIGQUEUE_MAX,
			_SC_TIMER_MAX,
			/* Values for the argument to `sysconf'
                 corresponding to _POSIX2_* symbols.  */
			_SC_BC_BASE_MAX,
			_SC_BC_DIM_MAX,
			_SC_BC_SCALE_MAX,
			_SC_BC_STRING_MAX,
			_SC_COLL_WEIGHTS_MAX,
			_SC_EQUIV_CLASS_MAX,
			_SC_EXPR_NEST_MAX,
			_SC_LINE_MAX,
			_SC_RE_DUP_MAX,
			_SC_CHARCLASS_NAME_MAX,
			_SC_2_VERSION,
			_SC_2_C_BIND,
			_SC_2_C_DEV,
			_SC_2_FORT_DEV,
			_SC_2_FORT_RUN,
			_SC_2_SW_DEV,
			_SC_2_LOCALEDEF,
			_SC_PII,
			_SC_PII_XTI,
			_SC_PII_SOCKET,
			_SC_PII_INTERNET,
			_SC_PII_OSI,
			_SC_POLL,
			_SC_SELECT,
			_SC_UIO_MAXIOV,
			_SC_IOV_MAX = _SC_UIO_MAXIOV,
			_SC_PII_INTERNET_STREAM,
			_SC_PII_INTERNET_DGRAM,
			_SC_PII_OSI_COTS,
			_SC_PII_OSI_CLTS,
			_SC_PII_OSI_M,
			_SC_T_IOV_MAX,
			/* Values according to POSIX 1003.1c (POSIX threads).  */
			_SC_THREADS,
			_SC_THREAD_SAFE_FUNCTIONS,
			_SC_GETGR_R_SIZE_MAX,
			_SC_GETPW_R_SIZE_MAX,
			_SC_LOGIN_NAME_MAX,
			_SC_TTY_NAME_MAX,
			_SC_THREAD_DESTRUCTOR_ITERATIONS,
			_SC_THREAD_KEYS_MAX,
			_SC_THREAD_STACK_MIN,
			_SC_THREAD_THREADS_MAX,
			_SC_THREAD_ATTR_STACKADDR,
			_SC_THREAD_ATTR_STACKSIZE,
			_SC_THREAD_PRIORITY_SCHEDULING,
			_SC_THREAD_PRIO_INHERIT,
			_SC_THREAD_PRIO_PROTECT,
			_SC_THREAD_PROCESS_SHARED,
			_SC_NPROCESSORS_CONF,
			_SC_NPROCESSORS_ONLN,
			_SC_PHYS_PAGES,
			_SC_AVPHYS_PAGES,
			_SC_ATEXIT_MAX,
			_SC_PASS_MAX,
			_SC_XOPEN_VERSION,
			_SC_XOPEN_XCU_VERSION,
			_SC_XOPEN_UNIX,
			_SC_XOPEN_CRYPT,
			_SC_XOPEN_ENH_I18N,
			_SC_XOPEN_SHM,
			_SC_2_CHAR_TERM,
			_SC_2_C_VERSION,
			_SC_2_UPE,
			_SC_XOPEN_XPG2,
			_SC_XOPEN_XPG3,
			_SC_XOPEN_XPG4,
			_SC_CHAR_BIT,
			_SC_CHAR_MAX,
			_SC_CHAR_MIN,
			_SC_INT_MAX,
			_SC_INT_MIN,
			_SC_LONG_BIT,
			_SC_WORD_BIT,
			_SC_MB_LEN_MAX,
			_SC_NZERO,
			_SC_SSIZE_MAX,
			_SC_SCHAR_MAX,
			_SC_SCHAR_MIN,
			_SC_SHRT_MAX,
			_SC_SHRT_MIN,
			_SC_UCHAR_MAX,
			_SC_UINT_MAX,
			_SC_ULONG_MAX,
			_SC_USHRT_MAX,
			_SC_NL_ARGMAX,
			_SC_NL_LANGMAX,
			_SC_NL_MSGMAX,
			_SC_NL_NMAX,
			_SC_NL_SETMAX,
			_SC_NL_TEXTMAX,
			_SC_XBS5_ILP32_OFF32,
			_SC_XBS5_ILP32_OFFBIG,
			_SC_XBS5_LP64_OFF64,
			_SC_XBS5_LPBIG_OFFBIG,
			_SC_XOPEN_LEGACY,
			_SC_XOPEN_REALTIME,
			_SC_XOPEN_REALTIME_THREADS,
			_SC_ADVISORY_INFO,
			_SC_BARRIERS,
			_SC_BASE,
			_SC_C_LANG_SUPPORT,
			_SC_C_LANG_SUPPORT_R,
			_SC_CLOCK_SELECTION,
			_SC_CPUTIME,
			_SC_THREAD_CPUTIME,
			_SC_DEVICE_IO,
			_SC_DEVICE_SPECIFIC,
			_SC_DEVICE_SPECIFIC_R,
			_SC_FD_MGMT,
			_SC_FIFO,
			_SC_PIPE,
			_SC_FILE_ATTRIBUTES,
			_SC_FILE_LOCKING,
			_SC_FILE_SYSTEM,
			_SC_MONOTONIC_CLOCK,
			_SC_MULTI_PROCESS,
			_SC_SINGLE_PROCESS,
			_SC_NETWORKING,
			_SC_READER_WRITER_LOCKS,
			_SC_SPIN_LOCKS,
			_SC_REGEXP,
			_SC_REGEX_VERSION,
			_SC_SHELL,
			_SC_SIGNALS,
			_SC_SPAWN,
			_SC_SPORADIC_SERVER,
			_SC_THREAD_SPORADIC_SERVER,
			_SC_SYSTEM_DATABASE,
			_SC_SYSTEM_DATABASE_R,
			_SC_TIMEOUTS,
			_SC_TYPED_MEMORY_OBJECTS,
			_SC_USER_GROUPS,
			_SC_USER_GROUPS_R,
			_SC_2_PBS,
			_SC_2_PBS_ACCOUNTING,
			_SC_2_PBS_LOCATE,
			_SC_2_PBS_MESSAGE,
			_SC_2_PBS_TRACK,
			_SC_SYMLOOP_MAX,
			_SC_STREAMS,
			_SC_2_PBS_CHECKPOINT,
			_SC_V6_ILP32_OFF32,
			_SC_V6_ILP32_OFFBIG,
			_SC_V6_LP64_OFF64,
			_SC_V6_LPBIG_OFFBIG,
			_SC_HOST_NAME_MAX,
			_SC_TRACE,
			_SC_TRACE_EVENT_FILTER,
			_SC_TRACE_INHERIT,
			_SC_TRACE_LOG,
			_SC_LEVEL1_ICACHE_SIZE,
			_SC_LEVEL1_ICACHE_ASSOC,
			_SC_LEVEL1_ICACHE_LINESIZE,
			_SC_LEVEL1_DCACHE_SIZE,
			_SC_LEVEL1_DCACHE_ASSOC,
			_SC_LEVEL1_DCACHE_LINESIZE,
			_SC_LEVEL2_CACHE_SIZE,
			_SC_LEVEL2_CACHE_ASSOC,
			_SC_LEVEL2_CACHE_LINESIZE,
			_SC_LEVEL3_CACHE_SIZE,
			_SC_LEVEL3_CACHE_ASSOC,
			_SC_LEVEL3_CACHE_LINESIZE,
			_SC_LEVEL4_CACHE_SIZE,
			_SC_LEVEL4_CACHE_ASSOC,
			_SC_LEVEL4_CACHE_LINESIZE
		}

		public enum Errno : int
		{
			// errors & their values liberally copied from
			// FC2 /usr/include/asm/errno.h

			EPERM = 1, // Operation not permitted 
			ENOENT = 2, // No such file or directory 
			ESRCH = 3, // No such process 
			EINTR = 4, // Interrupted system call 
			EIO = 5, // I/O error 
			ENXIO = 6, // No such device or address 
			E2BIG = 7, // Arg list too long 
			ENOEXEC = 8, // Exec format error 
			EBADF = 9, // Bad file number 
			ECHILD = 10, // No child processes 
			EAGAIN = 11, // Try again 
			ENOMEM = 12, // Out of memory 
			EACCES = 13, // Permission denied 
			EFAULT = 14, // Bad address 
			ENOTBLK = 15, // Block device required 
			EBUSY = 16, // Device or resource busy 
			EEXIST = 17, // File exists 
			EXDEV = 18, // Cross-device link 
			ENODEV = 19, // No such device 
			ENOTDIR = 20, // Not a directory 
			EISDIR = 21, // Is a directory 
			EINVAL = 22, // Invalid argument 
			ENFILE = 23, // File table overflow 
			EMFILE = 24, // Too many open files 
			ENOTTY = 25, // Not a typewriter 
			ETXTBSY = 26, // Text file busy 
			EFBIG = 27, // File too large 
			ENOSPC = 28, // No space left on device 
			ESPIPE = 29, // Illegal seek 
			EROFS = 30, // Read-only file system 
			EMLINK = 31, // Too many links 
			EPIPE = 32, // Broken pipe 
			EDOM = 33, // Math argument out of domain of func 
			ERANGE = 34, // Math result not representable 
			EDEADLK = 35, // Resource deadlock would occur 
			ENAMETOOLONG = 36, // File name too long 
			ENOLCK = 37, // No record locks available 
			ENOSYS = 38, // Function not implemented 
			ENOTEMPTY = 39, // Directory not empty 
			ELOOP = 40, // Too many symbolic links encountered 
			EWOULDBLOCK = EAGAIN, // Operation would block 
			ENOMSG = 42, // No message of desired type 
			EIDRM = 43, // Identifier removed 
			ECHRNG = 44, // Channel number out of range 
			EL2NSYNC = 45, // Level 2 not synchronized 
			EL3HLT = 46, // Level 3 halted 
			EL3RST = 47, // Level 3 reset 
			ELNRNG = 48, // Link number out of range 
			EUNATCH = 49, // Protocol driver not attached 
			ENOCSI = 50, // No CSI structure available 
			EL2HLT = 51, // Level 2 halted 
			EBADE = 52, // Invalid exchange 
			EBADR = 53, // Invalid request descriptor 
			EXFULL = 54, // Exchange full 
			ENOANO = 55, // No anode 
			EBADRQC = 56, // Invalid request code 
			EBADSLT = 57, // Invalid slot 

			EDEADLOCK = EDEADLK,

			EBFONT = 59, // Bad font file format 
			ENOSTR = 60, // Device not a stream 
			ENODATA = 61, // No data available 
			ETIME = 62, // Timer expired 
			ENOSR = 63, // Out of streams resources 
			ENONET = 64, // Machine is not on the network 
			ENOPKG = 65, // Package not installed 
			EREMOTE = 66, // Object is remote 
			ENOLINK = 67, // Link has been severed 
			EADV = 68, // Advertise error 
			ESRMNT = 69, // Srmount error 
			ECOMM = 70, // Communication error on send 
			EPROTO = 71, // Protocol error 
			EMULTIHOP = 72, // Multihop attempted 
			EDOTDOT = 73, // RFS specific error 
			EBADMSG = 74, // Not a data message 
			EOVERFLOW = 75, // Value too large for defined data type 
			ENOTUNIQ = 76, // Name not unique on network 
			EBADFD = 77, // File descriptor in bad state 
			EREMCHG = 78, // Remote address changed 
			ELIBACC = 79, // Can not access a needed shared library 
			ELIBBAD = 80, // Accessing a corrupted shared library 
			ELIBSCN = 81, // .lib section in a.out corrupted 
			ELIBMAX = 82, // Attempting to link in too many shared libraries 
			ELIBEXEC = 83, // Cannot exec a shared library directly 
			EILSEQ = 84, // Illegal byte sequence 
			ERESTART = 85, // Interrupted system call should be restarted 
			ESTRPIPE = 86, // Streams pipe error 
			EUSERS = 87, // Too many users 
			ENOTSOCK = 88, // Socket operation on non-socket 
			EDESTADDRREQ = 89, // Destination address required 
			EMSGSIZE = 90, // Message too long 
			EPROTOTYPE = 91, // Protocol wrong type for socket 
			ENOPROTOOPT = 92, // Protocol not available 
			EPROTONOSUPPORT = 93, // Protocol not supported 
			ESOCKTNOSUPPORT = 94, // Socket type not supported 
			EOPNOTSUPP = 95, // Operation not supported on transport endpoint 
			EPFNOSUPPORT = 96, // Protocol family not supported 
			EAFNOSUPPORT = 97, // Address family not supported by protocol 
			EADDRINUSE = 98, // Address already in use 
			EADDRNOTAVAIL = 99, // Cannot assign requested address 
			ENETDOWN = 100, // Network is down 
			ENETUNREACH = 101, // Network is unreachable 
			ENETRESET = 102, // Network dropped connection because of reset 
			ECONNABORTED = 103, // Software caused connection abort 
			ECONNRESET = 104, // Connection reset by peer 
			ENOBUFS = 105, // No buffer space available 
			EISCONN = 106, // Transport endpoint is already connected 
			ENOTCONN = 107, // Transport endpoint is not connected 
			ESHUTDOWN = 108, // Cannot send after transport endpoint shutdown 
			ETOOMANYREFS = 109, // Too many references: cannot splice 
			ETIMEDOUT = 110, // Connection timed out 
			ECONNREFUSED = 111, // Connection refused 
			EHOSTDOWN = 112, // Host is down 
			EHOSTUNREACH = 113, // No route to host 
			EALREADY = 114, // Operation already in progress 
			EINPROGRESS = 115, // Operation now in progress 
			ESTALE = 116, // Stale NFS file handle 
			EUCLEAN = 117, // Structure needs cleaning 
			ENOTNAM = 118, // Not a XENIX named type file 
			ENAVAIL = 119, // No XENIX semaphores available 
			EISNAM = 120, // Is a named type file 
			EREMOTEIO = 121, // Remote I/O error 
			EDQUOT = 122, // Quota exceeded 

			ENOMEDIUM = 123, // No medium found 
			EMEDIUMTYPE = 124, // Wrong medium type 

			ECANCELED = 125,
			ENOKEY = 126,
			EKEYEXPIRED = 127,
			EKEYREVOKED = 128,
			EKEYREJECTED = 129,

			EOWNERDEAD = 130,
			ENOTRECOVERABLE = 131,

			// OS X-specific values: OS X value + 1000
			EPROCLIM = 1067, // Too many processes
			EBADRPC = 1072, // RPC struct is bad
			ERPCMISMATCH = 1073,    // RPC version wrong
			EPROGUNAVAIL = 1074,    // RPC prog. not avail
			EPROGMISMATCH = 1075,   // Program version wrong
			EPROCUNAVAIL = 1076,    // Bad procedure for program
			EFTYPE = 1079,  // Inappropriate file type or format
			EAUTH = 1080,   // Authentication error
			ENEEDAUTH = 1081,   // Need authenticator
			EPWROFF = 1082, // Device power is off
			EDEVERR = 1083, // Device error, e.g. paper out
			EBADEXEC = 1085,    // Bad executable
			EBADARCH = 1086,    // Bad CPU type in executable
			ESHLIBVERS = 1087,  // Shared library version mismatch
			EBADMACHO = 1088,   // Malformed Macho file
			ENOATTR = 1093, // Attribute not found
			ENOPOLICY = 1103,   // No such policy registered
		}
	}
}






namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeWindowsPlatform : IDetourNativePlatform
	{
		private readonly IDetourNativePlatform Inner;

		public DetourNativeWindowsPlatform(IDetourNativePlatform inner)
		{
			Inner = inner;
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// READWRITE causes an AccessViolationException / TargetInvocationException.
			if (!VirtualProtect(src, (IntPtr)size, PAGE.EXECUTE_READWRITE, out _))
			{
				throw LogAllSections(Marshal.GetLastWin32Error(), "MakeWriteable", src, size);
			}
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			if (!VirtualProtect(src, (IntPtr)size, PAGE.EXECUTE_READWRITE, out _))
			{
				throw LogAllSections(Marshal.GetLastWin32Error(), "MakeExecutable", src, size);
			}
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			if (!VirtualProtect(src, (IntPtr)size, PAGE.EXECUTE_READWRITE, out _))
			{
				throw LogAllSections(Marshal.GetLastWin32Error(), "MakeExecutable", src, size);
			}
		}

		public void FlushICache(IntPtr src, uint size)
		{
			if (!FlushInstructionCache(GetCurrentProcess(), src, (UIntPtr)size))
			{
				throw LogAllSections(Marshal.GetLastWin32Error(), "FlushICache", src, size);
			}
		}

		private Exception LogAllSections(int error, string from, IntPtr src, uint size)
		{
			Exception ex = new Win32Exception(error);
			if (MMDbgLog.Writer == null)
				return ex;

			MMDbgLog.Log($"{from} failed for 0x{(long)src:X16} + {size} - logging all memory sections");
			MMDbgLog.Log($"reason: {ex.Message}");

			try
			{
				IntPtr proc = GetCurrentProcess();
				IntPtr addr = (IntPtr)0x00000000000010000;
				int i = 0;
				while (true)
				{
					if (VirtualQueryEx(proc, addr, out MEMORY_BASIC_INFORMATION infoBasic, sizeof(MEMORY_BASIC_INFORMATION)) == 0)
						break;

					ulong srcL = (ulong)src;
					ulong srcR = srcL + size;
					ulong infoL = (ulong)infoBasic.BaseAddress;
					ulong infoR = infoL + (ulong)infoBasic.RegionSize;
					bool overlap = infoL <= srcR && srcL <= infoR;

					MMDbgLog.Log($"{(overlap ? "*" : "-")} #{i++}");
					MMDbgLog.Log($"addr: 0x{(long)infoBasic.BaseAddress:X16}");
					MMDbgLog.Log($"size: 0x{(long)infoBasic.RegionSize:X16}");
					MMDbgLog.Log($"aaddr: 0x{(long)infoBasic.AllocationBase:X16}");
					MMDbgLog.Log($"state: {infoBasic.State}");
					MMDbgLog.Log($"type: {infoBasic.Type}");
					MMDbgLog.Log($"protect: {infoBasic.Protect}");
					MMDbgLog.Log($"aprotect: {infoBasic.AllocationProtect}");

					try
					{
						IntPtr addrPrev = addr;
						addr = (IntPtr)((ulong)infoBasic.BaseAddress + (ulong)infoBasic.RegionSize);
						if ((ulong)addr <= (ulong)addrPrev)
							break;
					}
					catch (OverflowException)
					{
						MMDbgLog.Log("overflow");
						break;
					}
				}

			}
			catch
			{
				throw ex;
			}
			return ex;
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			return Inner.Create(from, to, type);
		}

		public void Free(NativeDetourData detour)
		{
			Inner.Free(detour);
		}

		public void Apply(NativeDetourData detour)
		{
			Inner.Apply(detour);
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			Inner.Copy(src, dst, type);
		}

		public IntPtr MemAlloc(uint size)
		{
			return Inner.MemAlloc(size);
		}

		public void MemFree(IntPtr ptr)
		{
			Inner.MemFree(ptr);
		}

		[DllImport("kernel32.dll", SetLastError = true)]
		private static extern bool VirtualProtect(IntPtr lpAddress, IntPtr dwSize, PAGE flNewProtect, out PAGE lpflOldProtect);

		[DllImport("kernel32.dll", SetLastError = true)]
		private static extern IntPtr GetCurrentProcess();

		[DllImport("kernel32.dll", SetLastError = true)]
		private static extern bool FlushInstructionCache(IntPtr hProcess, IntPtr lpBaseAddress, UIntPtr dwSize);

		[DllImport("kernel32.dll", SetLastError = true)]
		private static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, int dwLength);

		[Flags]
		private enum PAGE : uint
		{
			UNSET,
			NOACCESS =
				0b00000000000000000000000000000001,
			READONLY =
				0b00000000000000000000000000000010,
			READWRITE =
				0b00000000000000000000000000000100,
			WRITECOPY =
				0b00000000000000000000000000001000,
			EXECUTE =
				0b00000000000000000000000000010000,
			EXECUTE_READ =
				0b00000000000000000000000000100000,
			EXECUTE_READWRITE =
				0b00000000000000000000000001000000,
			EXECUTE_WRITECOPY =
				0b00000000000000000000000010000000,
			GUARD =
				0b00000000000000000000000100000000,
			NOCACHE =
				0b00000000000000000000001000000000,
			WRITECOMBINE =
				0b00000000000000000000010000000000,
		}

		private enum MEM : uint
		{
			UNSET,
			MEM_COMMIT =
				0b00000000000000000001000000000000,
			MEM_RESERVE =
				0b00000000000000000010000000000000,
			MEM_FREE =
				0b00000000000000010000000000000000,
			MEM_PRIVATE =
				0b00000000000000100000000000000000,
			MEM_MAPPED =
				0b00000000000001000000000000000000,
			MEM_IMAGE =
				0b00000001000000000000000000000000,
		}

		[StructLayout(LayoutKind.Sequential)]
		private struct MEMORY_BASIC_INFORMATION
		{
			public IntPtr BaseAddress;
			public IntPtr AllocationBase;
			public PAGE AllocationProtect;
			public IntPtr RegionSize;
			public MEM State;
			public PAGE Protect;
			public MEM Type;
		}

	}
}





namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	unsafe class DetourNativeX86Platform : IDetourNativePlatform
	{
		public enum DetourType : byte
		{
			Rel32,
			Abs32,
			Abs64,
			Abs64Split
		}
		private static readonly uint[] DetourSizes = {
			1 + 4,
			1 + 4 + 1,
			1 + 1 + 4 + 8,
			1 + 1 + 4
		};

		private static bool Is32Bit(long to)
			// JMP rel32 is "sign extended to 64-bits"
			=> (((ulong)to) & 0x000000007FFFFFFFUL) == ((ulong)to);

		private static DetourType GetDetourType(IntPtr from, IntPtr to, ref IntPtr extra)
		{
			long rel = (long)to - ((long)from + 5);
			/* Note: Check -rel as well, as f.e. FFFFFFFFF58545C0 -> FFFFFFFFF5827030 ends up with rel = FFFFFFFFFFFD2A6B
             * This is critical for some 32-bit environments, as in that case, an Abs64 detour gets emitted on x86 instead!
             * Checking for -rel ensures that backwards jumps are handled properly as well, using Rel32 detours.
             */
			if (Is32Bit(rel) || Is32Bit(-rel))
			{
				unsafe
				{
					if (*((byte*)from + 5) != 0x5f) // because Rel32 uses an E9 jump, the byte that would be immediately following the jump
						return DetourType.Rel32;     //   must not be 0x5f, otherwise it would be picked up by DetourRuntimeNETPlatform line 130
				}
			}

			if (Is32Bit((long)to))
				return DetourType.Abs32;

			// Sometimes we can use runtime-specific tricks to allocate some memory close to the from pointer.
			// This only works for managed methods, but it helps with avoiding overwriting adjacent memory.
			if ((DetourHelper.Runtime?.TryMemAllocScratchCloseTo(from, out extra, 8) ?? 0) >= 8)
			{
				rel = (long)extra - ((long)from + 6);
				if (Is32Bit(rel) || Is32Bit(-rel))
					return DetourType.Abs64Split;
			}

			return DetourType.Abs64;
		}

		public NativeDetourData Create(IntPtr from, IntPtr to, byte? type)
		{
			NativeDetourData detour = new NativeDetourData
			{
				Method = from,
				Target = to
			};
			detour.Size = DetourSizes[detour.Type = type ?? (byte)GetDetourType(from, to, ref detour.Extra)];
			// Console.WriteLine($"{nameof(DetourNativeX86Platform)} create: {(DetourType) detour.Type} 0x{detour.Method.ToString("X16")} + 0x{detour.Size.ToString("X8")} -> 0x{detour.Target.ToString("X16")}");
			return detour;
		}

		public void Free(NativeDetourData detour)
		{
			if ((DetourType)detour.Type == DetourType.Abs64Split)
			{
				// There's currently no way to free the scratch mem.
			}
		}

		public void Apply(NativeDetourData detour)
		{
			int offs = 0;

			// Console.WriteLine($"{nameof(DetourNativeX86Platform)} apply: {(DetourType) detour.Type} 0x{detour.Method.ToString("X16")} -> 0x{detour.Target.ToString("X16")}");
			switch ((DetourType)detour.Type)
			{
				case DetourType.Rel32:
					// JMP DeltaNextInstr
					detour.Method.Write(ref offs, (byte)0xE9);
					detour.Method.Write(ref offs, (uint)(int)(
						(long)detour.Target - ((long)detour.Method + offs + sizeof(uint))
					));
					break;

				case DetourType.Abs32:
					// Registerless PUSH + RET "absolute jump."
					// PUSH <to>
					detour.Method.Write(ref offs, (byte)0x68);
					detour.Method.Write(ref offs, (uint)detour.Target);
					// RET
					detour.Method.Write(ref offs, (byte)0xC3);
					break;

				case DetourType.Abs64:
				case DetourType.Abs64Split:
					// PUSH can only push 32-bit values and MOV RAX, <to>; JMP RAX voids RAX.
					// Registerless JMP [rip+0] + data "absolute jump."
					// JMP [rip+0]
					detour.Method.Write(ref offs, (byte)0xFF);
					detour.Method.Write(ref offs, (byte)0x25);
					if ((DetourType)detour.Type == DetourType.Abs64Split)
					{
						detour.Method.Write(ref offs, (uint)(int)(
							(long)detour.Extra - ((long)detour.Method + offs + sizeof(uint))
						));
						// <to>
						offs = 0;
						detour.Extra.Write(ref offs, (ulong)detour.Target);
					}
					else
					{
						detour.Method.Write(ref offs, (uint)0x00000000);
						// <to>
						detour.Method.Write(ref offs, (ulong)detour.Target);
					}
					break;

				default:
					throw new NotSupportedException($"Unknown detour type {detour.Type}");
			}
		}

		public void Copy(IntPtr src, IntPtr dst, byte type)
		{
			switch ((DetourType)type)
			{
				case DetourType.Rel32:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(byte*)((long)dst + 4) = *(byte*)((long)src + 4);
					break;

				case DetourType.Abs32:
				case DetourType.Abs64Split:
					*(uint*)((long)dst) = *(uint*)((long)src);
					*(ushort*)((long)dst + 4) = *(ushort*)((long)src + 4);
					break;

				case DetourType.Abs64:
					*(ulong*)((long)dst) = *(ulong*)((long)src);
					*(uint*)((long)dst + 8) = *(uint*)((long)src + 8);
					*(ushort*)((long)dst + 12) = *(ushort*)((long)src + 12);
					break;

				default:
					throw new NotSupportedException($"Unknown detour type {type}");
			}
		}

		public void MakeWritable(IntPtr src, uint size)
		{
			// no-op.
		}

		public void MakeExecutable(IntPtr src, uint size)
		{
			// no-op.
		}

		public void MakeReadWriteExecutable(IntPtr src, uint size)
		{
			// no-op.
		}

		public void FlushICache(IntPtr src, uint size)
		{
			// On X86, apparently a call / ret is enough to flush the entire cache.
		}

		public IntPtr MemAlloc(uint size)
		{
			return Marshal.AllocHGlobal((int)size);
		}

		public void MemFree(IntPtr ptr)
		{
			Marshal.FreeHGlobal(ptr);
		}
	}
}








#if !NET35

#endif

namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	abstract class DetourRuntimeILPlatform : IDetourRuntimePlatform
	{
		protected abstract RuntimeMethodHandle GetMethodHandle(MethodBase method);

		private readonly GlueThiscallStructRetPtrOrder GlueThiscallStructRetPtr;

		// The following dicts are needed to prevent the GC from collecting DynamicMethods without any visible references.
		// PinnedHandles is also used in certain situations as a fallback when getting a method from a handle may not work normally.
#if NET35
        protected Dictionary<MethodBase, PrivateMethodPin> PinnedMethods = new Dictionary<MethodBase, PrivateMethodPin>();
        protected Dictionary<RuntimeMethodHandle, PrivateMethodPin> PinnedHandles = new Dictionary<RuntimeMethodHandle, PrivateMethodPin>();
#else
		protected ConcurrentDictionary<MethodBase, PrivateMethodPin> PinnedMethods = new ConcurrentDictionary<MethodBase, PrivateMethodPin>();
		protected ConcurrentDictionary<RuntimeMethodHandle, PrivateMethodPin> PinnedHandles = new ConcurrentDictionary<RuntimeMethodHandle, PrivateMethodPin>();
#endif

		public abstract bool OnMethodCompiledWillBeCalled { get; }
		public abstract event OnMethodCompiledEvent OnMethodCompiled;

		private IntPtr ReferenceNonDynamicPoolPtr;
		private IntPtr ReferenceDynamicPoolPtr;

		public DetourRuntimeILPlatform()
		{
			// Perform a selftest if this runtime requires special handling for instance methods returning structs.
			// This is documented behavior for coreclr, but affects other runtimes (i.e. mono) as well!
			// Specifically, this should affect all __thiscalls

			// Use reflection to make sure that the selftest isn't optimized away.
			// Delegates are quite reliable for this job.

			MethodInfo selftestGetRefPtr = typeof(DetourRuntimeILPlatform).GetMethod("_SelftestGetRefPtr", BindingFlags.NonPublic | BindingFlags.Instance);
			MethodInfo selftestGetRefPtrHook = typeof(DetourRuntimeILPlatform).GetMethod("_SelftestGetRefPtrHook", BindingFlags.NonPublic | BindingFlags.Static);
			_HookSelftest(selftestGetRefPtr, selftestGetRefPtrHook);

			IntPtr selfPtr = ((Func<IntPtr>)Delegate.CreateDelegate(typeof(Func<IntPtr>), this, selftestGetRefPtr))();

			MethodInfo selftestGetStruct = typeof(DetourRuntimeILPlatform).GetMethod("_SelftestGetStruct", BindingFlags.NonPublic | BindingFlags.Instance);
			MethodInfo selftestGetStructHook = typeof(DetourRuntimeILPlatform).GetMethod("_SelftestGetStructHook", BindingFlags.NonPublic | BindingFlags.Static);
			_HookSelftest(selftestGetStruct, selftestGetStructHook);

			unsafe
			{
				fixed (GlueThiscallStructRetPtrOrder* orderPtr = &GlueThiscallStructRetPtr)
				{
					((Func<IntPtr, IntPtr, IntPtr, _SelftestStruct>)Delegate.CreateDelegate(typeof(Func<IntPtr, IntPtr, IntPtr, _SelftestStruct>), this, selftestGetStruct))((IntPtr)orderPtr, (IntPtr)orderPtr, selfPtr);
				}
			}

			// Get some reference (not reference as in ref but reference as in "to compare against") dyn and non-dyn method pointers.
			Pin(selftestGetRefPtr);
			ReferenceNonDynamicPoolPtr = GetNativeStart(selftestGetRefPtr);

			if (DynamicMethodDefinition.IsDynamicILAvailable)
			{
				MethodBase scratch;
				using (DynamicMethodDefinition copy = new DynamicMethodDefinition(_MemAllocScratchDummy))
				{
					copy.Name = $"MemAllocScratch<Reference>";
					scratch = DMDEmitDynamicMethodGenerator.Generate(copy);
				}
				Pin(scratch);
				ReferenceDynamicPoolPtr = GetNativeStart(scratch);
			}
		}

		private void _HookSelftest(MethodInfo from, MethodInfo to)
		{
			Pin(from);
			Pin(to);
			NativeDetourData detour = DetourHelper.Native.Create(
				GetNativeStart(from),
				GetNativeStart(to),
				null
			);
			DetourHelper.Native.MakeWritable(detour);
			DetourHelper.Native.Apply(detour);
			DetourHelper.Native.MakeExecutable(detour);
			DetourHelper.Native.FlushICache(detour);
			DetourHelper.Native.Free(detour);
			// No need to undo the detour.
		}

		#region Selftests

		#region Selftest: Get reference ptr

		[MethodImpl(MethodImplOptions.NoInlining)]
		private IntPtr _SelftestGetRefPtr()
		{
			Console.Error.WriteLine("If you're reading this, the MonoMod.RuntimeDetour selftest failed.");
			throw new Exception("This method should've been detoured!");
		}

		private static unsafe IntPtr _SelftestGetRefPtrHook(IntPtr self)
		{
			// This is only needed to obtain a raw IntPtr to a reference object.
			return self;
		}

		#endregion

		#region Selftest: Struct

		// In 32-bit envs, struct must be 3 or 4+ bytes big.
		// In 64-bit envs, struct must be 3, 5, 6, 7 or 9+ bytes big.
#pragma warning disable CS0169
		private struct _SelftestStruct
		{
			private readonly byte A, B, C;
		}
#pragma warning restore CS0169

		[MethodImpl(MethodImplOptions.NoInlining)]
		private _SelftestStruct _SelftestGetStruct(IntPtr x, IntPtr y, IntPtr thisPtr)
		{
			Console.Error.WriteLine("If you're reading this, the MonoMod.RuntimeDetour selftest failed.");
			throw new Exception("This method should've been detoured!");
		}

		private static unsafe void _SelftestGetStructHook(IntPtr a, IntPtr b, IntPtr c, IntPtr d, IntPtr e)
		{
			// Normally, a = this, b = x, c = y, d = thisPtr, e = garbage

			// For the general selftest, x must be equal to y.
			// If b != c, b is probably pointing to the return buffer or this.
			if (b == c)
			{
				// Original order.
				*((GlueThiscallStructRetPtrOrder*)b) = GlueThiscallStructRetPtrOrder.Original;

			}
			else if (b == e)
			{
				// For mono in Unity 5.6.X, a = __ret, b = this, c = x, d = y, e = thisPtr
				*((GlueThiscallStructRetPtrOrder*)c) = GlueThiscallStructRetPtrOrder.RetThisArgs;

			}
			else
			{
				// For coreclr x64 __thiscall, a = this, b = __ret, c = x, d = y, e = thisPtr
				*((GlueThiscallStructRetPtrOrder*)c) = GlueThiscallStructRetPtrOrder.ThisRetArgs;

			}
		}

		#endregion

		#endregion

		protected virtual IntPtr GetFunctionPointer(MethodBase method, RuntimeMethodHandle handle)
			=> handle.GetFunctionPointer();

		protected virtual void PrepareMethod(MethodBase method, RuntimeMethodHandle handle)
			=> RuntimeHelpers.PrepareMethod(handle);

		protected virtual void PrepareMethod(MethodBase method, RuntimeMethodHandle handle, RuntimeTypeHandle[] instantiation)
			=> RuntimeHelpers.PrepareMethod(handle, instantiation);

		protected virtual void DisableInlining(MethodBase method, RuntimeMethodHandle handle)
		{
			// no-op. Not supported on all platforms, but throwing an exception doesn't make sense.
		}

		public virtual MethodBase GetIdentifiable(MethodBase method)
		{
#if NET35
            lock (PinnedMethods)
                return PinnedHandles.TryGetValue(GetMethodHandle(method), out PrivateMethodPin pin) ? pin.Pin.Method : method;
#else
			return PinnedHandles.TryGetValue(GetMethodHandle(method), out PrivateMethodPin pin) ? pin.Pin.Method : method;
#endif
		}

		public virtual MethodPinInfo GetPin(MethodBase method)
		{
#if NET35
            lock (PinnedMethods)
                return PinnedMethods.TryGetValue(method, out PrivateMethodPin pin) ? pin.Pin : default;
#else
			return PinnedMethods.TryGetValue(method, out PrivateMethodPin pin) ? pin.Pin : default;
#endif
		}

		public virtual MethodPinInfo GetPin(RuntimeMethodHandle handle)
		{
#if NET35
            lock (PinnedMethods)
                return PinnedHandles.TryGetValue(handle, out PrivateMethodPin pin) ? pin.Pin : default;
#else
			return PinnedHandles.TryGetValue(handle, out PrivateMethodPin pin) ? pin.Pin : default;
#endif
		}

		public virtual MethodPinInfo[] GetPins()
		{
#if NET35
            lock (PinnedMethods)
                return PinnedHandles.Values.Select(p => p.Pin).ToArray();
#else
			return PinnedHandles.Values.ToArray().Select(p => p.Pin).ToArray();
#endif
		}

		public virtual IntPtr GetNativeStart(MethodBase method)
		{
			method = GetIdentifiable(method);
			bool pinGot;
			PrivateMethodPin pin;
#if NET35
            lock (PinnedMethods)
#endif
			{
				pinGot = PinnedMethods.TryGetValue(method, out pin);
			}
			if (pinGot)
				return GetFunctionPointer(method, pin.Pin.Handle);
			return GetFunctionPointer(method, GetMethodHandle(method));
		}

		public virtual void Pin(MethodBase method)
		{
			method = GetIdentifiable(method);
#if NET35
            lock (PinnedMethods) {
                if (PinnedMethods.TryGetValue(method, out PrivateMethodPin pin)) {
                    pin.Pin.Count++;
                    return;
                }

                MethodBase m = method;
                pin = new PrivateMethodPin();
                pin.Pin.Count = 1;

#else
			Interlocked.Increment(ref PinnedMethods.GetOrAdd(method, m => {
				PrivateMethodPin pin = new PrivateMethodPin();
#endif

				pin.Pin.Method = m;
				RuntimeMethodHandle handle = pin.Pin.Handle = GetMethodHandle(m);
				PinnedHandles[handle] = pin;

				DisableInlining(method, handle);
				if (method.DeclaringType?.IsGenericType ?? false)
				{
					PrepareMethod(method, handle, method.DeclaringType.GetGenericArguments().Select(type => type.TypeHandle).ToArray());
				}
				else
				{
					PrepareMethod(method, handle);
				}

#if !NET35
				return pin;
#endif
			}
#if !NET35
			).Pin.Count);
#endif
		}

		public virtual void Unpin(MethodBase method)
		{
			method = GetIdentifiable(method);
#if NET35
            lock (PinnedMethods) {
                if (!PinnedMethods.TryGetValue(method, out PrivateMethodPin pin))
                    return;

                if (pin.Pin.Count <= 1) {
                    PinnedMethods.Remove(method);
                    PinnedHandles.Remove(pin.Pin.Handle);
                    return;
                }
                pin.Pin.Count--;
            }
#else
			if (!PinnedMethods.TryGetValue(method, out PrivateMethodPin pin))
				return;

			if (Interlocked.Decrement(ref pin.Pin.Count) <= 0)
			{
				PinnedMethods.TryRemove(method, out _);
				PinnedHandles.TryRemove(pin.Pin.Handle, out _);
			}
#endif
		}

		public MethodInfo CreateCopy(MethodBase method)
		{
			method = GetIdentifiable(method);
			if (method == null || (method.GetMethodImplementationFlags() & (System.Reflection.MethodImplAttributes.OPTIL | System.Reflection.MethodImplAttributes.Native | System.Reflection.MethodImplAttributes.Runtime)) != 0)
			{
				throw new InvalidOperationException($"Uncopyable method: {method?.ToString() ?? "NULL"}");
			}

			using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(method))
				return dmd.Generate();
		}

		public bool TryCreateCopy(MethodBase method, out MethodInfo dm)
		{
			method = GetIdentifiable(method);
			if (method == null || (method.GetMethodImplementationFlags() & (System.Reflection.MethodImplAttributes.OPTIL | System.Reflection.MethodImplAttributes.Native | System.Reflection.MethodImplAttributes.Runtime)) != 0)
			{
				dm = null;
				return false;
			}

			try
			{
				dm = CreateCopy(method);
				return true;
			}
			catch
			{
				dm = null;
				return false;
			}
		}

		public MethodBase GetDetourTarget(MethodBase from, MethodBase to)
		{
			to = GetIdentifiable(to);

			MethodInfo dm = null;

			if (GlueThiscallStructRetPtr != GlueThiscallStructRetPtrOrder.Original &&
				from is MethodInfo fromInfo && !from.IsStatic &&
				to is MethodInfo toInfo && to.IsStatic &&
				fromInfo.ReturnType == toInfo.ReturnType &&
				fromInfo.ReturnType.IsValueType)
			{

				int size = fromInfo.ReturnType.GetManagedSize();
				// This assumes that 8 bytes long structs work fine in 64-bit envs but not 32-bit envs.
				if (size == 3 || size == 5 || size == 6 || size == 7 || size > IntPtr.Size)
				{
					Type thisType = from.GetThisParamType();
					Type retType = fromInfo.ReturnType.MakeByRefType(); // Refs are shiny pointers.

					int thisPos = 0;
					int retPos = 1;

					if (GlueThiscallStructRetPtr == GlueThiscallStructRetPtrOrder.RetThisArgs)
					{
						thisPos = 1;
						retPos = 0;
					}

					List<Type> argTypes = new List<Type> {
						thisType
					};
					argTypes.Insert(retPos, retType);

					argTypes.AddRange(from.GetParameters().Select(p => p.ParameterType));

					using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
						$"Glue:ThiscallStructRetPtr<{from.GetID(simple: true)},{to.GetID(simple: true)}>",
						typeof(void), argTypes.ToArray()
					))
					{
						ILProcessor il = dmd.GetILProcessor();

						// Load the return buffer address.
						il.Emit(OpCodes.Ldarg, retPos);

						// Invoke the target method with all remaining arguments.
						{
							il.Emit(OpCodes.Ldarg, thisPos);
							for (int i = 2; i < argTypes.Count; i++)
								il.Emit(OpCodes.Ldarg, i);
							il.Emit(OpCodes.Call, il.Body.Method.Module.ImportReference(to));
						}

						// Store the returned object to the return buffer.
						il.Emit(OpCodes.Stobj, il.Body.Method.Module.ImportReference(fromInfo.ReturnType));
						il.Emit(OpCodes.Ret);

						dm = dmd.Generate();
					}
				}
			}

			return dm ?? to;
		}

		public uint TryMemAllocScratchCloseTo(IntPtr target, out IntPtr ptr, int size)
		{
			/* We can create a new method that is of the same type (dynamic or non-dynamic) as the target method,
             * assume that it will be closer to it than a new method of the opposite type, and use it as a pseudo-malloc.
             *
             * This is only (kinda?) documented on mono so far.
             * See https://www.mono-project.com/docs/advanced/runtime/docs/memory-management/#memory-management-for-executable-code
             * It seems to also be observed on .NET Framework to some extent, although no pattern is determined yet. Maybe x86 debug?
             *
             * In the future, this might end up requiring and calling new native platform methods.
             * Ideally this should be moved into the native platform which then uses some form of VirtualAlloc / mmap hackery.
             *
             * This is quite ugly, especially because we have no direct control over the allocated memory location nor size.
             * -ade
             */

			if (size == 0 ||
				size > _MemAllocScratchDummySafeSize)
			{
				ptr = IntPtr.Zero;
				return 0;
			}

			const long GB = 1024 * 1024 * 1024;
			bool isNonDynamic = Math.Abs((long)target - (long)ReferenceNonDynamicPoolPtr) < GB;
			bool isDynamic = Math.Abs((long)target - (long)ReferenceDynamicPoolPtr) < GB;
			if (!isNonDynamic && !isDynamic)
			{
				ptr = IntPtr.Zero;
				return 0;
			}

			MethodBase scratch;
			using (DynamicMethodDefinition copy = new DynamicMethodDefinition(_MemAllocScratchDummy))
			{
				copy.Name = $"MemAllocScratch<{(long)target:X16}>";

				// On some versions of mono it is also possible to get dynamics close to non-dynamics by invoking before force-JITing.
				if (isDynamic)
					scratch = DMDEmitDynamicMethodGenerator.Generate(copy);
				else
					scratch = DMDCecilGenerator.Generate(copy);
			}

			Pin(scratch);
			ptr = GetNativeStart(scratch);
			DetourHelper.Native.MakeReadWriteExecutable(ptr, _MemAllocScratchDummySafeSize);
			return _MemAllocScratchDummySafeSize;
		}

		/* Random garbage method that should JIT into enough memory for us to write arbitrary data to,
         * but not too much for it to become wasteful once it's called often.
         * Use https://sharplab.io/ to estimate the footprint of the dummy when modifying it.
         * Make sure to measure both release and debug mode AND both x86 and x64 JIT results!
         * Neither mono nor ARM are options on sharplab.io, but hopefully it'll be enough as well...
         * Note that it MUST be public as there have been reported cases of visibility checks kicking in!
         * -ade
         */
		// Lowest measured so far: ret @ 0x19 on .NET Core x64 Release.
		protected static readonly uint _MemAllocScratchDummySafeSize = 16;
		protected static readonly MethodInfo _MemAllocScratchDummy =
			typeof(DetourRuntimeILPlatform).GetMethod(nameof(MemAllocScratchDummy), BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
		public static int MemAllocScratchDummy(int a, int b)
		{
			if (a >= 1024 && b >= 1024)
				return a + b;
			return MemAllocScratchDummy(a + b, b + 1);
		}

		protected class PrivateMethodPin
		{
			public MethodPinInfo Pin = new MethodPinInfo();
		}

		public struct MethodPinInfo
		{
			public int Count;
			public MethodBase Method;
			public RuntimeMethodHandle Handle;

			public override string ToString()
			{
				return $"(MethodPinInfo: {Count}, {Method}, 0x{(long)Handle.Value:X})";
			}
		}

		private enum GlueThiscallStructRetPtrOrder
		{
			Original,
			ThisRetArgs,
			RetThisArgs
		}
	}
}








namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	class DetourRuntimeMonoPlatform : DetourRuntimeILPlatform
	{
		private static readonly object[] _NoArgs = new object[0];

		private static readonly MethodInfo _DynamicMethod_CreateDynMethod =
			typeof(DynamicMethod).GetMethod("CreateDynMethod", BindingFlags.NonPublic | BindingFlags.Instance);

		private static readonly FieldInfo _DynamicMethod_mhandle =
			typeof(DynamicMethod).GetField("mhandle", BindingFlags.NonPublic | BindingFlags.Instance);

		public override bool OnMethodCompiledWillBeCalled => false;
#pragma warning disable CS0067 // Event never fired
		public override event OnMethodCompiledEvent OnMethodCompiled;
#pragma warning restore CS0067

		protected override RuntimeMethodHandle GetMethodHandle(MethodBase method)
		{
			// Compile the method handle before getting our hands on the final method handle.
			// Note that Mono can return RuntimeMethodInfo instead of DynamicMethod in some places, thus bypassing this.
			// Let's assume that the method was already compiled ahead of this method call if that is the case.
			if (method is DynamicMethod)
			{
				_DynamicMethod_CreateDynMethod?.Invoke(method, _NoArgs);
				if (_DynamicMethod_mhandle != null)
					return (RuntimeMethodHandle)_DynamicMethod_mhandle.GetValue(method);
			}

			return method.MethodHandle;
		}

		protected override unsafe void DisableInlining(MethodBase method, RuntimeMethodHandle handle)
		{
			// https://github.com/mono/mono/blob/34dee0ea4e969d6d5b37cb842fc3b9f73f2dc2ae/mono/metadata/class-internals.h#L64
			ushort* iflags = (ushort*)((long)handle.Value + 2);
			*iflags |= (ushort)MethodImplOptions.NoInlining;
		}
	}

}










namespace MonoMod.RuntimeDetour.Platforms
{
	// This is based on the Core 3.0 implementation because they are nearly identical, save for how to get the GUID
#if !MONOMOD_INTERNAL
	public
#endif
	class DetourRuntimeNET50Platform : DetourRuntimeNETCore30Platform
	{
		// As of .NET 5, this GUID is found at src/coreclr/src/inc/corinfo.h as JITEEVersionIdentifier
		public static new readonly Guid JitVersionGuid = new Guid("a5eec3a4-4176-43a7-8c2b-a05b551d4f49");
	}
}
















namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	class DetourRuntimeNETCore30Platform : DetourRuntimeNETCorePlatform
	{
		// The JitVersionGuid is the same for Core 3.0 and 3.1
		public static readonly Guid JitVersionGuid = new Guid("d609bed1-7831-49fc-bd49-b6f054dd4d46");

		protected override unsafe void DisableInlining(MethodBase method, RuntimeMethodHandle handle)
		{
			// https://github.com/dotnet/runtime/blob/89965be3ad2be404dc82bd9e688d5dd2a04bcb5f/src/coreclr/src/vm/method.hpp#L178
			// mdcNotInline = 0x2000
			// References to RuntimeMethodHandle (CORINFO_METHOD_HANDLE) pointing to MethodDesc
			// can be traced as far back as https://ntcore.com/files/netint_injection.htm

			const int offset =
				2 // UINT16 m_wFlags3AndTokenRemainder
			  + 1 // BYTE m_chunkIndex
			  + 1 // BYTE m_chunkIndex
			  + 2 // WORD m_wSlotNumber
			  ;
			ushort* m_wFlags = (ushort*)(((byte*)handle.Value) + offset);
			*m_wFlags |= 0x2000;
		}

		private d_compileMethod GetCompileMethod(IntPtr jit)
			=> ReadObjectVTable(jit, VTableIndex_ICorJitCompiler_compileMethod).AsDelegate<d_compileMethod>();

		private unsafe d_compileMethod our_compileMethod;
		private IntPtr real_compileMethodPtr;
		private d_compileMethod real_compileMethod;

		public override bool OnMethodCompiledWillBeCalled => true;

		protected override unsafe void InstallJitHooks(IntPtr jit)
		{
			SetupJitHookHelpers();
			real_compileMethod = GetCompileMethod(jit);

			our_compileMethod = CompileMethodHook;
			IntPtr our_compileMethodPtr = Marshal.GetFunctionPointerForDelegate(our_compileMethod);

			// Create a native trampoline to pre-JIT the hook itself
			{
				NativeDetourData trampolineData = CreateNativeTrampolineTo(our_compileMethodPtr);
				d_compileMethod trampoline = trampolineData.Method.AsDelegate<d_compileMethod>();
				trampoline(IntPtr.Zero, IntPtr.Zero, new CORINFO_METHOD_INFO(), 0, out _, out _);
				FreeNativeTrampoline(trampolineData);
			}

			// Make sure we run the cctor before the hook to avoid wierdness
			_ = hookEntrancy;

			// Install the JIT hook
			IntPtr* vtableEntry = GetVTableEntry(jit, VTableIndex_ICorJitCompiler_compileMethod);
			DetourHelper.Native.MakeWritable((IntPtr)vtableEntry, (uint)IntPtr.Size);
			real_compileMethodPtr = *vtableEntry;
			*vtableEntry = our_compileMethodPtr;
		}

		private static NativeDetourData CreateNativeTrampolineTo(IntPtr target)
		{
			IntPtr mem = DetourHelper.Native.MemAlloc(64); // 64 bytes should be enough on all platforms
			NativeDetourData data = DetourHelper.Native.Create(mem, target);
			DetourHelper.Native.MakeWritable(data);
			DetourHelper.Native.Apply(data);
			DetourHelper.Native.MakeExecutable(data);
			DetourHelper.Native.FlushICache(data);
			return data;
		}

		private static void FreeNativeTrampoline(NativeDetourData data)
		{
			DetourHelper.Native.MakeWritable(data);
			DetourHelper.Native.MemFree(data.Method);
			DetourHelper.Native.Free(data);
		}

		private enum CorJitResult
		{
			CORJIT_OK = 0,
			// There are more, but I don't particularly care about them
		}

		[StructLayout(LayoutKind.Sequential)]
		private unsafe struct CORINFO_SIG_INST
		{
			public uint classInstCount;
			public IntPtr* classInst; // CORINFO_CLASS_HANDLE* // (representative, not exact) instantiation for class type variables in signature
			public uint methInstCount;
			public IntPtr* methInst; // CORINFO_CLASS_HANDLE* // (representative, not exact) instantiation for method type variables in signature
		}

		[StructLayout(LayoutKind.Sequential)]
		private struct CORINFO_SIG_INFO
		{
			public int callConv; // CorInfoCallConv
			public IntPtr retTypeClass; // CORINFO_CLASS_HANDLE // if the return type is a value class, this is its handle (enums are normalized)
			public IntPtr retTypeSigClass; // CORINFO_CLASS_HANDLE // returns the value class as it is in the sig (enums are not converted to primitives)
			public byte retType; // CorInfoType : 8
			public byte flags; // unsigned : 8 // used by IL stubs code
			public ushort numArgs; // unsigned : 16 
			public CORINFO_SIG_INST sigInst; // information about how type variables are being instantiated in generic code
			public IntPtr args; // CORINFO_ARG_LIST_HANDLE
			public IntPtr pSig; // COR_SIGNATURE*
			public uint sbSig;
			public IntPtr scope; // CORINFO_MODULE_HANDLE // passed to getArgClass
			public uint token; // mdToken (aka ULONG32 aka unsigned int)
		}

		[StructLayout(LayoutKind.Sequential)]
		private unsafe struct CORINFO_METHOD_INFO
		{
			public IntPtr ftn;   // CORINFO_METHOD_HANDLE
			public IntPtr scope; // CORINFO_MODULE_HANDLE
			public byte* ILCode;
			public uint ILCodeSize;
			public uint maxStack;
			public uint EHcount;
			public int options; // CorInfoOptions
			public int regionKind; // CorInfoRegionKind
			public CORINFO_SIG_INFO args;
			public CORINFO_SIG_INFO locals;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private unsafe delegate CorJitResult d_compileMethod(
			IntPtr thisPtr, // ICorJitCompiler*
			IntPtr corJitInfo, // ICorJitInfo*
			in CORINFO_METHOD_INFO methodInfo, // CORINFO_METHOD_INFO*
			uint flags,
			out byte* nativeEntry,
			out ulong nativeSizeOfCode
		);

		[ThreadStatic]
		private static int hookEntrancy = 0;
		private unsafe CorJitResult CompileMethodHook(
			IntPtr jit, // ICorJitCompiler*
			IntPtr corJitInfo, // ICorJitInfo*
			in CORINFO_METHOD_INFO methodInfo, // CORINFO_METHOD_INFO*
			uint flags,
			out byte* nativeEntry,
			out ulong nativeSizeOfCode)
		{

			nativeEntry = null;
			nativeSizeOfCode = 0;

			if (jit == IntPtr.Zero)
				return CorJitResult.CORJIT_OK;

			hookEntrancy++;
			try
			{

				/* We've silenced any exceptions thrown by this in the past but it turns out this can throw?!
                 * Let's hope that all runtimes we're hooking the JIT of know how to deal with this - oh wait, not all do!
                 * FIXME: Linux .NET Core pre-5.0 (and sometimes even 5.0) can die in real_compileMethod on invalid IL?!
                 * -ade
                 */
				CorJitResult result = real_compileMethod(jit, corJitInfo, methodInfo, flags, out nativeEntry, out nativeSizeOfCode);

				if (hookEntrancy == 1)
				{
					try
					{
						// This is the top level JIT entry point, do our custom stuff
						RuntimeTypeHandle[] genericClassArgs = null;
						RuntimeTypeHandle[] genericMethodArgs = null;

						if (methodInfo.args.sigInst.classInst != null)
						{
							genericClassArgs = new RuntimeTypeHandle[methodInfo.args.sigInst.classInstCount];
							for (int i = 0; i < genericClassArgs.Length; i++)
							{
								genericClassArgs[i] = GetTypeFromNativeHandle(methodInfo.args.sigInst.classInst[i]).TypeHandle;
							}
						}
						if (methodInfo.args.sigInst.methInst != null)
						{
							genericMethodArgs = new RuntimeTypeHandle[methodInfo.args.sigInst.methInstCount];
							for (int i = 0; i < genericMethodArgs.Length; i++)
							{
								genericMethodArgs[i] = GetTypeFromNativeHandle(methodInfo.args.sigInst.methInst[i]).TypeHandle;
							}
						}

						RuntimeTypeHandle declaringType = GetDeclaringTypeOfMethodHandle(methodInfo.ftn).TypeHandle;
						RuntimeMethodHandle method = CreateHandleForHandlePointer(methodInfo.ftn);

						JitHookCore(declaringType, method, (IntPtr)nativeEntry, nativeSizeOfCode, genericClassArgs, genericMethodArgs);
					}
					catch
					{
						// eat the exception so we don't accidentally bubble up to native code
					}
				}

				return result;
			}
			finally
			{
				hookEntrancy--;
			}
		}

		protected delegate object d_MethodHandle_GetLoaderAllocator(IntPtr methodHandle);
		protected delegate object d_CreateRuntimeMethodInfoStub(IntPtr methodHandle, object loaderAllocator);
		protected delegate RuntimeMethodHandle d_CreateRuntimeMethodHandle(object runtimeMethodInfo);
		protected delegate Type d_GetDeclaringTypeOfMethodHandle(IntPtr methodHandle);
		protected delegate Type d_GetTypeFromNativeHandle(IntPtr handle);

		protected RuntimeMethodHandle CreateHandleForHandlePointer(IntPtr handle)
			=> CreateRuntimeMethodHandle(CreateRuntimeMethodInfoStub(handle, MethodHandle_GetLoaderAllocator(handle)));

		protected d_MethodHandle_GetLoaderAllocator MethodHandle_GetLoaderAllocator;
		protected d_CreateRuntimeMethodInfoStub CreateRuntimeMethodInfoStub;
		protected d_CreateRuntimeMethodHandle CreateRuntimeMethodHandle;
		protected d_GetDeclaringTypeOfMethodHandle GetDeclaringTypeOfMethodHandle;
		protected d_GetTypeFromNativeHandle GetTypeFromNativeHandle;

		protected virtual void SetupJitHookHelpers()
		{
			Type Unsafe = typeof(object).Assembly.GetType("Internal.Runtime.CompilerServices.Unsafe");
			MethodInfo Unsafe_As = Unsafe.GetMethods().First(m => m.Name == "As" && m.ReturnType.IsByRef);

			const BindingFlags StaticNonPublic = BindingFlags.Static | BindingFlags.NonPublic;

			// GetLoaderAllocator should always be present
			{ // set up GetLoaderAllocator
				MethodInfo getLoaderAllocator = typeof(RuntimeMethodHandle).GetMethod("GetLoaderAllocator", StaticNonPublic);

				MethodInfo invokeWrapper;
				using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
						"MethodHandle_GetLoaderAllocator", typeof(object), new Type[] { typeof(IntPtr) }
					))
				{
					ILGenerator il = dmd.GetILGenerator();
					Type paramType = getLoaderAllocator.GetParameters().First().ParameterType;
					il.Emit(System.Reflection.Emit.OpCodes.Ldarga_S, 0);
					il.Emit(System.Reflection.Emit.OpCodes.Call, Unsafe_As.MakeGenericMethod(typeof(IntPtr), paramType));
					il.Emit(System.Reflection.Emit.OpCodes.Ldobj, paramType);
					il.Emit(System.Reflection.Emit.OpCodes.Call, getLoaderAllocator);
					il.Emit(System.Reflection.Emit.OpCodes.Ret);

					invokeWrapper = dmd.Generate();
				}

				MethodHandle_GetLoaderAllocator = invokeWrapper.CreateDelegate<d_MethodHandle_GetLoaderAllocator>();
			}

			{ // set up GetTypeFromNativeHandle
				MethodInfo getTypeFromHandleUnsafe = GetOrCreateGetTypeFromHandleUnsafe();
				GetTypeFromNativeHandle = getTypeFromHandleUnsafe.CreateDelegate<d_GetTypeFromNativeHandle>();
			}

			{ // set up GetDeclaringTypeOfMethodHandle
				Type methodHandleInternal = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodHandleInternal");
				MethodInfo getDeclaringType = typeof(RuntimeMethodHandle).GetMethod("GetDeclaringType", StaticNonPublic, null, new Type[] { methodHandleInternal }, null);

				MethodInfo invokeWrapper;
				using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
						"GetDeclaringTypeOfMethodHandle", typeof(Type), new Type[] { typeof(IntPtr) }
					))
				{
					ILGenerator il = dmd.GetILGenerator();
					il.Emit(System.Reflection.Emit.OpCodes.Ldarga_S, 0);
					il.Emit(System.Reflection.Emit.OpCodes.Call, Unsafe_As.MakeGenericMethod(typeof(IntPtr), methodHandleInternal));
					il.Emit(System.Reflection.Emit.OpCodes.Ldobj, methodHandleInternal);
					il.Emit(System.Reflection.Emit.OpCodes.Call, getDeclaringType);
					il.Emit(System.Reflection.Emit.OpCodes.Ret);

					invokeWrapper = dmd.Generate();
				}

				GetDeclaringTypeOfMethodHandle = invokeWrapper.CreateDelegate<d_GetDeclaringTypeOfMethodHandle>();
			}

			{ // set up CreateRuntimeMethodInfoStub
				Type[] runtimeMethodInfoStubCtorArgs = new Type[] { typeof(IntPtr), typeof(object) };
				Type runtimeMethodInfoStub = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodInfoStub");
				ConstructorInfo runtimeMethodInfoStubCtor = runtimeMethodInfoStub.GetConstructor(runtimeMethodInfoStubCtorArgs);

				MethodInfo runtimeMethodInfoStubCtorWrapper;
				using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
						"new RuntimeMethodInfoStub", runtimeMethodInfoStub, runtimeMethodInfoStubCtorArgs
					))
				{
					ILGenerator il = dmd.GetILGenerator();
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
					il.Emit(System.Reflection.Emit.OpCodes.Newobj, runtimeMethodInfoStubCtor);
					il.Emit(System.Reflection.Emit.OpCodes.Ret);

					runtimeMethodInfoStubCtorWrapper = dmd.Generate();
				}

				CreateRuntimeMethodInfoStub = runtimeMethodInfoStubCtorWrapper.CreateDelegate<d_CreateRuntimeMethodInfoStub>();
			}

			{ // set up CreateRuntimeMethodHandle
				ConstructorInfo ctor = typeof(RuntimeMethodHandle).GetConstructors(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).First();

				MethodInfo ctorWrapper;
				using (DynamicMethodDefinition dmd = new DynamicMethodDefinition(
						"new RuntimeMethodHandle", typeof(RuntimeMethodHandle), new Type[] { typeof(object) }
					))
				{
					ILGenerator il = dmd.GetILGenerator();
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);
					il.Emit(System.Reflection.Emit.OpCodes.Newobj, ctor);
					il.Emit(System.Reflection.Emit.OpCodes.Ret);

					ctorWrapper = dmd.Generate();
				}

				CreateRuntimeMethodHandle = ctorWrapper.CreateDelegate<d_CreateRuntimeMethodHandle>();
			}
		}

		private MethodInfo _getTypeFromHandleUnsafeMethod;
		private MethodInfo GetOrCreateGetTypeFromHandleUnsafe()
		{
			if (_getTypeFromHandleUnsafeMethod != null)
				return _getTypeFromHandleUnsafeMethod;

			Assembly assembly;

			const string MethodName = "GetTypeFromHandleUnsafe";

#if !CECIL0_9
			using (
#endif
			ModuleDefinition module = ModuleDefinition.CreateModule(
				"MonoMod.RuntimeDetour.Runtime.NETCore3+Helpers",
				new ModuleParameters()
				{
					Kind = ModuleKind.Dll,
				}
			)
#if CECIL0_9
            ;
#else
			)
#endif
			{
				TypeDefinition type = new TypeDefinition(
					"System",
					"Type",
					MC.TypeAttributes.Public | MC.TypeAttributes.Abstract
				)
				{
					BaseType = module.TypeSystem.Object
				};
				module.Types.Add(type);

				MethodDefinition method = new MethodDefinition(
					MethodName,
					MC.MethodAttributes.Static | MC.MethodAttributes.Public,
					module.ImportReference(typeof(Type))
				)
				{
					IsInternalCall = true
				};
				method.Parameters.Add(new ParameterDefinition(module.ImportReference(typeof(IntPtr))));
				type.Methods.Add(method);

				assembly = ReflectionHelper.Load(module);
			}

			MakeAssemblySystemAssembly(assembly);

			return _getTypeFromHandleUnsafeMethod = assembly.GetType("System.Type").GetMethod(MethodName);
		}

		private static FieldInfo _runtimeAssemblyPtrField = Type.GetType("System.Reflection.RuntimeAssembly").GetField("m_assembly", BindingFlags.Instance | BindingFlags.NonPublic);
		protected virtual unsafe void MakeAssemblySystemAssembly(Assembly assembly)
		{

			// RuntimeAssembly.m_assembly is a DomainAssembly*,
			// which contains an Assembly*,
			// which contains a PEAssembly*,
			// which is a subclass of PEFile
			// which has a `flags` field, with bit 0x01 representing 'system'

			const int PEFILE_SYSTEM = 0x01;

			IntPtr domAssembly = (IntPtr)_runtimeAssemblyPtrField.GetValue(assembly);

			// DomainAssembly in src/coreclr/src/vm/domainfile.h
			int domOffset =
				IntPtr.Size + // VTable ptr
							  // DomainFile
				IntPtr.Size + // PTR_AppDomain               m_pDomain;
				IntPtr.Size + // PTR_PEFile                  m_pFile;
				IntPtr.Size + // PTR_PEFile                  m_pOriginalFile;
				IntPtr.Size + // PTR_Module                  m_pModule;
				sizeof(int) + // FileLoadLevel               m_level; // FileLoadLevel is an enum with unspecified type; I assume it defaults to 'int' because that's what `enum class` does
				IntPtr.Size + // LOADERHANDLE                m_hExposedModuleObject;
				IntPtr.Size + // ExInfo* m_pError;
				sizeof(int) + // DWORD                    m_notifyflags;
				sizeof(int) + // BOOL                        m_loading; // no matter the actual size of this BOOL, the next member is a pointer, and we'd always be misaligned
				IntPtr.Size + // DynamicMethodTable * m_pDynamicMethodTable;
				IntPtr.Size + // class UMThunkHash *m_pUMThunkHash;
				sizeof(int) + // BOOL m_bDisableActivationCheck;
				sizeof(int) + // DWORD m_dwReasonForRejectingNativeImage;
							  // DomainAssembly
				IntPtr.Size + // LOADERHANDLE                            m_hExposedAssemblyObject;
				0; // here is our Assembly*

			if (IntPtr.Size == 8)
			{
				domOffset +=
					sizeof(int); // padding to align the next TADDR (which is a void*) (m_hExposedModuleObject)
			}

			IntPtr pAssembly = *(IntPtr*)(((byte*)domAssembly) + domOffset);

			// Assembly in src/coreclr/src/vm/assembly.hpp
			int pAssemOffset =
				IntPtr.Size + // PTR_BaseDomain        m_pDomain;
				IntPtr.Size + // PTR_ClassLoader       m_pClassLoader;
				IntPtr.Size + // PTR_MethodDesc        m_pEntryPoint;
				IntPtr.Size + // PTR_Module            m_pManifest;
				0; // here is out PEAssembly* (manifestFile)

			IntPtr peAssembly = *(IntPtr*)(((byte*)pAssembly) + pAssemOffset);

			// PEAssembly in src/coreclr/src/vm/pefile.h
			int peAssemOffset =
				IntPtr.Size + // VTable ptr
							  // PEFile
				IntPtr.Size + // PTR_PEImage              m_identity;
				IntPtr.Size + // PTR_PEImage              m_openedILimage;
				sizeof(int) + // BOOL                     m_MDImportIsRW_Debugger_Use_Only; // i'm pretty sure that these bools are sizeof(int)
				sizeof(int) + // Volatile<BOOL>           m_bHasPersistentMDImport;         // but they might not be, and it might vary (that would be a pain in the ass)
				IntPtr.Size + // IMDInternalImport       *m_pMDImport;
				IntPtr.Size + // IMetaDataImport2        *m_pImporter;
				IntPtr.Size + // IMetaDataEmit           *m_pEmitter;
				IntPtr.Size + // SimpleRWLock            *m_pMetadataLock;
				sizeof(int) + // Volatile<LONG>           m_refCount; // fuck C long
				+0; // here is out int (flags)

			int* flags = (int*)(((byte*)peAssembly) + peAssemOffset);
			*flags |= PEFILE_SYSTEM;
		}

		protected void HookPermanent(MethodBase from, MethodBase to)
		{
			Pin(from);
			Pin(to);
			HookPermanent(GetNativeStart(from), GetNativeStart(to));
		}
		protected void HookPermanent(IntPtr from, IntPtr to)
		{
			NativeDetourData detour = DetourHelper.Native.Create(
				from, to, null
			);
			DetourHelper.Native.MakeWritable(detour);
			DetourHelper.Native.Apply(detour);
			DetourHelper.Native.MakeExecutable(detour);
			DetourHelper.Native.FlushICache(detour);
			DetourHelper.Native.Free(detour);
			// No need to undo the detour.
		}
	}
}











namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	class DetourRuntimeNETCorePlatform : DetourRuntimeNETPlatform
	{

		// All of this stuff is for JIT hooking in RuntimeDetour so we can update hooks when a method is re-jitted
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate IntPtr d_getJit();
		private static d_getJit getJit;

		protected static IntPtr GetJitObject()
		{
			if (getJit == null)
			{
				// To make sure we get the right clrjit, we enumerate the process's modules and find the one 
				//   with the name we care about, then use its full path to gat a handle and load symbols.
				Process currentProc = Process.GetCurrentProcess();
				ProcessModule clrjitModule = currentProc.Modules.Cast<ProcessModule>()
					.FirstOrDefault(m => Path.GetFileNameWithoutExtension(m.FileName).EndsWith("clrjit", StringComparison.Ordinal));
				if (clrjitModule == null)
					throw new PlatformNotSupportedException();

				if (!DynDll.TryOpenLibrary(clrjitModule.FileName, out IntPtr clrjitPtr))
					throw new PlatformNotSupportedException();

				if (PlatformHelper.Is(MonoPlatform.Windows))
				{
					// we can use this check only on Windows, because only Windows actually has FilveVersionInfo
					// this is preferred because it checks the version of the JIT, rather than the runtime library
					//   which is what actually determines the layout.
					isNet5Jit = clrjitModule.FileVersionInfo.ProductMajorPart >= 5;
				}
				else
				{
					// this gets System.Private.CorLib's major version, which *should* match the runtime version
					// it is the only method we have at the moment to detect it on non-Windows platforms
					isNet5Jit = typeof(object).Assembly.GetName().Version.Major >= 5;
				}

				try
				{
					getJit = clrjitPtr.GetFunction(nameof(getJit)).AsDelegate<d_getJit>();
				}
				catch
				{
					DynDll.CloseLibrary(clrjitPtr);
					throw;
				}
			}

			return getJit();
		}

		private static bool isNet5Jit;

		protected static Guid GetJitGuid(IntPtr jit)
		{
			int getVersionIdentIndex = isNet5Jit ? vtableIndex_ICorJitCompiler_getVersionIdentifier_net5
												 : vtableIndex_ICorJitCompiler_getVersionIdentifier;
			d_getVersionIdentifier getVersionIdentifier = ReadObjectVTable(jit, getVersionIdentIndex)
				.AsDelegate<d_getVersionIdentifier>();
			getVersionIdentifier(jit, out Guid guid);
			return guid;
		}

		// The offset to use is determined in GetJitObject where other properties of the JIT are determined
		private const int vtableIndex_ICorJitCompiler_getVersionIdentifier = 4;
		private const int vtableIndex_ICorJitCompiler_getVersionIdentifier_net5 = 2;
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void d_getVersionIdentifier(
			IntPtr thisPtr, // ICorJitCompiler*
			out Guid versionIdentifier
		);

		protected virtual int VTableIndex_ICorJitCompiler_compileMethod => 0;

		protected static unsafe IntPtr* GetVTableEntry(IntPtr @object, int index)
			=> (*(IntPtr**)@object) + index;
		protected static unsafe IntPtr ReadObjectVTable(IntPtr @object, int index)
			=> *GetVTableEntry(@object, index);

		protected override void DisableInlining(MethodBase method, RuntimeMethodHandle handle)
		{
			// https://github.com/dotnet/runtime/blob/89965be3ad2be404dc82bd9e688d5dd2a04bcb5f/src/coreclr/src/vm/method.hpp#L178
			// mdcNotInline = 0x2000
			// References to RuntimeMethodHandle (CORINFO_METHOD_HANDLE) pointing to MethodDesc
			// can be traced as far back as https://ntcore.com/files/netint_injection.htm
		}

		protected virtual void InstallJitHooks(IntPtr jitObject) => throw new PlatformNotSupportedException();

		public override bool OnMethodCompiledWillBeCalled => false;
		public override event OnMethodCompiledEvent OnMethodCompiled;

		protected virtual void JitHookCore(
			RuntimeTypeHandle declaringType,
			RuntimeMethodHandle methodHandle,
			IntPtr methodBodyStart,
			ulong methodBodySize,
			RuntimeTypeHandle[] genericClassArguments,
			RuntimeTypeHandle[] genericMethodArguments
		)
		{
			try
			{
				Type declType = Type.GetTypeFromHandle(declaringType);
				if (genericClassArguments != null && declType.IsGenericTypeDefinition)
				{
					declType = declType.MakeGenericType(genericClassArguments.Select(Type.GetTypeFromHandle).ToArray());
				}
				MethodBase method = MethodBase.GetMethodFromHandle(methodHandle, declType.TypeHandle);
				// method is null for P/Invokes, ComImports and other dynamic interop methods.
				// Just to be 100% sure that it ISN'T an already known-but-"hidden" pinned method though...
				if (method == null)
				{
					method = GetPin(methodHandle).Method;
				}
				try
				{
					OnMethodCompiled?.Invoke(method, methodBodyStart, methodBodySize);
				}
				catch (Exception e)
				{
					MMDbgLog.Log($"Error executing OnMethodCompiled event: {e}");
				}
			}
			catch (Exception e)
			{
				MMDbgLog.Log($"Error in JitHookCore: {e}");
			}
		}

		public static DetourRuntimeNETCorePlatform Create()
		{
			try
			{
				IntPtr jit = GetJitObject();
				Guid jitGuid = GetJitGuid(jit);

				DetourRuntimeNETCorePlatform platform = null;

				if (jitGuid == DetourRuntimeNET50Platform.JitVersionGuid)
				{
					platform = new DetourRuntimeNET50Platform();
				}
				else if (jitGuid == DetourRuntimeNETCore30Platform.JitVersionGuid)
				{
					platform = new DetourRuntimeNETCore30Platform();
				}
				// TODO: add more known JIT GUIDs

				if (platform == null)
					return new DetourRuntimeNETCorePlatform();

				platform?.InstallJitHooks(jit);
				return platform;
			}
			catch (Exception e)
			{
				MMDbgLog.Log("Could not get JIT information for the runtime, falling out to the version without JIT hooks");
				MMDbgLog.Log($"Error: {e}");
			}

			return new DetourRuntimeNETCorePlatform();
		}
	}
}












namespace MonoMod.RuntimeDetour.Platforms
{
#if !MONOMOD_INTERNAL
	public
#endif
	class DetourRuntimeNETPlatform : DetourRuntimeILPlatform
	{
		private static readonly object[] _NoArgs = new object[0];

		private static readonly Type _RTDynamicMethod =
			typeof(DynamicMethod).GetNestedType("RTDynamicMethod", BindingFlags.NonPublic);
		private static readonly FieldInfo _RTDynamicMethod_m_owner =
			_RTDynamicMethod?.GetField("m_owner", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

		private static readonly FieldInfo _DynamicMethod_m_method =
			typeof(DynamicMethod).GetField("m_method", BindingFlags.NonPublic | BindingFlags.Instance);

		private static readonly MethodInfo _DynamicMethod_GetMethodDescriptor =
			typeof(DynamicMethod).GetMethod("GetMethodDescriptor", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly FieldInfo _RuntimeMethodHandle_m_value =
			typeof(RuntimeMethodHandle).GetField("m_value", BindingFlags.NonPublic | BindingFlags.Instance);

		private static readonly MethodInfo _RuntimeHelpers__CompileMethod =
			typeof(RuntimeHelpers).GetMethod("_CompileMethod", BindingFlags.NonPublic | BindingFlags.Static);
		private static readonly bool _RuntimeHelpers__CompileMethod_TakesIntPtr =
			_RuntimeHelpers__CompileMethod?.GetParameters()[0].ParameterType.FullName == "System.IntPtr";
		private static readonly bool _RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo =
			_RuntimeHelpers__CompileMethod?.GetParameters()[0].ParameterType.FullName == "System.IRuntimeMethodInfo";

		public override MethodBase GetIdentifiable(MethodBase method)
		{
			if (_RTDynamicMethod_m_owner != null && method.GetType() == _RTDynamicMethod)
				return (MethodBase)_RTDynamicMethod_m_owner.GetValue(method);
			return base.GetIdentifiable(method);
		}

		protected override RuntimeMethodHandle GetMethodHandle(MethodBase method)
		{
			// Compile the method handle before getting our hands on the final method handle.
			if (method is DynamicMethod dm)
			{
				if (_RuntimeHelpers__CompileMethod_TakesIntPtr)
				{
					// mscorlib 2.0.0.0
					_RuntimeHelpers__CompileMethod.Invoke(null, new object[] { ((RuntimeMethodHandle)_DynamicMethod_GetMethodDescriptor.Invoke(dm, _NoArgs)).Value });

				}
				else if (_RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo)
				{
					// mscorlib 4.0.0.0
					_RuntimeHelpers__CompileMethod.Invoke(null, new object[] { _RuntimeMethodHandle_m_value.GetValue(((RuntimeMethodHandle)_DynamicMethod_GetMethodDescriptor.Invoke(dm, _NoArgs))) });

				}
				else
				{
					// This should work just fine.
					// It abuses the fact that CreateDelegate first compiles the DynamicMethod, before creating the delegate and failing.
					// Only side effect: It introduces a possible deadlock in f.e. tModLoader, which adds a FirstChanceException handler.
					try
					{
						dm.CreateDelegate(typeof(MulticastDelegate));
					}
					catch
					{
					}
				}

				if (_DynamicMethod_m_method != null)
					return (RuntimeMethodHandle)_DynamicMethod_m_method.GetValue(method);
				if (_DynamicMethod_GetMethodDescriptor != null)
					return (RuntimeMethodHandle)_DynamicMethod_GetMethodDescriptor.Invoke(method, _NoArgs);
			}

			return method.MethodHandle;
		}

		protected override void DisableInlining(MethodBase method, RuntimeMethodHandle handle)
		{
			// This is not needed for .NET Framework - see DisableInliningTest.
		}

		protected override unsafe IntPtr GetFunctionPointer(MethodBase method, RuntimeMethodHandle handle)
		{
			MMDbgLog.Log($"mets: {method.GetID()}");
			MMDbgLog.Log($"meth: 0x{(long)handle.Value:X16}");
			MMDbgLog.Log($"getf: 0x{(long)handle.GetFunctionPointer():X16}");

			bool regenerated = false;

		ReloadFuncPtr:

			IntPtr ptr;

			if (method.IsVirtual && (method.DeclaringType?.IsValueType ?? false))
			{
				/* .NET has got TWO MethodDescs and thus TWO ENTRY POINTS for virtual struct methods (f.e. override ToString).
                 * More info: https://mattwarren.org/2017/08/02/A-look-at-the-internals-of-boxing-in-the-CLR/#unboxing-stub-creation
                 *
                 * Observations made so far:
                 * - GetFunctionPointer ALWAYS returns a pointer to the unboxing stub handle.
                 * - On x86, the "real" entry point is often found 8 bytes after the unboxing stub entry point.
                 * - Methods WILL be called INDIRECTLY using the pointer found in the "real" MethodDesc.
                 * - The "real" MethodDesc will be updated, which isn't an issue except that we can't patch the stub in time.
                 * - The "real" stub will stay untouched.
                 * - LDFTN RETURNS A POINTER TO THE "REAL" ENTRY POINT.
                 *
                 * Exceptions so far:
                 * - SOME interface methods seem to follow similar rules, but ldftn isn't enough.
                 * - Can't use GetBaseDefinition to check for interface methods as that holds up ALC unloading. (Mapping info is fine though...)
                 */
				MMDbgLog.Log($"ldfn: 0x{(long)method.GetLdftnPointer():X16}");
				bool interfaced = false;
				foreach (Type intf in method.DeclaringType.GetInterfaces())
				{
					if (method.DeclaringType.GetInterfaceMap(intf).TargetMethods.Contains(method))
					{
						interfaced = true;
						break;
					}
				}
				ptr = method.GetLdftnPointer();
				if (!interfaced)
				{
					return ptr;
				}

			}
			else
			{
				// Your typical method.
				ptr = base.GetFunctionPointer(method, handle);
			}

			/* Many (if not all) NGEN'd methods (f.e. those from mscorlib.ni.dll) are handled in a special manner.
             * When debugged using WinDbg, !dumpmd for the handle gives a different CodeAddr than ldftn or GetFunctionPointer.
             * When using !ip2md on the ldftn / GetFunctionPointer result, no MD is found.
             * There is only one MD, we're already accessing it, but we still can't access the "real" entry point.
             * Luckily a jmp to it exists within the stub returned by GetFunctionPointer.
             * Sadly detecting when to read it is... ugly, to say the least.
             * This pretty much acts as the reverse of DetourNative*Platform.Apply
             * Maybe this should be Native*Platform-ified in the future, but for now...
             */

			// IMPORTANT: IN SOME CIRCUMSTANCES, THIS CAN FIND ThePreStub AS THE ENTRY POINT.

			if (PlatformHelper.Is(MonoPlatform.ARM))
			{
				// TODO: Debug detouring NGEN'd methods on ARM.

			}
			else if (IntPtr.Size == 4)
			{
				int iptr = (int)ptr;
				// x86
				if (*(byte*)(iptr + 0x00) == 0xb8 && // mov ... (mscorlib_ni!???)
					*(byte*)(iptr + 0x05) == 0x90 && // nop
					*(byte*)(iptr + 0x06) == 0xe8 && // call ... (clr!PrecodeRemotingThunk)
					*(byte*)(iptr + 0x0b) == 0xe9 // jmp {DELTA}
				)
				{
					// delta = to - (from + 1 + sizeof(int))
					// to = delta + (from + 1 + sizeof(int))
					int from = iptr + 0x0b;
					int delta = *(int*)(from + 1);
					int to = delta + (from + 1 + sizeof(int));
					ptr = NotThePreStub(ptr, (IntPtr)to);
					MMDbgLog.Log($"ngen: 0x{(long)ptr:X8}");
					return ptr;
				}

				// .NET Core
				if (*(byte*)(iptr + 0x00) == 0xe9 && // jmp {DELTA}
					*(byte*)(iptr + 0x05) == 0x5f // pop rdi
				)
				{
					// delta = to - (from + 1 + sizeof(int))
					// to = delta + (from + 1 + sizeof(int))
					int from = iptr;
					int delta = *(int*)(from + 1);
					int to = delta + (from + 1 + sizeof(int));
					ptr = NotThePreStub(ptr, (IntPtr)to);
					MMDbgLog.Log($"ngen: 0x{(int)ptr:X8}");
					return ptr;
				}

			}
			else
			{
				long lptr = (long)ptr;
				// x64 .NET Framework
				if (*(uint*)(lptr + 0x00) == 0x74___c9_85_48 && // in reverse order: test rcx, rcx | je ...
					*(uint*)(lptr + 0x05) == 0x49___01_8b_48 && // in reverse order: rax, qword ptr [rcx] | mov ...
					*(uint*)(lptr + 0x12) == 0x74___c2_3b_49 && // in reverse order: cmp rax, r10 | je ...
					*(ushort*)(lptr + 0x17) == 0xb8_48 // in reverse order: mov {TARGET}
				)
				{
					ptr = NotThePreStub(ptr, (IntPtr)(*(ulong*)(lptr + 0x19)));
					MMDbgLog.Log($"ngen: 0x{(long)ptr:X16}");
					return ptr;
				}

				// FIXME: on Core, it seems that *every* method has this stub, not just NGEN'd methods
				//        It also seems to correctly find the body, but because ThePreStub is always -1,
				//          it never returns that.
				//        One consequence of this seems to be that re-JITting a method calling a patched
				//          method causes it to use a new stub, except not patched.

				// It seems that if there is *any* pause between the method being prepared, and this being
				//   called, there is a chance that the JIT will do something funky and reset the thunk for
				//   the method (which is what GetFunctionPointer gives) back to a call to PrecodeFixupThunk.
				// This can be observed by checking for the first byte being 0xe8 instead of 0xe9.
				// If this happens at the wrong moment, we won't get the opportunity to patch the actual method
				//   body because our only pointer to it will have been deleted.

				// In conclusion: *Do we need to disable re-JITing while patching?*

				// Correction for the above: It seems that .NET Core ALWAYS has one indirection before the method
				//   body, and that indirection is used as an easy way to call into the JIT when necessary. Also,
				//   the JIT never generates a call directly to ThePreStub, but instead generates a call to
				//   PrecodeFixupThunk which then calls ThePreStub.

				// x64 .NET Core
				if (*(byte*)(lptr + 0x00) == 0xe9 &&   // jmp {DELTA}
					*(byte*)(lptr + 0x05) == 0x5f      // pop rdi
				)
				{
					// delta = to - (from + 1 + sizeof(int))
					// to = delta + (from + 1 + sizeof(int))
					long from = lptr;
					int delta = *(int*)(from + 1);
					long to = delta + (from + 1 + sizeof(int));
					ptr = NotThePreStub(ptr, (IntPtr)to);
#if MONOMOD_RUNTIMEDETOUR_NET_SCAN_MANUAL
                    // This ain't enough though! Turns out if we stop here, ptr is in a region that can be free'd,
                    // while the *actual actual* method body can still remain in memory. What even is this limbo?
                    // Let's try to navigate out of here by using further guesswork.
                    lptr = (long) ptr;
                    if (*(ushort*) (lptr + 0x00)                == 0xb8_48 &&       // movabs rax, ???
                        ((*(uint*) (lptr + 0x0A)) & 0x00ffffff) == 0x__08_ff_66 &&  // dec WORD PTR [rax]
                        *(ushort*) (lptr + 0x0D)                == 0x85_0f          // jne {DELTA}
                    ) {
                        from = lptr;
                        delta = *(int*) (from + 0x0D + 2);
                        to = delta + (from + 0x0D + 2 + sizeof(int));
                        // Noticed this by sheer luck. Maybe a link to the coreclr source would be neat in the future tho.
                        if ((*(long*) ((long) handle.Value + 0x10)) == to ||
                            (*(long*) ((long) handle.Value + 0x18)) == to)
                            ptr = NotThePreStub(ptr, (IntPtr) to);
                    }
                    // Generics are pain.
                    if (*(byte*) (lptr + 0x01)      == 0xb8 &&      // movabs {last arg + 1}, {generic type handle}
                        *(ushort*) (lptr + 0x0A)    == 0xb8_48 &&   // movabs rax, {TARGET}
                        *(ushort*) (lptr + 0x14)    == 0xe0_ff      // jmp rax
                    ) {
                        from = lptr;
                        long typeHandle = *(long*) (from + 0x00 + 2);
                        to = *(long*) (from + 0x0A + 2);
                        // Yet another coincidence to add to the "find in coreclr src please" list.
                        if (method.DeclaringType.TypeHandle.Value == (IntPtr) typeHandle)
                            ptr = NotThePreStub(ptr, (IntPtr) to);
                    }
#endif
#if MONOMOD_RUNTIMEDETOUR_NET_SCAN_AUTO
					// And because we don't know what else awaits us, let's auto-scan!
					for (int scan = 0; scan < 16; scan++)
					{
						lptr = (long)ptr + scan;
						if (*(ushort*)(lptr + 0x00) == 0xb8_48 &&   // movabs rax, {PTR}
							*(ushort*)(lptr + 0x0A) == 0xe0_ff      // jmp rax
						)
						{
							to = *(long*)(lptr + 0x02);
							ptr = NotThePreStub(ptr, (IntPtr)to);
							scan = -1;
							continue;
						}
						if ((*(ushort*)(lptr + 0x00) & 0xfff0) == 0xb8_40 &&  // movabs ??1, ???
							((*(uint*)(lptr + 0x0A)) & 0x00f0ffff) == 0x__00_ff_66 &&  // dec WORD PTR [??1]
							*(ushort*)(lptr + 0x0D) == 0x85_0f &&  // jne {DELTA}
							(*(byte*)(lptr + 0x00) & 0x0f) == (*(byte*)(lptr + 0x0C) & 0x0f) // ??1 == ??1
						)
						{
							from = lptr;
							delta = *(int*)(from + 0x0D + 2);
							to = delta + (from + 0x0D + 2 + sizeof(int));
							ptr = NotThePreStub(ptr, (IntPtr)to);
							scan = -1;
							continue;
						}
					}
#endif
#if MONOMOD_RUNTIMEDETOUR_NET_SCAN_MANUAL && !MONOMOD_RUNTIMEDETOUR_NET_SCAN_AUTO
                    // And apparently if we're on wine, it likes to fool us really hard.
                    // HEY WINE DEVS: Feel free to poke me about this. I'm hating this too.
                    // HEY VALVE: If you're seeing this, thanks for lying about "everything works~"
                    // Check for this when *only* scanning manually, as auto-scanning finds this too.
                    lptr = (long) ptr;
                    if (PlatformHelper.Is(Platform.Wine) &&
                        *(ushort*) (lptr + 0x00) == 0xb8_48 && // movabs rax, {PTR}
                        *(ushort*) (lptr + 0x0A) == 0xe0_ff // jmp rax
                    ) {
                        to = *(long*) (lptr + 0x02);
                        ptr = NotThePreStub(ptr, (IntPtr) to);
                    }
#endif
					MMDbgLog.Log($"ngen: 0x{(long)ptr:X16}");
					return ptr;
				}

				// x64 .NET Core, but the thunk was reset
				// This can also just be an optimized method immediately calling another method.
				if (*(byte*)(lptr + 0x00) == 0xe8 && !regenerated)
				{ // call
					MMDbgLog.Log($"Method thunk reset; regenerating");
					regenerated = true;
					int precodeThunkOffset = *(int*)(lptr + 1);
					long precodeThunk = precodeThunkOffset + (lptr + 1 + sizeof(int));
					MMDbgLog.Log($"PrecodeFixupThunk: 0x{precodeThunk:X16}");
					PrepareMethod(method, handle);
					goto ReloadFuncPtr;
				}
			}


			return ptr;
		}

		private static IntPtr ThePreStub = IntPtr.Zero;

		public override bool OnMethodCompiledWillBeCalled => false;
#pragma warning disable CS0067 // Event never fired
		public override event OnMethodCompiledEvent OnMethodCompiled;
#pragma warning restore CS0067

		private IntPtr NotThePreStub(IntPtr ptrGot, IntPtr ptrParsed)
		{
			if (ThePreStub == IntPtr.Zero)
			{
				ThePreStub = (IntPtr)(-2);

				// FIXME: Find a better less likely called NGEN'd candidate that points to ThePreStub.
				// This was "found" by tModLoader.
				// Can be missing in .NET 5.0 outside of Windows for some reason.
				MethodInfo mi = typeof(System.Net.HttpWebRequest).Assembly
					.GetType("System.Net.Connection")
					?.GetMethod("SubmitRequest", BindingFlags.NonPublic | BindingFlags.Instance);

				if (mi != null)
				{
					ThePreStub = GetNativeStart(mi);
					MMDbgLog.Log($"ThePreStub: 0x{(long)ThePreStub:X16}");
				}
				else if (PlatformHelper.Is(MonoPlatform.Windows))
				{
					// FIXME: This should be -1 (always return ptrGot) on all plats, but SubmitRequest is Windows-only?
					ThePreStub = (IntPtr)(-1);
				}
			}

			return (ptrParsed == ThePreStub /*|| ThePreStub == (IntPtr) (-1)*/) ? ptrGot : ptrParsed;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono
{

	static class Disposable
	{

		public static Disposable<T> Owned<T>(T value) where T : class, IDisposable
		{
			return new Disposable<T>(value, owned: true);
		}

		public static Disposable<T> NotOwned<T>(T value) where T : class, IDisposable
		{
			return new Disposable<T>(value, owned: false);
		}
	}

	struct Disposable<T> : IDisposable where T : class, IDisposable
	{

		internal readonly T value;
		readonly bool owned;

		public Disposable(T value, bool owned)
		{
			this.value = value;
			this.owned = owned;
		}

		public void Dispose()
		{
			if (value != null && owned)
				value.Dispose();
		}
	}
}













namespace MonoMod.Utils
{
	/// <summary>
	/// A DMDGenerator implementation using Mono.Cecil to build an in-memory assembly.
	/// </summary>
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class DMDCecilGenerator : DMDGenerator<DMDCecilGenerator>
	{

		protected override MethodInfo _Generate(DynamicMethodDefinition dmd, object context)
		{
			MethodDefinition def = dmd.Definition;
			TypeDefinition typeDef = context as TypeDefinition;

			bool moduleIsTemporary = false;
			ModuleDefinition module = typeDef?.Module;
			HashSet<string> accessChecksIgnored = null;
			if (typeDef == null)
			{
				moduleIsTemporary = true;
				accessChecksIgnored = new HashSet<string>();

				string name = dmd.GetDumpName("Cecil");
				module = ModuleDefinition.CreateModule(name, new ModuleParameters()
				{
					Kind = ModuleKind.Dll,
#if !CECIL0_9
					ReflectionImporterProvider = MMReflectionImporter.ProviderNoDefault
#endif
				});

				module.Assembly.CustomAttributes.Add(new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_UnverifiableCodeAttribute)));

				if (dmd.Debug)
				{
					CustomAttribute caDebug = new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_DebuggableAttribute));
					caDebug.ConstructorArguments.Add(new CustomAttributeArgument(
						module.ImportReference(typeof(DebuggableAttribute.DebuggingModes)),
						DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.Default
					));
					module.Assembly.CustomAttributes.Add(caDebug);
				}

				typeDef = new TypeDefinition(
					"",
					$"DMD<{dmd.OriginalMethod?.Name?.Replace('.', '_')}>?{GetHashCode()}",
					Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Abstract | Mono.Cecil.TypeAttributes.Sealed | Mono.Cecil.TypeAttributes.Class
				)
				{
					BaseType = module.TypeSystem.Object
				};

				module.Types.Add(typeDef);
			}

			try
			{

				MethodDefinition clone = null;

				TypeReference tr_IsVolatile = new TypeReference("System.Runtime.CompilerServices", "IsVolatile", module, module.TypeSystem.CoreLibrary);

#pragma warning disable IDE0039 // Use local function
				Relinker relinker = (mtp, ctx) => {
					if (mtp == def)
						return clone;
					return module.ImportReference(mtp);
				};
#pragma warning restore IDE0039 // Use local function

				clone = new MethodDefinition(dmd.Name ?? "_" + def.Name.Replace('.', '_'), def.Attributes, module.TypeSystem.Void)
				{
					MethodReturnType = def.MethodReturnType,
					Attributes = Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.HideBySig | Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static,
					ImplAttributes = Mono.Cecil.MethodImplAttributes.IL | Mono.Cecil.MethodImplAttributes.Managed,
					DeclaringType = typeDef,
					NoInlining = true
				};

				foreach (ParameterDefinition param in def.Parameters)
					clone.Parameters.Add(param.Clone().Relink(relinker, clone));

				clone.ReturnType = def.ReturnType.Relink(relinker, clone);

				typeDef.Methods.Add(clone);

				clone.HasThis = def.HasThis;
				Mono.Cecil.Cil.MethodBody body = clone.Body = def.Body.Clone(clone);

				foreach (VariableDefinition var in clone.Body.Variables)
					var.VariableType = var.VariableType.Relink(relinker, clone);

				foreach (ExceptionHandler handler in clone.Body.ExceptionHandlers)
					if (handler.CatchType != null)
						handler.CatchType = handler.CatchType.Relink(relinker, clone);

				for (int instri = 0; instri < body.Instructions.Count; instri++)
				{
					Instruction instr = body.Instructions[instri];
					object operand = instr.Operand;

					// Import references.
					if (operand is ParameterDefinition param)
					{
						operand = clone.Parameters[param.Index];

					}
					else if (operand is IMetadataTokenProvider mtp)
					{
						operand = mtp.Relink(relinker, clone);

					}

					// System.Reflection doesn't contain any volatility info.
					// System.Reflection.Emit presumably does something similar to this.
					// Mono.Cecil thus isn't aware of the volatility as part of the imported field reference.
					// The modifier is still necessary though.
					// This is done here instead of the copier as Runtime and other users can't track modreqs
					if (instr.Previous?.OpCode == OpCodes.Volatile &&
						operand is FieldReference fref &&
						(fref.FieldType as RequiredModifierType)?.ModifierType != tr_IsVolatile)
					{
						fref.FieldType = new RequiredModifierType(tr_IsVolatile, fref.FieldType);
					}

					if (operand is DynamicMethodReference dmref)
					{
						// TODO: Fix up DynamicMethod inline refs.
					}

					if (accessChecksIgnored != null && operand is MemberReference mref)
					{
						IMetadataScope asmRef = (mref as TypeReference)?.Scope ?? mref.DeclaringType.Scope;
						if (!accessChecksIgnored.Contains(asmRef.Name))
						{
							CustomAttribute caAccess = new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute));
							caAccess.ConstructorArguments.Add(new CustomAttributeArgument(
								module.ImportReference(typeof(DebuggableAttribute.DebuggingModes)),
								asmRef.Name
							));
							module.Assembly.CustomAttributes.Add(caAccess);
							accessChecksIgnored.Add(asmRef.Name);
						}
					}

					instr.Operand = operand;
				}

				clone.HasThis = false;

				if (def.HasThis)
				{
					TypeReference type = def.DeclaringType;
					if (type.IsValueType)
						type = new ByReferenceType(type);
					clone.Parameters.Insert(0, new ParameterDefinition("<>_this", Mono.Cecil.ParameterAttributes.None, type.Relink(relinker, clone)));
				}

				if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MONOMOD_DMD_DUMP")))
				{
					string dir = Path.GetFullPath(Environment.GetEnvironmentVariable("MONOMOD_DMD_DUMP"));
					string name = module.Name + ".dll";
					string path = Path.Combine(dir, name);
					dir = Path.GetDirectoryName(path);
					if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
						Directory.CreateDirectory(dir);
					if (File.Exists(path))
						File.Delete(path);
					using (Stream fileStream = File.OpenWrite(path))
						module.Write(fileStream);
				}

				Assembly asm = ReflectionHelper.Load(module);

				return asm.GetType(typeDef.FullName.Replace("+", "\\+", StringComparison.Ordinal), false, false)
					.GetMethod(clone.Name, BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);

			}
			finally
			{
#if !CECIL0_9
				if (moduleIsTemporary)
					module.Dispose();
#endif
			}
		}

	}
}
#if !NETSTANDARD











namespace MonoMod.Utils
{
	internal static partial class _DMDEmit
	{

		private readonly static MethodInfo m_MethodBase_InvokeSimple = typeof(MethodBase).GetMethod(
			"Invoke", BindingFlags.Public | BindingFlags.Instance, null,
			new Type[] { typeof(object), typeof(object[]) },
			null
		);

		private static MethodBuilder _CreateMethodProxy(MethodBuilder context, MethodInfo target)
		{
			TypeBuilder tb = (TypeBuilder)context.DeclaringType;
			string name = $".dmdproxy<{target.Name.Replace('.', '_')}>?{target.GetHashCode()}";
			MethodBuilder mb;

			// System.NotSupportedException: The invoked member is not supported before the type is created.
			/*
            mb = tb.GetMethod(name, BindingFlags.NonPublic | BindingFlags.Static) as MethodBuilder;
            if (mb != null)
                return mb;
            */

			Type[] args = target.GetParameters().Select(param => param.ParameterType).ToArray();
			mb = tb.DefineMethod(
				name,
				System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Private | System.Reflection.MethodAttributes.Static,
				CallingConventions.Standard,
				target.ReturnType,
				args
			);
			ILGenerator il = mb.GetILGenerator();

			// Load the DynamicMethod reference first.
			il.EmitReference(target);

			// Load any other arguments on top of that.
			il.Emit(System.Reflection.Emit.OpCodes.Ldnull);
			il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, args.Length);
			il.Emit(System.Reflection.Emit.OpCodes.Newarr, typeof(object));

			for (int i = 0; i < args.Length; i++)
			{
				il.Emit(System.Reflection.Emit.OpCodes.Dup);
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, i);

				il.Emit(System.Reflection.Emit.OpCodes.Ldarg, i);

				Type argType = args[i];
				bool argIsByRef = argType.IsByRef;
				if (argIsByRef)
					argType = argType.GetElementType();
				bool argIsValueType = argType.IsValueType;
				if (argIsValueType)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Box, argType);
				}

				il.Emit(System.Reflection.Emit.OpCodes.Stelem_Ref);
			}

			// Invoke the delegate and return its result.
			il.Emit(System.Reflection.Emit.OpCodes.Callvirt, m_MethodBase_InvokeSimple);

			if (target.ReturnType == typeof(void))
				il.Emit(System.Reflection.Emit.OpCodes.Pop);
			else if (target.ReturnType.IsValueType)
				il.Emit(System.Reflection.Emit.OpCodes.Unbox_Any, target.ReturnType);
			il.Emit(System.Reflection.Emit.OpCodes.Ret);

			return mb;
		}

	}
}
#endif

















namespace MonoMod.Utils
{
	internal static partial class _DMDEmit
	{

		private static readonly Dictionary<short, System.Reflection.Emit.OpCode> _ReflOpCodes = new Dictionary<short, System.Reflection.Emit.OpCode>();
		private static readonly Dictionary<short, Mono.Cecil.Cil.OpCode> _CecilOpCodes = new Dictionary<short, Mono.Cecil.Cil.OpCode>();

		static _DMDEmit()
		{
			foreach (FieldInfo field in typeof(System.Reflection.Emit.OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
			{
				System.Reflection.Emit.OpCode reflOpCode = (System.Reflection.Emit.OpCode)field.GetValue(null);
				_ReflOpCodes[reflOpCode.Value] = reflOpCode;
			}

			foreach (FieldInfo field in typeof(Mono.Cecil.Cil.OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
			{
				Mono.Cecil.Cil.OpCode cecilOpCode = (Mono.Cecil.Cil.OpCode)field.GetValue(null);
				_CecilOpCodes[cecilOpCode.Value] = cecilOpCode;
			}
		}

		public static void Generate(DynamicMethodDefinition dmd, MethodBase _mb, ILGenerator il)
		{
			MethodDefinition def = dmd.Definition;
			DynamicMethod dm = _mb as DynamicMethod;
#if !NETSTANDARD
			MethodBuilder mb = _mb as MethodBuilder;
			ModuleBuilder moduleBuilder = mb?.Module as ModuleBuilder;
			// moduleBuilder.Assembly sometimes avoids the .Assembly override under mysterious circumstances.
			AssemblyBuilder assemblyBuilder = (mb?.DeclaringType as TypeBuilder)?.Assembly as AssemblyBuilder;
			HashSet<Assembly> accessChecksIgnored = null;
			if (mb != null)
			{
				accessChecksIgnored = new HashSet<Assembly>();
			}
#endif

#if !CECIL0_9
			MethodDebugInformation defInfo = dmd.Debug ? def.DebugInformation : null;
#endif

			if (dm != null)
			{
				foreach (ParameterDefinition param in def.Parameters)
				{
					dm.DefineParameter(param.Index + 1, (System.Reflection.ParameterAttributes)param.Attributes, param.Name);
				}
			}
#if !NETSTANDARD
			if (mb != null)
			{
				foreach (ParameterDefinition param in def.Parameters)
				{
					mb.DefineParameter(param.Index + 1, (System.Reflection.ParameterAttributes)param.Attributes, param.Name);
				}
			}
#endif

			LocalBuilder[] locals = def.Body.Variables.Select(
				var => {
					LocalBuilder local = il.DeclareLocal(var.VariableType.ResolveReflection(), var.IsPinned);
#if !NETSTANDARD && !CECIL0_9
					if (mb != null && defInfo != null && defInfo.TryGetName(var, out string name))
					{
						local.SetLocalSymInfo(name);
					}
#endif
					return local;
				}
			).ToArray();

			// Pre-pass - Set up label map.
			Dictionary<Instruction, Label> labelMap = new Dictionary<Instruction, Label>();
			foreach (Instruction instr in def.Body.Instructions)
			{
				if (instr.Operand is Instruction[] targets)
				{
					foreach (Instruction target in targets)
						if (!labelMap.ContainsKey(target))
							labelMap[target] = il.DefineLabel();

				}
				else if (instr.Operand is Instruction target)
				{
					if (!labelMap.ContainsKey(target))
						labelMap[target] = il.DefineLabel();
				}
			}

#if !NETSTANDARD && !CECIL0_9
			Dictionary<Document, ISymbolDocumentWriter> infoDocCache = mb == null ? null : new Dictionary<Document, ISymbolDocumentWriter>();
#endif

			int paramOffs = def.HasThis ? 1 : 0;
			object[] emitArgs = new object[2];
			bool checkTryEndEarly = false;
			foreach (Instruction instr in def.Body.Instructions)
			{
				if (labelMap.TryGetValue(instr, out Label label))
					il.MarkLabel(label);

#if !NETSTANDARD && !CECIL0_9
				SequencePoint instrInfo = defInfo?.GetSequencePoint(instr);
				if (mb != null && instrInfo != null)
				{
					if (!infoDocCache.TryGetValue(instrInfo.Document, out ISymbolDocumentWriter infoDoc))
					{
						infoDocCache[instrInfo.Document] = infoDoc = moduleBuilder.DefineDocument(
							instrInfo.Document.Url,
							instrInfo.Document.LanguageGuid,
							instrInfo.Document.LanguageVendorGuid,
							instrInfo.Document.TypeGuid
						);
					}
					il.MarkSequencePoint(infoDoc, instrInfo.StartLine, instrInfo.StartColumn, instrInfo.EndLine, instrInfo.EndColumn);
				}
#endif

				foreach (ExceptionHandler handler in def.Body.ExceptionHandlers)
				{
					if (checkTryEndEarly && handler.HandlerEnd == instr)
					{
						il.EndExceptionBlock();
					}

					if (handler.TryStart == instr)
					{
						il.BeginExceptionBlock();
					}
					else if (handler.FilterStart == instr)
					{
						il.BeginExceptFilterBlock();
					}
					else if (handler.HandlerStart == instr)
					{
						switch (handler.HandlerType)
						{
							case ExceptionHandlerType.Filter:
								il.BeginCatchBlock(null);
								break;
							case ExceptionHandlerType.Catch:
								il.BeginCatchBlock(handler.CatchType.ResolveReflection());
								break;
							case ExceptionHandlerType.Finally:
								il.BeginFinallyBlock();
								break;
							case ExceptionHandlerType.Fault:
								il.BeginFaultBlock();
								break;
						}

					}

					// Avoid duplicate endfilter / endfinally
					if (handler.HandlerStart == instr.Next)
					{
						switch (handler.HandlerType)
						{
							case ExceptionHandlerType.Filter:
								if (instr.OpCode == Mono.Cecil.Cil.OpCodes.Endfilter)
									goto SkipEmit;
								break;
							case ExceptionHandlerType.Finally:
								if (instr.OpCode == Mono.Cecil.Cil.OpCodes.Endfinally)
									goto SkipEmit;
								break;
						}
					}
				}

				if (instr.OpCode.OperandType == Mono.Cecil.Cil.OperandType.InlineNone)
					il.Emit(_ReflOpCodes[instr.OpCode.Value]);
				else
				{
					object operand = instr.Operand;

					if (operand is Instruction[] targets)
					{
						operand = targets.Select(target => labelMap[target]).ToArray();
						// Let's hope that the JIT treats the long forms identically to the short forms.
						instr.OpCode = instr.OpCode.ToLongOp();

					}
					else if (operand is Instruction target)
					{
						operand = labelMap[target];
						// Let's hope that the JIT treats the long forms identically to the short forms.
						instr.OpCode = instr.OpCode.ToLongOp();

					}
					else if (operand is VariableDefinition var)
					{
						operand = locals[var.Index];

					}
					else if (operand is ParameterDefinition param)
					{
						operand = param.Index + paramOffs;

					}
					else if (operand is MemberReference mref)
					{
						MemberInfo member = mref == def ? _mb : mref.ResolveReflection();
						operand = member;
#if !NETSTANDARD
						if (mb != null && member != null)
						{
							Assembly asm = member.Module?.Assembly;
							if (asm != null && !accessChecksIgnored.Contains(asm))
							{
								// while (member.DeclaringType != null)
								//     member = member.DeclaringType;
								assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute, new object[] {
									asm.GetName().Name
								}));
								accessChecksIgnored.Add(asm);
							}
						}
#endif

					}
					else if (operand is Mono.Cecil.CallSite csite)
					{
						if (dm != null)
						{
							// SignatureHelper in unmanaged contexts cannot be fully made use of for DynamicMethods.
							_EmitCallSite(dm, il, _ReflOpCodes[instr.OpCode.Value], csite);
							continue;
						}
#if !NETSTANDARD
						operand = csite.ResolveReflection(mb.Module);
#else
                        throw new NotSupportedException();
#endif
					}

#if !NETSTANDARD
					if (mb != null && operand is MethodBase called && called.DeclaringType == null)
					{
						// "Global" methods (f.e. DynamicMethods) cannot be tokenized.
						if (instr.OpCode == Mono.Cecil.Cil.OpCodes.Call)
						{
							if (called is MethodInfo target && target.IsDynamicMethod())
							{
								// This should be heavily optimizable.
								operand = _CreateMethodProxy(mb, target);

							}
							else
							{
								IntPtr ptr = called.GetLdftnPointer();
								if (IntPtr.Size == 4)
									il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, (int)ptr);
								else
									il.Emit(System.Reflection.Emit.OpCodes.Ldc_I8, (long)ptr);
								il.Emit(System.Reflection.Emit.OpCodes.Conv_I);
								instr.OpCode = Mono.Cecil.Cil.OpCodes.Calli;
								operand = ((MethodReference)instr.Operand).ResolveReflectionSignature(mb.Module);
							}
						}
						else
						{
							throw new NotSupportedException($"Unsupported global method operand on opcode {instr.OpCode.Name}");
						}
					}
#endif

					if (operand == null)
						throw new NullReferenceException($"Unexpected null in {def} @ {instr}");

					il.DynEmit(_ReflOpCodes[instr.OpCode.Value], operand);
				}

				if (!checkTryEndEarly)
				{
					foreach (ExceptionHandler handler in def.Body.ExceptionHandlers)
					{
						if (handler.HandlerEnd == instr.Next)
						{
							il.EndExceptionBlock();
						}
					}
				}

				checkTryEndEarly = false;
				continue;

			SkipEmit:
				checkTryEndEarly = true;
				continue;
			}
		}

		public static void ResolveWithModifiers(TypeReference typeRef, out Type type, out Type[] typeModReq, out Type[] typeModOpt, List<Type> modReq = null, List<Type> modOpt = null)
		{
			if (modReq == null)
				modReq = new List<Type>();
			else
				modReq.Clear();

			if (modOpt == null)
				modOpt = new List<Type>();
			else
				modOpt.Clear();

			for (
				TypeReference mod = typeRef;
				mod is TypeSpecification modSpec;
				mod = modSpec.ElementType
			)
			{
				switch (mod)
				{
					case RequiredModifierType paramTypeModReq:
						modReq.Add(paramTypeModReq.ModifierType.ResolveReflection());
						break;

					case OptionalModifierType paramTypeOptReq:
						modOpt.Add(paramTypeOptReq.ModifierType.ResolveReflection());
						break;
				}
			}

			type = typeRef.ResolveReflection();
			typeModReq = modReq.ToArray();
			typeModOpt = modOpt.ToArray();
		}

	}
}










namespace MonoMod.Utils
{
	// The following mostly qualifies as r/badcode material.
	internal static partial class _DMDEmit
	{

		// Mono
		private static readonly MethodInfo _ILGen_make_room =
			typeof(ILGenerator).GetMethod("make_room", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly MethodInfo _ILGen_emit_int =
			typeof(ILGenerator).GetMethod("emit_int", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly MethodInfo _ILGen_ll_emit =
			typeof(ILGenerator).GetMethod("ll_emit", BindingFlags.NonPublic | BindingFlags.Instance);

		// .NET
		private static readonly MethodInfo _ILGen_EnsureCapacity =
			typeof(ILGenerator).GetMethod("EnsureCapacity", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly MethodInfo _ILGen_PutInteger4 =
			typeof(ILGenerator).GetMethod("PutInteger4", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly MethodInfo _ILGen_InternalEmit =
			typeof(ILGenerator).GetMethod("InternalEmit", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly MethodInfo _ILGen_UpdateStackSize =
			typeof(ILGenerator).GetMethod("UpdateStackSize", BindingFlags.NonPublic | BindingFlags.Instance);

		private static readonly FieldInfo f_DynILGen_m_scope =
			typeof(ILGenerator).Assembly
			.GetType("System.Reflection.Emit.DynamicILGenerator")?.GetField("m_scope", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly FieldInfo f_DynScope_m_tokens =
			typeof(ILGenerator).Assembly
			.GetType("System.Reflection.Emit.DynamicScope")?.GetField("m_tokens", BindingFlags.NonPublic | BindingFlags.Instance);

		// Based on https://referencesource.microsoft.com/#mscorlib/system/reflection/mdimport.cs,74bfbae3c61889bc
		private static readonly Type[] CorElementTypes = new Type[] {
			null,
			typeof(void),
			typeof(bool),
			typeof(char),
			typeof(sbyte),
			typeof(byte),
			typeof(short),
			typeof(ushort),
			typeof(int),
			typeof(uint),
			typeof(long),
			typeof(ulong),
			typeof(string),
			typeof(IntPtr)
		};

		internal static void _EmitCallSite(DynamicMethod dm, ILGenerator il, System.Reflection.Emit.OpCode opcode, Mono.Cecil.CallSite csite)
		{
			/* The mess in this method is heavily based off of the code available at the following links:
             * https://github.com/Microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/mscorlib/system/reflection/emit/dynamicmethod.cs#L791
             * https://github.com/Microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/mscorlib/system/reflection/emit/dynamicilgenerator.cs#L353
             * https://github.com/mono/mono/blob/82e573122a55482bf6592f36f819597238628385/mcs/class/corlib/System.Reflection.Emit/DynamicMethod.cs#L411
             * https://github.com/mono/mono/blob/82e573122a55482bf6592f36f819597238628385/mcs/class/corlib/System.Reflection.Emit/ILGenerator.cs#L800
             * https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/src/System/Reflection/Emit/SignatureHelper.cs#L57
             */

			List<object> _tokens = null;
			int _GetTokenForType(Type v)
			{
				_tokens.Add(v.TypeHandle);
				return _tokens.Count - 1 | 0x02000000 /* (int) MetadataTokenType.TypeDef */;
			}
			int _GetTokenForSig(byte[] v)
			{
				_tokens.Add(v);
				return _tokens.Count - 1 | 0x11000000 /* (int) MetadataTokenType.Signature */;
			}
#if !NETSTANDARD
			DynamicILInfo _info = null;
			if (DynamicMethodDefinition._IsMono)
			{
				// GetDynamicILInfo throws "invalid signature" in .NET - let's hope for the best for mono...
				_info = dm.GetDynamicILInfo();
			}
			else
			{
#endif
				// For .NET, we need to access DynamicScope m_scope and its List<object> m_tokens
				_tokens = f_DynScope_m_tokens.GetValue(f_DynILGen_m_scope.GetValue(il)) as List<object>;
#if !NETSTANDARD
			}

			int GetTokenForType(Type v) => _info != null ? _info.GetTokenFor(v.TypeHandle) : _GetTokenForType(v);
			int GetTokenForSig(byte[] v) => _info != null ? _info.GetTokenFor(v) : _GetTokenForSig(v);

#else
            int GetTokenForType(Type v) => _GetTokenForType(v);
            int GetTokenForSig(byte[] v) => _GetTokenForSig(v);
#endif

			byte[] signature = new byte[32];
			int currSig = 0;
			int sizeLoc = -1;

			// This expects a MdSigCallingConvention
			AddData((byte)csite.CallingConvention);
			sizeLoc = currSig++;

			List<Type> modReq = new List<Type>();
			List<Type> modOpt = new List<Type>();

			ResolveWithModifiers(csite.ReturnType, out Type returnType, out Type[] returnTypeModReq, out Type[] returnTypeModOpt, modReq, modOpt);
			AddArgument(returnType, returnTypeModReq, returnTypeModOpt);

			foreach (ParameterDefinition param in csite.Parameters)
			{
				if (param.ParameterType.IsSentinel)
					AddElementType(0x41 /* CorElementType.Sentinel */);

				if (param.ParameterType.IsPinned)
				{
					AddElementType(0x45 /* CorElementType.Pinned */);
					// AddArgument(param.ParameterType.ResolveReflection());
					// continue;
				}

				ResolveWithModifiers(param.ParameterType, out Type paramType, out Type[] paramTypeModReq, out Type[] paramTypeModOpt, modReq, modOpt);
				AddArgument(paramType, paramTypeModReq, paramTypeModOpt);
			}

			AddElementType(0x00 /* CorElementType.End */);

			// For most signatures, this will set the number of elements in a byte which we have reserved for it.
			// However, if we have a field signature, we don't set the length and return.
			// If we have a signature with more than 128 arguments, we can't just set the number of elements,
			// we actually have to allocate more space (e.g. shift everything in the array one or more spaces to the
			// right.  We do this by making a copy of the array and leaving the correct number of blanks.  This new
			// array is now set to be m_signature and we use the AddData method to set the number of elements properly.
			// The forceCopy argument can be used to force SetNumberOfSignatureElements to make a copy of
			// the array.  This is useful for GetSignature which promises to trim the array to be the correct size anyway.

			byte[] temp;
			int newSigSize;
			int currSigHolder = currSig;

			// We need to have more bytes for the size.  Figure out how many bytes here.
			// Since we need to copy anyway, we're just going to take the cost of doing a
			// new allocation.
			if (csite.Parameters.Count < 0x80)
			{
				newSigSize = 1;
			}
			else if (csite.Parameters.Count < 0x4000)
			{
				newSigSize = 2;
			}
			else
			{
				newSigSize = 4;
			}

			// Allocate the new array.
			temp = new byte[currSig + newSigSize - 1];

			// Copy the calling convention.  The calling convention is always just one byte
			// so we just copy that byte.  Then copy the rest of the array, shifting everything
			// to make room for the new number of elements.
			temp[0] = signature[0];
			Buffer.BlockCopy(signature, sizeLoc + 1, temp, sizeLoc + newSigSize, currSigHolder - (sizeLoc + 1));
			signature = temp;

			//Use the AddData method to add the number of elements appropriately compressed.
			currSig = sizeLoc;
			AddData(csite.Parameters.Count);
			currSig = currSigHolder + (newSigSize - 1);

			// This case will only happen if the user got the signature through 
			// InternalGetSignature first and then called GetSignature.
			if (signature.Length > currSig)
			{
				temp = new byte[currSig];
				Array.Copy(signature, temp, currSig);
				signature = temp;
			}

			// Emit.

			if (_ILGen_emit_int != null)
			{
				// Mono
				_ILGen_make_room.Invoke(il, new object[] { 6 });
				_ILGen_ll_emit.Invoke(il, new object[] { opcode });
				_ILGen_emit_int.Invoke(il, new object[] { GetTokenForSig(signature) });

			}
			else
			{
				// .NET
				_ILGen_EnsureCapacity.Invoke(il, new object[] { 7 });
				_ILGen_InternalEmit.Invoke(il, new object[] { opcode });

				// The only IL instruction that has VarPop behaviour, that takes a
				// Signature token as a parameter is calli.  Pop the parameters and
				// the native function pointer.  To be conservative, do not pop the
				// this pointer since this information is not easily derived from
				// SignatureHelper.
				if (opcode.StackBehaviourPop == System.Reflection.Emit.StackBehaviour.Varpop)
				{
					// Pop the arguments and native function pointer off the stack.
					_ILGen_UpdateStackSize.Invoke(il, new object[] { opcode, -csite.Parameters.Count - 1 });
				}

				_ILGen_PutInteger4.Invoke(il, new object[] { GetTokenForSig(signature) });
			}

			void AddArgument(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
			{
				if (optionalCustomModifiers != null)
					foreach (Type t in optionalCustomModifiers)
						InternalAddTypeToken(GetTokenForType(t), 0x20 /* CorElementType.CModOpt */);

				if (requiredCustomModifiers != null)
					foreach (Type t in requiredCustomModifiers)
						InternalAddTypeToken(GetTokenForType(t), 0x1F /* CorElementType.CModReqd */);

				AddOneArgTypeHelper(clsArgument);
			}

			void AddData(int data)
			{
				// A managed representation of CorSigCompressData; 

				if (currSig + 4 > signature.Length)
				{
					signature = ExpandArray(signature);
				}

				if (data <= 0x7F)
				{
					signature[currSig++] = (byte)(data & 0xFF);
				}
				else if (data <= 0x3FFF)
				{
					signature[currSig++] = (byte)((data >> 8) | 0x80);
					signature[currSig++] = (byte)(data & 0xFF);
				}
				else if (data <= 0x1FFFFFFF)
				{
					signature[currSig++] = (byte)((data >> 24) | 0xC0);
					signature[currSig++] = (byte)((data >> 16) & 0xFF);
					signature[currSig++] = (byte)((data >> 8) & 0xFF);
					signature[currSig++] = (byte)((data) & 0xFF);
				}
				else
				{
					throw new ArgumentException("Integer or token was too large to be encoded.");
				}
			}

			byte[] ExpandArray(byte[] inArray, int requiredLength = -1)
			{
				if (requiredLength < inArray.Length)
					requiredLength = inArray.Length * 2;

				byte[] outArray = new byte[requiredLength];
				Buffer.BlockCopy(inArray, 0, outArray, 0, inArray.Length);
				return outArray;
			}

			void AddElementType(byte cvt)
			{
				// Adds an element to the signature.  A managed represenation of CorSigCompressElement
				if (currSig + 1 > signature.Length)
					signature = ExpandArray(signature);

				signature[currSig++] = cvt;
			}

			void AddToken(int token)
			{
				// A managed represenation of CompressToken
				// Pulls the token appart to get a rid, adds some appropriate bits
				// to the token and then adds this to the signature.

				int rid = (token & 0x00FFFFFF); //This is RidFromToken;
				int type = (token & unchecked((int)0xFF000000)); //This is TypeFromToken;

				if (rid > 0x3FFFFFF)
				{
					// token is too big to be compressed    
					throw new ArgumentException("Integer or token was too large to be encoded.");
				}

				rid = (rid << 2);

				// TypeDef is encoded with low bits 00  
				// TypeRef is encoded with low bits 01  
				// TypeSpec is encoded with low bits 10    
				if (type == 0x01000000 /* MetadataTokenType.TypeRef */)
				{
					//if type is mdtTypeRef
					rid |= 0x1;
				}
				else if (type == 0x1b000000 /* MetadataTokenType.TypeSpec */)
				{
					//if type is mdtTypeSpec
					rid |= 0x2;
				}

				AddData(rid);
			}

			void InternalAddTypeToken(int clsToken, byte CorType)
			{
				// Add a type token into signature. CorType will be either CorElementType.Class or CorElementType.ValueType
				AddElementType(CorType);
				AddToken(clsToken);
			}

			void AddOneArgTypeHelper(Type clsArgument) { AddOneArgTypeHelperWorker(clsArgument, false); }
			void AddOneArgTypeHelperWorker(Type clsArgument, bool lastWasGenericInst)
			{
				if (clsArgument.IsGenericType && (!clsArgument.IsGenericTypeDefinition || !lastWasGenericInst))
				{
					AddElementType(0x15 /* CorElementType.GenericInst */);

					AddOneArgTypeHelperWorker(clsArgument.GetGenericTypeDefinition(), true);

					Type[] genargs = clsArgument.GetGenericArguments();

					AddData(genargs.Length);

					foreach (Type t in genargs)
						AddOneArgTypeHelper(t);
				}
				else if (clsArgument.IsByRef)
				{
					AddElementType(0x10 /* CorElementType.ByRef */);
					clsArgument = clsArgument.GetElementType();
					AddOneArgTypeHelper(clsArgument);
				}
				else if (clsArgument.IsPointer)
				{
					AddElementType(0x0F /* CorElementType.Ptr */);
					AddOneArgTypeHelper(clsArgument.GetElementType());
				}
				else if (clsArgument.IsArray)
				{
#if false
                        if (clsArgument.IsArray && clsArgument == clsArgument.GetElementType().MakeArrayType()) { // .IsSZArray unavailable.
                            AddElementType(0x1D /* CorElementType.SzArray */);

                            AddOneArgTypeHelper(clsArgument.GetElementType());
                        } else
#endif
					{
						AddElementType(0x14 /* CorElementType.Array */);

						AddOneArgTypeHelper(clsArgument.GetElementType());

						// put the rank information
						int rank = clsArgument.GetArrayRank();
						AddData(rank);     // rank
						AddData(0);     // upper bounds
						AddData(rank);  // lower bound
						for (int i = 0; i < rank; i++)
							AddData(0);
					}
				}
				else
				{
					// This isn't 100% accurate, but... oh well.
					byte type = 0; // 0 is reserved anyway.

					for (int i = 0; i < CorElementTypes.Length; i++)
					{
						if (clsArgument == CorElementTypes[i])
						{
							type = (byte)i;
							break;
						}
					}

					if (type == 0)
					{
						if (clsArgument == typeof(object))
						{
							type = 0x1C /* CorElementType.Object */;
						}
						else if (clsArgument.IsValueType)
						{
							type = 0x11 /* CorElementType.ValueType */;
						}
						else
						{
							// Let's hope for the best.
							type = 0x12 /* CorElementType.Class */;
						}
					}

					if (type <= 0x0E /* CorElementType.String */ ||
						type == 0x16 /* CorElementType.TypedByRef */ ||
						type == 0x18 /* CorElementType.I */ ||
						type == 0x19 /* CorElementType.U */ ||
						type == 0x1C /* CorElementType.Object */
					)
					{
						AddElementType(type);
					}
					else if (clsArgument.IsValueType)
					{
						InternalAddTypeToken(GetTokenForType(clsArgument), 0x11 /* CorElementType.ValueType */);
					}
					else
					{
						InternalAddTypeToken(GetTokenForType(clsArgument), 0x12 /* CorElementType.Class */);
					}
				}
			}

		}

	}
}
















namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class DMDEmitDynamicMethodGenerator : DMDGenerator<DMDEmitDynamicMethodGenerator>
	{

		private static readonly FieldInfo _DynamicMethod_returnType =
			typeof(DynamicMethod).GetField("returnType", BindingFlags.NonPublic | BindingFlags.Instance) ??
			typeof(DynamicMethod).GetField("m_returnType", BindingFlags.NonPublic | BindingFlags.Instance);

		protected override MethodInfo _Generate(DynamicMethodDefinition dmd, object context)
		{
			MethodBase orig = dmd.OriginalMethod;
			MethodDefinition def = dmd.Definition;

			Type[] argTypes;

			if (orig != null)
			{
				ParameterInfo[] args = orig.GetParameters();
				int offs = 0;
				if (!orig.IsStatic)
				{
					offs++;
					argTypes = new Type[args.Length + 1];
					argTypes[0] = orig.GetThisParamType();
				}
				else
				{
					argTypes = new Type[args.Length];
				}
				for (int i = 0; i < args.Length; i++)
					argTypes[i + offs] = args[i].ParameterType;

			}
			else
			{
				int offs = 0;
				if (def.HasThis)
				{
					offs++;
					argTypes = new Type[def.Parameters.Count + 1];
					Type type = def.DeclaringType.ResolveReflection();
					if (type.IsValueType)
						type = type.MakeByRefType();
					argTypes[0] = type;
				}
				else
				{
					argTypes = new Type[def.Parameters.Count];
				}
				for (int i = 0; i < def.Parameters.Count; i++)
					argTypes[i + offs] = def.Parameters[i].ParameterType.ResolveReflection();
			}

			string name = dmd.Name ?? $"DMD<{orig?.GetID(simple: true) ?? def.GetID(simple: true)}>";
			Type retType = (orig as MethodInfo)?.ReturnType ?? def.ReturnType?.ResolveReflection();

			MMDbgLog.Log($"new DynamicMethod: {retType} {name}({string.Join(",", argTypes.Select(type => type?.ToString()).ToArray())})");
			if (orig != null)
				MMDbgLog.Log($"orig: {(orig as MethodInfo)?.ReturnType?.ToString() ?? "NULL"} {orig.Name}({string.Join(",", orig.GetParameters().Select(arg => arg?.ParameterType?.ToString() ?? "NULL").ToArray())})");
			MMDbgLog.Log($"mdef: {def.ReturnType?.ToString() ?? "NULL"} {name}({string.Join(",", def.Parameters.Select(arg => arg?.ParameterType?.ToString() ?? "NULL").ToArray())})");

			DynamicMethod dm = new DynamicMethod(
				name,
				typeof(void), argTypes,
				orig?.DeclaringType ?? dmd.OwnerType ?? typeof(DynamicMethodDefinition),
				true // If any random errors pop up, try setting this to false first.
			);

			// DynamicMethods don't officially "support" certain return types, such as ByRef types.
			_DynamicMethod_returnType.SetValue(dm, retType);

			ILGenerator il = dm.GetILGenerator();

			_DMDEmit.Generate(dmd, dm, il);

			return dm;
		}

	}
}
#if !NETSTANDARD
















namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class DMDEmitMethodBuilderGenerator : DMDGenerator<DMDEmitMethodBuilderGenerator>
	{

		private static readonly bool _MBCanRunAndCollect = Enum.IsDefined(typeof(AssemblyBuilderAccess), "RunAndCollect");

		protected override MethodInfo _Generate(DynamicMethodDefinition dmd, object context)
		{
			TypeBuilder typeBuilder = context as TypeBuilder;
			MethodBuilder method = GenerateMethodBuilder(dmd, typeBuilder);
			typeBuilder = (TypeBuilder)method.DeclaringType;
			Type type = typeBuilder.CreateType();
			if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MONOMOD_DMD_DUMP")))
			{
				string path = method.Module.FullyQualifiedName;
				string name = Path.GetFileName(path);
				string dir = Path.GetDirectoryName(path);
				if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				if (File.Exists(path))
					File.Delete(path);
				((AssemblyBuilder)typeBuilder.Assembly).Save(name);
			}
			return type.GetMethod(method.Name, BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
		}

		public static MethodBuilder GenerateMethodBuilder(DynamicMethodDefinition dmd, TypeBuilder typeBuilder)
		{
			MethodBase orig = dmd.OriginalMethod;
			MethodDefinition def = dmd.Definition;

			if (typeBuilder == null)
			{
				string dumpDir = Environment.GetEnvironmentVariable("MONOMOD_DMD_DUMP");
				if (string.IsNullOrEmpty(dumpDir))
				{
					dumpDir = null;
				}
				else
				{
					dumpDir = Path.GetFullPath(dumpDir);
				}
				bool collect = string.IsNullOrEmpty(dumpDir) && _MBCanRunAndCollect;
				AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(
					new AssemblyName()
					{
						Name = dmd.GetDumpName("MethodBuilder")
					},
					collect ? (AssemblyBuilderAccess)9 : AssemblyBuilderAccess.RunAndSave,
					dumpDir
				);

				ab.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_UnverifiableCodeAttribute, new object[] {
				}));

				if (dmd.Debug)
				{
					ab.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_DebuggableAttribute, new object[] {
						DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.Default
					}));
				}

				// Note: Debugging can fail on mono if Mono.CompilerServices.SymbolWriter.dll cannot be found,
				// or if Mono.CompilerServices.SymbolWriter.SymbolWriterImpl can't be found inside of that.
				// https://github.com/mono/mono/blob/f879e35e3ed7496d819bd766deb8be6992d068ed/mcs/class/corlib/System.Reflection.Emit/ModuleBuilder.cs#L146
				ModuleBuilder module = ab.DefineDynamicModule($"{ab.GetName().Name}.dll", $"{ab.GetName().Name}.dll", dmd.Debug);
				typeBuilder = module.DefineType(
					$"DMD<{orig?.GetID(simple: true)?.Replace('.', '_')}>?{dmd.GetHashCode()}",
					System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Abstract | System.Reflection.TypeAttributes.Sealed | System.Reflection.TypeAttributes.Class
				);
			}

			Type[] argTypes;
			Type[][] argTypesModReq;
			Type[][] argTypesModOpt;

			if (orig != null)
			{
				ParameterInfo[] args = orig.GetParameters();
				int offs = 0;
				if (!orig.IsStatic)
				{
					offs++;
					argTypes = new Type[args.Length + 1];
					argTypesModReq = new Type[args.Length + 1][];
					argTypesModOpt = new Type[args.Length + 1][];
					argTypes[0] = orig.GetThisParamType();
					argTypesModReq[0] = Type.EmptyTypes;
					argTypesModOpt[0] = Type.EmptyTypes;
				}
				else
				{
					argTypes = new Type[args.Length];
					argTypesModReq = new Type[args.Length][];
					argTypesModOpt = new Type[args.Length][];
				}

				for (int i = 0; i < args.Length; i++)
				{
					argTypes[i + offs] = args[i].ParameterType;
					argTypesModReq[i + offs] = args[i].GetRequiredCustomModifiers();
					argTypesModOpt[i + offs] = args[i].GetOptionalCustomModifiers();
				}

			}
			else
			{
				int offs = 0;
				if (def.HasThis)
				{
					offs++;
					argTypes = new Type[def.Parameters.Count + 1];
					argTypesModReq = new Type[def.Parameters.Count + 1][];
					argTypesModOpt = new Type[def.Parameters.Count + 1][];
					Type type = def.DeclaringType.ResolveReflection();
					if (type.IsValueType)
						type = type.MakeByRefType();
					argTypes[0] = type;
					argTypesModReq[0] = Type.EmptyTypes;
					argTypesModOpt[0] = Type.EmptyTypes;
				}
				else
				{
					argTypes = new Type[def.Parameters.Count];
					argTypesModReq = new Type[def.Parameters.Count][];
					argTypesModOpt = new Type[def.Parameters.Count][];
				}

				List<Type> modReq = new List<Type>();
				List<Type> modOpt = new List<Type>();

				for (int i = 0; i < def.Parameters.Count; i++)
				{
					_DMDEmit.ResolveWithModifiers(def.Parameters[i].ParameterType, out Type paramType, out Type[] paramTypeModReq, out Type[] paramTypeModOpt, modReq, modOpt);
					argTypes[i + offs] = paramType;
					argTypesModReq[i + offs] = paramTypeModReq;
					argTypesModOpt[i + offs] = paramTypeModOpt;
				}
			}

			// Required because the return type modifiers aren't easily accessible via reflection.
			_DMDEmit.ResolveWithModifiers(def.ReturnType, out Type returnType, out Type[] returnTypeModReq, out Type[] returnTypeModOpt);

			MethodBuilder mb = typeBuilder.DefineMethod(
				dmd.Name ?? (orig?.Name ?? def.Name).Replace('.', '_'),
				System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Public | System.Reflection.MethodAttributes.Static,
				CallingConventions.Standard,
				returnType, returnTypeModReq, returnTypeModOpt,
				argTypes, argTypesModReq, argTypesModOpt
			);
			ILGenerator il = mb.GetILGenerator();

			_DMDEmit.Generate(dmd, mb, il);

			return mb;
		}

	}
}
#endif













namespace MonoMod.Utils
{
#pragma warning disable IDE1006 // Naming Styles
	internal interface _IDMDGenerator
	{
#pragma warning restore IDE1006 // Naming Styles
		MethodInfo Generate(DynamicMethodDefinition dmd, object context);
	}
	/// <summary>
	/// A DynamicMethodDefinition "generator", responsible for generating a runtime MethodInfo from a DMD MethodDefinition.
	/// </summary>
	/// <typeparam name="TSelf"></typeparam>
#if !MONOMOD_INTERNAL
	public
#endif
	abstract class DMDGenerator<TSelf> : _IDMDGenerator where TSelf : DMDGenerator<TSelf>, new()
	{

		private static TSelf _Instance;

		protected abstract MethodInfo _Generate(DynamicMethodDefinition dmd, object context);

		MethodInfo _IDMDGenerator.Generate(DynamicMethodDefinition dmd, object context)
		{
			return _Postbuild(_Generate(dmd, context));
		}

		public static MethodInfo Generate(DynamicMethodDefinition dmd, object context = null)
			=> _Postbuild((_Instance ?? (_Instance = new TSelf()))._Generate(dmd, context));

		internal static unsafe MethodInfo _Postbuild(MethodInfo mi)
		{
			if (mi == null)
				return null;

			if (DynamicMethodDefinition._IsMono)
			{
				// Luckily we're guaranteed to be safe from DynamicMethod -> RuntimeMethodInfo conversions.
				if (!(mi is DynamicMethod) && mi.DeclaringType != null)
				{
					// get_Assembly is virtual in some versions of Mono (notably older ones and the infamous Unity fork).
					// ?. results in a call instead of callvirt to skip a redundant nullcheck, which breaks this on ^...
					Module module = mi?.Module;
					if (module == null)
						return mi;
					Assembly asm = module.Assembly; // Let's hope that this doesn't get optimized into a call.
					Type asmType = asm?.GetType();
					if (asmType == null)
						return mi;

					asm.SetMonoCorlibInternal(true);
				}
			}

			return mi;
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Rocks
{

	public class DocCommentId
	{
		StringBuilder id;

		DocCommentId()
		{
			id = new StringBuilder();
		}

		void WriteField(FieldDefinition field)
		{
			WriteDefinition('F', field);
		}

		void WriteEvent(EventDefinition @event)
		{
			WriteDefinition('E', @event);
		}

		void WriteType(TypeDefinition type)
		{
			id.Append('T').Append(':');
			WriteTypeFullName(type);
		}

		void WriteMethod(MethodDefinition method)
		{
			WriteDefinition('M', method);

			if (method.HasGenericParameters)
			{
				id.Append('`').Append('`');
				id.Append(method.GenericParameters.Count);
			}

			if (method.HasParameters)
				WriteParameters(method.Parameters);

			if (IsConversionOperator(method))
				WriteReturnType(method);
		}

		static bool IsConversionOperator(MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			return self.IsSpecialName
				&& (self.Name == "op_Explicit" || self.Name == "op_Implicit");
		}

		void WriteReturnType(MethodDefinition method)
		{
			id.Append('~');
			WriteTypeSignature(method.ReturnType);
		}

		void WriteProperty(PropertyDefinition property)
		{
			WriteDefinition('P', property);

			if (property.HasParameters)
				WriteParameters(property.Parameters);
		}

		void WriteParameters(IList<ParameterDefinition> parameters)
		{
			id.Append('(');
			WriteList(parameters, p => WriteTypeSignature(p.ParameterType));
			id.Append(')');
		}

		void WriteTypeSignature(TypeReference type)
		{
			switch (type.MetadataType)
			{
				case MetadataType.Array:
					WriteArrayTypeSignature((ArrayType)type);
					break;
				case MetadataType.ByReference:
					WriteTypeSignature(((ByReferenceType)type).ElementType);
					id.Append('@');
					break;
				case MetadataType.FunctionPointer:
					WriteFunctionPointerTypeSignature((FunctionPointerType)type);
					break;
				case MetadataType.GenericInstance:
					WriteGenericInstanceTypeSignature((GenericInstanceType)type);
					break;
				case MetadataType.Var:
					id.Append('`');
					id.Append(((GenericParameter)type).Position);
					break;
				case MetadataType.MVar:
					id.Append('`').Append('`');
					id.Append(((GenericParameter)type).Position);
					break;
				case MetadataType.OptionalModifier:
					WriteModiferTypeSignature((OptionalModifierType)type, '!');
					break;
				case MetadataType.RequiredModifier:
					WriteModiferTypeSignature((RequiredModifierType)type, '|');
					break;
				case MetadataType.Pointer:
					WriteTypeSignature(((PointerType)type).ElementType);
					id.Append('*');
					break;
				default:
					WriteTypeFullName(type);
					break;
			}
		}

		void WriteGenericInstanceTypeSignature(GenericInstanceType type)
		{
			if (type.ElementType.IsTypeSpecification())
				throw new NotSupportedException();

			WriteTypeFullName(type.ElementType, stripGenericArity: true);
			id.Append('{');
			WriteList(type.GenericArguments, WriteTypeSignature);
			id.Append('}');
		}

		void WriteList<T>(IList<T> list, Action<T> action)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if (i > 0)
					id.Append(',');

				action(list[i]);
			}
		}

		void WriteModiferTypeSignature(IModifierType type, char id)
		{
			WriteTypeSignature(type.ElementType);
			this.id.Append(id);
			WriteTypeSignature(type.ModifierType);
		}

		void WriteFunctionPointerTypeSignature(FunctionPointerType type)
		{
			id.Append("=FUNC:");
			WriteTypeSignature(type.ReturnType);

			if (type.HasParameters)
				WriteParameters(type.Parameters);
		}

		void WriteArrayTypeSignature(ArrayType type)
		{
			WriteTypeSignature(type.ElementType);

			if (type.IsVector)
			{
				id.Append("[]");
				return;
			}

			id.Append("[");

			WriteList(type.Dimensions, dimension => {
				if (dimension.LowerBound.HasValue)
					id.Append(dimension.LowerBound.Value);

				id.Append(':');

				if (dimension.UpperBound.HasValue)
					id.Append(dimension.UpperBound.Value - (dimension.LowerBound.GetValueOrDefault() + 1));
			});

			id.Append("]");
		}

		void WriteDefinition(char id, IMemberDefinition member)
		{
			this.id.Append(id)
				.Append(':');

			WriteTypeFullName(member.DeclaringType);
			this.id.Append('.');
			WriteItemName(member.Name);
		}

		void WriteTypeFullName(TypeReference type, bool stripGenericArity = false)
		{
			if (type.DeclaringType != null)
			{
				WriteTypeFullName(type.DeclaringType);
				id.Append('.');
			}

			if (!string.IsNullOrEmpty(type.Namespace))
			{
				id.Append(type.Namespace);
				id.Append('.');
			}

			var name = type.Name;

			if (stripGenericArity)
			{
				var index = name.LastIndexOf('`');
				if (index > 0)
					name = name.Substring(0, index);
			}

			id.Append(name);
		}

		void WriteItemName(string name)
		{
			id.Append(name.Replace('.', '#').Replace('<', '{').Replace('>', '}'));
		}

		public override string ToString()
		{
			return id.ToString();
		}

		public static string GetDocCommentId(IMemberDefinition member)
		{
			if (member == null)
				throw new ArgumentNullException("member");

			var documentId = new DocCommentId();

			switch (member.MetadataToken.TokenType)
			{
				case TokenType.Field:
					documentId.WriteField((FieldDefinition)member);
					break;
				case TokenType.Method:
					documentId.WriteMethod((MethodDefinition)member);
					break;
				case TokenType.TypeDef:
					documentId.WriteType((TypeDefinition)member);
					break;
				case TokenType.Event:
					documentId.WriteEvent((EventDefinition)member);
					break;
				case TokenType.Property:
					documentId.WriteProperty((PropertyDefinition)member);
					break;
				default:
					throw new NotSupportedException(member.FullName);
			}

			return documentId.ToString();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Cil
{

	public enum DocumentType
	{
		Other,
		Text,
	}

	public enum DocumentHashAlgorithm
	{
		None,
		MD5,
		SHA1,
		SHA256,
	}

	public enum DocumentLanguage
	{
		Other,
		C,
		Cpp,
		CSharp,
		Basic,
		Java,
		Cobol,
		Pascal,
		Cil,
		JScript,
		Smc,
		MCpp,
		FSharp,
	}

	public enum DocumentLanguageVendor
	{
		Other,
		Microsoft,
	}

	public sealed class Document : DebugInformation
	{

		string url;

		Guid type;
		Guid hash_algorithm;
		Guid language;
		Guid language_vendor;

		byte[] hash;
		byte[] embedded_source;

		public string Url
		{
			get { return url; }
			set { url = value; }
		}

		public DocumentType Type
		{
			get { return type.ToType(); }
			set { type = value.ToGuid(); }
		}

		public Guid TypeGuid
		{
			get { return type; }
			set { type = value; }
		}

		public DocumentHashAlgorithm HashAlgorithm
		{
			get { return hash_algorithm.ToHashAlgorithm(); }
			set { hash_algorithm = value.ToGuid(); }
		}

		public Guid HashAlgorithmGuid
		{
			get { return hash_algorithm; }
			set { hash_algorithm = value; }
		}

		public DocumentLanguage Language
		{
			get { return language.ToLanguage(); }
			set { language = value.ToGuid(); }
		}

		public Guid LanguageGuid
		{
			get { return language; }
			set { language = value; }
		}

		public DocumentLanguageVendor LanguageVendor
		{
			get { return language_vendor.ToVendor(); }
			set { language_vendor = value.ToGuid(); }
		}

		public Guid LanguageVendorGuid
		{
			get { return language_vendor; }
			set { language_vendor = value; }
		}

		public byte[] Hash
		{
			get { return hash; }
			set { hash = value; }
		}

		public byte[] EmbeddedSource
		{
			get { return embedded_source; }
			set { embedded_source = value; }
		}

		public Document(string url)
		{
			this.url = url;
			this.hash = Empty<byte>.Array;
			this.embedded_source = Empty<byte>.Array;
			this.token = new MetadataToken(TokenType.Document);
		}
	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed partial class DynamicMethodDefinition
	{

		private static OpCode[] _CecilOpCodes1X;
		private static OpCode[] _CecilOpCodes2X;

		private static void _InitCopier()
		{
			_CecilOpCodes1X = new OpCode[0xe1];
			_CecilOpCodes2X = new OpCode[0x1f];

			foreach (FieldInfo field in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
			{
				OpCode opcode = (OpCode)field.GetValue(null);
				if (opcode.OpCodeType == Mono.Cecil.Cil.OpCodeType.Nternal)
					continue;

				if (opcode.Size == 1)
					_CecilOpCodes1X[opcode.Value] = opcode;
				else
					_CecilOpCodes2X[opcode.Value & 0xff] = opcode;
			}
		}

		private void _CopyMethodToDefinition()
		{
			MethodBase method = OriginalMethod;
			Module moduleFrom = method.Module;
			System.Reflection.MethodBody bodyFrom = method.GetMethodBody();
			byte[] data = bodyFrom?.GetILAsByteArray();
			if (data == null)
				throw new NotSupportedException("Body-less method");

			MethodDefinition def = Definition;
			ModuleDefinition moduleTo = def.Module;
			Mono.Cecil.Cil.MethodBody bodyTo = def.Body;
			ILProcessor processor = bodyTo.GetILProcessor();

			Type[] typeArguments = null;
			if (method.DeclaringType.IsGenericType)
				typeArguments = method.DeclaringType.GetGenericArguments();

			Type[] methodArguments = null;
			if (method.IsGenericMethod)
				methodArguments = method.GetGenericArguments();

			foreach (LocalVariableInfo info in bodyFrom.LocalVariables)
			{
				TypeReference type = moduleTo.ImportReference(info.LocalType);
				if (info.IsPinned)
					type = new PinnedType(type);
				bodyTo.Variables.Add(new VariableDefinition(type));
			}

			using (BinaryReader reader = new BinaryReader(new MemoryStream(data)))
			{
				for (Instruction instr = null, prev = null; reader.BaseStream.Position < reader.BaseStream.Length; prev = instr)
				{
					int offset = (int)reader.BaseStream.Position;
					instr = Instruction.Create(OpCodes.Nop);
					byte op = reader.ReadByte();
					instr.OpCode = op != 0xfe ? _CecilOpCodes1X[op] : _CecilOpCodes2X[reader.ReadByte()];
					instr.Offset = offset;
					if (prev != null)
						prev.Next = instr;
					instr.Previous = prev;
					ReadOperand(reader, instr);
					bodyTo.Instructions.Add(instr);
				}
			}

			foreach (Instruction instr in bodyTo.Instructions)
			{
				switch (instr.OpCode.OperandType)
				{
					case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
					case Mono.Cecil.Cil.OperandType.InlineBrTarget:
						instr.Operand = GetInstruction((int)instr.Operand);
						break;

					case Mono.Cecil.Cil.OperandType.InlineSwitch:
						int[] offsets = (int[])instr.Operand;
						Instruction[] targets = new Instruction[offsets.Length];
						for (int i = 0; i < offsets.Length; i++)
							targets[i] = GetInstruction(offsets[i]);
						instr.Operand = targets;
						break;
				}
			}

			foreach (ExceptionHandlingClause clause in bodyFrom.ExceptionHandlingClauses)
			{
				ExceptionHandler handler = new ExceptionHandler((ExceptionHandlerType)clause.Flags);
				bodyTo.ExceptionHandlers.Add(handler);

				handler.TryStart = GetInstruction(clause.TryOffset);
				handler.TryEnd = GetInstruction(clause.TryOffset + clause.TryLength);

				handler.FilterStart = handler.HandlerType != ExceptionHandlerType.Filter ? null : GetInstruction(clause.FilterOffset);
				handler.HandlerStart = GetInstruction(clause.HandlerOffset);
				handler.HandlerEnd = GetInstruction(clause.HandlerOffset + clause.HandlerLength);

				handler.CatchType = handler.HandlerType != ExceptionHandlerType.Catch ? null : clause.CatchType == null ? null : moduleTo.ImportReference(clause.CatchType);
			}

			void ReadOperand(BinaryReader reader, Instruction instr)
			{
				int index, offs, length;
				switch (instr.OpCode.OperandType)
				{
					case Mono.Cecil.Cil.OperandType.InlineNone:
						instr.Operand = null;
						break;

					case Mono.Cecil.Cil.OperandType.InlineSwitch:
						length = reader.ReadInt32();
						offs = (int)reader.BaseStream.Position + (4 * length);
						int[] targets = new int[length];
						for (int i = 0; i < length; i++)
							targets[i] = reader.ReadInt32() + offs;
						instr.Operand = targets;
						break;

					case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
						offs = reader.ReadSByte();
						instr.Operand = (int)reader.BaseStream.Position + offs;
						break;

					case Mono.Cecil.Cil.OperandType.InlineBrTarget:
						offs = reader.ReadInt32();
						instr.Operand = (int)reader.BaseStream.Position + offs;
						break;

					case Mono.Cecil.Cil.OperandType.ShortInlineI:
						instr.Operand = instr.OpCode == OpCodes.Ldc_I4_S ? reader.ReadSByte() : (object)reader.ReadByte();
						break;

					case Mono.Cecil.Cil.OperandType.InlineI:
						instr.Operand = reader.ReadInt32();
						break;

					case Mono.Cecil.Cil.OperandType.ShortInlineR:
						instr.Operand = reader.ReadSingle();
						break;

					case Mono.Cecil.Cil.OperandType.InlineR:
						instr.Operand = reader.ReadDouble();
						break;

					case Mono.Cecil.Cil.OperandType.InlineI8:
						instr.Operand = reader.ReadInt64();
						break;

					case Mono.Cecil.Cil.OperandType.InlineSig:
						instr.Operand = moduleTo.ImportCallSite(moduleFrom, moduleFrom.ResolveSignature(reader.ReadInt32()));
						break;

					case Mono.Cecil.Cil.OperandType.InlineString:
						instr.Operand = moduleFrom.ResolveString(reader.ReadInt32());
						break;

					case Mono.Cecil.Cil.OperandType.InlineTok:
						instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Any);
						break;

					case Mono.Cecil.Cil.OperandType.InlineType:
						instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Type);
						break;

					case Mono.Cecil.Cil.OperandType.InlineMethod:
						instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Method);
						break;

					case Mono.Cecil.Cil.OperandType.InlineField:
						instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Field);
						break;

					case Mono.Cecil.Cil.OperandType.ShortInlineVar:
					case Mono.Cecil.Cil.OperandType.InlineVar:
						index = instr.OpCode.OperandType == Mono.Cecil.Cil.OperandType.ShortInlineVar ? reader.ReadByte() : reader.ReadInt16();
						instr.Operand = bodyTo.Variables[index];
						break;

					case Mono.Cecil.Cil.OperandType.InlineArg:
					case Mono.Cecil.Cil.OperandType.ShortInlineArg:
						index = instr.OpCode.OperandType == Mono.Cecil.Cil.OperandType.ShortInlineArg ? reader.ReadByte() : reader.ReadInt16();
						instr.Operand = def.Parameters[index];
						break;

					case Mono.Cecil.Cil.OperandType.InlinePhi: // No opcode seems to use this
					default:
						throw new NotSupportedException($"Unsupported opcode ${instr.OpCode.Name}");
				}
			}

			MemberReference ResolveTokenAs(int token, TokenResolutionMode resolveMode)
			{
				try
				{
					switch (resolveMode)
					{
						case TokenResolutionMode.Type:
							Type resolvedType = moduleFrom.ResolveType(token, typeArguments, methodArguments);
							resolvedType.FixReflectionCacheAuto();
							return moduleTo.ImportReference(resolvedType);

						case TokenResolutionMode.Method:
							MethodBase resolvedMethod = moduleFrom.ResolveMethod(token, typeArguments, methodArguments);
							resolvedMethod.GetRealDeclaringType()?.FixReflectionCacheAuto();
							return moduleTo.ImportReference(resolvedMethod);

						case TokenResolutionMode.Field:
							FieldInfo resolvedField = moduleFrom.ResolveField(token, typeArguments, methodArguments);
							resolvedField.GetRealDeclaringType()?.FixReflectionCacheAuto();
							return moduleTo.ImportReference(resolvedField);

						case TokenResolutionMode.Any:
							switch (moduleFrom.ResolveMember(token, typeArguments, methodArguments))
							{
								case Type i:
									i.FixReflectionCacheAuto();
									return moduleTo.ImportReference(i);

								case MethodBase i:
									i.GetRealDeclaringType()?.FixReflectionCacheAuto();
									return moduleTo.ImportReference(i);

								case FieldInfo i:
									i.GetRealDeclaringType()?.FixReflectionCacheAuto();
									return moduleTo.ImportReference(i);

								case var resolved:
									throw new NotSupportedException($"Invalid resolved member type {resolved.GetType()}");
							}

						default:
							throw new NotSupportedException($"Invalid TokenResolutionMode {resolveMode}");
					}

				}
				catch (MissingMemberException)
				{
					// we could not resolve the method normally, so lets read the import table
					// but we can only do that if the module was loaded from disk
					// this can still throw if the assembly is a dynamic one, but if that's broken, you have bigger issues
					string filePath = moduleFrom.Assembly.Location;
					if (!File.Exists(filePath))
					{
						// in this case, the fallback cannot be followed, and so throwing the original error gives the user information
						throw;
					}

					// TODO: make this cached somehow so its not read and re-opened a bunch
					using (AssemblyDefinition assembly = AssemblyDefinition.ReadAssembly(filePath, new ReaderParameters
					{
						ReadingMode = ReadingMode.Deferred
					}))
					{
						ModuleDefinition module = assembly.Modules.First(m => m.Name == moduleFrom.Name);
						// this should only fail if the token itself is somehow wrong
						MemberReference reference = (MemberReference)module.LookupToken(token);
						// the explicit casts here are to throw if they are incorrect
						// normally the references would need to be imported, but moduleTo isn't written to anywhere
						switch (resolveMode)
						{
							case TokenResolutionMode.Type:
								return (TypeReference)reference;

							case TokenResolutionMode.Method:
								return (MethodReference)reference;

							case TokenResolutionMode.Field:
								return (FieldReference)reference;

							case TokenResolutionMode.Any:
								return reference;

							default:
								throw new NotSupportedException($"Invalid TokenResolutionMode {resolveMode}");
						}
					}
				}
			}

			Instruction GetInstruction(int offset)
			{
				int last = bodyTo.Instructions.Count - 1;
				if (offset < 0 || offset > bodyTo.Instructions[last].Offset)
					return null;

				int min = 0;
				int max = last;
				while (min <= max)
				{
					int mid = min + ((max - min) / 2);
					Instruction instr = bodyTo.Instructions[mid];

					if (offset == instr.Offset)
						return instr;

					if (offset < instr.Offset)
						max = mid - 1;
					else
						min = mid + 1;
				}

				return null;
			}

		}

		private enum TokenResolutionMode
		{
			Any,
			Type,
			Method,
			Field
		}

	}
}

















namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed partial class DynamicMethodDefinition : IDisposable
	{

		static DynamicMethodDefinition()
		{
			_InitCopier();
		}

		internal static readonly bool _IsMono = Type.GetType("Mono.Runtime") != null;
		internal static readonly bool _IsNewMonoSRE = _IsMono && typeof(DynamicMethod).GetField("il_info", BindingFlags.NonPublic | BindingFlags.Instance) != null;
		internal static readonly bool _IsOldMonoSRE = _IsMono && !_IsNewMonoSRE && typeof(DynamicMethod).GetField("ilgen", BindingFlags.NonPublic | BindingFlags.Instance) != null;

		// If SRE has been stubbed out, prefer Cecil.
		private static bool _PreferCecil =
			(_IsMono && (
				// Mono 4.X+
				!_IsNewMonoSRE &&
				// Unity pre 2018
				!_IsOldMonoSRE
			)) ||

			(!_IsMono && (
				// .NET
				typeof(ILGenerator).Assembly
				.GetType("System.Reflection.Emit.DynamicILGenerator")
				?.GetField("m_scope", BindingFlags.NonPublic | BindingFlags.Instance) == null
			)) ||

			false;

		public static bool IsDynamicILAvailable => !_PreferCecil;

		internal static readonly ConstructorInfo c_DebuggableAttribute = typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(DebuggableAttribute.DebuggingModes) });
		internal static readonly ConstructorInfo c_UnverifiableCodeAttribute = typeof(UnverifiableCodeAttribute).GetConstructor(new Type[] { });
		internal static readonly ConstructorInfo c_IgnoresAccessChecksToAttribute = typeof(System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute).GetConstructor(new Type[] { typeof(string) });

		internal static readonly Type t__IDMDGenerator = typeof(_IDMDGenerator);
		internal static readonly Dictionary<string, _IDMDGenerator> _DMDGeneratorCache = new Dictionary<string, _IDMDGenerator>();

		[Obsolete("Use OriginalMethod instead.")]
		public MethodBase Method => OriginalMethod;
		public MethodBase OriginalMethod { get; private set; }
		private MethodDefinition _Definition;
		public MethodDefinition Definition => _Definition;
		private ModuleDefinition _Module;
		public ModuleDefinition Module => _Module;

		public string Name;

		public Type OwnerType;

		public bool Debug = false;

		private Guid GUID = Guid.NewGuid();

		private bool _IsDisposed;

		internal DynamicMethodDefinition()
		{
			Debug = Environment.GetEnvironmentVariable("MONOMOD_DMD_DEBUG") == "1";
		}

		public DynamicMethodDefinition(MethodBase method)
			: this()
		{
			OriginalMethod = method ?? throw new ArgumentNullException(nameof(method));
			Reload();
		}

		public DynamicMethodDefinition(string name, Type returnType, Type[] parameterTypes)
			: this()
		{
			Name = name;
			OriginalMethod = null;

			_CreateDynModule(name, returnType, parameterTypes);
		}

		public ILProcessor GetILProcessor()
		{
			return Definition.Body.GetILProcessor();
		}

		public ILGenerator GetILGenerator()
		{
			return new Cil.CecilILGenerator(Definition.Body.GetILProcessor()).GetProxy();
		}

		private ModuleDefinition _CreateDynModule(string name, Type returnType, Type[] parameterTypes)
		{
			ModuleDefinition module = _Module = ModuleDefinition.CreateModule($"DMD:DynModule<{name}>?{GetHashCode()}", new ModuleParameters()
			{
				Kind = ModuleKind.Dll,
#if !CECIL0_9
				ReflectionImporterProvider = MMReflectionImporter.ProviderNoDefault
#endif
			});

			TypeDefinition type = new TypeDefinition(
				"",
				$"DMD<{name}>?{GetHashCode()}",
				Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Class
			);
			module.Types.Add(type);

			MethodDefinition def = _Definition = new MethodDefinition(
				name,
				Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.HideBySig | Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static,
				returnType != null ? module.ImportReference(returnType) : module.TypeSystem.Void
			);
			foreach (Type paramType in parameterTypes)
				def.Parameters.Add(new ParameterDefinition(module.ImportReference(paramType)));
			type.Methods.Add(def);

			return module;
		}

		public void Reload()
		{
			MethodBase orig = OriginalMethod;
			if (orig == null)
				throw new InvalidOperationException();

			ModuleDefinition module = null;

			try
			{
				_Definition = null;

#if !CECIL0_9
				_Module?.Dispose();
#endif
				_Module = null;

				Type[] argTypes;
				ParameterInfo[] args = orig.GetParameters();
				int offs = 0;
				if (!orig.IsStatic)
				{
					offs++;
					argTypes = new Type[args.Length + 1];
					argTypes[0] = orig.GetThisParamType();
				}
				else
				{
					argTypes = new Type[args.Length];
				}
				for (int i = 0; i < args.Length; i++)
					argTypes[i + offs] = args[i].ParameterType;

				module = _CreateDynModule(orig.GetID(simple: true), (orig as MethodInfo)?.ReturnType, argTypes);

				_CopyMethodToDefinition();

				MethodDefinition def = Definition;
				if (!orig.IsStatic)
				{
					def.Parameters[0].Name = "this";
				}
				for (int i = 0; i < args.Length; i++)
					def.Parameters[i + offs].Name = args[i].Name;

				_Module = module;
				module = null;
			}
			catch
			{
#if !CECIL0_9
				module?.Dispose();
#endif
				throw;
			}
		}

		public MethodInfo Generate()
			=> Generate(null);
		public MethodInfo Generate(object context)
		{
			string typeName = Environment.GetEnvironmentVariable("MONOMOD_DMD_TYPE");

			switch (typeName?.ToLower(CultureInfo.InvariantCulture))
			{
				case "dynamicmethod":
				case "dm":
					return DMDEmitDynamicMethodGenerator.Generate(this, context);

#if !NETSTANDARD
				case "methodbuilder":
				case "mb":
					return DMDEmitMethodBuilderGenerator.Generate(this, context);
#endif

				case "cecil":
				case "md":
					return DMDCecilGenerator.Generate(this, context);

				default:
					Type type = ReflectionHelper.GetType(typeName);
					if (type != null)
					{
						if (!t__IDMDGenerator.IsCompatible(type))
							throw new ArgumentException($"Invalid DMDGenerator type: {typeName}");
						if (!_DMDGeneratorCache.TryGetValue(typeName, out _IDMDGenerator gen))
							_DMDGeneratorCache[typeName] = gen = Activator.CreateInstance(type) as _IDMDGenerator;
						return gen.Generate(this, context);
					}

					if (_PreferCecil)
						return DMDCecilGenerator.Generate(this, context);

					if (Debug)
#if NETSTANDARD
                        return DMDCecilGenerator.Generate(this, context);
#else
						return DMDEmitMethodBuilderGenerator.Generate(this, context);
#endif

					// In .NET Framework, DynamicILGenerator doesn't support fault and filter blocks.
					// This is a non-issue in .NET Core, yet it could still be an issue in mono.
					// https://github.com/dotnet/coreclr/issues/1764
#if NETFRAMEWORK
                    if (Definition.Body.ExceptionHandlers.Any(eh =>
                        eh.HandlerType == ExceptionHandlerType.Fault ||
                        eh.HandlerType == ExceptionHandlerType.Filter
                    ))
#if NETSTANDARD
                        return DMDCecilGenerator.Generate(this, context);
#else
                        return DMDEmitMethodBuilderGenerator.Generate(this, context);
#endif
#endif

					return DMDEmitDynamicMethodGenerator.Generate(this, context);
			}
		}

		public void Dispose()
		{
			if (_IsDisposed)
				return;
			_IsDisposed = true;
			_Module.Dispose();
		}

		public string GetDumpName(string type)
		{
			// TODO: Add {Definition.GetID(withType: false)} without killing MethodBuilder
			return $"DMDASM.{GUID.GetHashCode():X8}{(string.IsNullOrEmpty(type) ? "" : $".{type}")}";
		}

	}
}









namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static class DynamicMethodHelper
	{

		// Used in EmitReference.
		private static List<object> References = new List<object>();
		public static object GetReference(int id) => References[id];
		public static void SetReference(int id, object obj) => References[id] = obj;
		private static int AddReference(object obj)
		{
			lock (References)
			{
				References.Add(obj);
				return References.Count - 1;
			}
		}
		public static void FreeReference(int id) => References[id] = null;

		private static readonly MethodInfo _GetMethodFromHandle = typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[] { typeof(RuntimeMethodHandle) });
		private static readonly MethodInfo _GetReference = typeof(DynamicMethodHelper).GetMethod("GetReference");

		/// <summary>
		/// Fill the DynamicMethod with a stub.
		/// </summary>
		public static SRE.DynamicMethod Stub(this SRE.DynamicMethod dm)
		{
			SRE.ILGenerator il = dm.GetILGenerator();
			for (int i = 0; i < 32; i++)
			{
				// Prevent mono from inlining the DynamicMethod.
				il.Emit(SRE.OpCodes.Nop);
			}
			if (dm.ReturnType != typeof(void))
			{
				il.DeclareLocal(dm.ReturnType);
				il.Emit(SRE.OpCodes.Ldloca_S, (sbyte)0);
				il.Emit(SRE.OpCodes.Initobj, dm.ReturnType);
				il.Emit(SRE.OpCodes.Ldloc_0);
			}
			il.Emit(SRE.OpCodes.Ret);
			return dm;
		}

		/// <summary>
		/// Fill the DynamicMethod with a stub.
		/// </summary>
		public static DynamicMethodDefinition Stub(this DynamicMethodDefinition dmd)
		{
			CIL.ILProcessor il = dmd.GetILProcessor();
			for (int i = 0; i < 32; i++)
			{
				// Prevent mono from inlining the DynamicMethod.
				il.Emit(CIL.OpCodes.Nop);
			}
			if (dmd.Definition.ReturnType != dmd.Definition.Module.TypeSystem.Void)
			{
				il.Body.Variables.Add(new CIL.VariableDefinition(dmd.Definition.ReturnType));
				il.Emit(CIL.OpCodes.Ldloca_S, (sbyte)0);
				il.Emit(CIL.OpCodes.Initobj, dmd.Definition.ReturnType);
				il.Emit(CIL.OpCodes.Ldloc_0);
			}
			il.Emit(CIL.OpCodes.Ret);
			return dmd;
		}

		/// <summary>
		/// Emit a reference to an arbitrary object. Note that the references "leak."
		/// </summary>
		public static int EmitReference<T>(this SRE.ILGenerator il, T obj)
		{
			Type t = typeof(T);
			int id = AddReference(obj);
			il.Emit(SRE.OpCodes.Ldc_I4, id);
			il.Emit(SRE.OpCodes.Call, _GetReference);
			if (t.IsValueType)
				il.Emit(SRE.OpCodes.Unbox_Any, t);
			return id;
		}

		/// <summary>
		/// Emit a reference to an arbitrary object. Note that the references "leak."
		/// </summary>
		public static int EmitReference<T>(this CIL.ILProcessor il, T obj)
		{
			ModuleDefinition ilModule = il.Body.Method.Module;
			Type t = typeof(T);
			int id = AddReference(obj);
			il.Emit(CIL.OpCodes.Ldc_I4, id);
			il.Emit(CIL.OpCodes.Call, ilModule.ImportReference(_GetReference));
			if (t.IsValueType)
				il.Emit(CIL.OpCodes.Unbox_Any, ilModule.ImportReference(t));
			return id;
		}

		/// <summary>
		/// Emit a reference to an arbitrary object. Note that the references "leak."
		/// </summary>
		public static int EmitGetReference<T>(this SRE.ILGenerator il, int id)
		{
			Type t = typeof(T);
			il.Emit(SRE.OpCodes.Ldc_I4, id);
			il.Emit(SRE.OpCodes.Call, _GetReference);
			if (t.IsValueType)
				il.Emit(SRE.OpCodes.Unbox_Any, t);
			return id;
		}

		/// <summary>
		/// Emit a reference to an arbitrary object. Note that the references "leak."
		/// </summary>
		public static int EmitGetReference<T>(this CIL.ILProcessor il, int id)
		{
			ModuleDefinition ilModule = il.Body.Method.Module;
			Type t = typeof(T);
			il.Emit(CIL.OpCodes.Ldc_I4, id);
			il.Emit(CIL.OpCodes.Call, ilModule.ImportReference(_GetReference));
			if (t.IsValueType)
				il.Emit(CIL.OpCodes.Unbox_Any, ilModule.ImportReference(t));
			return id;
		}

	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	class DynamicMethodReference : MethodReference
	{
		public MethodInfo DynamicMethod;

		public DynamicMethodReference(ModuleDefinition module, MethodInfo dm)
			: base("", module.TypeSystem.Void)
		{
			DynamicMethod = dm;
		}
	}
}
#pragma warning disable IDE1006 // Naming Styles









namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static class DynDll
	{
		/// <summary>
		/// Allows you to remap library paths / names and specify loading flags. Useful for cross-platform compatibility. Applies only to DynDll.
		/// </summary>
		public static Dictionary<string, List<DynDllMapping>> Mappings = new Dictionary<string, List<DynDllMapping>>();

		#region kernel32 imports

		[DllImport("kernel32", SetLastError = true)]
		private static extern IntPtr GetModuleHandle(string lpModuleName);
		[DllImport("kernel32", SetLastError = true)]
		private static extern IntPtr LoadLibrary(string lpFileName);
		[DllImport("kernel32", SetLastError = true)]
		private static extern bool FreeLibrary(IntPtr hLibModule);
		[DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

		#endregion

		#region dl imports

		[DllImport("dl", EntryPoint = "dlopen", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl_dlopen(string filename, int flags);
		[DllImport("dl", EntryPoint = "dlclose", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern bool dl_dlclose(IntPtr handle);
		[DllImport("dl", EntryPoint = "dlsym", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl_dlsym(IntPtr handle, string symbol);
		[DllImport("dl", EntryPoint = "dlerror", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl_dlerror();

		#endregion

		#region libdl.so.2 imports

		[DllImport("libdl.so.2", EntryPoint = "dlopen", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl2_dlopen(string filename, int flags);
		[DllImport("libdl.so.2", EntryPoint = "dlclose", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern bool dl2_dlclose(IntPtr handle);
		[DllImport("libdl.so.2", EntryPoint = "dlsym", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl2_dlsym(IntPtr handle, string symbol);
		[DllImport("libdl.so.2", EntryPoint = "dlerror", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		private static extern IntPtr dl2_dlerror();

		#endregion

		#region dl wrappers

		private static int dlVersion = 1;

		private static IntPtr dlopen(string filename, int flags)
		{
			while (true)
			{
				try
				{
					switch (dlVersion)
					{
						case 1:
							return dl2_dlopen(filename, flags);

						case 0:
						default:
							return dl_dlopen(filename, flags);
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}

		private static bool dlclose(IntPtr handle)
		{
			while (true)
			{
				try
				{
					switch (dlVersion)
					{
						case 1:
							return dl2_dlclose(handle);

						case 0:
						default:
							return dl_dlclose(handle);
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}

		private static IntPtr dlsym(IntPtr handle, string symbol)
		{
			while (true)
			{
				try
				{
					switch (dlVersion)
					{
						case 1:
							return dl2_dlsym(handle, symbol);

						case 0:
						default:
							return dl_dlsym(handle, symbol);
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}

		private static IntPtr dlerror()
		{
			while (true)
			{
				try
				{
					switch (dlVersion)
					{
						case 1:
							return dl2_dlerror();

						case 0:
						default:
							return dl_dlerror();
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}

		#endregion

		static DynDll()
		{
			// Run a dummy dlerror to resolve it so that it won't interfere with the first call
			if (!PlatformHelper.Is(MonoPlatform.Windows))
				dlerror();
		}

		private static bool CheckError(out Exception exception)
		{
			if (PlatformHelper.Is(MonoPlatform.Windows))
			{
				int errorCode = Marshal.GetLastWin32Error();
				if (errorCode != 0)
				{
					exception = new Win32Exception(errorCode);
					return false;
				}
			}
			else
			{
				IntPtr errorCode = dlerror();
				if (errorCode != IntPtr.Zero)
				{
					exception = new Win32Exception(Marshal.PtrToStringAnsi(errorCode));
					return false;
				}
			}

			exception = null;
			return true;
		}

		/// <summary>
		/// Open a given library and get its handle.
		/// </summary>
		/// <param name="name">The library name.</param>
		/// <param name="skipMapping">Whether to skip using the mapping or not.</param>
		/// <param name="flags">Any optional platform-specific flags.</param>
		/// <returns>The library handle.</returns>
		public static IntPtr OpenLibrary(string name, bool skipMapping = false, int? flags = null)
		{
			if (!InternalTryOpenLibrary(name, out var libraryPtr, skipMapping, flags))
				throw new DllNotFoundException($"Unable to load library '{name}'");

			if (!CheckError(out var exception))
				throw exception;

			return libraryPtr;
		}

		/// <summary>
		/// Try to open a given library and get its handle.
		/// </summary>
		/// <param name="name">The library name.</param>
		/// <param name="libraryPtr">The library handle, or null if it failed loading.</param>
		/// <param name="skipMapping">Whether to skip using the mapping or not.</param>
		/// <param name="flags">Any optional platform-specific flags.</param>
		/// <returns>True if the handle was obtained, false otherwise.</returns>
		public static bool TryOpenLibrary(string name, out IntPtr libraryPtr, bool skipMapping = false, int? flags = null)
		{
			return InternalTryOpenLibrary(name, out libraryPtr, skipMapping, flags) || CheckError(out _);
		}

		private static bool InternalTryOpenLibrary(string name, out IntPtr libraryPtr, bool skipMapping, int? flags)
		{
			if (name != null && !skipMapping && Mappings.TryGetValue(name, out List<DynDllMapping> mappingList))
			{
				foreach (var mapping in mappingList)
				{
					if (InternalTryOpenLibrary(mapping.LibraryName, out libraryPtr, true, mapping.Flags))
						return true;
				}

				libraryPtr = IntPtr.Zero;
				return true;
			}

			if (PlatformHelper.Is(MonoPlatform.Windows))
			{
				libraryPtr = name == null
					? GetModuleHandle(name)
					: LoadLibrary(name);
			}
			else
			{
				int _flags = flags ?? (DlopenFlags.RTLD_NOW | DlopenFlags.RTLD_GLOBAL); // Default should match LoadLibrary.

				libraryPtr = dlopen(name, _flags);

				if (libraryPtr == IntPtr.Zero && File.Exists(name))
					libraryPtr = dlopen(Path.GetFullPath(name), _flags);
			}

			return libraryPtr != IntPtr.Zero;
		}

		/// <summary>
		/// Release a library handle obtained via OpenLibrary. Don't release the result of OpenLibrary(null)!
		/// </summary>
		/// <param name="lib">The library handle.</param>
		public static bool CloseLibrary(IntPtr lib)
		{
			if (PlatformHelper.Is(MonoPlatform.Windows))
				CloseLibrary(lib);
			else
				dlclose(lib);

			return CheckError(out _);
		}

		/// <summary>
		/// Get a function pointer for a function in the given library.
		/// </summary>
		/// <param name="libraryPtr">The library handle.</param>
		/// <param name="name">The function name.</param>
		/// <returns>The function pointer.</returns>
		public static IntPtr GetFunction(this IntPtr libraryPtr, string name)
		{
			if (!InternalTryGetFunction(libraryPtr, name, out var functionPtr))
				throw new MissingMethodException($"Unable to load function '{name}'");

			if (!CheckError(out var exception))
				throw exception;

			return functionPtr;
		}

		/// <summary>
		/// Get a function pointer for a function in the given library.
		/// </summary>
		/// <param name="libraryPtr">The library handle.</param>
		/// <param name="name">The function name.</param>
		/// <param name="functionPtr">The function pointer, or null if it wasn't found.</param>
		/// <returns>True if the function pointer was obtained, false otherwise.</returns>
		public static bool TryGetFunction(this IntPtr libraryPtr, string name, out IntPtr functionPtr)
		{
			return InternalTryGetFunction(libraryPtr, name, out functionPtr) || CheckError(out _);
		}

		private static bool InternalTryGetFunction(IntPtr libraryPtr, string name, out IntPtr functionPtr)
		{
			if (libraryPtr == IntPtr.Zero)
				throw new ArgumentNullException(nameof(libraryPtr));

			functionPtr = PlatformHelper.Is(MonoPlatform.Windows)
				? GetProcAddress(libraryPtr, name)
				: dlsym(libraryPtr, name);

			return functionPtr != IntPtr.Zero;
		}

		/// <summary>
		/// Extension method wrapping Marshal.GetDelegateForFunctionPointer
		/// </summary>
		public static T AsDelegate<T>(this IntPtr s) where T : class
		{
#pragma warning disable CS0618 // Type or member is obsolete
			return Marshal.GetDelegateForFunctionPointer(s, typeof(T)) as T;
#pragma warning restore CS0618 // Type or member is obsolete
		}

		/// <summary>
		/// Fill all static delegate fields with the DynDllImport attribute.
		/// Call this early on in the static constructor.
		/// </summary>
		/// <param name="type">The type containing the DynDllImport delegate fields.</param>
		/// <param name="mappings">Any optional mappings similar to the static mappings.</param>
		public static void ResolveDynDllImports(this Type type, Dictionary<string, List<DynDllMapping>> mappings = null)
			=> InternalResolveDynDllImports(type, null, mappings);

		/// <summary>
		/// Fill all instance delegate fields with the DynDllImport attribute.
		/// Call this early on in the constructor.
		/// </summary>
		/// <param name="instance">An instance of a type containing the DynDllImport delegate fields.</param>
		/// <param name="mappings">Any optional mappings similar to the static mappings.</param>
		public static void ResolveDynDllImports(object instance, Dictionary<string, List<DynDllMapping>> mappings = null)
			=> InternalResolveDynDllImports(instance.GetType(), instance, mappings);

		private static void InternalResolveDynDllImports(Type type, object instance, Dictionary<string, List<DynDllMapping>> mappings)
		{
			BindingFlags fieldFlags = BindingFlags.Public | BindingFlags.NonPublic;
			if (instance == null)
				fieldFlags |= BindingFlags.Static;
			else
				fieldFlags |= BindingFlags.Instance;

			foreach (FieldInfo field in type.GetFields(fieldFlags))
			{
				bool found = true;

				foreach (DynDllImportAttribute attrib in field.GetCustomAttributes(typeof(DynDllImportAttribute), true))
				{
					found = false;

					IntPtr libraryPtr = IntPtr.Zero;

					if (mappings != null && mappings.TryGetValue(attrib.LibraryName, out List<DynDllMapping> mappingList))
					{
						bool mappingFound = false;

						foreach (var mapping in mappingList)
						{
							if (TryOpenLibrary(mapping.LibraryName, out libraryPtr, true, mapping.Flags))
							{
								mappingFound = true;
								break;
							}
						}

						if (!mappingFound)
							continue;
					}
					else
					{
						if (!TryOpenLibrary(attrib.LibraryName, out libraryPtr))
							continue;
					}


					foreach (string entryPoint in attrib.EntryPoints.Concat(new[] { field.Name, field.FieldType.Name }))
					{
						if (!libraryPtr.TryGetFunction(entryPoint, out IntPtr functionPtr))
							continue;

#pragma warning disable CS0618 // Type or member is obsolete
						field.SetValue(instance, Marshal.GetDelegateForFunctionPointer(functionPtr, field.FieldType));
#pragma warning restore CS0618 // Type or member is obsolete

						found = true;
						break;
					}

					if (found)
						break;
				}

				if (!found)
					throw new EntryPointNotFoundException($"No matching entry point found for {field.Name} in {field.DeclaringType.FullName}");
			}
		}

		public static class DlopenFlags
		{
			public const int RTLD_LAZY = 0x0001;
			public const int RTLD_NOW = 0x0002;
			public const int RTLD_LOCAL = 0x0000;
			public const int RTLD_GLOBAL = 0x0100;
		}
	}

	/// <summary>
	/// Similar to DllImport, but requires you to run typeof(DeclaringType).ResolveDynDllImports();
	/// </summary>
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public class DynDllImportAttribute : Attribute
	{
		/// <summary>
		/// The library or library alias to use.
		/// </summary>
		public string LibraryName { get; set; }

		/// <summary>
		/// A list of possible entrypoints that the function can be resolved to. Implicitly includes the field name and delegate name.
		/// </summary>
		public string[] EntryPoints { get; set; }

		/// <param name="libraryName">The library or library alias to use.</param>
		/// <param name="entryPoints">A list of possible entrypoints that the function can be resolved to. Implicitly includes the field name and delegate name.</param>
		public DynDllImportAttribute(string libraryName, params string[] entryPoints)
		{
			LibraryName = libraryName;
			EntryPoints = entryPoints;
		}
	}

	/// <summary>
	/// A mapping entry, to be used by <see cref="DynDllImportAttribute"/>.
	/// </summary>
	public sealed class DynDllMapping
	{
		/// <summary>
		/// The name as which the library will be resolved as. Useful to remap libraries or to provide full paths.
		/// </summary>
		public string LibraryName { get; set; }

		/// <summary>
		/// Platform-dependent loading flags.
		/// </summary>
		public int? Flags { get; set; }

		/// <param name="libraryName">The name as which the library will be resolved as. Useful to remap libraries or to provide full paths.</param>
		/// <param name="flags">Platform-dependent loading flags.</param>
		public DynDllMapping(string libraryName, int? flags = null)
		{
			LibraryName = libraryName ?? throw new ArgumentNullException(nameof(libraryName));
			Flags = flags;
		}

		public static implicit operator DynDllMapping(string libraryName)
		{
			return new DynDllMapping(libraryName);
		}
	}
}//
 // Author:
 //   Jb Evain (jbevain@gmail.com)
 //
 // Copyright (c) 2008 - 2015 Jb Evain
 // Copyright (c) 2008 - 2011 Novell, Inc.
 //
 // Licensed under the MIT/X11 license.
 //

namespace Mono.Cecil.Metadata
{

	enum ElementType : byte
	{
		None = 0x00,
		Void = 0x01,
		Boolean = 0x02,
		Char = 0x03,
		I1 = 0x04,
		U1 = 0x05,
		I2 = 0x06,
		U2 = 0x07,
		I4 = 0x08,
		U4 = 0x09,
		I8 = 0x0a,
		U8 = 0x0b,
		R4 = 0x0c,
		R8 = 0x0d,
		String = 0x0e,
		Ptr = 0x0f,   // Followed by <type> token
		ByRef = 0x10,   // Followed by <type> token
		ValueType = 0x11,   // Followed by <type> token
		Class = 0x12,   // Followed by <type> token
		Var = 0x13,   // Followed by generic parameter number
		Array = 0x14,   // <type> <rank> <boundsCount> <bound1>  <loCount> <lo1>
		GenericInst = 0x15,   // <type> <type-arg-count> <type-1> ... <type-n> */
		TypedByRef = 0x16,
		I = 0x18,   // System.IntPtr
		U = 0x19,   // System.UIntPtr
		FnPtr = 0x1b,   // Followed by full method signature
		Object = 0x1c,   // System.Object
		SzArray = 0x1d,   // Single-dim array with 0 lower bound
		MVar = 0x1e,   // Followed by generic parameter number
		CModReqD = 0x1f,   // Required modifier : followed by a TypeDef or TypeRef token
		CModOpt = 0x20,   // Optional modifier : followed by a TypeDef or TypeRef token
		Internal = 0x21,   // Implemented within the CLI
		Modifier = 0x40,   // Or'd with following element types
		Sentinel = 0x41,   // Sentinel for varargs method signature
		Pinned = 0x45,   // Denotes a local variable that points at a pinned object

		// special undocumented constants
		Type = 0x50,
		Boxed = 0x51,
		Enum = 0x55
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil
{

	public sealed class EmbeddedResource : Resource
	{

		readonly MetadataReader reader;

		uint? offset;
		byte[] data;
		Stream stream;

		public override ResourceType ResourceType
		{
			get { return ResourceType.Embedded; }
		}

		public EmbeddedResource(string name, ManifestResourceAttributes attributes, byte[] data) :
			base(name, attributes)
		{
			this.data = data;
		}

		public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream) :
			base(name, attributes)
		{
			this.stream = stream;
		}

		internal EmbeddedResource(string name, ManifestResourceAttributes attributes, uint offset, MetadataReader reader)
			: base(name, attributes)
		{
			this.offset = offset;
			this.reader = reader;
		}

		public Stream GetResourceStream()
		{
			if (stream != null)
				return stream;

			if (data != null)
				return new MemoryStream(data);

			if (offset.HasValue)
				return new MemoryStream(reader.GetManagedResource(offset.Value));

			throw new InvalidOperationException();
		}

		public byte[] GetResourceData()
		{
			if (stream != null)
				return ReadStream(stream);

			if (data != null)
				return data;

			if (offset.HasValue)
				return reader.GetManagedResource(offset.Value);

			throw new InvalidOperationException();
		}

		static byte[] ReadStream(Stream stream)
		{
			int read;

			if (stream.CanSeek)
			{
				var length = (int)stream.Length;
				var data = new byte[length];
				int offset = 0;

				while ((read = stream.Read(data, offset, length - offset)) > 0)
					offset += read;

				return data;
			}

			var buffer = new byte[1024 * 8];
			var memory = new MemoryStream();
			while ((read = stream.Read(buffer, 0, buffer.Length)) > 0)
				memory.Write(buffer, 0, read);

			return memory.ToArray();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono
{

	static class Empty<T>
	{

		public static readonly T[] Array = new T[0];
	}

	class ArgumentNullOrEmptyException : ArgumentException
	{

		public ArgumentNullOrEmptyException(string paramName)
			: base("Argument null or empty", paramName)
		{
		}
	}
}

namespace Mono.Cecil
{

	static partial class Mixin
	{

		public static bool IsNullOrEmpty<T>(this T[] self)
		{
			return self == null || self.Length == 0;
		}

		public static bool IsNullOrEmpty<T>(this Collection<T> self)
		{
			return self == null || self.size == 0;
		}

		public static T[] Resize<T>(this T[] self, int length)
		{
			Array.Resize(ref self, length);
			return self;
		}

		public static T[] Add<T>(this T[] self, T item)
		{
			if (self == null)
			{
				self = new[] { item };
				return self;
			}

			self = self.Resize(self.Length + 1);
			self[self.Length - 1] = item;
			return self;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum EventAttributes : ushort
	{
		None = 0x0000,
		SpecialName = 0x0200,   // Event is special
		RTSpecialName = 0x0400   // CLI provides 'special' behavior, depending upon the name of the event
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil
{

	public sealed class EventDefinition : EventReference, IMemberDefinition
	{

		ushort attributes;

		Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition add_method;
		internal MethodDefinition invoke_method;
		internal MethodDefinition remove_method;
		internal Collection<MethodDefinition> other_methods;

		public EventAttributes Attributes
		{
			get { return (EventAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public MethodDefinition AddMethod
		{
			get
			{
				if (add_method != null)
					return add_method;

				InitializeMethods();
				return add_method;
			}
			set { add_method = value; }
		}

		public MethodDefinition InvokeMethod
		{
			get
			{
				if (invoke_method != null)
					return invoke_method;

				InitializeMethods();
				return invoke_method;
			}
			set { invoke_method = value; }
		}

		public MethodDefinition RemoveMethod
		{
			get
			{
				if (remove_method != null)
					return remove_method;

				InitializeMethods();
				return remove_method;
			}
			set { remove_method = value; }
		}

		public bool HasOtherMethods
		{
			get
			{
				if (other_methods != null)
					return other_methods.Count > 0;

				InitializeMethods();
				return !other_methods.IsNullOrEmpty();
			}
		}

		public Collection<MethodDefinition> OtherMethods
		{
			get
			{
				if (other_methods != null)
					return other_methods;

				InitializeMethods();

				if (other_methods == null)
					Interlocked.CompareExchange(ref other_methods, new Collection<MethodDefinition>(), null);

				return other_methods;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		#region EventAttributes

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((ushort)EventAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((ushort)EventAttributes.SpecialName, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((ushort)EventAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((ushort)EventAttributes.RTSpecialName, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType
		{
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public override bool IsDefinition
		{
			get { return true; }
		}

		public EventDefinition(string name, EventAttributes attributes, TypeReference eventType)
			: base(name, eventType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken(TokenType.Event);
		}

		void InitializeMethods()
		{
			var module = this.Module;
			if (module == null)
				return;

			lock (module.SyncRoot)
			{
				if (add_method != null
					|| invoke_method != null
					|| remove_method != null)
					return;

				if (!module.HasImage())
					return;

				module.Read(this, (@event, reader) => reader.ReadMethods(@event));
			}
		}

		public override EventDefinition Resolve()
		{
			return this;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public abstract class EventReference : MemberReference
	{

		TypeReference event_type;

		public TypeReference EventType
		{
			get { return event_type; }
			set { event_type = value; }
		}

		public override string FullName
		{
			get { return event_type.FullName + " " + MemberFullName(); }
		}

		protected EventReference(string name, TypeReference eventType)
			: base(name)
		{
			Mixin.CheckType(eventType, Mixin.Argument.eventType);
			event_type = eventType;
		}

		protected override IMemberDefinition ResolveDefinition()
		{
			return this.Resolve();
		}

		public new abstract EventDefinition Resolve();
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Cil
{

	public enum ExceptionHandlerType
	{
		Catch = 0,
		Filter = 1,
		Finally = 2,
		Fault = 4,
	}

	public sealed class ExceptionHandler
	{

		Instruction try_start;
		Instruction try_end;
		Instruction filter_start;
		Instruction handler_start;
		Instruction handler_end;

		TypeReference catch_type;
		ExceptionHandlerType handler_type;

		public Instruction TryStart
		{
			get { return try_start; }
			set { try_start = value; }
		}

		public Instruction TryEnd
		{
			get { return try_end; }
			set { try_end = value; }
		}

		public Instruction FilterStart
		{
			get { return filter_start; }
			set { filter_start = value; }
		}

		public Instruction HandlerStart
		{
			get { return handler_start; }
			set { handler_start = value; }
		}

		public Instruction HandlerEnd
		{
			get { return handler_end; }
			set { handler_end = value; }
		}

		public TypeReference CatchType
		{
			get { return catch_type; }
			set { catch_type = value; }
		}

		public ExceptionHandlerType HandlerType
		{
			get { return handler_type; }
			set { handler_type = value; }
		}

		public ExceptionHandler(ExceptionHandlerType handlerType)
		{
			this.handler_type = handlerType;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public sealed class ExportedType : IMetadataTokenProvider
	{

		string @namespace;
		string name;
		uint attributes;
		IMetadataScope scope;
		ModuleDefinition module;
		int identifier;
		ExportedType declaring_type;
		internal MetadataToken token;

		public string Namespace
		{
			get { return @namespace; }
			set { @namespace = value; }
		}

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public TypeAttributes Attributes
		{
			get { return (TypeAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public IMetadataScope Scope
		{
			get
			{
				if (declaring_type != null)
					return declaring_type.Scope;

				return scope;
			}
			set
			{
				if (declaring_type != null)
				{
					declaring_type.Scope = value;
					return;
				}

				scope = value;
			}
		}

		public ExportedType DeclaringType
		{
			get { return declaring_type; }
			set { declaring_type = value; }
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		public int Identifier
		{
			get { return identifier; }
			set { identifier = value; }
		}

		#region TypeAttributes

		public bool IsNotPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic, value); }
		}

		public bool IsPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public, value); }
		}

		public bool IsNestedPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic, value); }
		}

		public bool IsNestedPrivate
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate, value); }
		}

		public bool IsNestedFamily
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily, value); }
		}

		public bool IsNestedAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly, value); }
		}

		public bool IsNestedFamilyAndAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem, value); }
		}

		public bool IsNestedFamilyOrAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem, value); }
		}

		public bool IsAutoLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout, value); }
		}

		public bool IsSequentialLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout, value); }
		}

		public bool IsExplicitLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout, value); }
		}

		public bool IsClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class, value); }
		}

		public bool IsInterface
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface, value); }
		}

		public bool IsAbstract
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Abstract); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Abstract, value); }
		}

		public bool IsSealed
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Sealed); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Sealed, value); }
		}

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.SpecialName, value); }
		}

		public bool IsImport
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Import); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Import, value); }
		}

		public bool IsSerializable
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Serializable); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Serializable, value); }
		}

		public bool IsAnsiClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass, value); }
		}

		public bool IsUnicodeClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass, value); }
		}

		public bool IsAutoClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass, value); }
		}

		public bool IsBeforeFieldInit
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.BeforeFieldInit); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.BeforeFieldInit, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.HasSecurity, value); }
		}

		#endregion

		public bool IsForwarder
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Forwarder); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Forwarder, value); }
		}

		public string FullName
		{
			get
			{
				var fullname = string.IsNullOrEmpty(@namespace)
					? name
					: @namespace + '.' + name;

				if (declaring_type != null)
					return declaring_type.FullName + "/" + fullname;

				return fullname;
			}
		}

		public ExportedType(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
		{
			this.@namespace = @namespace;
			this.name = name;
			this.scope = scope;
			this.module = module;
		}

		public override string ToString()
		{
			return FullName;
		}

		public TypeDefinition Resolve()
		{
			return module.Resolve(CreateReference());
		}

		internal TypeReference CreateReference()
		{
			return new TypeReference(@namespace, name, module, scope)
			{
				DeclaringType = declaring_type != null ? declaring_type.CreateReference() : null,
			};
		}
	}
}












namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Safely resolve a reference, silently discarding any exceptions.
		/// </summary>
		/// <param name="r">The reference to resolve.</param>
		/// <returns>The resolved definition or null.</returns>
		public static TypeDefinition SafeResolve(this TypeReference r)
		{
			try
			{
				return r.Resolve();
			}
			catch
			{
				return null;
			}
		}

		/// <summary>
		/// Safely resolve a reference, silently discarding any exceptions.
		/// </summary>
		/// <param name="r">The reference to resolve.</param>
		/// <returns>The resolved definition or null.</returns>
		public static FieldDefinition SafeResolve(this FieldReference r)
		{
			try
			{
				return r.Resolve();
			}
			catch
			{
				return null;
			}
		}

		/// <summary>
		/// Safely resolve a reference, silently discarding any exceptions.
		/// </summary>
		/// <param name="r">The reference to resolve.</param>
		/// <returns>The resolved definition or null.</returns>
		public static MethodDefinition SafeResolve(this MethodReference r)
		{
			try
			{
				return r.Resolve();
			}
			catch
			{
				return null;
			}
		}

		/// <summary>
		/// Safely resolve a reference, silently discarding any exceptions.
		/// </summary>
		/// <param name="r">The reference to resolve.</param>
		/// <returns>The resolved definition or null.</returns>
		public static PropertyDefinition SafeResolve(this PropertyReference r)
		{
			try
			{
				return r.Resolve();
			}
			catch
			{
				return null;
			}
		}

		/// <summary>
		/// Get a certain custom attribute from an attribute provider.
		/// </summary>
		/// <param name="cap">The attribute provider.</param>
		/// <param name="attribute">The custom attribute name.</param>
		/// <returns>The first matching custom attribute, or null if no matching attribute has been found.</returns>
		public static CustomAttribute GetCustomAttribute(this Mono.Cecil.ICustomAttributeProvider cap, string attribute)
		{
			if (cap == null || !cap.HasCustomAttributes)
				return null;
			foreach (CustomAttribute attrib in cap.CustomAttributes)
				if (attrib.AttributeType.FullName == attribute)
					return attrib;
			return null;
		}

		/// <summary>
		/// Determine if an attribute provider has got a specific custom attribute.
		/// </summary>
		/// <param name="cap">The attribute provider.</param>
		/// <param name="attribute">The custom attribute name.</param>
		/// <returns>true if the attribute provider contains the given custom attribute, false otherwise.</returns>
		public static bool HasCustomAttribute(this Mono.Cecil.ICustomAttributeProvider cap, string attribute)
			=> cap.GetCustomAttribute(attribute) != null;

		/// <summary>
		/// Get the integer value pushed onto the stack with this instruction.
		/// </summary>
		/// <param name="instr">The instruction to get the pushed integer value for.</param>
		/// <returns>The pushed integer value.</returns>
		public static int GetInt(this Instruction instr)
		{
			OpCode op = instr.OpCode;
			if (op == OpCodes.Ldc_I4_M1)
				return -1;
			if (op == OpCodes.Ldc_I4_0)
				return 0;
			if (op == OpCodes.Ldc_I4_1)
				return 1;
			if (op == OpCodes.Ldc_I4_2)
				return 2;
			if (op == OpCodes.Ldc_I4_3)
				return 3;
			if (op == OpCodes.Ldc_I4_4)
				return 4;
			if (op == OpCodes.Ldc_I4_5)
				return 5;
			if (op == OpCodes.Ldc_I4_6)
				return 6;
			if (op == OpCodes.Ldc_I4_7)
				return 7;
			if (op == OpCodes.Ldc_I4_8)
				return 8;
			if (op == OpCodes.Ldc_I4_S)
				return (sbyte)instr.Operand;
			return (int)instr.Operand;
		}
		/// <summary>
		/// Get the integer value pushed onto the stack with this instruction.
		/// </summary>
		/// <param name="instr">The instruction to get the pushed integer value for.</param>
		/// <returns>The pushed integer value or null.</returns>
		public static int? GetIntOrNull(this Instruction instr)
		{
			OpCode op = instr.OpCode;
			if (op == OpCodes.Ldc_I4_M1)
				return -1;
			if (op == OpCodes.Ldc_I4_0)
				return 0;
			if (op == OpCodes.Ldc_I4_1)
				return 1;
			if (op == OpCodes.Ldc_I4_2)
				return 2;
			if (op == OpCodes.Ldc_I4_3)
				return 3;
			if (op == OpCodes.Ldc_I4_4)
				return 4;
			if (op == OpCodes.Ldc_I4_5)
				return 5;
			if (op == OpCodes.Ldc_I4_6)
				return 6;
			if (op == OpCodes.Ldc_I4_7)
				return 7;
			if (op == OpCodes.Ldc_I4_8)
				return 8;
			if (op == OpCodes.Ldc_I4_S)
				return (sbyte)instr.Operand;
			if (op == OpCodes.Ldc_I4)
				return (int)instr.Operand;
			return null;
		}

		/// <summary>
		/// Determine if the method call is a base method call.
		/// </summary>
		/// <param name="body">The caller method body.</param>
		/// <param name="called">The called method.</param>
		/// <returns>True if the called method is a base method of the caller method, false otherwise.</returns>
		public static bool IsBaseMethodCall(this Mono.Cecil.Cil.MethodBody body, MethodReference called)
		{
			MethodDefinition caller = body.Method;
			if (called == null)
				return false;
			TypeReference calledType = called.DeclaringType;
			while (calledType is TypeSpecification)
				calledType = ((TypeSpecification)calledType).ElementType;
			string calledTypeName = calledType.GetPatchFullName();

			bool callingBaseType = false;
			try
			{
				TypeDefinition baseType = caller.DeclaringType;
				while ((baseType = baseType.BaseType?.SafeResolve()) != null)
					if (baseType.GetPatchFullName() == calledTypeName)
					{
						callingBaseType = true;
						break;
					}
			}
			catch
			{
				callingBaseType = caller.DeclaringType.GetPatchFullName() == calledTypeName;
			}
			if (!callingBaseType)
				return false;

			// return caller.IsMatchingSignature(called);
			return true;
		}

		/// <summary>
		/// Determine if the given method can be preferably called using callvirt.
		/// </summary>
		/// <param name="method">The called method.</param>
		/// <returns>True if the called method can be called using callvirt, false otherwise.</returns>
		public static bool IsCallvirt(this MethodReference method)
		{
			if (!method.HasThis)
				return false;
			if (method.DeclaringType.IsValueType)
				return false;
			return true;
		}

		/// <summary>
		/// Determine if the given type is a struct (also known as "value type") or struct-alike (f.e. primitive).
		/// </summary>
		/// <param name="type">The type to check.</param>
		/// <returns>True if the type is a struct, primitive or similar, false otherwise.</returns>
		public static bool IsStruct(this TypeReference type)
		{
			if (!type.IsValueType)
				return false;
			if (type.IsPrimitive)
				return false;
			return true;
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		private static readonly Type t_Code = typeof(Code);
		private static readonly Type t_OpCodes = typeof(OpCodes);

		private static readonly Dictionary<int, OpCode> _ToLongOp = new Dictionary<int, OpCode>();
		/// <summary>
		/// Get the long form opcode for any short form opcode.
		/// </summary>
		/// <param name="op">The short form opcode.</param>
		/// <returns>The long form opcode.</returns>
		public static OpCode ToLongOp(this OpCode op)
		{
			string name = Enum.GetName(t_Code, op.Code);
			if (!name.EndsWith("_S", StringComparison.Ordinal))
				return op;
			lock (_ToLongOp)
			{
				if (_ToLongOp.TryGetValue((int)op.Code, out OpCode found))
					return found;
				return _ToLongOp[(int)op.Code] = (OpCode?)t_OpCodes.GetField(name.Substring(0, name.Length - 2))?.GetValue(null) ?? op;
			}
		}

		private static readonly Dictionary<int, OpCode> _ToShortOp = new Dictionary<int, OpCode>();
		/// <summary>
		/// Get the short form opcode for any long form opcode.
		/// </summary>
		/// <param name="op">The long form opcode.</param>
		/// <returns>The short form opcode.</returns>
		public static OpCode ToShortOp(this OpCode op)
		{
			string name = Enum.GetName(t_Code, op.Code);
			if (name.EndsWith("_S", StringComparison.Ordinal))
				return op;
			lock (_ToShortOp)
			{
				if (_ToShortOp.TryGetValue((int)op.Code, out OpCode found))
					return found;
				return _ToShortOp[(int)op.Code] = (OpCode?)t_OpCodes.GetField(name + "_S")?.GetValue(null) ?? op;
			}
		}


		/// <summary>
		/// Calculate updated instruction offsets. Required for certain manual fixes.
		/// </summary>
		/// <param name="method">The method to recalculate the IL instruction offsets for.</param>
		public static void RecalculateILOffsets(this MethodDefinition method)
		{
			if (!method.HasBody)
				return;

			int offs = 0;
			for (int i = 0; i < method.Body.Instructions.Count; i++)
			{
				Instruction instr = method.Body.Instructions[i];
				instr.Offset = offs;
				offs += instr.GetSize();
			}
		}

		/// <summary>
		/// Fix (and optimize) any instructions which should use the long / short form opcodes instead.
		/// </summary>
		/// <param name="method">The method to apply the fixes to.</param>
		public static void FixShortLongOps(this MethodDefinition method)
		{
			if (!method.HasBody)
				return;

			// Convert short to long ops.
			for (int i = 0; i < method.Body.Instructions.Count; i++)
			{
				Instruction instr = method.Body.Instructions[i];
				if (instr.Operand is Instruction)
				{
					instr.OpCode = instr.OpCode.ToLongOp();
				}
			}

			method.RecalculateILOffsets();

			// Optimize long to short ops.
			bool optimized;
			do
			{
				optimized = false;
				for (int i = 0; i < method.Body.Instructions.Count; i++)
				{
					Instruction instr = method.Body.Instructions[i];
					// Change short <-> long operations as the method grows / shrinks.
					if (instr.Operand is Instruction target)
					{
						// Thanks to Chicken Bones for helping out with this!
						int distance = target.Offset - (instr.Offset + instr.GetSize());
						if (distance == (sbyte)distance)
						{
							OpCode prev = instr.OpCode;
							instr.OpCode = instr.OpCode.ToShortOp();
							optimized = prev != instr.OpCode;
						}
					}
				}
			} while (optimized);
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Check if the signatures of a given System.Reflection and Mono.Cecil member reference match.
		/// </summary>
		/// <param name="minfo">The System.Reflection member reference.</param>
		/// <param name="mref">The Mono.Cecil member reference.</param>
		/// <returns>True if both references share the same signature, false otherwise.</returns>
		public static bool Is(this MemberInfo minfo, MemberReference mref)
			=> mref.Is(minfo);
		/// <summary>
		/// Check if the signatures of a given System.Reflection and Mono.Cecil member reference match.
		/// </summary>
		/// <param name="mref">The Mono.Cecil member reference.</param>
		/// <param name="minfo">The System.Reflection member reference.</param>
		/// <returns>True if both references share the same signature, false otherwise.</returns>
		public static bool Is(this MemberReference mref, MemberInfo minfo)
		{
			if (mref == null)
				return false;

			TypeReference mrefDecl = mref.DeclaringType;
			if (mrefDecl?.FullName == "<Module>")
				mrefDecl = null;

			if (mref is GenericParameter genParamRef)
			{
				if (!(minfo is Type genParamInfo))
					return false;

				if (!genParamInfo.IsGenericParameter)
				{
					if (genParamRef.Owner is IGenericInstance genParamRefOwner)
						return genParamRefOwner.GenericArguments[genParamRef.Position].Is(genParamInfo);
					else
						return false;
				}

				// Don't check owner as it introduces a circular check.
				/*
                if (!(genParamRef.Owner as MemberReference).Is(genParamInfo.DeclaringMethod ?? (System.Reflection.MemberInfo) genParamInfo.DeclaringType))
                    return false;
                */
				return genParamRef.Position == genParamInfo.GenericParameterPosition;
			}

			if (minfo.DeclaringType != null)
			{
				if (mrefDecl == null)
					return false;

				Type declType = minfo.DeclaringType;

				if (minfo is Type)
				{
					// Note: type.DeclaringType is supposed to == type.DeclaringType.GetGenericTypeDefinition()
					// For whatever reason, old versions of mono (f.e. shipped with Unity 5.0.3) break this,
					// requiring us to call .GetGenericTypeDefinition() manually instead.
					if (declType.IsGenericType && !declType.IsGenericTypeDefinition)
						declType = declType.GetGenericTypeDefinition();
				}

				if (!mrefDecl.Is(declType))
					return false;

			}
			else if (mrefDecl != null)
				return false;

			// Note: This doesn't work for TypeSpecification, as the reflection-side type.Name changes with some modifiers (f.e. IsArray).
			if (!(mref is TypeSpecification) && mref.Name != minfo.Name)
				return false;

			if (mref is TypeReference typeRef)
			{
				if (!(minfo is Type typeInfo))
					return false;

				if (typeInfo.IsGenericParameter)
					return false;

				if (mref is GenericInstanceType genTypeRef)
				{
					if (!typeInfo.IsGenericType)
						return false;

					Collection<TypeReference> gparamRefs = genTypeRef.GenericArguments;
					Type[] gparamInfos = typeInfo.GetGenericArguments();
					if (gparamRefs.Count != gparamInfos.Length)
						return false;

					for (int i = 0; i < gparamRefs.Count; i++)
					{
						if (!gparamRefs[i].Is(gparamInfos[i]))
							return false;
					}

					return genTypeRef.ElementType.Is(typeInfo.GetGenericTypeDefinition());

				}
				else if (typeRef.HasGenericParameters)
				{
					if (!typeInfo.IsGenericType)
						return false;

					Collection<GenericParameter> gparamRefs = typeRef.GenericParameters;
					Type[] gparamInfos = typeInfo.GetGenericArguments();
					if (gparamRefs.Count != gparamInfos.Length)
						return false;

					for (int i = 0; i < gparamRefs.Count; i++)
					{
						if (!gparamRefs[i].Is(gparamInfos[i]))
							return false;
					}

				}
				else if (typeInfo.IsGenericType)
					return false;

				if (mref is ArrayType arrayTypeRef)
				{
					if (!typeInfo.IsArray)
						return false;

					return arrayTypeRef.Dimensions.Count == typeInfo.GetArrayRank() && arrayTypeRef.ElementType.Is(typeInfo.GetElementType());
				}

				if (mref is ByReferenceType byRefTypeRef)
				{
					if (!typeInfo.IsByRef)
						return false;

					return byRefTypeRef.ElementType.Is(typeInfo.GetElementType());
				}

				if (mref is PointerType ptrTypeRef)
				{
					if (!typeInfo.IsPointer)
						return false;

					return ptrTypeRef.ElementType.Is(typeInfo.GetElementType());
				}

				if (mref is TypeSpecification typeSpecRef)
					// Note: There are TypeSpecifications which map to non-ElementType-y reflection Types.
					return typeSpecRef.ElementType.Is(typeInfo.HasElementType ? typeInfo.GetElementType() : typeInfo);

				// DeclaringType was already checked before.
				// Avoid converting nested type separators between + (.NET) and / (cecil)
				if (mrefDecl != null)
					return mref.Name == typeInfo.Name;
				return mref.FullName == typeInfo.FullName.Replace("+", "/", StringComparison.Ordinal);

			}
			else if (minfo is Type)
				return false;

			if (mref is MethodReference methodRef)
			{
				if (!(minfo is MethodBase methodInfo))
					return false;

				Collection<ParameterDefinition> paramRefs = methodRef.Parameters;
				ParameterInfo[] paramInfos = methodInfo.GetParameters();
				if (paramRefs.Count != paramInfos.Length)
					return false;

				if (mref is GenericInstanceMethod genMethodRef)
				{
					if (!methodInfo.IsGenericMethod)
						return false;

					Collection<TypeReference> gparamRefs = genMethodRef.GenericArguments;
					Type[] gparamInfos = methodInfo.GetGenericArguments();
					if (gparamRefs.Count != gparamInfos.Length)
						return false;

					for (int i = 0; i < gparamRefs.Count; i++)
					{
						if (!gparamRefs[i].Is(gparamInfos[i]))
							return false;
					}

					return genMethodRef.ElementMethod.Is((methodInfo as System.Reflection.MethodInfo)?.GetGenericMethodDefinition() ?? methodInfo);

				}
				else if (methodRef.HasGenericParameters)
				{
					if (!methodInfo.IsGenericMethod)
						return false;

					Collection<GenericParameter> gparamRefs = methodRef.GenericParameters;
					Type[] gparamInfos = methodInfo.GetGenericArguments();
					if (gparamRefs.Count != gparamInfos.Length)
						return false;

					for (int i = 0; i < gparamRefs.Count; i++)
					{
						if (!gparamRefs[i].Is(gparamInfos[i]))
							return false;
					}

				}
				else if (methodInfo.IsGenericMethod)
					return false;

				Relinker resolver = null;
				resolver = (paramMemberRef, ctx) => paramMemberRef is TypeReference paramTypeRef ? ResolveParameter(paramTypeRef) : paramMemberRef;
				TypeReference ResolveParameter(TypeReference paramTypeRef)
				{
					if (paramTypeRef is GenericParameter paramGenParamTypeRef)
					{
						if (paramGenParamTypeRef.Owner is MethodReference && methodRef is GenericInstanceMethod paramGenMethodRef)
							return paramGenMethodRef.GenericArguments[paramGenParamTypeRef.Position];

						if (paramGenParamTypeRef.Owner is TypeReference paramGenParamTypeRefOwnerType && methodRef.DeclaringType is GenericInstanceType genTypeRefRef &&
							paramGenParamTypeRefOwnerType.FullName == genTypeRefRef.ElementType.FullName) // This is to prevent List<Tuple<...>> checks from incorrectly checking Tuple's args in List.
							return genTypeRefRef.GenericArguments[paramGenParamTypeRef.Position];

						return paramTypeRef;
					}

					if (paramTypeRef == methodRef.DeclaringType.GetElementType())
						return methodRef.DeclaringType;

					return paramTypeRef;
				}

				if (!methodRef.ReturnType.Relink(resolver, null).Is(((methodInfo as System.Reflection.MethodInfo)?.ReturnType ?? typeof(void))) &&
					!methodRef.ReturnType.Is(((methodInfo as System.Reflection.MethodInfo)?.ReturnType ?? typeof(void))))
					return false;

				for (int i = 0; i < paramRefs.Count; i++)
					if (!paramRefs[i].ParameterType.Relink(resolver, null).Is(paramInfos[i].ParameterType) &&
						!paramRefs[i].ParameterType.Is(paramInfos[i].ParameterType))
						return false;

				return true;

			}
			else if (minfo is MethodInfo)
				return false;

			if (mref is FieldReference != minfo is FieldInfo)
				return false;

			if (mref is PropertyReference != minfo is PropertyInfo)
				return false;

			if (mref is EventReference != minfo is EventInfo)
				return false;

			return true;
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		public static IMetadataTokenProvider ImportReference(this ModuleDefinition mod, IMetadataTokenProvider mtp)
		{
			if (mtp is TypeReference)
				return mod.ImportReference((TypeReference)mtp);
			if (mtp is FieldReference)
				return mod.ImportReference((FieldReference)mtp);
			if (mtp is MethodReference)
				return mod.ImportReference((MethodReference)mtp);
			return mtp;
		}

#if CECIL0_9
        public static TypeReference ImportReference(this ModuleDefinition mod, TypeReference type)
            => mod.Import(type);
        public static TypeReference ImportReference(this ModuleDefinition mod, Type type, IGenericParameterProvider context)
            => mod.Import(type, context);
        public static FieldReference ImportReference(this ModuleDefinition mod, System.Reflection.FieldInfo field)
            => mod.Import(field);
        public static FieldReference ImportReference(this ModuleDefinition mod, System.Reflection.FieldInfo field, IGenericParameterProvider context)
            => mod.Import(field, context);
        public static MethodReference ImportReference(this ModuleDefinition mod, System.Reflection.MethodBase method)
            => mod.Import(method);
        public static MethodReference ImportReference(this ModuleDefinition mod, System.Reflection.MethodBase method, IGenericParameterProvider context)
            => mod.Import(method, context);
        public static TypeReference ImportReference(this ModuleDefinition mod, TypeReference type, IGenericParameterProvider context)
            => mod.Import(type, context);
        public static TypeReference ImportReference(this ModuleDefinition mod, Type type)
            => mod.Import(type);
        public static FieldReference ImportReference(this ModuleDefinition mod, FieldReference field)
            => mod.Import(field);
        public static MethodReference ImportReference(this ModuleDefinition mod, MethodReference method)
            => mod.Import(method);
        public static MethodReference ImportReference(this ModuleDefinition mod, MethodReference method, IGenericParameterProvider context)
            => mod.Import(method, context);
        public static FieldReference ImportReference(this ModuleDefinition mod, FieldReference field, IGenericParameterProvider context)
            => mod.Import(field, context);
#endif

	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// See <see cref="List{T}.AddRange(IEnumerable{T})"/>
		/// </summary>
		public static void AddRange<T>(this Collection<T> list, IEnumerable<T> other)
		{
			foreach (T entry in other)
				list.Add(entry);
		}
		/// <summary>
		/// See <see cref="List{T}.AddRange(IEnumerable{T})"/>
		/// </summary>
		public static void AddRange(this IDictionary dict, IDictionary other)
		{
			foreach (DictionaryEntry entry in other)
				dict.Add(entry.Key, entry.Value);
		}
		/// <summary>
		/// See <see cref="List{T}.AddRange(IEnumerable{T})"/>
		/// </summary>
		public static void AddRange<K, V>(this IDictionary<K, V> dict, IDictionary<K, V> other)
		{
			foreach (KeyValuePair<K, V> entry in other)
				dict.Add(entry.Key, entry.Value);
		}
		/// <summary>
		/// See <see cref="List{T}.AddRange(IEnumerable{T})"/>
		/// </summary>
		public static void AddRange<K, V>(this Dictionary<K, V> dict, Dictionary<K, V> other)
		{
			foreach (KeyValuePair<K, V> entry in other)
				dict.Add(entry.Key, entry.Value);
		}

		/// <summary>
		/// See <see cref="List{T}.InsertRange(int, IEnumerable{T})"/>
		/// </summary>
		public static void InsertRange<T>(this Collection<T> list, int index, IEnumerable<T> other)
		{
			foreach (T entry in other)
				list.Insert(index++, entry);
		}

	}
}














namespace MonoMod.Utils
{
	/// <summary>
	/// Collection of extensions used by MonoMod and other projects.
	/// </summary>
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		// Use this source file for any extensions which don't deserve their own source files.

		private static readonly object[] _NoArgs = new object[0];

		private static readonly Dictionary<Type, FieldInfo> fmap_mono_assembly = new Dictionary<Type, FieldInfo>();
		// Old versions of Mono which lack the arch field in MonoAssemblyName don't parse ProcessorArchitecture.
		private static readonly bool _MonoAssemblyNameHasArch =
			new AssemblyName("Dummy, ProcessorArchitecture=MSIL").ProcessorArchitecture == ProcessorArchitecture.MSIL;

		private static readonly Type _RTDynamicMethod =
			typeof(DynamicMethod).GetNestedType("RTDynamicMethod", BindingFlags.NonPublic | BindingFlags.Public);

		/// <summary>
		/// Determine if two types are compatible with each other (f.e. object with string, or enums with their underlying integer type).
		/// </summary>
		/// <param name="type">The first type.</param>
		/// <param name="other">The second type.</param>
		/// <returns>True if both types are compatible with each other, false otherwise.</returns>
		public static bool IsCompatible(this Type type, Type other)
			=> _IsCompatible(type, other) || _IsCompatible(other, type);
		private static bool _IsCompatible(this Type type, Type other)
		{
			if (type == other)
				return true;

			if (type.IsAssignableFrom(other))
				return true;

			if (other.IsEnum && IsCompatible(type, Enum.GetUnderlyingType(other)))
				return true;

			return false;
		}

		public static T GetDeclaredMember<T>(this T member) where T : MemberInfo
		{
			if (member.DeclaringType == member.ReflectedType)
				return member;

			int mt = member.MetadataToken;
			foreach (MemberInfo other in member.DeclaringType.GetMembers((BindingFlags)(-1)))
			{
				if (other.MetadataToken == mt)
					return (T)other;
			}

			return member;
		}

		public static unsafe void SetMonoCorlibInternal(this Assembly asm, bool value)
		{
			if (Type.GetType("Mono.Runtime") == null)
				return;

			// Mono doesn't know about IgnoresAccessChecksToAttribute,
			// but it lets some assemblies have unrestricted access.

			// https://github.com/mono/mono/blob/df846bcbc9706e325f3b5dca4d09530b80e9db83/mono/metadata/metadata-internals.h#L207
			// https://github.com/mono/mono/blob/1af992a5ffa46e20dd61a64b6dcecef0edb5c459/mono/metadata/appdomain.c#L1286
			// https://github.com/mono/mono/blob/beb81d3deb068f03efa72be986c96f9c3ab66275/mono/metadata/class.c#L5748
			// https://github.com/mono/mono/blob/83fc1456dbbd3a789c68fe0f3875820c901b1bd6/mcs/class/corlib/System.Reflection/Assembly.cs#L96
			// https://github.com/mono/mono/blob/cf69b4725976e51416bfdff22f3e1834006af00a/mcs/class/corlib/System.Reflection/RuntimeAssembly.cs#L59
			// https://github.com/mono/mono/blob/cf69b4725976e51416bfdff22f3e1834006af00a/mcs/class/corlib/System.Reflection.Emit/AssemblyBuilder.cs#L247
			// https://github.com/mono/mono/blob/ee3a669dc30689af8c8919afc61d226683a1aaa3/mcs/class/corlib/System.Reflection.Emit/AssemblyBuilder.cs#L258

			Type asmType = asm?.GetType();
			if (asmType == null)
				return;

			// _mono_assembly has changed places between Mono versions.
			FieldInfo f_mono_assembly;
			lock (fmap_mono_assembly)
			{
				if (!fmap_mono_assembly.TryGetValue(asmType, out f_mono_assembly))
				{
					f_mono_assembly =
						asmType.GetField("_mono_assembly", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance) ??
						asmType.GetField("dynamic_assembly", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
					fmap_mono_assembly[asmType] = f_mono_assembly;
				}
			}
			if (f_mono_assembly == null)
				return;

			// Assemblies marked as corlib_internal are hidden from AppDomain.GetAssemblies()
			// Make sure that at least the ReflectionHelper can find anything inside of them.
			AssemblyName name = new AssemblyName(asm.FullName);
			lock (ReflectionHelper.AssemblyCache)
			{
				WeakReference asmRef = new WeakReference(asm);
				ReflectionHelper.AssemblyCache[asm.GetRuntimeHashedFullName()] = asmRef;
				ReflectionHelper.AssemblyCache[name.FullName] = asmRef;
				ReflectionHelper.AssemblyCache[name.Name] = asmRef;
			}

			long asmPtr = 0L;
			// For AssemblyBuilders, dynamic_assembly is of type UIntPtr which doesn't cast to IntPtr
			switch (f_mono_assembly.GetValue(asm))
			{
				case IntPtr i:
					asmPtr = (long)i;
					break;
				case UIntPtr u:
					asmPtr = (long)u;
					break;
			}

			int offs =
				// ref_count (4 + padding)
				IntPtr.Size +
				// basedir
				IntPtr.Size +

				// aname
				// name
				IntPtr.Size +
				// culture
				IntPtr.Size +
				// hash_value
				IntPtr.Size +
				// public_key
				IntPtr.Size +
				// public_key_token (17 + padding)
				20 +
				// hash_alg
				4 +
				// hash_len
				4 +
				// flags
				4 +

				// major, minor, build, revision[, arch] (10 framework / 20 core + padding)
				(
					!_MonoAssemblyNameHasArch ? (
						typeof(object).Assembly.GetName().Name == "System.Private.CoreLib" ?
						16 :
						8
					) : (
						typeof(object).Assembly.GetName().Name == "System.Private.CoreLib" ?
						(IntPtr.Size == 4 ? 20 : 24) :
						(IntPtr.Size == 4 ? 12 : 16)
					)
				) +

				// image
				IntPtr.Size +
				// friend_assembly_names
				IntPtr.Size +
				// friend_assembly_names_inited
				1 +
				// in_gac
				1 +
				// dynamic
				1;
			byte* corlibInternalPtr = (byte*)(asmPtr + offs);
			*corlibInternalPtr = value ? (byte)1 : (byte)0;
		}

		public static bool IsDynamicMethod(this MethodBase method)
		{
			// .NET throws when trying to get metadata like the token / handle, but has got RTDynamicMethod.
			if (_RTDynamicMethod != null)
				return method is DynamicMethod || method.GetType() == _RTDynamicMethod;

			// Mono doesn't throw and instead returns 0 on its fake RuntimeMethodInfo.
			// Note that other runtime-internal methods (such as int[,].Get) are still resolvable yet have a token of 0.
			if (method is DynamicMethod)
				return true;

			// Fake DynamicMethods MUST have those.
			if (method.MetadataToken != 0 ||
				!method.IsStatic ||
				!method.IsPublic ||
				(method.Attributes & System.Reflection.MethodAttributes.ReuseSlot) != System.Reflection.MethodAttributes.ReuseSlot)
				return false;

			// Fake DynamicMethods aren't part of their declaring type.
			// Sounds obvious, but seems like the only real method to verify that it's a fake DynamicMethod.
			foreach (MethodInfo other in method.DeclaringType.GetMethods(BindingFlags.Public | BindingFlags.Static))
				if (method == other)
					return false;
			return true;
		}

		public static object SafeGetTarget(this WeakReference weak)
		{
			try
			{
				return weak.Target;
			}
			catch (InvalidOperationException)
			{
				// FUCK OLD UNITY MONO
				// https://github.com/Unity-Technologies/mono/blob/unity-2017.4/mcs/class/corlib/System/WeakReference.cs#L96
				// https://github.com/Unity-Technologies/mono/blob/unity-2017.4-mbe/mcs/class/corlib/System/WeakReference.cs#L94
				// https://docs.microsoft.com/en-us/archive/blogs/yunjin/trivial-debugging-note-using-weakreference-in-finalizer
				// "So on CLR V2.0 offical released build, you could safely use WeakReference in finalizer."
				return null;
			}
		}

		public static bool SafeGetIsAlive(this WeakReference weak)
		{
			try
			{
				return weak.IsAlive;
			}
			catch (InvalidOperationException)
			{
				// See above FUCK OLD UNITY MONO note.
				return false;
			}
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Creates a delegate of the specified type from this method.
		/// </summary>
		/// <param name="method">The method to create the delegate from.</param>
		/// <typeparam name="T">The type of the delegate to create.</typeparam>
		/// <returns>The delegate for this method.</returns>
		public static T CreateDelegate<T>(this MethodBase method) where T : Delegate
			=> (T)CreateDelegate(method, typeof(T), null);
		/// <summary>
		/// Creates a delegate of the specified type with the specified target from this method.
		/// </summary>
		/// <param name="method">The method to create the delegate from.</param>
		/// <typeparam name="T">The type of the delegate to create.</typeparam>
		/// <param name="target">The object targeted by the delegate.</param>
		/// <returns>The delegate for this method.</returns>
		public static T CreateDelegate<T>(this MethodBase method, object target) where T : Delegate
			=> (T)CreateDelegate(method, typeof(T), target);
		/// <summary>
		/// Creates a delegate of the specified type from this method.
		/// </summary>
		/// <param name="method">The method to create the delegate from.</param>
		/// <param name="delegateType">The type of the delegate to create.</param>
		/// <returns>The delegate for this method.</returns>
		public static Delegate CreateDelegate(this MethodBase method, Type delegateType)
			=> CreateDelegate(method, delegateType, null);
		/// <summary>
		/// Creates a delegate of the specified type with the specified target from this method.
		/// </summary>
		/// <param name="method">The method to create the delegate from.</param>
		/// <param name="delegateType">The type of the delegate to create.</param>
		/// <param name="target">The object targeted by the delegate.</param>
		/// <returns>The delegate for this method.</returns>
		public static Delegate CreateDelegate(this MethodBase method, Type delegateType, object target)
		{
			if (!typeof(Delegate).IsAssignableFrom(delegateType))
				throw new ArgumentException("Type argument must be a delegate type!");
			if (method is System.Reflection.Emit.DynamicMethod dm)
				return dm.CreateDelegate(delegateType, target);

#if NETSTANDARD
            // Built-in CreateDelegate is available in .NET Standard
            if (method is System.Reflection.MethodInfo mi)
                return mi.CreateDelegate(delegateType, target);
#endif

			RuntimeMethodHandle handle = method.MethodHandle;
			RuntimeHelpers.PrepareMethod(handle);
			IntPtr ptr = handle.GetFunctionPointer();
			return (Delegate)Activator.CreateInstance(delegateType, target, ptr);
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Find a method for a given ID.
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="id">The method ID.</param>
		/// <param name="simple">Whether to perform a simple search pass as well or not.</param>
		/// <returns>The first matching method or null.</returns>
		public static MethodDefinition FindMethod(this TypeDefinition type, string id, bool simple = true)
		{
			if (simple && !id.Contains(" ", StringComparison.Ordinal))
			{
				// First simple pass: With type name (just "Namespace.Type::MethodName")
				foreach (MethodDefinition method in type.Methods)
					if (method.GetID(simple: true) == id)
						return method;
				// Second simple pass: Without type name (basically name only)
				foreach (MethodDefinition method in type.Methods)
					if (method.GetID(withType: false, simple: true) == id)
						return method;
			}

			// First pass: With type name (f.e. global searches)
			foreach (MethodDefinition method in type.Methods)
				if (method.GetID() == id)
					return method;
			// Second pass: Without type name (f.e. LinkTo)
			foreach (MethodDefinition method in type.Methods)
				if (method.GetID(withType: false) == id)
					return method;

			return null;
		}
		/// <summary>
		/// Find a method for a given ID recursively (including the passed type's base types).
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="id">The method ID.</param>
		/// <param name="simple">Whether to perform a simple search pass as well or not.</param>
		/// <returns>The first matching method or null.</returns>
		public static MethodDefinition FindMethodDeep(this TypeDefinition type, string id, bool simple = true)
		{
			return type.FindMethod(id, simple) ?? type.BaseType?.Resolve()?.FindMethodDeep(id, simple);
		}

		/// <summary>
		/// Find a method for a given ID.
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="id">The method ID.</param>
		/// <param name="simple">Whether to perform a simple search pass as well or not.</param>
		/// <returns>The first matching method or null.</returns>
		public static MethodInfo FindMethod(this Type type, string id, bool simple = true)
		{
			MethodInfo[] methods = type.GetMethods(
				BindingFlags.Instance | BindingFlags.Static |
				BindingFlags.Public | BindingFlags.NonPublic
			);

			if (simple && !id.Contains(" ", StringComparison.Ordinal))
			{
				// First simple pass: With type name (just "Namespace.Type::MethodName")
				foreach (MethodInfo method in methods)
					if (method.GetID(simple: true) == id)
						return method;
				// Second simple pass: Without type name (basically name only)
				foreach (MethodInfo method in methods)
					if (method.GetID(withType: false, simple: true) == id)
						return method;
			}

			// First pass: With type name (f.e. global searches)
			foreach (MethodInfo method in methods)
				if (method.GetID() == id)
					return method;
			// Second pass: Without type name (f.e. LinkTo)
			foreach (MethodInfo method in methods)
				if (method.GetID(withType: false) == id)
					return method;

			return null;
		}
		/// <summary>
		/// Find a method for a given ID recursively (including the passed type's base types).
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="id">The method ID.</param>
		/// <param name="simple">Whether to perform a simple search pass as well or not.</param>
		/// <returns>The first matching method or null.</returns>
		public static MethodInfo FindMethodDeep(this Type type, string id, bool simple = true)
		{
			return type.FindMethod(id, simple) ?? type.BaseType?.FindMethodDeep(id, simple);
		}

		/// <summary>
		/// Find a property for a given name.
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The property name.</param>
		/// <returns>The first matching property or null.</returns>
		public static PropertyDefinition FindProperty(this TypeDefinition type, string name)
		{
			foreach (PropertyDefinition prop in type.Properties)
				if (prop.Name == name)
					return prop;
			return null;
		}
		/// <summary>
		/// Find a property for a given name recursively (including the passed type's base types).
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The property name.</param>
		/// <returns>The first matching property or null.</returns>
		public static PropertyDefinition FindPropertyDeep(this TypeDefinition type, string name)
		{
			return type.FindProperty(name) ?? type.BaseType?.Resolve()?.FindPropertyDeep(name);
		}

		/// <summary>
		/// Find a field for a given name.
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The field name.</param>
		/// <returns>The first matching field or null.</returns>
		public static FieldDefinition FindField(this TypeDefinition type, string name)
		{
			foreach (FieldDefinition field in type.Fields)
				if (field.Name == name)
					return field;
			return null;
		}
		/// <summary>
		/// Find a field for a given name recursively (including the passed type's base types).
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The field name.</param>
		/// <returns>The first matching field or null.</returns>
		public static FieldDefinition FindFieldDeep(this TypeDefinition type, string name)
		{
			return type.FindField(name) ?? type.BaseType?.Resolve()?.FindFieldDeep(name);
		}

		/// <summary>
		/// Find an event for a given name.
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The event name.</param>
		/// <returns>The first matching event or null.</returns>
		public static EventDefinition FindEvent(this TypeDefinition type, string name)
		{
			foreach (EventDefinition eventDef in type.Events)
				if (eventDef.Name == name)
					return eventDef;
			return null;
		}
		/// <summary>
		/// Find an event for a given name recursively (including the passed type's base types).
		/// </summary>
		/// <param name="type">The type to search in.</param>
		/// <param name="name">The event name.</param>
		/// <returns>The first matching event or null.</returns>
		public static EventDefinition FindEventDeep(this TypeDefinition type, string name)
		{
			return type.FindEvent(name) ?? type.BaseType?.Resolve()?.FindEventDeep(name);
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
		/// </summary>
		/// <param name="method">The method to get the ID for.</param>
		/// <param name="name">The name to use instead of the reference's own name.</param>
		/// <param name="type">The ID to use instead of the reference's declaring type ID.</param>
		/// <param name="withType">Whether the type ID should be included or not. System.Reflection avoids it by default.</param>
		/// <param name="simple">Whether the ID should be "simple" (name only).</param>
		/// <returns>The ID.</returns>
		public static string GetID(this MethodReference method, string name = null, string type = null, bool withType = true, bool simple = false)
		{
			StringBuilder builder = new StringBuilder();

			if (simple)
			{
				if (withType && (type != null || method.DeclaringType != null))
					builder.Append(type ?? method.DeclaringType.GetPatchFullName()).Append("::");
				builder.Append(name ?? method.Name);
				return builder.ToString();
			}

			builder
				.Append(method.ReturnType.GetPatchFullName())
				.Append(" ");

			if (withType && (type != null || method.DeclaringType != null))
				builder.Append(type ?? method.DeclaringType.GetPatchFullName()).Append("::");

			builder
				.Append(name ?? method.Name);

			if (method is GenericInstanceMethod gim && gim.GenericArguments.Count != 0)
			{
				builder.Append("<");
				Collection<TypeReference> arguments = gim.GenericArguments;
				for (int i = 0; i < arguments.Count; i++)
				{
					if (i > 0)
						builder.Append(",");
					builder.Append(arguments[i].GetPatchFullName());
				}
				builder.Append(">");

			}
			else if (method.GenericParameters.Count != 0)
			{
				builder.Append("<");
				Collection<GenericParameter> arguments = method.GenericParameters;
				for (int i = 0; i < arguments.Count; i++)
				{
					if (i > 0)
						builder.Append(",");
					builder.Append(arguments[i].Name);
				}
				builder.Append(">");
			}

			builder.Append("(");

			if (method.HasParameters)
			{
				Collection<ParameterDefinition> parameters = method.Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					ParameterDefinition parameter = parameters[i];
					if (i > 0)
						builder.Append(",");

					if (parameter.ParameterType.IsSentinel)
						builder.Append("...,");

					builder.Append(parameter.ParameterType.GetPatchFullName());
				}
			}

			builder.Append(")");

			return builder.ToString();
		}

		/// <summary>
		/// Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
		/// </summary>
		/// <param name="method">The call site to get the ID for.</param>
		/// <returns>The ID.</returns>
		public static string GetID(this Mono.Cecil.CallSite method)
		{
			StringBuilder builder = new StringBuilder();

			builder
				.Append(method.ReturnType.GetPatchFullName())
				.Append(" ");

			builder.Append("(");

			if (method.HasParameters)
			{
				Collection<ParameterDefinition> parameters = method.Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					ParameterDefinition parameter = parameters[i];
					if (i > 0)
						builder.Append(",");

					if (parameter.ParameterType.IsSentinel)
						builder.Append("...,");

					builder.Append(parameter.ParameterType.GetPatchFullName());
				}
			}

			builder.Append(")");

			return builder.ToString();
		}

		private static readonly Type t_ParamArrayAttribute = typeof(ParamArrayAttribute);
		/// <summary>
		/// Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
		/// </summary>
		/// <param name="method">The method to get the ID for.</param>
		/// <param name="name">The name to use instead of the reference's own name.</param>
		/// <param name="type">The ID to use instead of the reference's declaring type ID.</param>
		/// <param name="withType">Whether the type ID should be included or not. System.Reflection avoids it by default.</param>
		/// <param name="proxyMethod">Whether the method is regarded as a proxy method or not. Setting this paramater to true will skip the first parameter.</param>
		/// <param name="simple">Whether the ID should be "simple" (name only).</param>
		/// <returns>The ID.</returns>
		public static string GetID(this System.Reflection.MethodBase method, string name = null, string type = null, bool withType = true, bool proxyMethod = false, bool simple = false)
		{
			while (method is System.Reflection.MethodInfo && method.IsGenericMethod && !method.IsGenericMethodDefinition)
				method = ((System.Reflection.MethodInfo)method).GetGenericMethodDefinition();

			StringBuilder builder = new StringBuilder();

			if (simple)
			{
				if (withType && (type != null || method.DeclaringType != null))
					builder.Append(type ?? method.DeclaringType.FullName).Append("::");
				builder.Append(name ?? method.Name);
				return builder.ToString();
			}

			builder
				.Append((method as System.Reflection.MethodInfo)?.ReturnType?.FullName ?? "System.Void")
				.Append(" ");

			if (withType && (type != null || method.DeclaringType != null))
				builder.Append(type ?? method.DeclaringType.FullName.Replace("+", "/", StringComparison.Ordinal)).Append("::");

			builder
				.Append(name ?? method.Name);

			if (method.ContainsGenericParameters)
			{
				builder.Append("<");
				Type[] arguments = method.GetGenericArguments();
				for (int i = 0; i < arguments.Length; i++)
				{
					if (i > 0)
						builder.Append(",");
					builder.Append(arguments[i].Name);
				}
				builder.Append(">");
			}

			builder.Append("(");

			System.Reflection.ParameterInfo[] parameters = method.GetParameters();
			for (int i = proxyMethod ? 1 : 0; i < parameters.Length; i++)
			{
				System.Reflection.ParameterInfo parameter = parameters[i];
				if (i > (proxyMethod ? 1 : 0))
					builder.Append(",");

				bool defined;
				try
				{
#if NETSTANDARD
                    defined = System.Reflection.CustomAttributeExtensions.IsDefined(parameter, t_ParamArrayAttribute, false);
#else
					defined = parameter.GetCustomAttributes(t_ParamArrayAttribute, false).Length != 0;
#endif
				}
				catch (NotSupportedException)
				{
					// Newer versions of Mono are stupidly strict and like to throw a NotSupportedException on DynamicMethod args.
					defined = false;
				}
				if (defined)
					builder.Append("...,");

				builder.Append(parameter.ParameterType.FullName);
			}

			builder.Append(")");

			return builder.ToString();
		}

	}
}







namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Get the "patch name" - the name of the target to patch - for the given member.
		/// </summary>
		/// <param name="mr">The member to get the patch name for.</param>
		/// <returns>The patch name.</returns>
		public static string GetPatchName(this MemberReference mr)
		{
			return (mr as Mono.Cecil.ICustomAttributeProvider)?.GetPatchName() ?? mr.Name;
		}
		/// <summary>
		/// Get the "patch name" - the name of the target to patch - for the given member.
		/// </summary>
		/// <param name="mr">The member to get the patch name for.</param>
		/// <returns>The patch name.</returns>
		public static string GetPatchFullName(this MemberReference mr)
		{
			return (mr as Mono.Cecil.ICustomAttributeProvider)?.GetPatchFullName(mr) ?? mr.FullName;
		}

		private static string GetPatchName(this Mono.Cecil.ICustomAttributeProvider cap)
		{
			string name;

			CustomAttribute patchAttrib = cap.GetCustomAttribute("MonoMod.MonoModPatch");
			if (patchAttrib != null)
			{
				name = (string)patchAttrib.ConstructorArguments[0].Value;
				int dotIndex = name.LastIndexOf('.');
				if (dotIndex != -1 && dotIndex != name.Length - 1)
				{
					name = name.Substring(dotIndex + 1);
				}
				return name;
			}

			// Backwards-compatibility: Check for patch_
			name = ((MemberReference)cap).Name;
			return name.StartsWith("patch_", StringComparison.Ordinal) ? name.Substring(6) : name;
		}
		private static string GetPatchFullName(this Mono.Cecil.ICustomAttributeProvider cap, MemberReference mr)
		{
			if (cap is TypeReference type)
			{
				CustomAttribute patchAttrib = cap.GetCustomAttribute("MonoMod.MonoModPatch");
				string name;

				if (patchAttrib != null)
				{
					name = (string)patchAttrib.ConstructorArguments[0].Value;
				}
				else
				{
					// Backwards-compatibility: Check for patch_
					name = ((MemberReference)cap).Name;
					name = name.StartsWith("patch_", StringComparison.Ordinal) ? name.Substring(6) : name;
				}

				if (name.StartsWith("global::", StringComparison.Ordinal))
					name = name.Substring(8); // Patch name is refering to a global type.
				else if (name.Contains(".", StringComparison.Ordinal) || name.Contains("/", StringComparison.Ordinal)) { } // Patch name is already a full name.
				else if (!string.IsNullOrEmpty(type.Namespace))
					name = type.Namespace + "." + name;
				else if (type.IsNested)
					name = type.DeclaringType.GetPatchFullName() + "/" + name;

				if (mr is TypeSpecification)
				{
					// Collect TypeSpecifications and append formats back to front.
					List<TypeSpecification> formats = new List<TypeSpecification>();
					TypeSpecification ts = (TypeSpecification)mr;
					do
					{
						formats.Add(ts);
					} while ((ts = (ts.ElementType as TypeSpecification)) != null);

					StringBuilder builder = new StringBuilder(name.Length + formats.Count * 4);
					builder.Append(name);
					for (int formati = formats.Count - 1; formati > -1; --formati)
					{
						ts = formats[formati];

						if (ts.IsByReference)
							builder.Append("&");
						else if (ts.IsPointer)
							builder.Append("*");
						else if (ts.IsPinned) { } // FullName not overriden.
						else if (ts.IsSentinel) { } // FullName not overriden.
						else if (ts.IsArray)
						{
							ArrayType array = (ArrayType)ts;
							if (array.IsVector)
								builder.Append("[]");
							else
							{
								builder.Append("[");
								for (int i = 0; i < array.Dimensions.Count; i++)
								{
									if (i > 0)
										builder.Append(",");
									builder.Append(array.Dimensions[i].ToString());
								}
								builder.Append("]");
							}
						}
						else if (ts.IsRequiredModifier)
							builder.Append("modreq(").Append(((RequiredModifierType)ts).ModifierType).Append(")");
						else if (ts.IsOptionalModifier)
							builder.Append("modopt(").Append(((OptionalModifierType)ts).ModifierType).Append(")");
						else if (ts.IsGenericInstance)
						{
							GenericInstanceType gen = (GenericInstanceType)ts;
							builder.Append("<");
							for (int i = 0; i < gen.GenericArguments.Count; i++)
							{
								if (i > 0)
									builder.Append(",");
								builder.Append(gen.GenericArguments[i].GetPatchFullName());
							}
							builder.Append(">");
						}
						else if (ts.IsFunctionPointer)
						{
							FunctionPointerType fpt = (FunctionPointerType)ts;
							builder.Append(" ").Append(fpt.ReturnType.GetPatchFullName()).Append(" *(");
							if (fpt.HasParameters)
								for (int i = 0; i < fpt.Parameters.Count; i++)
								{
									ParameterDefinition parameter = fpt.Parameters[i];
									if (i > 0)
										builder.Append(",");

									if (parameter.ParameterType.IsSentinel)
										builder.Append("...,");

									builder.Append(parameter.ParameterType.FullName);
								}
							builder.Append(")");
						}
						else
							throw new NotSupportedException($"MonoMod can't handle TypeSpecification: {type.FullName} ({type.GetType()})");
					}

					name = builder.ToString();
				}

				return name;
			}

			if (cap is FieldReference field)
			{
				return $"{field.FieldType.GetPatchFullName()} {field.DeclaringType.GetPatchFullName()}::{cap.GetPatchName()}";
			}

			if (cap is MethodReference)
				throw new InvalidOperationException("GetPatchFullName not supported on MethodReferences - use GetID instead");

			throw new InvalidOperationException($"GetPatchFullName not supported on type {cap.GetType()}");
		}

	}
}












namespace MonoMod.Utils
{
	/// <summary>
	/// The relinker callback delegate type.
	/// </summary>
	/// <param name="mtp">The reference (metadata token provider) to relink.</param>
	/// <param name="context">The generic context provided to relink generic references.</param>
	/// <returns>A relinked reference.</returns>
	public delegate IMetadataTokenProvider Relinker(IMetadataTokenProvider mtp, IGenericParameterProvider context);
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		/// <summary>
		/// Clone the given method definition.
		/// </summary>
		/// <param name="o">The original method.</param>
		/// <param name="c">The method definition to apply the cloning process onto, or null to create a new method.</param>
		/// <returns>A clone of the original method.</returns>
		public static MethodDefinition Clone(this MethodDefinition o, MethodDefinition c = null)
		{
			if (o == null)
				return null;
			if (c == null)
				c = new MethodDefinition(o.Name, o.Attributes, o.ReturnType);
			c.Name = o.Name;
			c.Attributes = o.Attributes;
			c.ReturnType = o.ReturnType;
			c.DeclaringType = o.DeclaringType;
			c.MetadataToken = c.MetadataToken;
			c.Body = o.Body.Clone(c);
			c.Attributes = o.Attributes;
			c.ImplAttributes = o.ImplAttributes;
			c.PInvokeInfo = o.PInvokeInfo;
			c.IsPreserveSig = o.IsPreserveSig;
			c.IsPInvokeImpl = o.IsPInvokeImpl;

			foreach (GenericParameter genParam in o.GenericParameters)
				c.GenericParameters.Add(genParam.Clone());

			foreach (ParameterDefinition param in o.Parameters)
				c.Parameters.Add(param);

			foreach (CustomAttribute attrib in o.CustomAttributes)
				c.CustomAttributes.Add(attrib.Clone());

			foreach (MethodReference @override in o.Overrides)
				c.Overrides.Add(@override);

			return c;
		}

		/// <summary>
		/// Clone the given method body.
		/// </summary>
		/// <param name="bo">The original method body.</param>
		/// <param name="m">The method which will own the newly cloned method body.</param>
		/// <returns>A clone of the original method body.</returns>
		public static Mono.Cecil.Cil.MethodBody Clone(this Mono.Cecil.Cil.MethodBody bo, MethodDefinition m)
		{
			if (bo == null)
				return null;

			Mono.Cecil.Cil.MethodBody bc = new Mono.Cecil.Cil.MethodBody(m);
			bc.MaxStackSize = bo.MaxStackSize;
			bc.InitLocals = bo.InitLocals;
			bc.LocalVarToken = bo.LocalVarToken;

			bc.Instructions.AddRange(bo.Instructions.Select(o => {
				Instruction c = Instruction.Create(OpCodes.Nop);
				c.OpCode = o.OpCode;
				c.Operand = o.Operand;
				c.Offset = o.Offset;
				return c;
			}));

			foreach (Instruction c in bc.Instructions)
			{
				if (c.Operand is Instruction target)
				{
					c.Operand = bc.Instructions[bo.Instructions.IndexOf(target)];
				}
				else if (c.Operand is Instruction[] targets)
				{
					c.Operand = targets.Select(i => bc.Instructions[bo.Instructions.IndexOf(i)]).ToArray();
				}
			}

			bc.ExceptionHandlers.AddRange(bo.ExceptionHandlers.Select(o => {
				ExceptionHandler c = new ExceptionHandler(o.HandlerType);
				c.TryStart = o.TryStart == null ? null : bc.Instructions[bo.Instructions.IndexOf(o.TryStart)];
				c.TryEnd = o.TryEnd == null ? null : bc.Instructions[bo.Instructions.IndexOf(o.TryEnd)];
				c.FilterStart = o.FilterStart == null ? null : bc.Instructions[bo.Instructions.IndexOf(o.FilterStart)];
				c.HandlerStart = o.HandlerStart == null ? null : bc.Instructions[bo.Instructions.IndexOf(o.HandlerStart)];
				c.HandlerEnd = o.HandlerEnd == null ? null : bc.Instructions[bo.Instructions.IndexOf(o.HandlerEnd)];
				c.CatchType = o.CatchType;
				return c;
			}));

			bc.Variables.AddRange(bo.Variables.Select(o => {
				VariableDefinition c = new VariableDefinition(o.VariableType);
				return c;
			}));

#if !CECIL0_9
			m.CustomDebugInformations.AddRange(bo.Method.CustomDebugInformations); // Abstract. TODO: Implement deep CustomDebugInformations copy.
			m.DebugInformation.SequencePoints.AddRange(bo.Method.DebugInformation.SequencePoints.Select(o => {
				SequencePoint c = new SequencePoint(bc.Instructions.FirstOrDefault(i => i.Offset == o.Offset), o.Document);
				c.StartLine = o.StartLine;
				c.StartColumn = o.StartColumn;
				c.EndLine = o.EndLine;
				c.EndColumn = o.EndColumn;
				return c;
			}));
#endif

			return bc;
		}

		private static readonly System.Reflection.FieldInfo f_GenericParameter_position = typeof(GenericParameter).GetField("position", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
		private static readonly System.Reflection.FieldInfo f_GenericParameter_type = typeof(GenericParameter).GetField("type", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
		/// <summary>
		/// Force-update a generic parameter's position and type.
		/// </summary>
		/// <param name="param">The generic parameter to update.</param>
		/// <param name="position">The new position.</param>
		/// <param name="type">The new type.</param>
		/// <returns>The updated generic parameter.</returns>
		public static GenericParameter Update(this GenericParameter param, int position, GenericParameterType type)
		{
			f_GenericParameter_position.SetValue(param, position);
			f_GenericParameter_type.SetValue(param, type);
			return param;
		}

		/// <summary>
		/// Resolve a given generic parameter in another context.
		/// </summary>
		/// <param name="provider">The new context.</param>
		/// <param name="orig">The original generic parameter.</param>
		/// <returns>A generic parameter provided by the given context which matches the original generic parameter.</returns>
		public static GenericParameter ResolveGenericParameter(this IGenericParameterProvider provider, GenericParameter orig)
		{
			// This can be true for T[,].Get in "Enter the Gungeon"
			if (provider is GenericParameter && ((GenericParameter)provider).Name == orig.Name)
				return (GenericParameter)provider;

			foreach (GenericParameter param in provider.GenericParameters)
				if (param.Name == orig.Name)
					return param;

			int index = orig.Position;
			if (provider is MethodReference && orig.DeclaringMethod != null)
			{
				if (index < provider.GenericParameters.Count)
					return provider.GenericParameters[index];
				else
					return new GenericParameter(orig.Name, provider).Update(index, GenericParameterType.Method);
			}

			if (provider is TypeReference && orig.DeclaringType != null)
				if (index < provider.GenericParameters.Count)
					return provider.GenericParameters[index];
				else
					return new GenericParameter(orig.Name, provider).Update(index, GenericParameterType.Type);

			return
				(provider as TypeSpecification)?.ElementType.ResolveGenericParameter(orig) ??
				(provider as MemberReference)?.DeclaringType?.ResolveGenericParameter(orig);
		}

		/// <summary>
		/// Relink the given member reference (metadata token provider).
		/// </summary>
		/// <param name="mtp">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static IMetadataTokenProvider Relink(this IMetadataTokenProvider mtp, Relinker relinker, IGenericParameterProvider context)
		{
			if (mtp is TypeReference) return ((TypeReference)mtp).Relink(relinker, context);
#if !CECIL0_10
			if (mtp is GenericParameterConstraint) return ((GenericParameterConstraint)mtp).Relink(relinker, context);
#endif
			if (mtp is MethodReference) return ((MethodReference)mtp).Relink(relinker, context);
			if (mtp is FieldReference) return ((FieldReference)mtp).Relink(relinker, context);
			if (mtp is ParameterDefinition) return ((ParameterDefinition)mtp).Relink(relinker, context);
			if (mtp is Mono.Cecil.CallSite) return ((Mono.Cecil.CallSite)mtp).Relink(relinker, context);
			throw new InvalidOperationException($"MonoMod can't handle metadata token providers of the type {mtp.GetType()}");
		}

		/// <summary>
		/// Relink the given type reference.
		/// </summary>
		/// <param name="type">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static TypeReference Relink(this TypeReference type, Relinker relinker, IGenericParameterProvider context)
		{
			if (type == null)
				return null;

			if (type is TypeSpecification ts)
			{
				TypeReference relinkedElem = ts.ElementType.Relink(relinker, context);

				if (type.IsSentinel)
					return new SentinelType(relinkedElem);

				if (type.IsByReference)
					return new ByReferenceType(relinkedElem);

				if (type.IsPointer)
					return new PointerType(relinkedElem);

				if (type.IsPinned)
					return new PinnedType(relinkedElem);

				if (type.IsArray)
				{
					ArrayType at = new ArrayType(relinkedElem, ((ArrayType)type).Rank);
					for (int i = 0; i < at.Rank; i++)
						// It's a struct.
						at.Dimensions[i] = ((ArrayType)type).Dimensions[i];
					return at;
				}

				if (type.IsRequiredModifier)
					return new RequiredModifierType(((RequiredModifierType)type).ModifierType.Relink(relinker, context), relinkedElem);

				if (type.IsOptionalModifier)
					return new OptionalModifierType(((OptionalModifierType)type).ModifierType.Relink(relinker, context), relinkedElem);

				if (type.IsGenericInstance)
				{
					GenericInstanceType git = new GenericInstanceType(relinkedElem);
					foreach (TypeReference genArg in ((GenericInstanceType)type).GenericArguments)
						git.GenericArguments.Add(genArg?.Relink(relinker, context));
					return git;
				}

				if (type.IsFunctionPointer)
				{
					FunctionPointerType fp = (FunctionPointerType)type;
					fp.ReturnType = fp.ReturnType.Relink(relinker, context);
					for (int i = 0; i < fp.Parameters.Count; i++)
						fp.Parameters[i].ParameterType = fp.Parameters[i].ParameterType.Relink(relinker, context);
					return fp;
				}

				throw new NotSupportedException($"MonoMod can't handle TypeSpecification: {type.FullName} ({type.GetType()})");
			}

			if (type.IsGenericParameter && context != null)
			{
				GenericParameter genParam = context.ResolveGenericParameter((GenericParameter)type);
				if (genParam == null)
					throw new RelinkTargetNotFoundException($"{RelinkTargetNotFoundException.DefaultMessage} {type.FullName} (context: {context})", type, context);
				for (int i = 0; i < genParam.Constraints.Count; i++)
					if (!genParam.Constraints[i].GetConstraintType().IsGenericInstance) // That is somehow possible and causes a stack overflow.
						genParam.Constraints[i] = genParam.Constraints[i].Relink(relinker, context);
				return genParam;
			}

			return (TypeReference)relinker(type, context);
		}

#if !CECIL0_10
		/// <summary>
		/// Relink the given type reference.
		/// </summary>
		/// <param name="constraint">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static GenericParameterConstraint Relink(this GenericParameterConstraint constraint, Relinker relinker, IGenericParameterProvider context)
		{
			if (constraint == null)
				return null;

			GenericParameterConstraint relink = new GenericParameterConstraint(constraint.ConstraintType.Relink(relinker, context));

			foreach (CustomAttribute attrib in constraint.CustomAttributes)
				relink.CustomAttributes.Add(attrib.Relink(relinker, context));

			return relink;
		}
#endif

		/// <summary>
		/// Relink the given method reference.
		/// </summary>
		/// <param name="method">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static IMetadataTokenProvider Relink(this MethodReference method, Relinker relinker, IGenericParameterProvider context)
		{
			if (method.IsGenericInstance)
			{
				GenericInstanceMethod methodg = (GenericInstanceMethod)method;
				GenericInstanceMethod gim = new GenericInstanceMethod((MethodReference)methodg.ElementMethod.Relink(relinker, context));
				foreach (TypeReference arg in methodg.GenericArguments)
					// Generic arguments for the generic instance are often given by the next higher provider.
					gim.GenericArguments.Add(arg.Relink(relinker, context));

				return (MethodReference)relinker(gim, context);
			}

			MethodReference relink = new MethodReference(method.Name, method.ReturnType, method.DeclaringType.Relink(relinker, context));

			relink.CallingConvention = method.CallingConvention;
			relink.ExplicitThis = method.ExplicitThis;
			relink.HasThis = method.HasThis;

			foreach (GenericParameter param in method.GenericParameters)
			{
				GenericParameter paramN = new GenericParameter(param.Name, param.Owner)
				{
					Attributes = param.Attributes
				}.Update(param.Position, param.Type);

				relink.GenericParameters.Add(paramN);

#pragma warning disable IDE0008 // TypeReference in cecil 0.10, GenericParameterConstraint in cecil 0.11
				foreach (var constraint in param.Constraints)
				{
#pragma warning restore IDE0008
					paramN.Constraints.Add(constraint.Relink(relinker, relink));
				}
			}

			relink.ReturnType = relink.ReturnType?.Relink(relinker, relink);

			foreach (ParameterDefinition param in method.Parameters)
			{
				param.ParameterType = param.ParameterType.Relink(relinker, method);
				relink.Parameters.Add(param);
			}

			return (MethodReference)relinker(relink, context);
		}

		/// <summary>
		/// Relink the given callsite.
		/// </summary>
		/// <param name="method">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static Mono.Cecil.CallSite Relink(this Mono.Cecil.CallSite method, Relinker relinker, IGenericParameterProvider context)
		{
			Mono.Cecil.CallSite relink = new Mono.Cecil.CallSite(method.ReturnType);

			relink.CallingConvention = method.CallingConvention;
			relink.ExplicitThis = method.ExplicitThis;
			relink.HasThis = method.HasThis;

			relink.ReturnType = relink.ReturnType?.Relink(relinker, context);

			foreach (ParameterDefinition param in method.Parameters)
			{
				param.ParameterType = param.ParameterType.Relink(relinker, context);
				relink.Parameters.Add(param);
			}

			return (Mono.Cecil.CallSite)relinker(relink, context);
		}

		/// <summary>
		/// Relink the given field reference.
		/// </summary>
		/// <param name="field">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static IMetadataTokenProvider Relink(this FieldReference field, Relinker relinker, IGenericParameterProvider context)
		{
			TypeReference declaringType = field.DeclaringType.Relink(relinker, context);
			return relinker(new FieldReference(field.Name, field.FieldType.Relink(relinker, declaringType), declaringType), context);
		}

		/// <summary>
		/// Relink the given parameter definition.
		/// </summary>
		/// <param name="param">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static ParameterDefinition Relink(this ParameterDefinition param, Relinker relinker, IGenericParameterProvider context)
		{
			param = (param.Method as MethodReference)?.Parameters[param.Index] ?? param;
			ParameterDefinition newParam = new ParameterDefinition(param.Name, param.Attributes, param.ParameterType.Relink(relinker, context))
			{
				IsIn = param.IsIn,
				IsLcid = param.IsLcid,
				IsOptional = param.IsOptional,
				IsOut = param.IsOut,
				IsReturnValue = param.IsReturnValue,
				MarshalInfo = param.MarshalInfo
			};
			if (param.HasConstant)
				newParam.Constant = param.Constant;
			return newParam;
		}

		/// <summary>
		/// Clone the given parameter definition.
		/// </summary>
		/// <param name="param">The original parameter definition.</param>
		/// <returns>A clone of the original parameter definition.</returns>
		public static ParameterDefinition Clone(this ParameterDefinition param)
		{
			ParameterDefinition newParam = new ParameterDefinition(param.Name, param.Attributes, param.ParameterType)
			{
				IsIn = param.IsIn,
				IsLcid = param.IsLcid,
				IsOptional = param.IsOptional,
				IsOut = param.IsOut,
				IsReturnValue = param.IsReturnValue,
				MarshalInfo = param.MarshalInfo
			};
			if (param.HasConstant)
				newParam.Constant = param.Constant;
			foreach (CustomAttribute attrib in param.CustomAttributes)
				newParam.CustomAttributes.Add(attrib.Clone());
			return newParam;
		}

		/// <summary>
		/// Relink the given custom attribute.
		/// </summary>
		/// <param name="attrib">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static CustomAttribute Relink(this CustomAttribute attrib, Relinker relinker, IGenericParameterProvider context)
		{
			CustomAttribute newAttrib = new CustomAttribute((MethodReference)attrib.Constructor.Relink(relinker, context));
			foreach (CustomAttributeArgument attribArg in attrib.ConstructorArguments)
				newAttrib.ConstructorArguments.Add(new CustomAttributeArgument(attribArg.Type.Relink(relinker, context), attribArg.Value));
			foreach (Mono.Cecil.CustomAttributeNamedArgument attribArg in attrib.Fields)
				newAttrib.Fields.Add(new Mono.Cecil.CustomAttributeNamedArgument(attribArg.Name,
					new CustomAttributeArgument(attribArg.Argument.Type.Relink(relinker, context), attribArg.Argument.Value))
				);
			foreach (Mono.Cecil.CustomAttributeNamedArgument attribArg in attrib.Properties)
				newAttrib.Properties.Add(new Mono.Cecil.CustomAttributeNamedArgument(attribArg.Name,
					new CustomAttributeArgument(attribArg.Argument.Type.Relink(relinker, context), attribArg.Argument.Value))
				);
			return newAttrib;
		}

		/// <summary>
		/// Clone the given custom attribute.
		/// </summary>
		/// <param name="attrib">The original custom attribute.</param>
		/// <returns>A clone of the original custom attribute.</returns>
		public static CustomAttribute Clone(this CustomAttribute attrib)
		{
			CustomAttribute newAttrib = new CustomAttribute(attrib.Constructor);
			foreach (CustomAttributeArgument attribArg in attrib.ConstructorArguments)
				newAttrib.ConstructorArguments.Add(new CustomAttributeArgument(attribArg.Type, attribArg.Value));
			foreach (Mono.Cecil.CustomAttributeNamedArgument attribArg in attrib.Fields)
				newAttrib.Fields.Add(new Mono.Cecil.CustomAttributeNamedArgument(attribArg.Name,
					new CustomAttributeArgument(attribArg.Argument.Type, attribArg.Argument.Value))
				);
			foreach (Mono.Cecil.CustomAttributeNamedArgument attribArg in attrib.Properties)
				newAttrib.Properties.Add(new Mono.Cecil.CustomAttributeNamedArgument(attribArg.Name,
					new CustomAttributeArgument(attribArg.Argument.Type, attribArg.Argument.Value))
				);
			return newAttrib;
		}

		/// <summary>
		/// Relink the given generic parameter reference.
		/// </summary>
		/// <param name="param">The reference to relink.</param>
		/// <param name="relinker">The relinker to use during the relinking process.</param>
		/// <param name="context">The generic context provided to relink generic references.</param>
		/// <returns>A relinked reference.</returns>
		public static GenericParameter Relink(this GenericParameter param, Relinker relinker, IGenericParameterProvider context)
		{
			GenericParameter newParam = new GenericParameter(param.Name, param.Owner)
			{
				Attributes = param.Attributes
			}.Update(param.Position, param.Type);
#pragma warning disable IDE0008 // TypeReference in cecil 0.10, GenericParameterConstraint in cecil 0.11
			foreach (var constraint in param.Constraints)
#pragma warning restore IDE0008
				newParam.Constraints.Add(constraint.Relink(relinker, context));
			return newParam;
		}

		/// <summary>
		/// Clone the given generic parameter.
		/// </summary>
		/// <param name="param">The original generic parameter.</param>
		/// <returns>A clone of the original generic parameter.</returns>
		public static GenericParameter Clone(this GenericParameter param)
		{
			GenericParameter newParam = new GenericParameter(param.Name, param.Owner)
			{
				Attributes = param.Attributes
			}.Update(param.Position, param.Type);
#pragma warning disable IDE0008 // TypeReference in cecil 0.10, GenericParameterConstraint in cecil 0.11
			foreach (var constraint in param.Constraints)
#pragma warning restore IDE0008
				newParam.Constraints.Add(constraint);
			return newParam;
		}

	}
}













namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class Extensions
	{

		private static readonly Dictionary<Type, int> _GetManagedSizeCache = new Dictionary<Type, int>() {
			{ typeof(void), 0 }
		};
		private static MethodInfo _GetManagedSizeHelper;
		/// <summary>
		/// Get the managed size of a given type. This matches an IL-level sizeof(t), even if it cannot be determined normally in C#.
		/// Note that sizeof(t) != Marshal.SizeOf(t), f.e. when t is char.
		/// </summary>
		/// <param name="t">The type to get the size from.</param>
		/// <returns>The managed type size.</returns>
		public static int GetManagedSize(this Type t)
		{
			if (_GetManagedSizeCache.TryGetValue(t, out int size))
				return size;

			if (_GetManagedSizeHelper == null)
			{
				Assembly asm;

				const string @namespace = "MonoMod.Utils";
				const string @name = "GetManagedSizeHelper";
				const string @fullName = @namespace + "." + @name;

#if !CECIL0_9
				using (
#endif
				ModuleDefinition module = ModuleDefinition.CreateModule(
					@fullName,
					new ModuleParameters()
					{
						Kind = ModuleKind.Dll,
#if !CECIL0_9 && MONOMOD_UTILS
                        ReflectionImporterProvider = MMReflectionImporter.Provider
#endif
					}
				)
#if CECIL0_9
                ;
#else
				)
#endif
				{

					TypeDefinition type = new TypeDefinition(
						@namespace,
						@name,
						MC.TypeAttributes.Public | MC.TypeAttributes.Abstract | MC.TypeAttributes.Sealed
					)
					{
						BaseType = module.TypeSystem.Object
					};
					module.Types.Add(type);

					MethodDefinition method = new MethodDefinition(@name,
						MC.MethodAttributes.Public | MC.MethodAttributes.Static | MC.MethodAttributes.HideBySig,
						module.TypeSystem.Int32
					);
					GenericParameter genParam = new GenericParameter("T", method);
					method.GenericParameters.Add(genParam);
					type.Methods.Add(method);

					ILProcessor il = method.Body.GetILProcessor();
					il.Emit(OpCodes.Sizeof, genParam);
					il.Emit(OpCodes.Ret);

					asm = ReflectionHelper.Load(module);
				}

				_GetManagedSizeHelper = asm.GetType(@fullName).GetMethod(@name);
			}

			size = (_GetManagedSizeHelper.MakeGenericMethod(t).CreateDelegate<Func<int>>() as Func<int>)();
			lock (_GetManagedSizeCache)
			{
				return _GetManagedSizeCache[t] = size;
			}
		}

		/// <summary>
		/// Get a type which matches what the method should receive via ldarg.0
		/// </summary>
		/// <param name="method">The method to obtain the "this" parameter type from.</param>
		/// <returns>The "this" parameter type.</returns>
		public static Type GetThisParamType(this MethodBase method)
		{
			Type type = method.DeclaringType;
			if (type.IsValueType)
				type = type.MakeByRefType();
			return type;
		}

		private static readonly Dictionary<MethodBase, Func<IntPtr>> _GetLdftnPointerCache = new Dictionary<MethodBase, Func<IntPtr>>();
		/// <summary>
		/// Get a native function pointer for a given method. This matches an IL-level ldftn.
		/// </summary>
		/// <remarks>
		/// The result of ldftn doesn't always match that of MethodHandle.GetFunctionPointer().
		/// For example, ldftn doesn't JIT-compile the method on mono, which thus keeps the class constructor untouched.
		/// And on .NET, struct overrides (f.e. ToString) have got multiple entry points pointing towards the same code.
		/// </remarks>
		/// <param name="m">The method to get a native function pointer for.</param>
		/// <returns>The native function pointer.</returns>
		public static IntPtr GetLdftnPointer(this MethodBase m)
		{
			if (_GetLdftnPointerCache.TryGetValue(m, out Func<IntPtr> func))
				return func();

			DynamicMethodDefinition dmd = new DynamicMethodDefinition(
				$"GetLdftnPointer<{m.GetID(simple: true)}>",
				typeof(IntPtr), Type.EmptyTypes
			);

			ILProcessor il = dmd.GetILProcessor();
			il.Emit(OpCodes.Ldftn, dmd.Definition.Module.ImportReference(m));
			il.Emit(OpCodes.Ret);

			lock (_GetLdftnPointerCache)
			{
				return (_GetLdftnPointerCache[m] = dmd.Generate().CreateDelegate<Func<IntPtr>>() as Func<IntPtr>)();
			}
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum FieldAttributes : ushort
	{
		FieldAccessMask = 0x0007,
		CompilerControlled = 0x0000,    // Member not referenceable
		Private = 0x0001,   // Accessible only by the parent type
		FamANDAssem = 0x0002,   // Accessible by sub-types only in this assembly
		Assembly = 0x0003,  // Accessible by anyone in the Assembly
		Family = 0x0004,    // Accessible only by type and sub-types
		FamORAssem = 0x0005,    // Accessible by sub-types anywhere, plus anyone in the assembly
		Public = 0x0006,    // Accessible by anyone who has visibility to this scope field contract attributes

		Static = 0x0010,    // Defined on type, else per instance
		InitOnly = 0x0020,  // Field may only be initialized, not written after init
		Literal = 0x0040,   // Value is compile time constant
		NotSerialized = 0x0080, // Field does not have to be serialized when type is remoted
		SpecialName = 0x0200,   // Field is special

		// Interop Attributes
		PInvokeImpl = 0x2000,   // Implementation is forwarded through PInvoke

		// Additional flags
		RTSpecialName = 0x0400, // CLI provides 'special' behavior, depending upon the name of the field
		HasFieldMarshal = 0x1000,   // Field has marshalling information
		HasDefault = 0x8000,    // Field has default
		HasFieldRVA = 0x0100     // Field has RVA
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class FieldDefinition : FieldReference, IMemberDefinition, IConstantProvider, IMarshalInfoProvider
	{

		ushort attributes;
		Collection<CustomAttribute> custom_attributes;

		int offset = Mixin.NotResolvedMarker;

		internal int rva = Mixin.NotResolvedMarker;
		byte[] initial_value;

		object constant = Mixin.NotResolved;

		MarshalInfo marshal_info;

		void ResolveLayout()
		{
			if (offset != Mixin.NotResolvedMarker)
				return;

			if (!HasImage)
			{
				offset = Mixin.NoDataMarker;
				return;
			}

			lock (Module.SyncRoot)
			{
				if (offset != Mixin.NotResolvedMarker)
					return;
				offset = Module.Read(this, (field, reader) => reader.ReadFieldLayout(field));
			}
		}

		public bool HasLayoutInfo
		{
			get
			{
				if (offset >= 0)
					return true;

				ResolveLayout();

				return offset >= 0;
			}
		}

		public int Offset
		{
			get
			{
				if (offset >= 0)
					return offset;

				ResolveLayout();

				return offset >= 0 ? offset : -1;
			}
			set { offset = value; }
		}

		internal FieldDefinitionProjection WindowsRuntimeProjection
		{
			get { return (FieldDefinitionProjection)projection; }
			set { projection = value; }
		}

		void ResolveRVA()
		{
			if (rva != Mixin.NotResolvedMarker)
				return;

			if (!HasImage)
				return;

			lock (Module.SyncRoot)
			{
				if (rva != Mixin.NotResolvedMarker)
					return;
				rva = Module.Read(this, (field, reader) => reader.ReadFieldRVA(field));
			}
		}

		public int RVA
		{
			get
			{
				if (rva > 0)
					return rva;

				ResolveRVA();

				return rva > 0 ? rva : 0;
			}
		}

		public byte[] InitialValue
		{
			get
			{
				if (initial_value != null)
					return initial_value;

				ResolveRVA();

				if (initial_value == null)
					initial_value = Empty<byte>.Array;

				return initial_value;
			}
			set
			{
				initial_value = value;
				HasFieldRVA = !initial_value.IsNullOrEmpty();
				rva = 0;
			}
		}

		public FieldAttributes Attributes
		{
			get { return (FieldAttributes)attributes; }
			set
			{
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException();

				attributes = (ushort)value;
			}
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant
		{
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		public bool HasMarshalInfo
		{
			get
			{
				if (marshal_info != null)
					return true;

				return this.GetHasMarshalInfo(Module);
			}
		}

		public MarshalInfo MarshalInfo
		{
			get { return marshal_info ?? (this.GetMarshalInfo(ref marshal_info, Module)); }
			set { marshal_info = value; }
		}

		#region FieldAttributes

		public bool IsCompilerControlled
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.CompilerControlled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.CompilerControlled, value); }
		}

		public bool IsPrivate
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Private, value); }
		}

		public bool IsFamilyAndAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamANDAssem, value); }
		}

		public bool IsAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Assembly); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Assembly, value); }
		}

		public bool IsFamily
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Family); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Family, value); }
		}

		public bool IsFamilyOrAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamORAssem); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamORAssem, value); }
		}

		public bool IsPublic
		{
			get { return attributes.GetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Public, value); }
		}

		public bool IsStatic
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.Static); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.Static, value); }
		}

		public bool IsInitOnly
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.InitOnly); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.InitOnly, value); }
		}

		public bool IsLiteral
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.Literal); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.Literal, value); }
		}

		public bool IsNotSerialized
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.NotSerialized); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.NotSerialized, value); }
		}

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.SpecialName, value); }
		}

		public bool IsPInvokeImpl
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.PInvokeImpl); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.PInvokeImpl, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.RTSpecialName, value); }
		}

		public bool HasDefault
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.HasDefault, value); }
		}

		public bool HasFieldRVA
		{
			get { return attributes.GetAttributes((ushort)FieldAttributes.HasFieldRVA); }
			set { attributes = attributes.SetAttributes((ushort)FieldAttributes.HasFieldRVA, value); }
		}

		#endregion

		public override bool IsDefinition
		{
			get { return true; }
		}

		public new TypeDefinition DeclaringType
		{
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType)
			: base(name, fieldType)
		{
			this.attributes = (ushort)attributes;
		}

		public override FieldDefinition Resolve()
		{
			return this;
		}
	}

	static partial class Mixin
	{

		public const int NotResolvedMarker = -2;
		public const int NoDataMarker = -1;
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public class FieldReference : MemberReference
	{

		TypeReference field_type;

		public TypeReference FieldType
		{
			get { return field_type; }
			set { field_type = value; }
		}

		public override string FullName
		{
			get { return field_type.FullName + " " + MemberFullName(); }
		}

		public override bool ContainsGenericParameter
		{
			get { return field_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		internal FieldReference()
		{
			this.token = new MetadataToken(TokenType.MemberRef);
		}

		public FieldReference(string name, TypeReference fieldType)
			: base(name)
		{
			Mixin.CheckType(fieldType, Mixin.Argument.fieldType);

			this.field_type = fieldType;
			this.token = new MetadataToken(TokenType.MemberRef);
		}

		public FieldReference(string name, TypeReference fieldType, TypeReference declaringType)
			: this(name, fieldType)
		{
			Mixin.CheckType(declaringType, Mixin.Argument.declaringType);

			this.DeclaringType = declaringType;
		}

		protected override IMemberDefinition ResolveDefinition()
		{
			return this.Resolve();
		}

		public new virtual FieldDefinition Resolve()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException();

			return module.Resolve(this);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	enum FileAttributes : uint
	{
		ContainsMetaData = 0x0000,  // This is not a resource file
		ContainsNoMetaData = 0x0001,    // This is a resource file or other non-metadata-containing file
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.Rocks
{

	static class Functional
	{

		public static System.Func<A, R> Y<A, R>(System.Func<System.Func<A, R>, System.Func<A, R>> f)
		{
			System.Func<A, R> g = null;
			g = f(a => g(a));
			return g;
		}

		public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element)
		{
			if (source == null)
				throw new ArgumentNullException("source");

			return PrependIterator(source, element);
		}

		static IEnumerable<TSource> PrependIterator<TSource>(IEnumerable<TSource> source, TSource element)
		{
			yield return element;

			foreach (var item in source)
				yield return item;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public sealed class FunctionPointerType : TypeSpecification, IMethodSignature
	{

		readonly MethodReference function;

		public bool HasThis
		{
			get { return function.HasThis; }
			set { function.HasThis = value; }
		}

		public bool ExplicitThis
		{
			get { return function.ExplicitThis; }
			set { function.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention
		{
			get { return function.CallingConvention; }
			set { function.CallingConvention = value; }
		}

		public bool HasParameters
		{
			get { return function.HasParameters; }
		}

		public Collection<ParameterDefinition> Parameters
		{
			get { return function.Parameters; }
		}

		public TypeReference ReturnType
		{
			get { return function.MethodReturnType.ReturnType; }
			set { function.MethodReturnType.ReturnType = value; }
		}

		public MethodReturnType MethodReturnType
		{
			get { return function.MethodReturnType; }
		}

		public override string Name
		{
			get { return function.Name; }
			set { throw new InvalidOperationException(); }
		}

		public override string Namespace
		{
			get { return string.Empty; }
			set { throw new InvalidOperationException(); }
		}

		public override ModuleDefinition Module
		{
			get { return ReturnType.Module; }
		}

		public override IMetadataScope Scope
		{
			get { return function.ReturnType.Scope; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsFunctionPointer
		{
			get { return true; }
		}

		public override bool ContainsGenericParameter
		{
			get { return function.ContainsGenericParameter; }
		}

		public override string FullName
		{
			get
			{
				var signature = new StringBuilder();
				signature.Append(function.Name);
				signature.Append(" ");
				signature.Append(function.ReturnType.FullName);
				signature.Append(" *");
				this.MethodSignatureFullName(signature);
				return signature.ToString();
			}
		}

		public FunctionPointerType()
			: base(null)
		{
			this.function = new MethodReference();
			this.function.Name = "method";
			this.etype = MD.ElementType.FnPtr;
		}

		public override TypeDefinition Resolve()
		{
			return null;
		}

		public override TypeReference GetElementType()
		{
			return this;
		}
	}
}






namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static class GCListener
	{

		public static event Action OnCollect;
		private static bool Unloading;

		static GCListener()
		{
			new CollectionDummy();

#if NETSTANDARD
            Type t_AssemblyLoadContext = typeof(Assembly).GetTypeInfo().Assembly.GetType("System.Runtime.Loader.AssemblyLoadContext");
            if (t_AssemblyLoadContext != null) {
                object alc = t_AssemblyLoadContext.GetMethod("GetLoadContext").Invoke(null, new object[] { typeof(GCListener).Assembly });
                EventInfo e_Unloading = t_AssemblyLoadContext.GetEvent("Unloading");
                e_Unloading.AddEventHandler(alc, Delegate.CreateDelegate(
                    e_Unloading.EventHandlerType,
                    typeof(GCListener).GetMethod("UnloadingALC", BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod(t_AssemblyLoadContext)
                ));
            }
#endif
		}

#if NETSTANDARD
#pragma warning disable IDE0051 // Remove unused private members
#pragma warning disable IDE0060 // Remove unused parameter
        private static void UnloadingALC<T>(T alc) {
#pragma warning restore IDE0051 // Remove unused private members
#pragma warning restore IDE0060 // Remove unused parameter
            Unloading = true;
        }
#endif

		private sealed class CollectionDummy
		{
			~CollectionDummy()
			{
				Unloading |= AppDomain.CurrentDomain.IsFinalizingForUnload() || Environment.HasShutdownStarted;

				if (!Unloading)
					GC.ReRegisterForFinalize(this);

				OnCollect?.Invoke();
			}
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance, IGenericContext
	{

		Collection<TypeReference> arguments;

		public bool HasGenericArguments
		{
			get { return !arguments.IsNullOrEmpty(); }
		}

		public Collection<TypeReference> GenericArguments
		{
			get
			{
				if (arguments == null)
					Interlocked.CompareExchange(ref arguments, new Collection<TypeReference>(), null);

				return arguments;
			}
		}

		public override bool IsGenericInstance
		{
			get { return true; }
		}

		IGenericParameterProvider IGenericContext.Method
		{
			get { return ElementMethod; }
		}

		IGenericParameterProvider IGenericContext.Type
		{
			get { return ElementMethod.DeclaringType; }
		}

		public override bool ContainsGenericParameter
		{
			get { return this.ContainsGenericParameter() || base.ContainsGenericParameter; }
		}

		public override string FullName
		{
			get
			{
				var signature = new StringBuilder();
				var method = this.ElementMethod;
				signature.Append(method.ReturnType.FullName)
					.Append(" ")
					.Append(method.DeclaringType.FullName)
					.Append("::")
					.Append(method.Name);
				this.GenericInstanceFullName(signature);
				this.MethodSignatureFullName(signature);
				return signature.ToString();

			}
		}

		public GenericInstanceMethod(MethodReference method)
			: base(method)
		{
		}

		internal GenericInstanceMethod(MethodReference method, int arity)
			: this(method)
		{
			this.arguments = new Collection<TypeReference>(arity);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//








namespace Mono.Cecil
{

	public sealed class GenericInstanceType : TypeSpecification, IGenericInstance, IGenericContext
	{

		Collection<TypeReference> arguments;

		public bool HasGenericArguments
		{
			get { return !arguments.IsNullOrEmpty(); }
		}

		public Collection<TypeReference> GenericArguments
		{
			get
			{
				if (arguments == null)
					Interlocked.CompareExchange(ref arguments, new Collection<TypeReference>(), null);

				return arguments;
			}
		}

		public override TypeReference DeclaringType
		{
			get { return ElementType.DeclaringType; }
			set { throw new NotSupportedException(); }
		}

		public override string FullName
		{
			get
			{
				var name = new StringBuilder();
				name.Append(base.FullName);
				this.GenericInstanceFullName(name);
				return name.ToString();
			}
		}

		public override bool IsGenericInstance
		{
			get { return true; }
		}

		public override bool ContainsGenericParameter
		{
			get { return this.ContainsGenericParameter() || base.ContainsGenericParameter; }
		}

		IGenericParameterProvider IGenericContext.Type
		{
			get { return ElementType; }
		}

		public GenericInstanceType(TypeReference type)
			: base(type)
		{
			base.IsValueType = type.IsValueType;
			this.etype = MD.ElementType.GenericInst;
		}

		internal GenericInstanceType(TypeReference type, int arity)
			: this(type)
		{
			this.arguments = new Collection<TypeReference>(arity);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Cecil
{

	public sealed class GenericParameter : TypeReference, ICustomAttributeProvider
	{

		internal int position;
		internal GenericParameterType type;
		internal IGenericParameterProvider owner;

		ushort attributes;
		GenericParameterConstraintCollection constraints;
		Collection<CustomAttribute> custom_attributes;

		public GenericParameterAttributes Attributes
		{
			get { return (GenericParameterAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public int Position
		{
			get { return position; }
		}

		public GenericParameterType Type
		{
			get { return type; }
		}

		public IGenericParameterProvider Owner
		{
			get { return owner; }
		}

		public bool HasConstraints
		{
			get
			{
				if (constraints != null)
					return constraints.Count > 0;

				return HasImage && Module.Read(this, (generic_parameter, reader) => reader.HasGenericConstraints(generic_parameter));
			}
		}

		public Collection<GenericParameterConstraint> Constraints
		{
			get
			{
				if (constraints != null)
					return constraints;

				if (HasImage)
					return Module.Read(ref constraints, this, (generic_parameter, reader) => reader.ReadGenericConstraints(generic_parameter));

				Interlocked.CompareExchange(ref constraints, new GenericParameterConstraintCollection(this), null);
				return constraints;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		public override IMetadataScope Scope
		{
			get
			{
				if (owner == null)
					return null;

				return owner.GenericParameterType == GenericParameterType.Method
					? ((MethodReference)owner).DeclaringType.Scope
					: ((TypeReference)owner).Scope;
			}
			set { throw new InvalidOperationException(); }
		}

		public override TypeReference DeclaringType
		{
			get { return owner as TypeReference; }
			set { throw new InvalidOperationException(); }
		}

		public MethodReference DeclaringMethod
		{
			get { return owner as MethodReference; }
		}

		public override ModuleDefinition Module
		{
			get { return module ?? owner.Module; }
		}

		public override string Name
		{
			get
			{
				if (!string.IsNullOrEmpty(base.Name))
					return base.Name;

				return base.Name = (type == GenericParameterType.Method ? "!!" : "!") + position;
			}
		}

		public override string Namespace
		{
			get { return string.Empty; }
			set { throw new InvalidOperationException(); }
		}

		public override string FullName
		{
			get { return Name; }
		}

		public override bool IsGenericParameter
		{
			get { return true; }
		}

		public override bool ContainsGenericParameter
		{
			get { return true; }
		}

		public override MetadataType MetadataType
		{
			get { return (MetadataType)etype; }
		}

		#region GenericParameterAttributes

		public bool IsNonVariant
		{
			get { return attributes.GetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.NonVariant); }
			set { attributes = attributes.SetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.NonVariant, value); }
		}

		public bool IsCovariant
		{
			get { return attributes.GetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Covariant); }
			set { attributes = attributes.SetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Covariant, value); }
		}

		public bool IsContravariant
		{
			get { return attributes.GetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Contravariant); }
			set { attributes = attributes.SetMaskedAttributes((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Contravariant, value); }
		}

		public bool HasReferenceTypeConstraint
		{
			get { return attributes.GetAttributes((ushort)GenericParameterAttributes.ReferenceTypeConstraint); }
			set { attributes = attributes.SetAttributes((ushort)GenericParameterAttributes.ReferenceTypeConstraint, value); }
		}

		public bool HasNotNullableValueTypeConstraint
		{
			get { return attributes.GetAttributes((ushort)GenericParameterAttributes.NotNullableValueTypeConstraint); }
			set { attributes = attributes.SetAttributes((ushort)GenericParameterAttributes.NotNullableValueTypeConstraint, value); }
		}

		public bool HasDefaultConstructorConstraint
		{
			get { return attributes.GetAttributes((ushort)GenericParameterAttributes.DefaultConstructorConstraint); }
			set { attributes = attributes.SetAttributes((ushort)GenericParameterAttributes.DefaultConstructorConstraint, value); }
		}

		#endregion

		public GenericParameter(IGenericParameterProvider owner)
			: this(string.Empty, owner)
		{
		}

		public GenericParameter(string name, IGenericParameterProvider owner)
			: base(string.Empty, name)
		{
			if (owner == null)
				throw new ArgumentNullException();

			this.position = -1;
			this.owner = owner;
			this.type = owner.GenericParameterType;
			this.etype = ConvertGenericParameterType(this.type);
			this.token = new MetadataToken(TokenType.GenericParam);

		}

		internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module)
			: base(string.Empty, string.Empty)
		{
			Mixin.CheckModule(module);

			this.position = position;
			this.type = type;
			this.etype = ConvertGenericParameterType(type);
			this.module = module;
			this.token = new MetadataToken(TokenType.GenericParam);
		}

		static ElementType ConvertGenericParameterType(GenericParameterType type)
		{
			switch (type)
			{
				case GenericParameterType.Type:
					return ElementType.Var;
				case GenericParameterType.Method:
					return ElementType.MVar;
			}

			throw new ArgumentOutOfRangeException();
		}

		public override TypeDefinition Resolve()
		{
			return null;
		}
	}

	sealed class GenericParameterCollection : Collection<GenericParameter>
	{

		readonly IGenericParameterProvider owner;

		internal GenericParameterCollection(IGenericParameterProvider owner)
		{
			this.owner = owner;
		}

		internal GenericParameterCollection(IGenericParameterProvider owner, int capacity)
			: base(capacity)
		{
			this.owner = owner;
		}

		protected override void OnAdd(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);
		}

		protected override void OnInsert(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);

			for (int i = index; i < size; i++)
				items[i].position = i + 1;
		}

		protected override void OnSet(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);
		}

		void UpdateGenericParameter(GenericParameter item, int index)
		{
			item.owner = owner;
			item.position = index;
			item.type = owner.GenericParameterType;
		}

		protected override void OnRemove(GenericParameter item, int index)
		{
			item.owner = null;
			item.position = -1;
			item.type = GenericParameterType.Type;

			for (int i = index + 1; i < size; i++)
				items[i].position = i - 1;
		}
	}

	public sealed class GenericParameterConstraint : ICustomAttributeProvider
	{

		internal GenericParameter generic_parameter;
		internal MetadataToken token;

		TypeReference constraint_type;
		Collection<CustomAttribute> custom_attributes;

		public TypeReference ConstraintType
		{
			get { return constraint_type; }
			set { constraint_type = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				if (generic_parameter == null)
					return false;

				return this.GetHasCustomAttributes(generic_parameter.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get
			{
				if (generic_parameter == null)
				{
					if (custom_attributes == null)
						Interlocked.CompareExchange(ref custom_attributes, new Collection<CustomAttribute>(), null);
					return custom_attributes;
				}

				return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, generic_parameter.Module));
			}
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token)
		{
			this.constraint_type = constraintType;
			this.token = token;
		}

		public GenericParameterConstraint(TypeReference constraintType)
		{
			Mixin.CheckType(constraintType, Mixin.Argument.constraintType);

			this.constraint_type = constraintType;
			this.token = new MetadataToken(TokenType.GenericParamConstraint);
		}
	}

	class GenericParameterConstraintCollection : Collection<GenericParameterConstraint>
	{
		readonly GenericParameter generic_parameter;

		internal GenericParameterConstraintCollection(GenericParameter genericParameter)
		{
			this.generic_parameter = genericParameter;
		}

		internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length)
			: base(length)
		{
			this.generic_parameter = genericParameter;
		}

		protected override void OnAdd(GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnInsert(GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnSet(GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnRemove(GenericParameterConstraint item, int index)
		{
			item.generic_parameter = null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum GenericParameterAttributes : ushort
	{
		VarianceMask = 0x0003,
		NonVariant = 0x0000,
		Covariant = 0x0001,
		Contravariant = 0x0002,

		SpecialConstraintMask = 0x001c,
		ReferenceTypeConstraint = 0x0004,
		NotNullableValueTypeConstraint = 0x0008,
		DefaultConstructorConstraint = 0x0010
	}
}



namespace Mono.Cecil
{
	internal sealed class GenericParameterResolver
	{
		internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference)
		{
			if (methodReference.DeclaringType.IsArray && methodReference.Name == "Get")
				return methodReference.ReturnType;

			var genericInstanceMethod = methodReference as GenericInstanceMethod;
			var declaringGenericInstanceType = methodReference.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return methodReference.ReturnType;

			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, methodReference.ReturnType);
		}

		internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference)
		{
			return ResolveIfNeeded(null, fieldReference.DeclaringType as GenericInstanceType, fieldReference.FieldType);
		}

		internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter)
		{
			var genericInstanceMethod = method as GenericInstanceMethod;
			var declaringGenericInstanceType = method.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return parameter.ParameterType;

			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, parameter.ParameterType);
		}

		internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable)
		{
			var genericInstanceMethod = method as GenericInstanceMethod;
			var declaringGenericInstanceType = method.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return variable.VariableType;

			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, variable.VariableType);
		}

		private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType)
		{
			var byRefType = parameterType as ByReferenceType;
			if (byRefType != null)
				return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, byRefType);

			var arrayType = parameterType as ArrayType;
			if (arrayType != null)
				return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, arrayType);

			var genericInstanceType = parameterType as GenericInstanceType;
			if (genericInstanceType != null)
				return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, genericInstanceType);

			var genericParameter = parameterType as GenericParameter;
			if (genericParameter != null)
				return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, genericParameter);

			var requiredModifierType = parameterType as RequiredModifierType;
			if (requiredModifierType != null && ContainsGenericParameters(requiredModifierType))
				return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, requiredModifierType.ElementType);

			if (ContainsGenericParameters(parameterType))
				throw new Exception("Unexpected generic parameter.");

			return parameterType;
		}

		private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement)
		{
			return (genericParameterElement.MetadataType == MetadataType.MVar)
				? (genericInstanceMethod != null ? genericInstanceMethod.GenericArguments[genericParameterElement.Position] : genericParameterElement)
				: genericInstanceType.GenericArguments[genericParameterElement.Position];
		}

		private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType)
		{
			return new ArrayType(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, arrayType.ElementType), arrayType.Rank);
		}

		private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType)
		{
			return new ByReferenceType(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, byReferenceType.ElementType));
		}

		private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1)
		{
			if (!ContainsGenericParameters(genericInstanceType1))
				return genericInstanceType1;

			var newGenericInstance = new GenericInstanceType(genericInstanceType1.ElementType);

			foreach (var genericArgument in genericInstanceType1.GenericArguments)
			{
				if (!genericArgument.IsGenericParameter)
				{
					newGenericInstance.GenericArguments.Add(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, genericArgument));
					continue;
				}

				var genParam = (GenericParameter)genericArgument;

				switch (genParam.Type)
				{
					case GenericParameterType.Type:
						{
							if (genericInstanceType == null)
								throw new NotSupportedException();

							newGenericInstance.GenericArguments.Add(genericInstanceType.GenericArguments[genParam.Position]);
						}
						break;

					case GenericParameterType.Method:
						{
							if (genericInstanceMethod == null)
								newGenericInstance.GenericArguments.Add(genParam);
							else
								newGenericInstance.GenericArguments.Add(genericInstanceMethod.GenericArguments[genParam.Position]);
						}
						break;
				}
			}

			return newGenericInstance;
		}

		private static bool ContainsGenericParameters(TypeReference typeReference)
		{
			var genericParameter = typeReference as GenericParameter;
			if (genericParameter != null)
				return true;

			var arrayType = typeReference as ArrayType;
			if (arrayType != null)
				return ContainsGenericParameters(arrayType.ElementType);

			var pointerType = typeReference as PointerType;
			if (pointerType != null)
				return ContainsGenericParameters(pointerType.ElementType);

			var byRefType = typeReference as ByReferenceType;
			if (byRefType != null)
				return ContainsGenericParameters(byRefType.ElementType);

			var sentinelType = typeReference as SentinelType;
			if (sentinelType != null)
				return ContainsGenericParameters(sentinelType.ElementType);

			var pinnedType = typeReference as PinnedType;
			if (pinnedType != null)
				return ContainsGenericParameters(pinnedType.ElementType);

			var requiredModifierType = typeReference as RequiredModifierType;
			if (requiredModifierType != null)
				return ContainsGenericParameters(requiredModifierType.ElementType);

			var genericInstance = typeReference as GenericInstanceType;
			if (genericInstance != null)
			{
				foreach (var genericArgument in genericInstance.GenericArguments)
				{
					if (ContainsGenericParameters(genericArgument))
						return true;
				}

				return false;
			}

			if (typeReference is TypeSpecification)
				throw new NotSupportedException();

			return false;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Metadata
{

	sealed class GuidHeap : Heap
	{

		public GuidHeap(byte[] data)
			: base(data)
		{
		}

		public Guid Read(uint index)
		{
			const int guid_size = 16;

			if (index == 0 || ((index - 1) + guid_size) > data.Length)
				return new Guid();

			var buffer = new byte[guid_size];

			Buffer.BlockCopy(this.data, (int)((index - 1) * guid_size), buffer, 0, guid_size);

			return new Guid(buffer);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Metadata
{

	abstract class Heap
	{

		public int IndexSize;

		readonly internal byte[] data;

		protected Heap(byte[] data)
		{
			this.data = data;
		}
	}
}












namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	interface ICallSiteGenerator
	{

		Mono.Cecil.CallSite ToCallSite(ModuleDefinition module);

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public interface IConstantProvider : IMetadataTokenProvider
	{

		bool HasConstant { get; set; }
		object Constant { get; set; }
	}

	static partial class Mixin
	{

		internal static object NoValue = new object();
		internal static object NotResolved = new object();

		public static void ResolveConstant(
			this IConstantProvider self,
			ref object constant,
			ModuleDefinition module)
		{
			if (module == null)
			{
				constant = Mixin.NoValue;
				return;
			}

			lock (module.SyncRoot)
			{
				if (constant != Mixin.NotResolved)
					return;
				if (module.HasImage())
					constant = module.Read(self, (provider, reader) => reader.ReadConstant(provider));
				else
					constant = Mixin.NoValue;
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public interface ICustomAttributeProvider : IMetadataTokenProvider
	{

		Collection<CustomAttribute> CustomAttributes { get; }

		bool HasCustomAttributes { get; }
	}

	static partial class Mixin
	{

		public static bool GetHasCustomAttributes(
			this ICustomAttributeProvider self,
			ModuleDefinition module)
		{
			return module.HasImage() && module.Read(self, (provider, reader) => reader.HasCustomAttributes(provider));
		}

		public static Collection<CustomAttribute> GetCustomAttributes(
			this ICustomAttributeProvider self,
			ref Collection<CustomAttribute> variable,
			ModuleDefinition module)
		{
			if (module.HasImage())
				return module.Read(ref variable, self, (provider, reader) => reader.ReadCustomAttributes(provider));

			Interlocked.CompareExchange(ref variable, new Collection<CustomAttribute>(), null);
			return variable;
		}
	}
}




namespace MonoMod.RuntimeDetour
{
#if !MONOMOD_INTERNAL
	public
#endif
	interface IDetourNativePlatform
	{
		NativeDetourData Create(IntPtr from, IntPtr to, byte? type = null);
		void Free(NativeDetourData detour);
		void Apply(NativeDetourData detour);
		void Copy(IntPtr src, IntPtr dst, byte type);
		void MakeWritable(IntPtr src, uint size);
		void MakeExecutable(IntPtr src, uint size);
		void MakeReadWriteExecutable(IntPtr src, uint size);
		void FlushICache(IntPtr src, uint size);
		IntPtr MemAlloc(uint size);
		void MemFree(IntPtr ptr);
	}
}







namespace MonoMod.RuntimeDetour
{
#if !MONOMOD_INTERNAL
	public
#endif
	interface IDetourRuntimePlatform
	{
		MethodBase GetIdentifiable(MethodBase method);
		IntPtr GetNativeStart(MethodBase method);
		MethodInfo CreateCopy(MethodBase method);
		bool TryCreateCopy(MethodBase method, out MethodInfo dm);
		void Pin(MethodBase method);
		void Unpin(MethodBase method);
		MethodBase GetDetourTarget(MethodBase from, MethodBase to);
		uint TryMemAllocScratchCloseTo(IntPtr target, out IntPtr ptr, int size);

		bool OnMethodCompiledWillBeCalled { get; }
		event OnMethodCompiledEvent OnMethodCompiled;
	}

#if !MONOMOD_INTERNAL
	public
#endif
	delegate void OnMethodCompiledEvent(MethodBase method, IntPtr codeStart, ulong codeSize);
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public interface IGenericInstance : IMetadataTokenProvider
	{

		bool HasGenericArguments { get; }
		Collection<TypeReference> GenericArguments { get; }
	}

	static partial class Mixin
	{

		public static bool ContainsGenericParameter(this IGenericInstance self)
		{
			var arguments = self.GenericArguments;

			for (int i = 0; i < arguments.Count; i++)
				if (arguments[i].ContainsGenericParameter)
					return true;

			return false;
		}

		public static void GenericInstanceFullName(this IGenericInstance self, StringBuilder builder)
		{
			builder.Append("<");
			var arguments = self.GenericArguments;
			for (int i = 0; i < arguments.Count; i++)
			{
				if (i > 0)
					builder.Append(",");
				builder.Append(arguments[i].FullName);
			}
			builder.Append(">");
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil
{

	public interface IGenericParameterProvider : IMetadataTokenProvider
	{

		bool HasGenericParameters { get; }
		bool IsDefinition { get; }
		ModuleDefinition Module { get; }
		Collection<GenericParameter> GenericParameters { get; }
		GenericParameterType GenericParameterType { get; }
	}

	public enum GenericParameterType
	{
		Type,
		Method
	}

	interface IGenericContext
	{

		bool IsDefinition { get; }
		IGenericParameterProvider Type { get; }
		IGenericParameterProvider Method { get; }
	}

	static partial class Mixin
	{

		public static bool GetHasGenericParameters(
			this IGenericParameterProvider self,
			ModuleDefinition module)
		{
			return module.HasImage() && module.Read(self, (provider, reader) => reader.HasGenericParameters(provider));
		}

		public static Collection<GenericParameter> GetGenericParameters(
			this IGenericParameterProvider self,
			ref Collection<GenericParameter> collection,
			ModuleDefinition module)
		{
			if (module.HasImage())
				return module.Read(ref collection, self, (provider, reader) => reader.ReadGenericParameters(provider));

			Interlocked.CompareExchange(ref collection, new GenericParameterCollection(self), null);
			return collection;
		}
	}
}
namespace System.Runtime.CompilerServices
{
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
#if !MONOMOD_INTERNAL
	public
#endif
	class IgnoresAccessChecksToAttribute : Attribute
	{
		public string AssemblyName { get; }
		public IgnoresAccessChecksToAttribute(string assemblyName)
		{
			AssemblyName = assemblyName;
		}
	}
}







namespace MonoMod.Utils.Cil
{
	/// <summary>
	/// Abstract version of System.Reflection.Emit.ILGenerator. See <see cref="System.Reflection.Emit.ILGenerator"/> for proper documentation.
	/// </summary>
#if !MONOMOD_INTERNAL
	public
#endif
	abstract partial class ILGeneratorShim
	{

		public abstract int ILOffset { get; }
		public abstract void BeginCatchBlock(Type exceptionType);
		public abstract void BeginExceptFilterBlock();
		public abstract System.Reflection.Emit.Label BeginExceptionBlock();
		public abstract void BeginFaultBlock();
		public abstract void BeginFinallyBlock();
		public abstract void BeginScope();
		public abstract System.Reflection.Emit.LocalBuilder DeclareLocal(Type localType);
		public abstract System.Reflection.Emit.LocalBuilder DeclareLocal(Type localType, bool pinned);
		public abstract System.Reflection.Emit.Label DefineLabel();
		public abstract void Emit(System.Reflection.Emit.OpCode opcode);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, byte arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, double arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, short arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, int arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, long arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, ConstructorInfo con);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, FieldInfo field);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, MethodInfo meth);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, sbyte arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, float arg);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, string str);
		public abstract void Emit(System.Reflection.Emit.OpCode opcode, Type cls);
		public abstract void EmitCall(System.Reflection.Emit.OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
		public abstract void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
		public abstract void EmitCalli(System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
		public abstract void EmitWriteLine(System.Reflection.Emit.LocalBuilder localBuilder);
		public abstract void EmitWriteLine(FieldInfo fld);
		public abstract void EmitWriteLine(string value);
		public abstract void EndExceptionBlock();
		public abstract void EndScope();
		public abstract void MarkLabel(System.Reflection.Emit.Label loc);
		public abstract void ThrowException(Type excType);
		public abstract void UsingNamespace(string usingNamespace);

	}
}












namespace MonoMod.Utils.Cil
{
#if !MONOMOD_INTERNAL
	public
#endif
	partial class ILGeneratorShim
	{

		/// <summary>
		/// Get a "real" ILGenerator for this ILGeneratorShim.
		/// </summary>
		/// <returns>A "real" ILGenerator.</returns>
		public System.Reflection.Emit.ILGenerator GetProxy()
		{
			return (System.Reflection.Emit.ILGenerator)ILGeneratorBuilder
				.GenerateProxy()
				.MakeGenericType(GetType())
				.GetConstructors()[0]
				.Invoke(new object[] { this });
		}

		/// <summary>
		/// Get the proxy type for a given ILGeneratorShim type. The proxy type implements ILGenerator.
		/// </summary>
		/// <typeparam name="TShim">The ILGeneratorShim type.</typeparam>
		/// <returns>The "real" ILGenerator type.</returns>
		public static Type GetProxyType<TShim>() where TShim : ILGeneratorShim => GetProxyType(typeof(TShim));
		/// <summary>
		/// Get the proxy type for a given ILGeneratorShim type. The proxy type implements ILGenerator.
		/// </summary>
		/// <param name="tShim">The ILGeneratorShim type.</param>
		/// <returns>The "real" ILGenerator type.</returns>
		public static Type GetProxyType(Type tShim) => ProxyType.MakeGenericType(tShim);
		/// <summary>
		/// Get the non-generic proxy type implementing ILGenerator.
		/// </summary>
		/// <returns>The "real" ILGenerator type, non-generic.</returns>
		public static Type ProxyType => ILGeneratorBuilder.GenerateProxy();

		internal static class ILGeneratorBuilder
		{

			// NOTE: If you plan on changing this, keep in mind that any InternalsVisibleToAttributes need to be updated as well!
			public const string Namespace = "MonoMod.Utils.Cil";
			public const string Name = "ILGeneratorProxy";
			public const string FullName = Namespace + "." + Name;
			public const string TargetName = "Target";
			static Type ProxyType;

			public static Type GenerateProxy()
			{
				if (ProxyType != null)
					return ProxyType;
				Assembly asm;

				Type t_ILGenerator = typeof(System.Reflection.Emit.ILGenerator);
				Type t_ILGeneratorProxyTarget = typeof(ILGeneratorShim);

#if !CECIL0_9
				using (
#endif
				ModuleDefinition module = ModuleDefinition.CreateModule(
					FullName,
					new ModuleParameters()
					{
						Kind = ModuleKind.Dll,
#if !CECIL0_9 && MONOMOD_UTILS
                        ReflectionImporterProvider = MMReflectionImporter.Provider
#endif
					}
				)
#if CECIL0_9
                ;
#else
				)
#endif
				{

					CustomAttribute ca_IACTA = new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute));
					ca_IACTA.ConstructorArguments.Add(new CustomAttributeArgument(module.TypeSystem.String, typeof(ILGeneratorShim).Assembly.GetName().Name));
					module.Assembly.CustomAttributes.Add(ca_IACTA);

					TypeDefinition type = new TypeDefinition(
						Namespace,
						Name,
						TypeAttributes.Public
					)
					{
						BaseType = module.ImportReference(t_ILGenerator)
					};
					module.Types.Add(type);

					TypeReference tr_ILGeneratorProxyTarget = module.ImportReference(t_ILGeneratorProxyTarget);

					GenericParameter g_TTarget = new GenericParameter("TTarget", type);
#if CECIL0_10
                    g_TTarget.Constraints.Add(tr_ILGeneratorProxyTarget);
#else
					g_TTarget.Constraints.Add(new GenericParameterConstraint(tr_ILGeneratorProxyTarget));
#endif
					type.GenericParameters.Add(g_TTarget);

					FieldDefinition fd_Target = new FieldDefinition(
						TargetName,
						FieldAttributes.Public,
						g_TTarget
					);
					type.Fields.Add(fd_Target);


					GenericInstanceType git = new GenericInstanceType(type);
					git.GenericArguments.Add(g_TTarget);

					FieldReference fr_Target = new FieldReference(TargetName, g_TTarget, git);

					MethodDefinition ctor = new MethodDefinition(".ctor",
						MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName,
						module.TypeSystem.Void
					);
					ctor.Parameters.Add(new ParameterDefinition(g_TTarget));
					type.Methods.Add(ctor);

					ILProcessor il = ctor.Body.GetILProcessor();
					il.Emit(OpCodes.Ldarg_0);
					il.Emit(OpCodes.Ldarg_1);
					il.Emit(OpCodes.Stfld, fr_Target);
					il.Emit(OpCodes.Ret);

					foreach (MethodInfo orig in t_ILGenerator.GetMethods(BindingFlags.Public | BindingFlags.Instance))
					{
						MethodInfo target = t_ILGeneratorProxyTarget.GetMethod(orig.Name, orig.GetParameters().Select(p => p.ParameterType).ToArray());
						if (target == null)
							continue;

						MethodDefinition proxy = new MethodDefinition(
							orig.Name,
							MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig,
							module.ImportReference(orig.ReturnType)
						)
						{
							HasThis = true
						};
						foreach (ParameterInfo param in orig.GetParameters())
							proxy.Parameters.Add(new ParameterDefinition(module.ImportReference(param.ParameterType)));
						type.Methods.Add(proxy);

						il = proxy.Body.GetILProcessor();
						il.Emit(OpCodes.Ldarg_0);
						il.Emit(OpCodes.Ldfld, fr_Target);
						foreach (ParameterDefinition param in proxy.Parameters)
							il.Emit(OpCodes.Ldarg, param);
						il.Emit(target.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, il.Body.Method.Module.ImportReference(target));
						il.Emit(OpCodes.Ret);
					}

					asm = ReflectionHelper.Load(module);
					asm.SetMonoCorlibInternal(true);
				}

				// .NET hates to acknowledge manually loaded assemblies.
				// Luckily, ReflectionHelper already does the following for asm.
				// Sadly, we can't control how MonoMod.Common / MonoMod.Utils / ... gets loaded.
				ResolveEventHandler mmcResolver = (asmSender, asmArgs) => {
					AssemblyName asmName = new AssemblyName(asmArgs.Name);
					if (asmName.Name == typeof(ILGeneratorBuilder).Assembly.GetName().Name)
						return typeof(ILGeneratorBuilder).Assembly;
					return null;
				};

				AppDomain.CurrentDomain.AssemblyResolve += mmcResolver;
				try
				{
					ProxyType = asm.GetType(FullName);
				}
				finally
				{
					AppDomain.CurrentDomain.AssemblyResolve -= mmcResolver;
				}

				if (ProxyType == null)
				{
					StringBuilder builder = new StringBuilder();
					builder.Append("Couldn't find ILGeneratorShim proxy \"").Append(FullName).Append("\" in autogenerated \"").Append(asm.FullName).AppendLine("\"");

					Type[] types;
					Exception[] exceptions;
					try
					{
						types = asm.GetTypes();
						exceptions = null;

					}
					catch (ReflectionTypeLoadException e)
					{
						types = e.Types;
						exceptions = new Exception[e.LoaderExceptions.Length + 1];
						exceptions[0] = e;
						for (int i = 0; i < e.LoaderExceptions.Length; i++)
							exceptions[i + 1] = e.LoaderExceptions[i];
					}

					builder.AppendLine("Listing all types in autogenerated assembly:");
					foreach (Type type in types)
						builder.AppendLine(type?.FullName ?? "<NULL>");

					if ((exceptions?.Length ?? 0) > 0)
					{
						builder.AppendLine("Listing all exceptions:");
						for (int i = 0; i < exceptions.Length; i++)
							builder.Append("#").Append(i).Append(": ").AppendLine(exceptions[i]?.ToString() ?? "NULL");
					}

					throw new Exception(builder.ToString());
				}

				return ProxyType;
			}

		}

	}

#if !MONOMOD_INTERNAL
	public
#endif
	static class ILGeneratorShimExt
	{

		private static readonly Dictionary<Type, MethodInfo> _Emitters = new Dictionary<Type, MethodInfo>();
		private static readonly Dictionary<Type, MethodInfo> _EmittersShim = new Dictionary<Type, MethodInfo>();

		static ILGeneratorShimExt()
		{
			foreach (MethodInfo method in typeof(System.Reflection.Emit.ILGenerator).GetMethods())
			{
				if (method.Name != "Emit")
					continue;

				ParameterInfo[] args = method.GetParameters();
				if (args.Length != 2)
					continue;

				if (args[0].ParameterType != typeof(System.Reflection.Emit.OpCode))
					continue;
				_Emitters[args[1].ParameterType] = method;
			}

			foreach (MethodInfo method in typeof(ILGeneratorShim).GetMethods())
			{
				if (method.Name != "Emit")
					continue;

				ParameterInfo[] args = method.GetParameters();
				if (args.Length != 2)
					continue;

				if (args[0].ParameterType != typeof(System.Reflection.Emit.OpCode))
					continue;
				_EmittersShim[args[1].ParameterType] = method;
			}
		}

		public static ILGeneratorShim GetProxiedShim(this System.Reflection.Emit.ILGenerator il)
			=> il.GetType().GetField(
				ILGeneratorShim.ILGeneratorBuilder.TargetName,
				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance
			)?.GetValue(il) as ILGeneratorShim;

		public static T GetProxiedShim<T>(this System.Reflection.Emit.ILGenerator il) where T : ILGeneratorShim
			=> il.GetProxiedShim() as T;

		public static object DynEmit(this System.Reflection.Emit.ILGenerator il, System.Reflection.Emit.OpCode opcode, object operand)
			=> il.DynEmit(new object[] { opcode, operand });

		public static object DynEmit(this System.Reflection.Emit.ILGenerator il, object[] emitArgs)
		{
			Type operandType = emitArgs[1].GetType();

			object target = il.GetProxiedShim() ?? (object)il;
			Dictionary<Type, MethodInfo> emitters = target is ILGeneratorShim ? _EmittersShim : _Emitters;

			if (!emitters.TryGetValue(operandType, out MethodInfo emit))
				emit = emitters.FirstOrDefault(kvp => kvp.Key.IsAssignableFrom(operandType)).Value;
			if (emit == null)
				throw new InvalidOperationException($"Unexpected unemittable operand type {operandType.FullName}");

			return emit.Invoke(target, emitArgs);
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	interface IILVisitor
	{
		void OnInlineNone(OpCode opcode);
		void OnInlineSByte(OpCode opcode, sbyte value);
		void OnInlineByte(OpCode opcode, byte value);
		void OnInlineInt32(OpCode opcode, int value);
		void OnInlineInt64(OpCode opcode, long value);
		void OnInlineSingle(OpCode opcode, float value);
		void OnInlineDouble(OpCode opcode, double value);
		void OnInlineString(OpCode opcode, string value);
		void OnInlineBranch(OpCode opcode, int offset);
		void OnInlineSwitch(OpCode opcode, int[] offsets);
		void OnInlineVariable(OpCode opcode, VariableDefinition variable);
		void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);
		void OnInlineSignature(OpCode opcode, CallSite callSite);
		void OnInlineType(OpCode opcode, TypeReference type);
		void OnInlineField(OpCode opcode, FieldReference field);
		void OnInlineMethod(OpCode opcode, MethodReference method);
	}

#if INSIDE_ROCKS
	public
#endif
	static class ILParser
	{

		class ParseContext
		{
			public CodeReader Code { get; set; }
			public int Position { get; set; }
			public MetadataReader Metadata { get; set; }
			public Collection<VariableDefinition> Variables { get; set; }
			public IILVisitor Visitor { get; set; }
		}

		public static void Parse(MethodDefinition method, IILVisitor visitor)
		{
			if (method == null)
				throw new ArgumentNullException("method");
			if (visitor == null)
				throw new ArgumentNullException("visitor");
			if (!method.HasBody || !method.HasImage)
				throw new ArgumentException();

			method.Module.Read(method, (m, _) => {
				ParseMethod(m, visitor);
				return true;
			});
		}

		static void ParseMethod(MethodDefinition method, IILVisitor visitor)
		{
			var context = CreateContext(method, visitor);
			var code = context.Code;

			var flags = code.ReadByte();

			switch (flags & 0x3)
			{
				case 0x2: // tiny
					int code_size = flags >> 2;
					ParseCode(code_size, context);
					break;
				case 0x3: // fat
					code.Advance(-1);
					ParseFatMethod(context);
					break;
				default:
					throw new NotSupportedException();
			}

			code.MoveBackTo(context.Position);
		}

		static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
		{
			var code = method.Module.Read(method, (_, reader) => reader.code);
			var position = code.MoveTo(method);

			return new ParseContext
			{
				Code = code,
				Position = position,
				Metadata = code.reader,
				Visitor = visitor,
			};
		}

		static void ParseFatMethod(ParseContext context)
		{
			var code = context.Code;

			code.Advance(4);
			var code_size = code.ReadInt32();
			var local_var_token = code.ReadToken();

			if (local_var_token != MetadataToken.Zero)
				context.Variables = code.ReadVariables(local_var_token);

			ParseCode(code_size, context);
		}

		static void ParseCode(int code_size, ParseContext context)
		{
			var code = context.Code;
			var metadata = context.Metadata;
			var visitor = context.Visitor;

			var start = code.Position;
			var end = start + code_size;

			while (code.Position < end)
			{
				var il_opcode = code.ReadByte();
				var opcode = il_opcode != 0xfe
					? OpCodes.OneByteOpCode[il_opcode]
					: OpCodes.TwoBytesOpCode[code.ReadByte()];

				switch (opcode.OperandType)
				{
					case Mono.Cecil.Cil.OperandType.InlineNone:
						visitor.OnInlineNone(opcode);
						break;
					case Mono.Cecil.Cil.OperandType.InlineSwitch:
						var length = code.ReadInt32();
						var branches = new int[length];
						for (int i = 0; i < length; i++)
							branches[i] = code.ReadInt32();
						visitor.OnInlineSwitch(opcode, branches);
						break;
					case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
						visitor.OnInlineBranch(opcode, code.ReadSByte());
						break;
					case Mono.Cecil.Cil.OperandType.InlineBrTarget:
						visitor.OnInlineBranch(opcode, code.ReadInt32());
						break;
					case Mono.Cecil.Cil.OperandType.ShortInlineI:
						if (opcode == OpCodes.Ldc_I4_S)
							visitor.OnInlineSByte(opcode, code.ReadSByte());
						else
							visitor.OnInlineByte(opcode, code.ReadByte());
						break;
					case Mono.Cecil.Cil.OperandType.InlineI:
						visitor.OnInlineInt32(opcode, code.ReadInt32());
						break;
					case Mono.Cecil.Cil.OperandType.InlineI8:
						visitor.OnInlineInt64(opcode, code.ReadInt64());
						break;
					case Mono.Cecil.Cil.OperandType.ShortInlineR:
						visitor.OnInlineSingle(opcode, code.ReadSingle());
						break;
					case Mono.Cecil.Cil.OperandType.InlineR:
						visitor.OnInlineDouble(opcode, code.ReadDouble());
						break;
					case Mono.Cecil.Cil.OperandType.InlineSig:
						visitor.OnInlineSignature(opcode, code.GetCallSite(code.ReadToken()));
						break;
					case Mono.Cecil.Cil.OperandType.InlineString:
						visitor.OnInlineString(opcode, code.GetString(code.ReadToken()));
						break;
					case Mono.Cecil.Cil.OperandType.ShortInlineArg:
						visitor.OnInlineArgument(opcode, code.GetParameter(code.ReadByte()));
						break;
					case Mono.Cecil.Cil.OperandType.InlineArg:
						visitor.OnInlineArgument(opcode, code.GetParameter(code.ReadInt16()));
						break;
					case Mono.Cecil.Cil.OperandType.ShortInlineVar:
						visitor.OnInlineVariable(opcode, GetVariable(context, code.ReadByte()));
						break;
					case Mono.Cecil.Cil.OperandType.InlineVar:
						visitor.OnInlineVariable(opcode, GetVariable(context, code.ReadInt16()));
						break;
					case Mono.Cecil.Cil.OperandType.InlineTok:
					case Mono.Cecil.Cil.OperandType.InlineField:
					case Mono.Cecil.Cil.OperandType.InlineMethod:
					case Mono.Cecil.Cil.OperandType.InlineType:
						var member = metadata.LookupToken(code.ReadToken());
						switch (member.MetadataToken.TokenType)
						{
							case TokenType.TypeDef:
							case TokenType.TypeRef:
							case TokenType.TypeSpec:
								visitor.OnInlineType(opcode, (TypeReference)member);
								break;
							case TokenType.Method:
							case TokenType.MethodSpec:
								visitor.OnInlineMethod(opcode, (MethodReference)member);
								break;
							case TokenType.Field:
								visitor.OnInlineField(opcode, (FieldReference)member);
								break;
							case TokenType.MemberRef:
								var field_ref = member as FieldReference;
								if (field_ref != null)
								{
									visitor.OnInlineField(opcode, field_ref);
									break;
								}

								var method_ref = member as MethodReference;
								if (method_ref != null)
								{
									visitor.OnInlineMethod(opcode, method_ref);
									break;
								}

								throw new InvalidOperationException();
						}
						break;
				}
			}
		}

		static VariableDefinition GetVariable(ParseContext context, int index)
		{
			return context.Variables[index];
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Cil
{

	public sealed class ILProcessor
	{

		readonly MethodBody body;
		readonly Collection<Instruction> instructions;

		public MethodBody Body
		{
			get { return body; }
		}

		internal ILProcessor(MethodBody body)
		{
			this.body = body;
			this.instructions = body.Instructions;
		}

		public Instruction Create(OpCode opcode)
		{
			return Instruction.Create(opcode);
		}

		public Instruction Create(OpCode opcode, TypeReference type)
		{
			return Instruction.Create(opcode, type);
		}

		public Instruction Create(OpCode opcode, CallSite site)
		{
			return Instruction.Create(opcode, site);
		}

		public Instruction Create(OpCode opcode, MethodReference method)
		{
			return Instruction.Create(opcode, method);
		}

		public Instruction Create(OpCode opcode, FieldReference field)
		{
			return Instruction.Create(opcode, field);
		}

		public Instruction Create(OpCode opcode, string value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, sbyte value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, byte value)
		{
			if (opcode.OperandType == OperandType.ShortInlineVar)
				return Instruction.Create(opcode, body.Variables[value]);

			if (opcode.OperandType == OperandType.ShortInlineArg)
				return Instruction.Create(opcode, body.GetParameter(value));

			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, int value)
		{
			if (opcode.OperandType == OperandType.InlineVar)
				return Instruction.Create(opcode, body.Variables[value]);

			if (opcode.OperandType == OperandType.InlineArg)
				return Instruction.Create(opcode, body.GetParameter(value));

			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, long value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, float value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, double value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, Instruction target)
		{
			return Instruction.Create(opcode, target);
		}

		public Instruction Create(OpCode opcode, Instruction[] targets)
		{
			return Instruction.Create(opcode, targets);
		}

		public Instruction Create(OpCode opcode, VariableDefinition variable)
		{
			return Instruction.Create(opcode, variable);
		}

		public Instruction Create(OpCode opcode, ParameterDefinition parameter)
		{
			return Instruction.Create(opcode, parameter);
		}

		public void Emit(OpCode opcode)
		{
			Append(Create(opcode));
		}

		public void Emit(OpCode opcode, TypeReference type)
		{
			Append(Create(opcode, type));
		}

		public void Emit(OpCode opcode, MethodReference method)
		{
			Append(Create(opcode, method));
		}

		public void Emit(OpCode opcode, CallSite site)
		{
			Append(Create(opcode, site));
		}

		public void Emit(OpCode opcode, FieldReference field)
		{
			Append(Create(opcode, field));
		}

		public void Emit(OpCode opcode, string value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, byte value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, sbyte value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, int value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, long value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, float value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, double value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, Instruction target)
		{
			Append(Create(opcode, target));
		}

		public void Emit(OpCode opcode, Instruction[] targets)
		{
			Append(Create(opcode, targets));
		}

		public void Emit(OpCode opcode, VariableDefinition variable)
		{
			Append(Create(opcode, variable));
		}

		public void Emit(OpCode opcode, ParameterDefinition parameter)
		{
			Append(Create(opcode, parameter));
		}

		public void InsertBefore(Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException("target");
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			var index = instructions.IndexOf(target);
			if (index == -1)
				throw new ArgumentOutOfRangeException("target");

			instructions.Insert(index, instruction);
		}

		public void InsertAfter(Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException("target");
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			var index = instructions.IndexOf(target);
			if (index == -1)
				throw new ArgumentOutOfRangeException("target");

			instructions.Insert(index + 1, instruction);
		}

		public void InsertAfter(int index, Instruction instruction)
		{
			if (index < 0 || index >= instructions.Count)
				throw new ArgumentOutOfRangeException("index");
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			instructions.Insert(index + 1, instruction);
		}

		public void Append(Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			instructions.Add(instruction);
		}

		public void Replace(Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException("target");
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			InsertAfter(target, instruction);
			Remove(target);
		}

		public void Replace(int index, Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			InsertAfter(index, instruction);
			RemoveAt(index);
		}

		public void Remove(Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			if (!instructions.Remove(instruction))
				throw new ArgumentOutOfRangeException("instruction");
		}

		public void RemoveAt(int index)
		{
			if (index < 0 || index >= instructions.Count)
				throw new ArgumentOutOfRangeException("index");

			instructions.RemoveAt(index);
		}

		public void Clear()
		{
			instructions.Clear();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//










namespace Mono.Cecil.PE
{

	sealed class Image : IDisposable
	{

		public Disposable<Stream> Stream;
		public string FileName;

		public ModuleKind Kind;
		public uint Characteristics;
		public string RuntimeVersion;
		public TargetArchitecture Architecture;
		public ModuleCharacteristics DllCharacteristics;
		public ushort LinkerVersion;
		public ushort SubSystemMajor;
		public ushort SubSystemMinor;

		public ImageDebugHeader DebugHeader;

		public Section[] Sections;

		public Section MetadataSection;

		public uint EntryPointToken;
		public uint Timestamp;
		public ModuleAttributes Attributes;

		public DataDirectory Win32Resources;
		public DataDirectory Debug;
		public DataDirectory Resources;
		public DataDirectory StrongName;

		public StringHeap StringHeap;
		public BlobHeap BlobHeap;
		public UserStringHeap UserStringHeap;
		public GuidHeap GuidHeap;
		public TableHeap TableHeap;
		public PdbHeap PdbHeap;

		readonly int[] coded_index_sizes = new int[14];

		readonly Func<Table, int> counter;

		public Image()
		{
			counter = GetTableLength;
		}

		public bool HasTable(Table table)
		{
			return GetTableLength(table) > 0;
		}

		public int GetTableLength(Table table)
		{
			return (int)TableHeap[table].Length;
		}

		public int GetTableIndexSize(Table table)
		{
			return GetTableLength(table) < 65536 ? 2 : 4;
		}

		public int GetCodedIndexSize(CodedIndex coded_index)
		{
			var index = (int)coded_index;
			var size = coded_index_sizes[index];
			if (size != 0)
				return size;

			return coded_index_sizes[index] = coded_index.GetSize(counter);
		}

		public uint ResolveVirtualAddress(RVA rva)
		{
			var section = GetSectionAtVirtualAddress(rva);
			if (section == null)
				throw new ArgumentOutOfRangeException();

			return ResolveVirtualAddressInSection(rva, section);
		}

		public uint ResolveVirtualAddressInSection(RVA rva, Section section)
		{
			return rva + section.PointerToRawData - section.VirtualAddress;
		}

		public Section GetSection(string name)
		{
			var sections = this.Sections;
			for (int i = 0; i < sections.Length; i++)
			{
				var section = sections[i];
				if (section.Name == name)
					return section;
			}

			return null;
		}

		public Section GetSectionAtVirtualAddress(RVA rva)
		{
			var sections = this.Sections;
			for (int i = 0; i < sections.Length; i++)
			{
				var section = sections[i];
				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.SizeOfRawData)
					return section;
			}

			return null;
		}

		BinaryStreamReader GetReaderAt(RVA rva)
		{
			var section = GetSectionAtVirtualAddress(rva);
			if (section == null)
				return null;

			var reader = new BinaryStreamReader(Stream.value);
			reader.MoveTo(ResolveVirtualAddressInSection(rva, section));
			return reader;
		}

		public TRet GetReaderAt<TItem, TRet>(RVA rva, TItem item, Func<TItem, BinaryStreamReader, TRet> read) where TRet : class
		{
			var position = Stream.value.Position;
			try
			{
				var reader = GetReaderAt(rva);
				if (reader == null)
					return null;

				return read(item, reader);
			}
			finally
			{
				Stream.value.Position = position;
			}
		}

		public bool HasDebugTables()
		{
			return HasTable(Table.Document)
				|| HasTable(Table.MethodDebugInformation)
				|| HasTable(Table.LocalScope)
				|| HasTable(Table.LocalVariable)
				|| HasTable(Table.LocalConstant)
				|| HasTable(Table.StateMachineMethod)
				|| HasTable(Table.CustomDebugInformation);
		}

		public void Dispose()
		{
			Stream.Dispose();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//










namespace Mono.Cecil.PE
{

	sealed class ImageReader : BinaryStreamReader
	{

		readonly Image image;

		DataDirectory cli;
		DataDirectory metadata;

		uint table_heap_offset;

		public ImageReader(Disposable<Stream> stream, string file_name)
			: base(stream.value)
		{
			image = new Image();
			image.Stream = stream;
			image.FileName = file_name;
		}

		void MoveTo(DataDirectory directory)
		{
			BaseStream.Position = image.ResolveVirtualAddress(directory.VirtualAddress);
		}

		void ReadImage()
		{
			if (BaseStream.Length < 128)
				throw new BadImageFormatException();

			// - DOSHeader

			// PE					2
			// Start				58
			// Lfanew				4
			// End					64

			if (ReadUInt16() != 0x5a4d)
				throw new BadImageFormatException();

			Advance(58);

			MoveTo(ReadUInt32());

			if (ReadUInt32() != 0x00004550)
				throw new BadImageFormatException();

			// - PEFileHeader

			// Machine				2
			image.Architecture = ReadArchitecture();

			// NumberOfSections		2
			ushort sections = ReadUInt16();

			// TimeDateStamp		4
			image.Timestamp = ReadUInt32();
			// PointerToSymbolTable	4
			// NumberOfSymbols		4
			// OptionalHeaderSize	2
			Advance(10);

			// Characteristics		2
			ushort characteristics = ReadUInt16();

			ushort subsystem, dll_characteristics;
			ReadOptionalHeaders(out subsystem, out dll_characteristics);
			ReadSections(sections);
			ReadCLIHeader();
			ReadMetadata();
			ReadDebugHeader();

			image.Characteristics = characteristics;
			image.Kind = GetModuleKind(characteristics, subsystem);
			image.DllCharacteristics = (ModuleCharacteristics)dll_characteristics;
		}

		TargetArchitecture ReadArchitecture()
		{
			return (TargetArchitecture)ReadUInt16();
		}

		static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
		{
			if ((characteristics & 0x2000) != 0) // ImageCharacteristics.Dll
				return ModuleKind.Dll;

			if (subsystem == 0x2 || subsystem == 0x9) // SubSystem.WindowsGui || SubSystem.WindowsCeGui
				return ModuleKind.Windows;

			return ModuleKind.Console;
		}

		void ReadOptionalHeaders(out ushort subsystem, out ushort dll_characteristics)
		{
			// - PEOptionalHeader
			//   - StandardFieldsHeader

			// Magic				2
			bool pe64 = ReadUInt16() == 0x20b;

			//						pe32 || pe64

			image.LinkerVersion = ReadUInt16();
			// CodeSize				4
			// InitializedDataSize	4
			// UninitializedDataSize4
			// EntryPointRVA		4
			// BaseOfCode			4
			// BaseOfData			4 || 0

			//   - NTSpecificFieldsHeader

			// ImageBase			4 || 8
			// SectionAlignment		4
			// FileAlignement		4
			// OSMajor				2
			// OSMinor				2
			// UserMajor			2
			// UserMinor			2
			// SubSysMajor			2
			// SubSysMinor			2
			Advance(44);

			image.SubSystemMajor = ReadUInt16();
			image.SubSystemMinor = ReadUInt16();

			// Reserved				4
			// ImageSize			4
			// HeaderSize			4
			// FileChecksum			4
			Advance(16);

			// SubSystem			2
			subsystem = ReadUInt16();

			// DLLFlags				2
			dll_characteristics = ReadUInt16();
			// StackReserveSize		4 || 8
			// StackCommitSize		4 || 8
			// HeapReserveSize		4 || 8
			// HeapCommitSize		4 || 8
			// LoaderFlags			4
			// NumberOfDataDir		4

			//   - DataDirectoriesHeader

			// ExportTable			8
			// ImportTable			8

			Advance(pe64 ? 56 : 40);

			// ResourceTable		8

			image.Win32Resources = ReadDataDirectory();

			// ExceptionTable		8
			// CertificateTable		8
			// BaseRelocationTable	8

			Advance(24);

			// Debug				8
			image.Debug = ReadDataDirectory();

			// Copyright			8
			// GlobalPtr			8
			// TLSTable				8
			// LoadConfigTable		8
			// BoundImport			8
			// IAT					8
			// DelayImportDescriptor8
			Advance(56);

			// CLIHeader			8
			cli = ReadDataDirectory();

			if (cli.IsZero)
				throw new BadImageFormatException();

			// Reserved				8
			Advance(8);
		}

		string ReadAlignedString(int length)
		{
			int read = 0;
			var buffer = new char[length];
			while (read < length)
			{
				var current = ReadByte();
				if (current == 0)
					break;

				buffer[read++] = (char)current;
			}

			Advance(-1 + ((read + 4) & ~3) - read);

			return new string(buffer, 0, read);
		}

		string ReadZeroTerminatedString(int length)
		{
			int read = 0;
			var buffer = new char[length];
			var bytes = ReadBytes(length);
			while (read < length)
			{
				var current = bytes[read];
				if (current == 0)
					break;

				buffer[read++] = (char)current;
			}

			return new string(buffer, 0, read);
		}

		void ReadSections(ushort count)
		{
			var sections = new Section[count];

			for (int i = 0; i < count; i++)
			{
				var section = new Section();

				// Name
				section.Name = ReadZeroTerminatedString(8);

				// VirtualSize		4
				Advance(4);

				// VirtualAddress	4
				section.VirtualAddress = ReadUInt32();
				// SizeOfRawData	4
				section.SizeOfRawData = ReadUInt32();
				// PointerToRawData	4
				section.PointerToRawData = ReadUInt32();

				// PointerToRelocations		4
				// PointerToLineNumbers		4
				// NumberOfRelocations		2
				// NumberOfLineNumbers		2
				// Characteristics			4
				Advance(16);

				sections[i] = section;
			}

			image.Sections = sections;
		}

		void ReadCLIHeader()
		{
			MoveTo(cli);

			// - CLIHeader

			// Cb						4
			// MajorRuntimeVersion		2
			// MinorRuntimeVersion		2
			Advance(8);

			// Metadata					8
			metadata = ReadDataDirectory();
			// Flags					4
			image.Attributes = (ModuleAttributes)ReadUInt32();
			// EntryPointToken			4
			image.EntryPointToken = ReadUInt32();
			// Resources				8
			image.Resources = ReadDataDirectory();
			// StrongNameSignature		8
			image.StrongName = ReadDataDirectory();
			// CodeManagerTable			8
			// VTableFixups				8
			// ExportAddressTableJumps	8
			// ManagedNativeHeader		8
		}

		void ReadMetadata()
		{
			MoveTo(metadata);

			if (ReadUInt32() != 0x424a5342)
				throw new BadImageFormatException();

			// MajorVersion			2
			// MinorVersion			2
			// Reserved				4
			Advance(8);

			image.RuntimeVersion = ReadZeroTerminatedString(ReadInt32());

			// Flags		2
			Advance(2);

			var streams = ReadUInt16();

			var section = image.GetSectionAtVirtualAddress(metadata.VirtualAddress);
			if (section == null)
				throw new BadImageFormatException();

			image.MetadataSection = section;

			for (int i = 0; i < streams; i++)
				ReadMetadataStream(section);

			if (image.PdbHeap != null)
				ReadPdbHeap();

			if (image.TableHeap != null)
				ReadTableHeap();
		}

		void ReadDebugHeader()
		{
			if (image.Debug.IsZero)
			{
				image.DebugHeader = new ImageDebugHeader(Empty<ImageDebugHeaderEntry>.Array);
				return;
			}

			MoveTo(image.Debug);

			var entries = new ImageDebugHeaderEntry[(int)image.Debug.Size / ImageDebugDirectory.Size];

			for (int i = 0; i < entries.Length; i++)
			{
				var directory = new ImageDebugDirectory
				{
					Characteristics = ReadInt32(),
					TimeDateStamp = ReadInt32(),
					MajorVersion = ReadInt16(),
					MinorVersion = ReadInt16(),
					Type = (ImageDebugType)ReadInt32(),
					SizeOfData = ReadInt32(),
					AddressOfRawData = ReadInt32(),
					PointerToRawData = ReadInt32(),
				};

				if (directory.PointerToRawData == 0 || directory.SizeOfData < 0)
				{
					entries[i] = new ImageDebugHeaderEntry(directory, Empty<byte>.Array);
					continue;
				}

				var position = Position;
				try
				{
					MoveTo((uint)directory.PointerToRawData);
					var data = ReadBytes(directory.SizeOfData);
					entries[i] = new ImageDebugHeaderEntry(directory, data);
				}
				finally
				{
					Position = position;
				}
			}

			image.DebugHeader = new ImageDebugHeader(entries);
		}

		void ReadMetadataStream(Section section)
		{
			// Offset		4
			uint offset = metadata.VirtualAddress - section.VirtualAddress + ReadUInt32(); // relative to the section start

			// Size			4
			uint size = ReadUInt32();

			var data = ReadHeapData(offset, size);

			var name = ReadAlignedString(16);
			switch (name)
			{
				case "#~":
				case "#-":
					image.TableHeap = new TableHeap(data);
					table_heap_offset = offset;
					break;
				case "#Strings":
					image.StringHeap = new StringHeap(data);
					break;
				case "#Blob":
					image.BlobHeap = new BlobHeap(data);
					break;
				case "#GUID":
					image.GuidHeap = new GuidHeap(data);
					break;
				case "#US":
					image.UserStringHeap = new UserStringHeap(data);
					break;
				case "#Pdb":
					image.PdbHeap = new PdbHeap(data);
					break;
			}
		}

		byte[] ReadHeapData(uint offset, uint size)
		{
			var position = BaseStream.Position;
			MoveTo(offset + image.MetadataSection.PointerToRawData);
			var data = ReadBytes((int)size);
			BaseStream.Position = position;

			return data;
		}

		void ReadTableHeap()
		{
			var heap = image.TableHeap;

			MoveTo(table_heap_offset + image.MetadataSection.PointerToRawData);

			// Reserved			4
			// MajorVersion		1
			// MinorVersion		1
			Advance(6);

			// HeapSizes		1
			var sizes = ReadByte();

			// Reserved2		1
			Advance(1);

			// Valid			8
			heap.Valid = ReadInt64();

			// Sorted			8
			heap.Sorted = ReadInt64();

			if (image.PdbHeap != null)
			{
				for (int i = 0; i < Mixin.TableCount; i++)
				{
					if (!image.PdbHeap.HasTable((Table)i))
						continue;

					heap.Tables[i].Length = image.PdbHeap.TypeSystemTableRows[i];
				}
			}

			for (int i = 0; i < Mixin.TableCount; i++)
			{
				if (!heap.HasTable((Table)i))
					continue;

				heap.Tables[i].Length = ReadUInt32();
			}

			SetIndexSize(image.StringHeap, sizes, 0x1);
			SetIndexSize(image.GuidHeap, sizes, 0x2);
			SetIndexSize(image.BlobHeap, sizes, 0x4);

			ComputeTableInformations();
		}

		static void SetIndexSize(Heap heap, uint sizes, byte flag)
		{
			if (heap == null)
				return;

			heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;
		}

		int GetTableIndexSize(Table table)
		{
			return image.GetTableIndexSize(table);
		}

		int GetCodedIndexSize(CodedIndex index)
		{
			return image.GetCodedIndexSize(index);
		}

		void ComputeTableInformations()
		{
			uint offset = (uint)BaseStream.Position - table_heap_offset - image.MetadataSection.PointerToRawData; // header

			int stridx_size = image.StringHeap != null ? image.StringHeap.IndexSize : 2;
			int guididx_size = image.GuidHeap != null ? image.GuidHeap.IndexSize : 2;
			int blobidx_size = image.BlobHeap != null ? image.BlobHeap.IndexSize : 2;

			var heap = image.TableHeap;
			var tables = heap.Tables;

			for (int i = 0; i < Mixin.TableCount; i++)
			{
				var table = (Table)i;
				if (!heap.HasTable(table))
					continue;

				int size;
				switch (table)
				{
					case Table.Module:
						size = 2    // Generation
							+ stridx_size   // Name
							+ (guididx_size * 3);   // Mvid, EncId, EncBaseId
						break;
					case Table.TypeRef:
						size = GetCodedIndexSize(CodedIndex.ResolutionScope)    // ResolutionScope
							+ (stridx_size * 2);    // Name, Namespace
						break;
					case Table.TypeDef:
						size = 4    // Flags
							+ (stridx_size * 2) // Name, Namespace
							+ GetCodedIndexSize(CodedIndex.TypeDefOrRef)    // BaseType
							+ GetTableIndexSize(Table.Field)    // FieldList
							+ GetTableIndexSize(Table.Method);  // MethodList
						break;
					case Table.FieldPtr:
						size = GetTableIndexSize(Table.Field);  // Field
						break;
					case Table.Field:
						size = 2    // Flags
							+ stridx_size   // Name
							+ blobidx_size; // Signature
						break;
					case Table.MethodPtr:
						size = GetTableIndexSize(Table.Method); // Method
						break;
					case Table.Method:
						size = 8    // Rva 4, ImplFlags 2, Flags 2
							+ stridx_size   // Name
							+ blobidx_size  // Signature
							+ GetTableIndexSize(Table.Param); // ParamList
						break;
					case Table.ParamPtr:
						size = GetTableIndexSize(Table.Param); // Param
						break;
					case Table.Param:
						size = 4    // Flags 2, Sequence 2
							+ stridx_size;  // Name
						break;
					case Table.InterfaceImpl:
						size = GetTableIndexSize(Table.TypeDef) // Class
							+ GetCodedIndexSize(CodedIndex.TypeDefOrRef);   // Interface
						break;
					case Table.MemberRef:
						size = GetCodedIndexSize(CodedIndex.MemberRefParent)    // Class
							+ stridx_size   // Name
							+ blobidx_size; // Signature
						break;
					case Table.Constant:
						size = 2    // Type
							+ GetCodedIndexSize(CodedIndex.HasConstant) // Parent
							+ blobidx_size; // Value
						break;
					case Table.CustomAttribute:
						size = GetCodedIndexSize(CodedIndex.HasCustomAttribute) // Parent
							+ GetCodedIndexSize(CodedIndex.CustomAttributeType) // Type
							+ blobidx_size; // Value
						break;
					case Table.FieldMarshal:
						size = GetCodedIndexSize(CodedIndex.HasFieldMarshal)    // Parent
							+ blobidx_size; // NativeType
						break;
					case Table.DeclSecurity:
						size = 2    // Action
							+ GetCodedIndexSize(CodedIndex.HasDeclSecurity) // Parent
							+ blobidx_size; // PermissionSet
						break;
					case Table.ClassLayout:
						size = 6    // PackingSize 2, ClassSize 4
							+ GetTableIndexSize(Table.TypeDef); // Parent
						break;
					case Table.FieldLayout:
						size = 4    // Offset
							+ GetTableIndexSize(Table.Field);   // Field
						break;
					case Table.StandAloneSig:
						size = blobidx_size;    // Signature
						break;
					case Table.EventMap:
						size = GetTableIndexSize(Table.TypeDef) // Parent
							+ GetTableIndexSize(Table.Event);   // EventList
						break;
					case Table.EventPtr:
						size = GetTableIndexSize(Table.Event);  // Event
						break;
					case Table.Event:
						size = 2    // Flags
							+ stridx_size // Name
							+ GetCodedIndexSize(CodedIndex.TypeDefOrRef);   // EventType
						break;
					case Table.PropertyMap:
						size = GetTableIndexSize(Table.TypeDef) // Parent
							+ GetTableIndexSize(Table.Property);    // PropertyList
						break;
					case Table.PropertyPtr:
						size = GetTableIndexSize(Table.Property);   // Property
						break;
					case Table.Property:
						size = 2    // Flags
							+ stridx_size   // Name
							+ blobidx_size; // Type
						break;
					case Table.MethodSemantics:
						size = 2    // Semantics
							+ GetTableIndexSize(Table.Method)   // Method
							+ GetCodedIndexSize(CodedIndex.HasSemantics);   // Association
						break;
					case Table.MethodImpl:
						size = GetTableIndexSize(Table.TypeDef) // Class
							+ GetCodedIndexSize(CodedIndex.MethodDefOrRef)  // MethodBody
							+ GetCodedIndexSize(CodedIndex.MethodDefOrRef); // MethodDeclaration
						break;
					case Table.ModuleRef:
						size = stridx_size; // Name
						break;
					case Table.TypeSpec:
						size = blobidx_size;    // Signature
						break;
					case Table.ImplMap:
						size = 2    // MappingFlags
							+ GetCodedIndexSize(CodedIndex.MemberForwarded) // MemberForwarded
							+ stridx_size   // ImportName
							+ GetTableIndexSize(Table.ModuleRef);   // ImportScope
						break;
					case Table.FieldRVA:
						size = 4    // RVA
							+ GetTableIndexSize(Table.Field);   // Field
						break;
					case Table.EncLog:
						size = 8;
						break;
					case Table.EncMap:
						size = 4;
						break;
					case Table.Assembly:
						size = 16 // HashAlgId 4, Version 4 * 2, Flags 4
							+ blobidx_size  // PublicKey
							+ (stridx_size * 2);    // Name, Culture
						break;
					case Table.AssemblyProcessor:
						size = 4;   // Processor
						break;
					case Table.AssemblyOS:
						size = 12;  // Platform 4, Version 2 * 4
						break;
					case Table.AssemblyRef:
						size = 12   // Version 2 * 4 + Flags 4
							+ (blobidx_size * 2)    // PublicKeyOrToken, HashValue
							+ (stridx_size * 2);    // Name, Culture
						break;
					case Table.AssemblyRefProcessor:
						size = 4    // Processor
							+ GetTableIndexSize(Table.AssemblyRef); // AssemblyRef
						break;
					case Table.AssemblyRefOS:
						size = 12   // Platform 4, Version 2 * 4
							+ GetTableIndexSize(Table.AssemblyRef); // AssemblyRef
						break;
					case Table.File:
						size = 4    // Flags
							+ stridx_size   // Name
							+ blobidx_size; // HashValue
						break;
					case Table.ExportedType:
						size = 8    // Flags 4, TypeDefId 4
							+ (stridx_size * 2) // Name, Namespace
							+ GetCodedIndexSize(CodedIndex.Implementation); // Implementation
						break;
					case Table.ManifestResource:
						size = 8    // Offset, Flags
							+ stridx_size   // Name
							+ GetCodedIndexSize(CodedIndex.Implementation); // Implementation
						break;
					case Table.NestedClass:
						size = GetTableIndexSize(Table.TypeDef) // NestedClass
							+ GetTableIndexSize(Table.TypeDef); // EnclosingClass
						break;
					case Table.GenericParam:
						size = 4    // Number, Flags
							+ GetCodedIndexSize(CodedIndex.TypeOrMethodDef) // Owner
							+ stridx_size;  // Name
						break;
					case Table.MethodSpec:
						size = GetCodedIndexSize(CodedIndex.MethodDefOrRef) // Method
							+ blobidx_size; // Instantiation
						break;
					case Table.GenericParamConstraint:
						size = GetTableIndexSize(Table.GenericParam)    // Owner
							+ GetCodedIndexSize(CodedIndex.TypeDefOrRef);   // Constraint
						break;
					case Table.Document:
						size = blobidx_size // Name
							+ guididx_size  // HashAlgorithm
							+ blobidx_size  // Hash
							+ guididx_size; // Language
						break;
					case Table.MethodDebugInformation:
						size = GetTableIndexSize(Table.Document)  // Document
							+ blobidx_size; // SequencePoints
						break;
					case Table.LocalScope:
						size = GetTableIndexSize(Table.Method)  // Method
							+ GetTableIndexSize(Table.ImportScope)  // ImportScope
							+ GetTableIndexSize(Table.LocalVariable)    // VariableList
							+ GetTableIndexSize(Table.LocalConstant)    // ConstantList
							+ 4 * 2;    // StartOffset, Length
						break;
					case Table.LocalVariable:
						size = 2    // Attributes
							+ 2     // Index
							+ stridx_size;  // Name
						break;
					case Table.LocalConstant:
						size = stridx_size  // Name
							+ blobidx_size; // Signature
						break;
					case Table.ImportScope:
						size = GetTableIndexSize(Table.ImportScope) // Parent
							+ blobidx_size;
						break;
					case Table.StateMachineMethod:
						size = GetTableIndexSize(Table.Method) // MoveNextMethod
							+ GetTableIndexSize(Table.Method);  // KickOffMethod
						break;
					case Table.CustomDebugInformation:
						size = GetCodedIndexSize(CodedIndex.HasCustomDebugInformation) // Parent
							+ guididx_size  // Kind
							+ blobidx_size; // Value
						break;
					default:
						throw new NotSupportedException();
				}

				tables[i].RowSize = (uint)size;
				tables[i].Offset = offset;

				offset += (uint)size * tables[i].Length;
			}
		}

		void ReadPdbHeap()
		{
			var heap = image.PdbHeap;

			var buffer = new ByteBuffer(heap.data);

			heap.Id = buffer.ReadBytes(20);
			heap.EntryPoint = buffer.ReadUInt32();
			heap.TypeSystemTables = buffer.ReadInt64();
			heap.TypeSystemTableRows = new uint[Mixin.TableCount];

			for (int i = 0; i < Mixin.TableCount; i++)
			{
				var table = (Table)i;
				if (!heap.HasTable(table))
					continue;

				heap.TypeSystemTableRows[i] = buffer.ReadUInt32();
			}
		}

		public static Image ReadImage(Disposable<Stream> stream, string file_name)
		{
			try
			{
				var reader = new ImageReader(stream, file_name);
				reader.ReadImage();
				return reader.image;
			}
			catch (EndOfStreamException e)
			{
				throw new BadImageFormatException(stream.value.GetFileName(), e);
			}
		}

		public static Image ReadPortablePdb(Disposable<Stream> stream, string file_name)
		{
			try
			{
				var reader = new ImageReader(stream, file_name);
				var length = (uint)stream.value.Length;

				reader.image.Sections = new[] {
					new Section {
						PointerToRawData = 0,
						SizeOfRawData = length,
						VirtualAddress = 0,
						VirtualSize = length,
					}
				};

				reader.metadata = new DataDirectory(0, length);
				reader.ReadMetadata();
				return reader.image;
			}
			catch (EndOfStreamException e)
			{
				throw new BadImageFormatException(stream.value.GetFileName(), e);
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil.PE
{

	sealed class ImageWriter : BinaryStreamWriter
	{

		readonly ModuleDefinition module;
		readonly MetadataBuilder metadata;
		readonly TextMap text_map;
		readonly internal Disposable<Stream> stream;

		readonly string runtime_version;

		ImageDebugHeader debug_header;

		ByteBuffer win32_resources;

		const uint pe_header_size = 0x98u;
		const uint section_header_size = 0x28u;
		const uint file_alignment = 0x200;
		const uint section_alignment = 0x2000;
		const ulong image_base = 0x00400000;

		internal const RVA text_rva = 0x2000;

		readonly bool pe64;
		readonly bool has_reloc;

		internal Section text;
		internal Section rsrc;
		internal Section reloc;

		ushort sections;

		ImageWriter(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable<Stream> stream, bool metadataOnly = false)
			: base(stream.value)
		{
			this.module = module;
			this.runtime_version = runtime_version;
			this.text_map = metadata.text_map;
			this.stream = stream;
			this.metadata = metadata;
			if (metadataOnly)
				return;

			this.pe64 = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64 || module.Architecture == TargetArchitecture.ARM64;
			this.has_reloc = module.Architecture == TargetArchitecture.I386;
			this.GetDebugHeader();
			this.GetWin32Resources();
			this.BuildTextMap();
			this.sections = (ushort)(has_reloc ? 2 : 1); // text + reloc?
		}

		void GetDebugHeader()
		{
			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null)
				debug_header = symbol_writer.GetDebugHeader();

			if (module.HasDebugHeader)
			{
				var header = module.GetDebugHeader();
				var deterministic = header.GetDeterministicEntry();
				if (deterministic == null)
					return;

				debug_header = debug_header.AddDeterministicEntry();
			}
		}

		void GetWin32Resources()
		{
			if (!module.HasImage)
				return;

			DataDirectory win32_resources_directory = module.Image.Win32Resources;
			var size = win32_resources_directory.Size;

			if (size > 0)
			{
				win32_resources = module.Image.GetReaderAt(win32_resources_directory.VirtualAddress, size, (s, reader) => new ByteBuffer(reader.ReadBytes((int)s)));
			}
		}

		public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
		{
			var writer = new ImageWriter(module, module.runtime_version, metadata, stream);
			writer.BuildSections();
			return writer;
		}

		public static ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
		{
			var writer = new ImageWriter(module, "PDB v1.0", metadata, stream, metadataOnly: true);
			var length = metadata.text_map.GetLength();
			writer.text = new Section { SizeOfRawData = length, VirtualSize = length };
			return writer;
		}

		void BuildSections()
		{
			var has_win32_resources = win32_resources != null;
			if (has_win32_resources)
				sections++;

			text = CreateSection(".text", text_map.GetLength(), null);
			var previous = text;

			if (has_win32_resources)
			{
				rsrc = CreateSection(".rsrc", (uint)win32_resources.length, previous);

				PatchWin32Resources(win32_resources);
				previous = rsrc;
			}

			if (has_reloc)
				reloc = CreateSection(".reloc", 12u, previous);
		}

		Section CreateSection(string name, uint size, Section previous)
		{
			return new Section
			{
				Name = name,
				VirtualAddress = previous != null
					? previous.VirtualAddress + Align(previous.VirtualSize, section_alignment)
					: text_rva,
				VirtualSize = size,
				PointerToRawData = previous != null
					? previous.PointerToRawData + previous.SizeOfRawData
					: Align(GetHeaderSize(), file_alignment),
				SizeOfRawData = Align(size, file_alignment)
			};
		}

		static uint Align(uint value, uint align)
		{
			align--;
			return (value + align) & ~align;
		}

		void WriteDOSHeader()
		{
			Write(new byte[] {
				// dos header start
				0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00,
				0x00, 0x04, 0x00, 0x00, 0x00, 0xff, 0xff,
				0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				// lfanew
				0x80, 0x00, 0x00, 0x00,
				// dos header end
				0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09,
				0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21,
				0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72,
				0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63,
				0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x62,
				0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69,
				0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x6d,
				0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,
				0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00
			});
		}

		ushort SizeOfOptionalHeader()
		{
			return (ushort)(!pe64 ? 0xe0 : 0xf0);
		}

		void WritePEFileHeader()
		{
			WriteUInt32(0x00004550);        // Magic
			WriteUInt16((ushort)module.Architecture);   // Machine
			WriteUInt16(sections);          // NumberOfSections
			WriteUInt32(metadata.timestamp);
			WriteUInt32(0); // PointerToSymbolTable
			WriteUInt32(0); // NumberOfSymbols
			WriteUInt16(SizeOfOptionalHeader());  // SizeOfOptionalHeader

			const ushort LargeAddressAware = 0x0020;

			// ExecutableImage | (!pe64 ? 32BitsMachine : LargeAddressAware)
			var characteristics = (ushort)(0x0002 | (!pe64 ? 0x0100 : LargeAddressAware));
			if (module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule)
				characteristics |= 0x2000;

			if (module.Image != null && (module.Image.Characteristics & LargeAddressAware) != 0)
				characteristics |= LargeAddressAware;

			WriteUInt16(characteristics);   // Characteristics
		}

		Section LastSection()
		{
			if (reloc != null)
				return reloc;

			if (rsrc != null)
				return rsrc;

			return text;
		}

		void WriteOptionalHeaders()
		{
			WriteUInt16((ushort)(!pe64 ? 0x10b : 0x20b)); // Magic
			WriteUInt16(module.linker_version);
			WriteUInt32(text.SizeOfRawData);    // CodeSize
			WriteUInt32((reloc != null ? reloc.SizeOfRawData : 0)
				+ (rsrc != null ? rsrc.SizeOfRawData : 0)); // InitializedDataSize
			WriteUInt32(0); // UninitializedDataSize

			var startub_stub = text_map.GetRange(TextSegment.StartupStub);
			WriteUInt32(startub_stub.Length > 0 ? startub_stub.Start : 0);  // EntryPointRVA
			WriteUInt32(text_rva);  // BaseOfCode

			if (!pe64)
			{
				WriteUInt32(0); // BaseOfData
				WriteUInt32((uint)image_base);  // ImageBase
			}
			else
			{
				WriteUInt64(image_base);    // ImageBase
			}

			WriteUInt32(section_alignment); // SectionAlignment
			WriteUInt32(file_alignment);        // FileAlignment

			WriteUInt16(4); // OSMajor
			WriteUInt16(0); // OSMinor
			WriteUInt16(0); // UserMajor
			WriteUInt16(0); // UserMinor
			WriteUInt16(module.subsystem_major);    // SubSysMajor
			WriteUInt16(module.subsystem_minor);    // SubSysMinor
			WriteUInt32(0); // Reserved

			var last_section = LastSection();
			WriteUInt32(last_section.VirtualAddress + Align(last_section.VirtualSize, section_alignment));  // ImageSize
			WriteUInt32(text.PointerToRawData); // HeaderSize

			WriteUInt32(0); // Checksum
			WriteUInt16(GetSubSystem());    // SubSystem
			WriteUInt16((ushort)module.Characteristics);    // DLLFlags

			if (!pe64)
			{
				const uint stack_reserve = 0x100000;
				const uint stack_commit = 0x1000;
				const uint heap_reserve = 0x100000;
				const uint heap_commit = 0x1000;

				WriteUInt32(stack_reserve);
				WriteUInt32(stack_commit);
				WriteUInt32(heap_reserve);
				WriteUInt32(heap_commit);
			}
			else
			{
				const ulong stack_reserve = 0x400000;
				const ulong stack_commit = 0x4000;
				const ulong heap_reserve = 0x100000;
				const ulong heap_commit = 0x2000;

				WriteUInt64(stack_reserve);
				WriteUInt64(stack_commit);
				WriteUInt64(heap_reserve);
				WriteUInt64(heap_commit);
			}

			WriteUInt32(0); // LoaderFlags
			WriteUInt32(16);    // NumberOfDataDir

			WriteZeroDataDirectory();   // ExportTable
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportDirectory)); // ImportTable
			if (rsrc != null)
			{                           // ResourceTable
				WriteUInt32(rsrc.VirtualAddress);
				WriteUInt32(rsrc.VirtualSize);
			}
			else
				WriteZeroDataDirectory();

			WriteZeroDataDirectory();   // ExceptionTable
			WriteZeroDataDirectory();   // CertificateTable
			WriteUInt32(reloc != null ? reloc.VirtualAddress : 0);          // BaseRelocationTable
			WriteUInt32(reloc != null ? reloc.VirtualSize : 0);

			if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
			{
				WriteUInt32(text_map.GetRVA(TextSegment.DebugDirectory));
				WriteUInt32((uint)(debug_header.Entries.Length * ImageDebugDirectory.Size));
			}
			else
				WriteZeroDataDirectory();

			WriteZeroDataDirectory();   // Copyright
			WriteZeroDataDirectory();   // GlobalPtr
			WriteZeroDataDirectory();   // TLSTable
			WriteZeroDataDirectory();   // LoadConfigTable
			WriteZeroDataDirectory();   // BoundImport
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportAddressTable));  // IAT
			WriteZeroDataDirectory();   // DelayImportDesc
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.CLIHeader));   // CLIHeader
			WriteZeroDataDirectory();   // Reserved
		}

		void WriteZeroDataDirectory()
		{
			WriteUInt32(0);
			WriteUInt32(0);
		}

		ushort GetSubSystem()
		{
			switch (module.Kind)
			{
				case ModuleKind.Console:
				case ModuleKind.Dll:
				case ModuleKind.NetModule:
					return 0x3;
				case ModuleKind.Windows:
					return 0x2;
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		void WriteSectionHeaders()
		{
			WriteSection(text, 0x60000020);

			if (rsrc != null)
				WriteSection(rsrc, 0x40000040);

			if (reloc != null)
				WriteSection(reloc, 0x42000040);
		}

		void WriteSection(Section section, uint characteristics)
		{
			var name = new byte[8];
			var sect_name = section.Name;
			for (int i = 0; i < sect_name.Length; i++)
				name[i] = (byte)sect_name[i];

			WriteBytes(name);
			WriteUInt32(section.VirtualSize);
			WriteUInt32(section.VirtualAddress);
			WriteUInt32(section.SizeOfRawData);
			WriteUInt32(section.PointerToRawData);
			WriteUInt32(0); // PointerToRelocations
			WriteUInt32(0); // PointerToLineNumbers
			WriteUInt16(0); // NumberOfRelocations
			WriteUInt16(0); // NumberOfLineNumbers
			WriteUInt32(characteristics);
		}

		uint GetRVAFileOffset(Section section, RVA rva)
		{
			return section.PointerToRawData + rva - section.VirtualAddress;
		}

		void MoveTo(uint pointer)
		{
			BaseStream.Seek(pointer, SeekOrigin.Begin);
		}

		void MoveToRVA(Section section, RVA rva)
		{
			BaseStream.Seek(GetRVAFileOffset(section, rva), SeekOrigin.Begin);
		}

		void MoveToRVA(TextSegment segment)
		{
			MoveToRVA(text, text_map.GetRVA(segment));
		}

		void WriteRVA(RVA rva)
		{
			if (!pe64)
				WriteUInt32(rva);
			else
				WriteUInt64(rva);
		}

		void PrepareSection(Section section)
		{
			MoveTo(section.PointerToRawData);

			const int buffer_size = 4096;

			if (section.SizeOfRawData <= buffer_size)
			{
				Write(new byte[section.SizeOfRawData]);
				MoveTo(section.PointerToRawData);
				return;
			}

			var written = 0;
			var buffer = new byte[buffer_size];
			while (written != section.SizeOfRawData)
			{
				var write_size = System.Math.Min((int)section.SizeOfRawData - written, buffer_size);
				Write(buffer, 0, write_size);
				written += write_size;
			}

			MoveTo(section.PointerToRawData);
		}

		void WriteText()
		{
			PrepareSection(text);

			// ImportAddressTable

			if (has_reloc)
			{
				WriteRVA(text_map.GetRVA(TextSegment.ImportHintNameTable));
				WriteRVA(0);
			}

			// CLIHeader

			WriteUInt32(0x48);
			WriteUInt16(2);
			WriteUInt16((ushort)((module.Runtime <= TargetRuntime.Net_1_1) ? 0 : 5));

			WriteUInt32(text_map.GetRVA(TextSegment.MetadataHeader));
			WriteUInt32(GetMetadataLength());
			WriteUInt32((uint)module.Attributes);
			WriteUInt32(metadata.entry_point.ToUInt32());
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.Resources));
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.StrongNameSignature));
			WriteZeroDataDirectory();   // CodeManagerTable
			WriteZeroDataDirectory();   // VTableFixups
			WriteZeroDataDirectory();   // ExportAddressTableJumps
			WriteZeroDataDirectory();   // ManagedNativeHeader

			// Code

			MoveToRVA(TextSegment.Code);
			WriteBuffer(metadata.code);

			// Resources

			MoveToRVA(TextSegment.Resources);
			WriteBuffer(metadata.resources);

			// Data

			if (metadata.data.length > 0)
			{
				MoveToRVA(TextSegment.Data);
				WriteBuffer(metadata.data);
			}

			// StrongNameSignature
			// stays blank

			// MetadataHeader

			MoveToRVA(TextSegment.MetadataHeader);
			WriteMetadataHeader();

			WriteMetadata();

			// DebugDirectory
			if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
			{
				MoveToRVA(TextSegment.DebugDirectory);
				WriteDebugDirectory();
			}

			if (!has_reloc)
				return;

			// ImportDirectory
			MoveToRVA(TextSegment.ImportDirectory);
			WriteImportDirectory();

			// StartupStub
			MoveToRVA(TextSegment.StartupStub);
			WriteStartupStub();
		}

		uint GetMetadataLength()
		{
			return text_map.GetRVA(TextSegment.DebugDirectory) - text_map.GetRVA(TextSegment.MetadataHeader);
		}

		public void WriteMetadataHeader()
		{
			WriteUInt32(0x424a5342);    // Signature
			WriteUInt16(1); // MajorVersion
			WriteUInt16(1); // MinorVersion
			WriteUInt32(0); // Reserved

			var version = GetZeroTerminatedString(runtime_version);
			WriteUInt32((uint)version.Length);
			WriteBytes(version);
			WriteUInt16(0); // Flags
			WriteUInt16(GetStreamCount());

			uint offset = text_map.GetRVA(TextSegment.TableHeap) - text_map.GetRVA(TextSegment.MetadataHeader);

			WriteStreamHeader(ref offset, TextSegment.TableHeap, "#~");
			WriteStreamHeader(ref offset, TextSegment.StringHeap, "#Strings");
			WriteStreamHeader(ref offset, TextSegment.UserStringHeap, "#US");
			WriteStreamHeader(ref offset, TextSegment.GuidHeap, "#GUID");
			WriteStreamHeader(ref offset, TextSegment.BlobHeap, "#Blob");
			WriteStreamHeader(ref offset, TextSegment.PdbHeap, "#Pdb");
		}

		ushort GetStreamCount()
		{
			return (ushort)(
				1   // #~
				+ 1 // #Strings
				+ (metadata.user_string_heap.IsEmpty ? 0 : 1)   // #US
				+ (metadata.guid_heap.IsEmpty ? 0 : 1)  // GUID
				+ (metadata.blob_heap.IsEmpty ? 0 : 1)
				+ (metadata.pdb_heap == null ? 0 : 1)); // #Blob
		}

		void WriteStreamHeader(ref uint offset, TextSegment heap, string name)
		{
			var length = (uint)text_map.GetLength(heap);
			if (length == 0)
				return;

			WriteUInt32(offset);
			WriteUInt32(length);
			WriteBytes(GetZeroTerminatedString(name));
			offset += length;
		}

		static int GetZeroTerminatedStringLength(string @string)
		{
			return (@string.Length + 1 + 3) & ~3;
		}

		static byte[] GetZeroTerminatedString(string @string)
		{
			return GetString(@string, GetZeroTerminatedStringLength(@string));
		}

		static byte[] GetSimpleString(string @string)
		{
			return GetString(@string, @string.Length);
		}

		static byte[] GetString(string @string, int length)
		{
			var bytes = new byte[length];
			for (int i = 0; i < @string.Length; i++)
				bytes[i] = (byte)@string[i];

			return bytes;
		}

		public void WriteMetadata()
		{
			WriteHeap(TextSegment.TableHeap, metadata.table_heap);
			WriteHeap(TextSegment.StringHeap, metadata.string_heap);
			WriteHeap(TextSegment.UserStringHeap, metadata.user_string_heap);
			WriteHeap(TextSegment.GuidHeap, metadata.guid_heap);
			WriteHeap(TextSegment.BlobHeap, metadata.blob_heap);
			WriteHeap(TextSegment.PdbHeap, metadata.pdb_heap);
		}

		void WriteHeap(TextSegment heap, HeapBuffer buffer)
		{
			if (buffer == null || buffer.IsEmpty)
				return;

			MoveToRVA(heap);
			WriteBuffer(buffer);
		}

		void WriteDebugDirectory()
		{
			var data_start = (int)BaseStream.Position + (debug_header.Entries.Length * ImageDebugDirectory.Size);

			for (var i = 0; i < debug_header.Entries.Length; i++)
			{
				var entry = debug_header.Entries[i];
				var directory = entry.Directory;
				WriteInt32(directory.Characteristics);
				WriteInt32(directory.TimeDateStamp);
				WriteInt16(directory.MajorVersion);
				WriteInt16(directory.MinorVersion);
				WriteInt32((int)directory.Type);
				WriteInt32(directory.SizeOfData);
				WriteInt32(directory.AddressOfRawData);
				WriteInt32(data_start);

				data_start += entry.Data.Length;
			}

			for (var i = 0; i < debug_header.Entries.Length; i++)
			{
				var entry = debug_header.Entries[i];
				WriteBytes(entry.Data);
			}
		}

		void WriteImportDirectory()
		{
			WriteUInt32(text_map.GetRVA(TextSegment.ImportDirectory) + 40); // ImportLookupTable
			WriteUInt32(0); // DateTimeStamp
			WriteUInt32(0); // ForwarderChain
			WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable) + 14);
			WriteUInt32(text_map.GetRVA(TextSegment.ImportAddressTable));
			Advance(20);

			// ImportLookupTable
			WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable));

			// ImportHintNameTable
			MoveToRVA(TextSegment.ImportHintNameTable);

			WriteUInt16(0); // Hint
			WriteBytes(GetRuntimeMain());
			WriteByte(0);
			WriteBytes(GetSimpleString("mscoree.dll"));
			WriteUInt16(0);
		}

		byte[] GetRuntimeMain()
		{
			return module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule
				? GetSimpleString("_CorDllMain")
				: GetSimpleString("_CorExeMain");
		}

		void WriteStartupStub()
		{
			switch (module.Architecture)
			{
				case TargetArchitecture.I386:
					WriteUInt16(0x25ff);
					WriteUInt32((uint)image_base + text_map.GetRVA(TextSegment.ImportAddressTable));
					return;
				default:
					throw new NotSupportedException();
			}
		}

		void WriteRsrc()
		{
			PrepareSection(rsrc);
			WriteBuffer(win32_resources);
		}

		void WriteReloc()
		{
			PrepareSection(reloc);

			var reloc_rva = text_map.GetRVA(TextSegment.StartupStub);
			reloc_rva += module.Architecture == TargetArchitecture.IA64 ? 0x20u : 2;
			var page_rva = reloc_rva & ~0xfffu;

			WriteUInt32(page_rva);  // PageRVA
			WriteUInt32(0x000c);    // Block Size

			switch (module.Architecture)
			{
				case TargetArchitecture.I386:
					WriteUInt32(0x3000 + reloc_rva - page_rva);
					break;
				default:
					throw new NotSupportedException();
			}
		}

		public void WriteImage()
		{
			WriteDOSHeader();
			WritePEFileHeader();
			WriteOptionalHeaders();
			WriteSectionHeaders();
			WriteText();
			if (rsrc != null)
				WriteRsrc();
			if (reloc != null)
				WriteReloc();
			Flush();
		}

		void BuildTextMap()
		{
			var map = text_map;

			map.AddMap(TextSegment.Code, metadata.code.length, !pe64 ? 4 : 16);
			map.AddMap(TextSegment.Resources, metadata.resources.length, 8);
			map.AddMap(TextSegment.Data, metadata.data.length, 4);
			if (metadata.data.length > 0)
				metadata.table_heap.FixupData(map.GetRVA(TextSegment.Data));
			map.AddMap(TextSegment.StrongNameSignature, GetStrongNameLength(), 4);

			BuildMetadataTextMap();

			int debug_dir_len = 0;
			if (debug_header != null && debug_header.HasEntries)
			{
				var directories_len = debug_header.Entries.Length * ImageDebugDirectory.Size;
				var data_address = (int)map.GetNextRVA(TextSegment.BlobHeap) + directories_len;
				var data_len = 0;

				for (var i = 0; i < debug_header.Entries.Length; i++)
				{
					var entry = debug_header.Entries[i];
					var directory = entry.Directory;

					directory.AddressOfRawData = entry.Data.Length == 0 ? 0 : data_address;
					entry.Directory = directory;

					data_len += entry.Data.Length;
					data_address += data_len;
				}

				debug_dir_len = directories_len + data_len;
			}

			map.AddMap(TextSegment.DebugDirectory, debug_dir_len, 4);

			if (!has_reloc)
			{
				var start = map.GetNextRVA(TextSegment.DebugDirectory);
				map.AddMap(TextSegment.ImportDirectory, new Range(start, 0));
				map.AddMap(TextSegment.ImportHintNameTable, new Range(start, 0));
				map.AddMap(TextSegment.StartupStub, new Range(start, 0));
				return;
			}

			RVA import_dir_rva = map.GetNextRVA(TextSegment.DebugDirectory);
			RVA import_hnt_rva = import_dir_rva + 48u;
			import_hnt_rva = (import_hnt_rva + 15u) & ~15u;
			uint import_dir_len = (import_hnt_rva - import_dir_rva) + 27u;

			RVA startup_stub_rva = import_dir_rva + import_dir_len;
			startup_stub_rva = module.Architecture == TargetArchitecture.IA64
				? (startup_stub_rva + 15u) & ~15u
				: 2 + ((startup_stub_rva + 3u) & ~3u);

			map.AddMap(TextSegment.ImportDirectory, new Range(import_dir_rva, import_dir_len));
			map.AddMap(TextSegment.ImportHintNameTable, new Range(import_hnt_rva, 0));
			map.AddMap(TextSegment.StartupStub, new Range(startup_stub_rva, GetStartupStubLength()));
		}

		public void BuildMetadataTextMap()
		{
			var map = text_map;

			map.AddMap(TextSegment.MetadataHeader, GetMetadataHeaderLength(module.RuntimeVersion));
			map.AddMap(TextSegment.TableHeap, metadata.table_heap.length, 4);
			map.AddMap(TextSegment.StringHeap, metadata.string_heap.length, 4);
			map.AddMap(TextSegment.UserStringHeap, metadata.user_string_heap.IsEmpty ? 0 : metadata.user_string_heap.length, 4);
			map.AddMap(TextSegment.GuidHeap, metadata.guid_heap.length, 4);
			map.AddMap(TextSegment.BlobHeap, metadata.blob_heap.IsEmpty ? 0 : metadata.blob_heap.length, 4);
			map.AddMap(TextSegment.PdbHeap, metadata.pdb_heap == null ? 0 : metadata.pdb_heap.length, 4);
		}

		uint GetStartupStubLength()
		{
			switch (module.Architecture)
			{
				case TargetArchitecture.I386:
					return 6;
				default:
					throw new NotSupportedException();
			}
		}

		int GetMetadataHeaderLength(string runtimeVersion)
		{
			return
				// MetadataHeader
				20 + GetZeroTerminatedStringLength(runtimeVersion)
				// #~ header
				+ 12
				// #Strings header
				+ 20
				// #US header
				+ (metadata.user_string_heap.IsEmpty ? 0 : 12)
				// #GUID header
				+ 16
				// #Blob header
				+ (metadata.blob_heap.IsEmpty ? 0 : 16)
				//
				+ (metadata.pdb_heap == null ? 0 : 16);
		}

		int GetStrongNameLength()
		{
			if (module.kind == ModuleKind.NetModule || module.Assembly == null)
				return 0;

			var public_key = module.Assembly.Name.PublicKey;
			if (public_key.IsNullOrEmpty())
				return 0;

			// in fx 2.0 the key may be from 384 to 16384 bits
			// so we must calculate the signature size based on
			// the size of the public key (minus the 32 byte header)
			int size = public_key.Length;
			if (size > 32)
				return size - 32;

			// note: size == 16 for the ECMA "key" which is replaced
			// by the runtime with a 1024 bits key (128 bytes)

			return 128; // default strongname signature size
		}

		public DataDirectory GetStrongNameSignatureDirectory()
		{
			return text_map.GetDataDirectory(TextSegment.StrongNameSignature);
		}

		public uint GetHeaderSize()
		{
			return pe_header_size + SizeOfOptionalHeader() + (sections * section_header_size);
		}

		void PatchWin32Resources(ByteBuffer resources)
		{
			PatchResourceDirectoryTable(resources);
		}

		void PatchResourceDirectoryTable(ByteBuffer resources)
		{
			resources.Advance(12);

			var entries = resources.ReadUInt16() + resources.ReadUInt16();

			for (int i = 0; i < entries; i++)
				PatchResourceDirectoryEntry(resources);
		}

		void PatchResourceDirectoryEntry(ByteBuffer resources)
		{
			resources.Advance(4);
			var child = resources.ReadUInt32();

			var position = resources.position;
			resources.position = (int)child & 0x7fffffff;

			if ((child & 0x80000000) != 0)
				PatchResourceDirectoryTable(resources);
			else
				PatchResourceDataEntry(resources);

			resources.position = position;
		}

		void PatchResourceDataEntry(ByteBuffer resources)
		{
			var rva = resources.ReadUInt32();
			resources.position -= 4;

			resources.WriteUInt32(rva - module.Image.Win32Resources.VirtualAddress + rsrc.VirtualAddress);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public interface IMarshalInfoProvider : IMetadataTokenProvider
	{

		bool HasMarshalInfo { get; }
		MarshalInfo MarshalInfo { get; set; }
	}

	static partial class Mixin
	{

		public static bool GetHasMarshalInfo(
			this IMarshalInfoProvider self,
			ModuleDefinition module)
		{
			return module.HasImage() && module.Read(self, (provider, reader) => reader.HasMarshalInfo(provider));
		}

		public static MarshalInfo GetMarshalInfo(
			this IMarshalInfoProvider self,
			ref MarshalInfo variable,
			ModuleDefinition module)
		{
			return module.HasImage()
				? module.Read(ref variable, self, (provider, reader) => reader.ReadMarshalInfo(provider))
				: null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public interface IMemberDefinition : ICustomAttributeProvider
	{

		string Name { get; set; }
		string FullName { get; }

		bool IsSpecialName { get; set; }
		bool IsRuntimeSpecialName { get; set; }

		TypeDefinition DeclaringType { get; set; }
	}

	static partial class Mixin
	{

		public static bool GetAttributes(this uint self, uint attributes)
		{
			return (self & attributes) != 0;
		}

		public static uint SetAttributes(this uint self, uint attributes, bool value)
		{
			if (value)
				return self | attributes;

			return self & ~attributes;
		}

		public static bool GetMaskedAttributes(this uint self, uint mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static uint SetMaskedAttributes(this uint self, uint mask, uint attributes, bool value)
		{
			if (value)
			{
				self &= ~mask;
				return self | attributes;
			}

			return self & ~(mask & attributes);
		}

		public static bool GetAttributes(this ushort self, ushort attributes)
		{
			return (self & attributes) != 0;
		}

		public static ushort SetAttributes(this ushort self, ushort attributes, bool value)
		{
			if (value)
				return (ushort)(self | attributes);

			return (ushort)(self & ~attributes);
		}

		public static bool GetMaskedAttributes(this ushort self, ushort mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static ushort SetMaskedAttributes(this ushort self, ushort mask, uint attributes, bool value)
		{
			if (value)
			{
				self = (ushort)(self & ~mask);
				return (ushort)(self | attributes);
			}

			return (ushort)(self & ~(mask & attributes));
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum MetadataScopeType
	{
		AssemblyNameReference,
		ModuleReference,
		ModuleDefinition,
	}

	public interface IMetadataScope : IMetadataTokenProvider
	{
		MetadataScopeType MetadataScopeType { get; }
		string Name { get; set; }
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public interface IMetadataTokenProvider
	{

		MetadataToken MetadataToken { get; set; }
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public interface IMethodSignature : IMetadataTokenProvider
	{

		bool HasThis { get; set; }
		bool ExplicitThis { get; set; }
		MethodCallingConvention CallingConvention { get; set; }

		bool HasParameters { get; }
		Collection<ParameterDefinition> Parameters { get; }
		TypeReference ReturnType { get; set; }
		MethodReturnType MethodReturnType { get; }
	}

	static partial class Mixin
	{

		public static bool HasImplicitThis(this IMethodSignature self)
		{
			return self.HasThis && !self.ExplicitThis;
		}

		public static void MethodSignatureFullName(this IMethodSignature self, StringBuilder builder)
		{
			builder.Append("(");

			if (self.HasParameters)
			{
				var parameters = self.Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					var parameter = parameters[i];
					if (i > 0)
						builder.Append(",");

					if (parameter.ParameterType.IsSentinel)
						builder.Append("...,");

					builder.Append(parameter.ParameterType.FullName);
				}
			}

			builder.Append(")");
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//








namespace Mono.Cecil
{

	public interface IMetadataImporterProvider
	{
		IMetadataImporter GetMetadataImporter(ModuleDefinition module);
	}

	public interface IMetadataImporter
	{
		AssemblyNameReference ImportReference(AssemblyNameReference reference);
		TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
		FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
		MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
	}

	public interface IReflectionImporterProvider
	{
		IReflectionImporter GetReflectionImporter(ModuleDefinition module);
	}

	public interface IReflectionImporter
	{
		AssemblyNameReference ImportReference(SR.AssemblyName reference);
		TypeReference ImportReference(Type type, IGenericParameterProvider context);
		FieldReference ImportReference(SR.FieldInfo field, IGenericParameterProvider context);
		MethodReference ImportReference(SR.MethodBase method, IGenericParameterProvider context);
	}

	struct ImportGenericContext
	{

		Collection<IGenericParameterProvider> stack;

		public bool IsEmpty { get { return stack == null; } }

		public ImportGenericContext(IGenericParameterProvider provider)
		{
			if (provider == null)
				throw new ArgumentNullException("provider");

			stack = null;

			Push(provider);
		}

		public void Push(IGenericParameterProvider provider)
		{
			if (stack == null)
				stack = new Collection<IGenericParameterProvider>(1) { provider };
			else
				stack.Add(provider);
		}

		public void Pop()
		{
			stack.RemoveAt(stack.Count - 1);
		}

		public TypeReference MethodParameter(string method, int position)
		{
			for (int i = stack.Count - 1; i >= 0; i--)
			{
				var candidate = stack[i] as MethodReference;
				if (candidate == null)
					continue;

				if (method != NormalizeMethodName(candidate))
					continue;

				return candidate.GenericParameters[position];
			}

			throw new InvalidOperationException();
		}

		public string NormalizeMethodName(MethodReference method)
		{
			return method.DeclaringType.GetElementType().FullName + "." + method.Name;
		}

		public TypeReference TypeParameter(string type, int position)
		{
			for (int i = stack.Count - 1; i >= 0; i--)
			{
				var candidate = GenericTypeFor(stack[i]);

				if (candidate.FullName != type)
					continue;

				return candidate.GenericParameters[position];
			}

			throw new InvalidOperationException();
		}

		static TypeReference GenericTypeFor(IGenericParameterProvider context)
		{
			var type = context as TypeReference;
			if (type != null)
				return type.GetElementType();

			var method = context as MethodReference;
			if (method != null)
				return method.DeclaringType.GetElementType();

			throw new InvalidOperationException();
		}

		public static ImportGenericContext For(IGenericParameterProvider context)
		{
			return context != null ? new ImportGenericContext(context) : default(ImportGenericContext);
		}
	}

	public class DefaultReflectionImporter : IReflectionImporter
	{

		readonly protected ModuleDefinition module;

		public DefaultReflectionImporter(ModuleDefinition module)
		{
			Mixin.CheckModule(module);

			this.module = module;
		}

		enum ImportGenericKind
		{
			Definition,
			Open,
		}

		static readonly Dictionary<Type, ElementType> type_etype_mapping = new Dictionary<Type, ElementType>(18) {
			{ typeof (void), ElementType.Void },
			{ typeof (bool), ElementType.Boolean },
			{ typeof (char), ElementType.Char },
			{ typeof (sbyte), ElementType.I1 },
			{ typeof (byte), ElementType.U1 },
			{ typeof (short), ElementType.I2 },
			{ typeof (ushort), ElementType.U2 },
			{ typeof (int), ElementType.I4 },
			{ typeof (uint), ElementType.U4 },
			{ typeof (long), ElementType.I8 },
			{ typeof (ulong), ElementType.U8 },
			{ typeof (float), ElementType.R4 },
			{ typeof (double), ElementType.R8 },
			{ typeof (string), ElementType.String },
			{ typeof (TypedReference), ElementType.TypedByRef },
			{ typeof (IntPtr), ElementType.I },
			{ typeof (UIntPtr), ElementType.U },
			{ typeof (object), ElementType.Object },
		};

		TypeReference ImportType(Type type, ImportGenericContext context)
		{
			return ImportType(type, context, ImportGenericKind.Open);
		}

		TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsTypeSpecification(type) || ImportOpenGenericType(type, import_kind))
				return ImportTypeSpecification(type, context);

			var reference = new TypeReference(
				string.Empty,
				type.Name,
				module,
				ImportScope(type),
				type.IsValueType);

			reference.etype = ImportElementType(type);

			if (IsNestedType(type))
				reference.DeclaringType = ImportType(type.DeclaringType, context, import_kind);
			else
				reference.Namespace = type.Namespace ?? string.Empty;

			if (type.IsGenericType)
				ImportGenericParameters(reference, type.GetGenericArguments());

			return reference;
		}

		protected virtual IMetadataScope ImportScope(Type type)
		{
			return ImportScope(type.Assembly);
		}

		static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
		{
			return type.IsGenericType && type.IsGenericTypeDefinition && import_kind == ImportGenericKind.Open;
		}

		static bool ImportOpenGenericMethod(SR.MethodBase method, ImportGenericKind import_kind)
		{
			return method.IsGenericMethod && method.IsGenericMethodDefinition && import_kind == ImportGenericKind.Open;
		}

		static bool IsNestedType(Type type)
		{
			return type.IsNested;
		}

		TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
		{
			if (type.IsByRef)
				return new ByReferenceType(ImportType(type.GetElementType(), context));

			if (type.IsPointer)
				return new PointerType(ImportType(type.GetElementType(), context));

			if (type.IsArray)
				return new ArrayType(ImportType(type.GetElementType(), context), type.GetArrayRank());

			if (type.IsGenericType)
				return ImportGenericInstance(type, context);

			if (type.IsGenericParameter)
				return ImportGenericParameter(type, context);

			throw new NotSupportedException(type.FullName);
		}

		static TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
		{
			if (context.IsEmpty)
				throw new InvalidOperationException();

			if (type.DeclaringMethod != null)
				return context.MethodParameter(NormalizeMethodName(type.DeclaringMethod), type.GenericParameterPosition);

			if (type.DeclaringType != null)
				return context.TypeParameter(NormalizeTypeFullName(type.DeclaringType), type.GenericParameterPosition);

			throw new InvalidOperationException();
		}

		static string NormalizeMethodName(SR.MethodBase method)
		{
			return NormalizeTypeFullName(method.DeclaringType) + "." + method.Name;
		}

		static string NormalizeTypeFullName(Type type)
		{
			if (IsNestedType(type))
				return NormalizeTypeFullName(type.DeclaringType) + "/" + type.Name;

			return type.FullName;
		}

		TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
		{
			var element_type = ImportType(type.GetGenericTypeDefinition(), context, ImportGenericKind.Definition);
			var arguments = type.GetGenericArguments();
			var instance = new GenericInstanceType(element_type, arguments.Length);
			var instance_arguments = instance.GenericArguments;

			context.Push(element_type);
			try
			{
				for (int i = 0; i < arguments.Length; i++)
					instance_arguments.Add(ImportType(arguments[i], context));

				return instance;
			}
			finally
			{
				context.Pop();
			}
		}

		static bool IsTypeSpecification(Type type)
		{
			return type.HasElementType
				|| IsGenericInstance(type)
				|| type.IsGenericParameter;
		}

		static bool IsGenericInstance(Type type)
		{
			return type.IsGenericType && !type.IsGenericTypeDefinition;
		}

		static ElementType ImportElementType(Type type)
		{
			ElementType etype;
			if (!type_etype_mapping.TryGetValue(type, out etype))
				return ElementType.None;

			return etype;
		}

		protected AssemblyNameReference ImportScope(SR.Assembly assembly)
		{
			return ImportReference(assembly.GetName());
		}

		public virtual AssemblyNameReference ImportReference(SR.AssemblyName name)
		{
			Mixin.CheckName(name);

			AssemblyNameReference reference;
			if (TryGetAssemblyNameReference(name, out reference))
				return reference;

			reference = new AssemblyNameReference(name.Name, name.Version)
			{
				PublicKeyToken = name.GetPublicKeyToken(),
				Culture = name.CultureInfo.Name,
				HashAlgorithm = (AssemblyHashAlgorithm)name.HashAlgorithm,
			};

			module.AssemblyReferences.Add(reference);

			return reference;
		}

		bool TryGetAssemblyNameReference(SR.AssemblyName name, out AssemblyNameReference assembly_reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++)
			{
				var reference = references[i];
				if (name.FullName != reference.FullName) // TODO compare field by field
					continue;

				assembly_reference = reference;
				return true;
			}

			assembly_reference = null;
			return false;
		}

		FieldReference ImportField(SR.FieldInfo field, ImportGenericContext context)
		{
			var declaring_type = ImportType(field.DeclaringType, context);

			if (IsGenericInstance(field.DeclaringType))
				field = ResolveFieldDefinition(field);

			context.Push(declaring_type);
			try
			{
				return new FieldReference
				{
					Name = field.Name,
					DeclaringType = declaring_type,
					FieldType = ImportType(field.FieldType, context),
				};
			}
			finally
			{
				context.Pop();
			}
		}

		static SR.FieldInfo ResolveFieldDefinition(SR.FieldInfo field)
		{
			return field.Module.ResolveField(field.MetadataToken);
		}

		static SR.MethodBase ResolveMethodDefinition(SR.MethodBase method)
		{
			return method.Module.ResolveMethod(method.MetadataToken);
		}

		MethodReference ImportMethod(SR.MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsMethodSpecification(method) || ImportOpenGenericMethod(method, import_kind))
				return ImportMethodSpecification(method, context);

			var declaring_type = ImportType(method.DeclaringType, context);

			if (IsGenericInstance(method.DeclaringType))
				method = ResolveMethodDefinition(method);

			var reference = new MethodReference
			{
				Name = method.Name,
				HasThis = HasCallingConvention(method, SR.CallingConventions.HasThis),
				ExplicitThis = HasCallingConvention(method, SR.CallingConventions.ExplicitThis),
				DeclaringType = ImportType(method.DeclaringType, context, ImportGenericKind.Definition),
			};

			if (HasCallingConvention(method, SR.CallingConventions.VarArgs))
				reference.CallingConvention &= MethodCallingConvention.VarArg;

			if (method.IsGenericMethod)
				ImportGenericParameters(reference, method.GetGenericArguments());

			context.Push(reference);
			try
			{
				var method_info = method as SR.MethodInfo;
				reference.ReturnType = method_info != null
					? ImportType(method_info.ReturnType, context)
					: ImportType(typeof(void), default(ImportGenericContext));

				var parameters = method.GetParameters();
				var reference_parameters = reference.Parameters;

				for (int i = 0; i < parameters.Length; i++)
					reference_parameters.Add(
						new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));

				reference.DeclaringType = declaring_type;

				return reference;
			}
			finally
			{
				context.Pop();
			}
		}

		static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
		{
			var provider_parameters = provider.GenericParameters;

			for (int i = 0; i < arguments.Length; i++)
				provider_parameters.Add(new GenericParameter(arguments[i].Name, provider));
		}

		static bool IsMethodSpecification(SR.MethodBase method)
		{
			return method.IsGenericMethod && !method.IsGenericMethodDefinition;
		}

		MethodReference ImportMethodSpecification(SR.MethodBase method, ImportGenericContext context)
		{
			var method_info = method as SR.MethodInfo;
			if (method_info == null)
				throw new InvalidOperationException();

			var element_method = ImportMethod(method_info.GetGenericMethodDefinition(), context, ImportGenericKind.Definition);
			var instance = new GenericInstanceMethod(element_method);
			var arguments = method.GetGenericArguments();
			var instance_arguments = instance.GenericArguments;

			context.Push(element_method);
			try
			{
				for (int i = 0; i < arguments.Length; i++)
					instance_arguments.Add(ImportType(arguments[i], context));

				return instance;
			}
			finally
			{
				context.Pop();
			}
		}

		static bool HasCallingConvention(SR.MethodBase method, SR.CallingConventions conventions)
		{
			return (method.CallingConvention & conventions) != 0;
		}

		public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context)
		{
			Mixin.CheckType(type);
			return ImportType(
				type,
				ImportGenericContext.For(context),
				context != null ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}

		public virtual FieldReference ImportReference(SR.FieldInfo field, IGenericParameterProvider context)
		{
			Mixin.CheckField(field);
			return ImportField(field, ImportGenericContext.For(context));
		}

		public virtual MethodReference ImportReference(SR.MethodBase method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod(method);
			return ImportMethod(method,
				ImportGenericContext.For(context),
				context != null ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}
	}

	public class DefaultMetadataImporter : IMetadataImporter
	{

		readonly protected ModuleDefinition module;

		public DefaultMetadataImporter(ModuleDefinition module)
		{
			Mixin.CheckModule(module);

			this.module = module;
		}

		TypeReference ImportType(TypeReference type, ImportGenericContext context)
		{
			if (type.IsTypeSpecification())
				return ImportTypeSpecification(type, context);

			var reference = new TypeReference(
				type.Namespace,
				type.Name,
				module,
				ImportScope(type),
				type.IsValueType);

			MetadataSystem.TryProcessPrimitiveTypeReference(reference);

			if (type.IsNested)
				reference.DeclaringType = ImportType(type.DeclaringType, context);

			if (type.HasGenericParameters)
				ImportGenericParameters(reference, type);

			return reference;
		}

		protected virtual IMetadataScope ImportScope(TypeReference type)
		{
			return ImportScope(type.Scope);
		}

		protected IMetadataScope ImportScope(IMetadataScope scope)
		{
			switch (scope.MetadataScopeType)
			{
				case MetadataScopeType.AssemblyNameReference:
					return ImportReference((AssemblyNameReference)scope);
				case MetadataScopeType.ModuleDefinition:
					if (scope == module) return scope;
					return ImportReference(((ModuleDefinition)scope).Assembly.Name);
				case MetadataScopeType.ModuleReference:
					throw new NotImplementedException();
			}

			throw new NotSupportedException();
		}

		public virtual AssemblyNameReference ImportReference(AssemblyNameReference name)
		{
			Mixin.CheckName(name);

			AssemblyNameReference reference;
			if (module.TryGetAssemblyNameReference(name, out reference))
				return reference;

			reference = new AssemblyNameReference(name.Name, name.Version)
			{
				Culture = name.Culture,
				HashAlgorithm = name.HashAlgorithm,
				IsRetargetable = name.IsRetargetable,
				IsWindowsRuntime = name.IsWindowsRuntime,
			};

			var pk_token = !name.PublicKeyToken.IsNullOrEmpty()
				? new byte[name.PublicKeyToken.Length]
				: Empty<byte>.Array;

			if (pk_token.Length > 0)
				Buffer.BlockCopy(name.PublicKeyToken, 0, pk_token, 0, pk_token.Length);

			reference.PublicKeyToken = pk_token;

			module.AssemblyReferences.Add(reference);

			return reference;
		}

		static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
		{
			var parameters = original.GenericParameters;
			var imported_parameters = imported.GenericParameters;

			for (int i = 0; i < parameters.Count; i++)
				imported_parameters.Add(new GenericParameter(parameters[i].Name, imported));
		}

		TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
		{
			switch (type.etype)
			{
				case ElementType.SzArray:
					var vector = (ArrayType)type;
					return new ArrayType(ImportType(vector.ElementType, context));
				case ElementType.Ptr:
					var pointer = (PointerType)type;
					return new PointerType(ImportType(pointer.ElementType, context));
				case ElementType.ByRef:
					var byref = (ByReferenceType)type;
					return new ByReferenceType(ImportType(byref.ElementType, context));
				case ElementType.Pinned:
					var pinned = (PinnedType)type;
					return new PinnedType(ImportType(pinned.ElementType, context));
				case ElementType.Sentinel:
					var sentinel = (SentinelType)type;
					return new SentinelType(ImportType(sentinel.ElementType, context));
				case ElementType.FnPtr:
					var fnptr = (FunctionPointerType)type;
					var imported_fnptr = new FunctionPointerType()
					{
						HasThis = fnptr.HasThis,
						ExplicitThis = fnptr.ExplicitThis,
						CallingConvention = fnptr.CallingConvention,
						ReturnType = ImportType(fnptr.ReturnType, context),
					};

					if (!fnptr.HasParameters)
						return imported_fnptr;

					for (int i = 0; i < fnptr.Parameters.Count; i++)
						imported_fnptr.Parameters.Add(new ParameterDefinition(
							ImportType(fnptr.Parameters[i].ParameterType, context)));

					return imported_fnptr;
				case ElementType.CModOpt:
					var modopt = (OptionalModifierType)type;
					return new OptionalModifierType(
						ImportType(modopt.ModifierType, context),
						ImportType(modopt.ElementType, context));
				case ElementType.CModReqD:
					var modreq = (RequiredModifierType)type;
					return new RequiredModifierType(
						ImportType(modreq.ModifierType, context),
						ImportType(modreq.ElementType, context));
				case ElementType.Array:
					var array = (ArrayType)type;
					var imported_array = new ArrayType(ImportType(array.ElementType, context));
					if (array.IsVector)
						return imported_array;

					var dimensions = array.Dimensions;
					var imported_dimensions = imported_array.Dimensions;

					imported_dimensions.Clear();

					for (int i = 0; i < dimensions.Count; i++)
					{
						var dimension = dimensions[i];

						imported_dimensions.Add(new ArrayDimension(dimension.LowerBound, dimension.UpperBound));
					}

					return imported_array;
				case ElementType.GenericInst:
					var instance = (GenericInstanceType)type;
					var element_type = ImportType(instance.ElementType, context);
					var arguments = instance.GenericArguments;
					var imported_instance = new GenericInstanceType(element_type, arguments.Count);
					var imported_arguments = imported_instance.GenericArguments;

					for (int i = 0; i < arguments.Count; i++)
						imported_arguments.Add(ImportType(arguments[i], context));

					return imported_instance;
				case ElementType.Var:
					var var_parameter = (GenericParameter)type;
					if (var_parameter.DeclaringType == null)
						throw new InvalidOperationException();
					return context.TypeParameter(var_parameter.DeclaringType.FullName, var_parameter.Position);
				case ElementType.MVar:
					var mvar_parameter = (GenericParameter)type;
					if (mvar_parameter.DeclaringMethod == null)
						throw new InvalidOperationException();
					return context.MethodParameter(context.NormalizeMethodName(mvar_parameter.DeclaringMethod), mvar_parameter.Position);
			}

			throw new NotSupportedException(type.etype.ToString());
		}

		FieldReference ImportField(FieldReference field, ImportGenericContext context)
		{
			var declaring_type = ImportType(field.DeclaringType, context);

			context.Push(declaring_type);
			try
			{
				return new FieldReference
				{
					Name = field.Name,
					DeclaringType = declaring_type,
					FieldType = ImportType(field.FieldType, context),
				};
			}
			finally
			{
				context.Pop();
			}
		}

		MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
		{
			if (method.IsGenericInstance)
				return ImportMethodSpecification(method, context);

			var declaring_type = ImportType(method.DeclaringType, context);

			var reference = new MethodReference
			{
				Name = method.Name,
				HasThis = method.HasThis,
				ExplicitThis = method.ExplicitThis,
				DeclaringType = declaring_type,
				CallingConvention = method.CallingConvention,
			};

			if (method.HasGenericParameters)
				ImportGenericParameters(reference, method);

			context.Push(reference);
			try
			{
				reference.ReturnType = ImportType(method.ReturnType, context);

				if (!method.HasParameters)
					return reference;

				var parameters = method.Parameters;
				var reference_parameters = reference.parameters = new ParameterDefinitionCollection(reference, parameters.Count);
				for (int i = 0; i < parameters.Count; i++)
					reference_parameters.Add(
						new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));

				return reference;
			}
			finally
			{
				context.Pop();
			}
		}

		MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
		{
			if (!method.IsGenericInstance)
				throw new NotSupportedException();

			var instance = (GenericInstanceMethod)method;
			var element_method = ImportMethod(instance.ElementMethod, context);
			var imported_instance = new GenericInstanceMethod(element_method);

			var arguments = instance.GenericArguments;
			var imported_arguments = imported_instance.GenericArguments;

			for (int i = 0; i < arguments.Count; i++)
				imported_arguments.Add(ImportType(arguments[i], context));

			return imported_instance;
		}

		public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
		{
			Mixin.CheckType(type);
			return ImportType(type, ImportGenericContext.For(context));
		}

		public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
		{
			Mixin.CheckField(field);
			return ImportField(field, ImportGenericContext.For(context));
		}

		public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod(method);
			return ImportMethod(method, ImportGenericContext.For(context));
		}
	}

	static partial class Mixin
	{

		public static void CheckModule(ModuleDefinition module)
		{
			if (module == null)
				throw new ArgumentNullException(Argument.module.ToString());
		}

		public static bool TryGetAssemblyNameReference(this ModuleDefinition module, AssemblyNameReference name_reference, out AssemblyNameReference assembly_reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++)
			{
				var reference = references[i];
				if (!Equals(name_reference, reference))
					continue;

				assembly_reference = reference;
				return true;
			}

			assembly_reference = null;
			return false;
		}

		static bool Equals(byte[] a, byte[] b)
		{
			if (ReferenceEquals(a, b))
				return true;
			if (a == null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++)
				if (a[i] != b[i])
					return false;
			return true;
		}

		static bool Equals<T>(T a, T b) where T : class, IEquatable<T>
		{
			if (ReferenceEquals(a, b))
				return true;
			if (a == null)
				return false;
			return a.Equals(b);
		}

		static bool Equals(AssemblyNameReference a, AssemblyNameReference b)
		{
			if (ReferenceEquals(a, b))
				return true;
			if (a.Name != b.Name)
				return false;
			if (!Equals(a.Version, b.Version))
				return false;
			if (a.Culture != b.Culture)
				return false;
			if (!Equals(a.PublicKeyToken, b.PublicKeyToken))
				return false;
			return true;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.Cil
{

	public sealed class Instruction
	{

		internal int offset;
		internal OpCode opcode;
		internal object operand;

		internal Instruction previous;
		internal Instruction next;

		public int Offset
		{
			get { return offset; }
			set { offset = value; }
		}

		public OpCode OpCode
		{
			get { return opcode; }
			set { opcode = value; }
		}

		public object Operand
		{
			get { return operand; }
			set { operand = value; }
		}

		public Instruction Previous
		{
			get { return previous; }
			set { previous = value; }
		}

		public Instruction Next
		{
			get { return next; }
			set { next = value; }
		}

		internal Instruction(int offset, OpCode opCode)
		{
			this.offset = offset;
			this.opcode = opCode;
		}

		internal Instruction(OpCode opcode, object operand)
		{
			this.opcode = opcode;
			this.operand = operand;
		}

		public int GetSize()
		{
			int size = opcode.Size;

			switch (opcode.OperandType)
			{
				case OperandType.InlineSwitch:
					return size + (1 + ((Instruction[])operand).Length) * 4;
				case OperandType.InlineI8:
				case OperandType.InlineR:
					return size + 8;
				case OperandType.InlineBrTarget:
				case OperandType.InlineField:
				case OperandType.InlineI:
				case OperandType.InlineMethod:
				case OperandType.InlineString:
				case OperandType.InlineTok:
				case OperandType.InlineType:
				case OperandType.ShortInlineR:
				case OperandType.InlineSig:
					return size + 4;
				case OperandType.InlineArg:
				case OperandType.InlineVar:
					return size + 2;
				case OperandType.ShortInlineBrTarget:
				case OperandType.ShortInlineI:
				case OperandType.ShortInlineArg:
				case OperandType.ShortInlineVar:
					return size + 1;
				default:
					return size;
			}
		}

		public override string ToString()
		{
			var instruction = new StringBuilder();

			AppendLabel(instruction, this);
			instruction.Append(':');
			instruction.Append(' ');
			instruction.Append(opcode.Name);

			if (operand == null)
				return instruction.ToString();

			instruction.Append(' ');

			switch (opcode.OperandType)
			{
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					AppendLabel(instruction, (Instruction)operand);
					break;
				case OperandType.InlineSwitch:
					var labels = (Instruction[])operand;
					for (int i = 0; i < labels.Length; i++)
					{
						if (i > 0)
							instruction.Append(',');

						AppendLabel(instruction, labels[i]);
					}
					break;
				case OperandType.InlineString:
					instruction.Append('\"');
					instruction.Append(operand);
					instruction.Append('\"');
					break;
				default:
					instruction.Append(operand);
					break;
			}

			return instruction.ToString();
		}

		static void AppendLabel(StringBuilder builder, Instruction instruction)
		{
			builder.Append("IL_");
			builder.Append(instruction.offset.ToString("x4"));
		}

		public static Instruction Create(OpCode opcode)
		{
			if (opcode.OperandType != OperandType.InlineNone)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, null);
		}

		public static Instruction Create(OpCode opcode, TypeReference type)
		{
			if (type == null)
				throw new ArgumentNullException("type");
			if (opcode.OperandType != OperandType.InlineType &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, type);
		}

		public static Instruction Create(OpCode opcode, CallSite site)
		{
			if (site == null)
				throw new ArgumentNullException("site");
			if (opcode.Code != Code.Calli)
				throw new ArgumentException("code");

			return new Instruction(opcode, site);
		}

		public static Instruction Create(OpCode opcode, MethodReference method)
		{
			if (method == null)
				throw new ArgumentNullException("method");
			if (opcode.OperandType != OperandType.InlineMethod &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, method);
		}

		public static Instruction Create(OpCode opcode, FieldReference field)
		{
			if (field == null)
				throw new ArgumentNullException("field");
			if (opcode.OperandType != OperandType.InlineField &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, field);
		}

		public static Instruction Create(OpCode opcode, string value)
		{
			if (value == null)
				throw new ArgumentNullException("value");
			if (opcode.OperandType != OperandType.InlineString)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, sbyte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI &&
				opcode != OpCodes.Ldc_I4_S)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, byte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI ||
				opcode == OpCodes.Ldc_I4_S)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, int value)
		{
			if (opcode.OperandType != OperandType.InlineI)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, long value)
		{
			if (opcode.OperandType != OperandType.InlineI8)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, float value)
		{
			if (opcode.OperandType != OperandType.ShortInlineR)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, double value)
		{
			if (opcode.OperandType != OperandType.InlineR)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, Instruction target)
		{
			if (target == null)
				throw new ArgumentNullException("target");
			if (opcode.OperandType != OperandType.InlineBrTarget &&
				opcode.OperandType != OperandType.ShortInlineBrTarget)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, target);
		}

		public static Instruction Create(OpCode opcode, Instruction[] targets)
		{
			if (targets == null)
				throw new ArgumentNullException("targets");
			if (opcode.OperandType != OperandType.InlineSwitch)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, targets);
		}

		public static Instruction Create(OpCode opcode, VariableDefinition variable)
		{
			if (variable == null)
				throw new ArgumentNullException("variable");
			if (opcode.OperandType != OperandType.ShortInlineVar &&
				opcode.OperandType != OperandType.InlineVar)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, variable);
		}

		public static Instruction Create(OpCode opcode, ParameterDefinition parameter)
		{
			if (parameter == null)
				throw new ArgumentNullException("parameter");
			if (opcode.OperandType != OperandType.ShortInlineArg &&
				opcode.OperandType != OperandType.InlineArg)
				throw new ArgumentException("opcode");

			return new Instruction(opcode, parameter);
		}
	}
}



namespace Microsoft.Cci.Pdb
{

	/// <summary>
	/// A range of CLR IL operations that comprise a lexical scope, specified as an IL offset and a length.
	/// </summary>
	interface ILocalScope
	{
		/// <summary>
		/// The offset of the first operation in the scope.
		/// </summary>
		uint Offset { get; }

		/// <summary>
		/// The length of the scope. Offset+Length equals the offset of the first operation outside the scope, or equals the method body length.
		/// </summary>
		uint Length { get; }
	}

	/// <summary>
	/// A description of the lexical scope in which a namespace type has been nested. This scope is tied to a particular
	/// method body, so that partial types can be accommodated.
	/// </summary>
	interface INamespaceScope
	{

		/// <summary>
		/// Zero or more used namespaces. These correspond to using clauses in C#.
		/// </summary>
		IEnumerable<IUsedNamespace> UsedNamespaces { get; }

	}


	/// <summary>
	/// A namespace that is used (imported) inside a namespace scope.
	/// </summary>
	interface IUsedNamespace
	{
		/// <summary>
		/// An alias for a namespace. For example the "x" of "" in C#. Empty if no alias is present.
		/// </summary>
		IName Alias { get; }

		/// <summary>
		/// The name of a namepace that has been aliased.  For example the "y.z" of "" or "using y.z" in C#.
		/// </summary>
		IName NamespaceName { get; }
	}

	/// <summary>
	/// The name of an entity. Typically name instances come from a common pool. Within the pool no two distinct instances will have the same Value or UniqueKey.
	/// </summary>
	interface IName
	{
		/// <summary>
		/// An integer that is unique within the pool from which the name instance has been allocated. Useful as a hashtable key.
		/// </summary>
		int UniqueKey
		{
			get;
			//^ ensures result > 0;
		}

		/// <summary>
		/// An integer that is unique within the pool from which the name instance has been allocated. Useful as a hashtable key.
		/// All name instances in the pool that have the same string value when ignoring the case of the characters in the string
		/// will have the same key value.
		/// </summary>
		int UniqueKeyIgnoringCase
		{
			get;
			//^ ensures result > 0;
		}

		/// <summary>
		/// The string value corresponding to this name.
		/// </summary>
		string Value { get; }
	}
}// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	// The IntHashTable class represents a dictionary of associated keys and
	// values with constant lookup time.
	//
	// Objects used as keys in a hashtable must implement the GetHashCode
	// and Equals methods (or they can rely on the default implementations
	// inherited from Object if key equality is simply reference
	// equality). Furthermore, the GetHashCode and Equals methods of
	// a key object must produce the same results given the same parameters
	// for the entire time the key is present in the hashtable. In practical
	// terms, this means that key objects should be immutable, at least for
	// the time they are used as keys in a hashtable.
	//
	// When entries are added to a hashtable, they are placed into
	// buckets based on the hashcode of their keys. Subsequent lookups of
	// keys will use the hashcode of the keys to only search a particular
	// bucket, thus substantially reducing the number of key comparisons
	// required to find an entry. A hashtable's maximum load factor, which
	// can be specified when the hashtable is instantiated, determines the
	// maximum ratio of hashtable entries to hashtable buckets. Smaller load
	// factors cause faster average lookup times at the cost of increased
	// memory consumption. The default maximum load factor of 1.0 generally
	// provides the best balance between speed and size. As entries are added
	// to a hashtable, the hashtable's actual load factor increases, and when
	// the actual load factor reaches the maximum load factor value, the
	// number of buckets in the hashtable is automatically increased by
	// approximately a factor of two (to be precise, the number of hashtable
	// buckets is increased to the smallest prime number that is larger than
	// twice the current number of hashtable buckets).
	//
	// Each object provides their own hash function, accessed by calling
	// GetHashCode().  However, one can write their own object
	// implementing IHashCodeProvider and pass it to a constructor on
	// the IntHashTable.  That hash function would be used for all objects in
	// the table.
	//
	// This IntHashTable is implemented to support multiple concurrent readers
	// and one concurrent writer without using any synchronization primitives.
	// All read methods essentially must protect themselves from a resize
	// occuring while they are running.  This was done by enforcing an
	// ordering on inserts & removes, as well as removing some member variables
	// and special casing the expand code to work in a temporary array instead
	// of the live bucket array.  All inserts must set a bucket's value and
	// key before setting the hash code & collision field.
	//
	// By Brian Grunkemeyer, algorithm by Patrick Dussud.
	// Version 1.30 2/20/2000
	//| <include path='docs/doc[@for="IntHashTable"]/*' />
	internal class IntHashTable
	{//: IEnumerable {
		/*
		  Implementation Notes:

		  This IntHashTable uses double hashing.  There are hashsize buckets in
		  the table, and each bucket can contain 0 or 1 element.  We a bit to
		  mark whether there's been a collision when we inserted multiple
		  elements (ie, an inserted item was hashed at least a second time and
		  we probed this bucket, but it was already in use).  Using the
		  collision bit, we can terminate lookups & removes for elements that
		  aren't in the hash table more quickly.  We steal the most
		  significant bit from the hash code to store the collision bit.

		  Our hash function is of the following form:

		  h(key, n) = h1(key) + n*h2(key)

		  where n is the number of times we've hit a collided bucket and
		  rehashed (on this particular lookup).  Here are our hash functions:

		  h1(key) = GetHash(key);  // default implementation calls key.GetHashCode();
		  h2(key) = 1 + (((h1(key) >> 5) + 1) % (hashsize - 1));

		  The h1 can return any number.  h2 must return a number between 1 and
		  hashsize - 1 that is relatively prime to hashsize (not a problem if
		  hashsize is prime).  (Knuth's Art of Computer Programming, Vol. 3,
		  p. 528-9)

		  If this is true, then we are guaranteed to visit every bucket in
		  exactly hashsize probes, since the least common multiple of hashsize
		  and h2(key) will be hashsize * h2(key).  (This is the first number
		  where adding h2 to h1 mod hashsize will be 0 and we will search the
		  same bucket twice).

		  We previously used a different h2(key, n) that was not constant.
		  That is a horrifically bad idea, unless you can prove that series
		  will never produce any identical numbers that overlap when you mod
		  them by hashsize, for all subranges from i to i+hashsize, for all i.
		  It's not worth investigating, since there was no clear benefit from
		  using that hash function, and it was broken.

		  For efficiency reasons, we've implemented this by storing h1 and h2
		  in a temporary, and setting a variable called seed equal to h1.  We
		  do a probe, and if we collided, we simply add h2 to seed each time
		  through the loop.

		  A good test for h2() is to subclass IntHashTable, provide your own
		  implementation of GetHash() that returns a constant, then add many
		  items to the hash table.  Make sure Count equals the number of items
		  you inserted.

		  -- Brian Grunkemeyer, 10/28/1999
		*/

		// A typical resize algorithm would pick the smallest prime number in this array
		// that is larger than twice the previous capacity. 
		// Suppose our Hashtable currently has capacity x and enough elements are added 
		// such that a resize needs to occur. Resizing first computes 2x then finds the 
		// first prime in the table greater than 2x, i.e. if primes are ordered 
		// p_1, p_2, , p_i,, it finds p_n such that p_n-1 < 2x < p_n. 
		// Doubling is important for preserving the asymptotic complexity of the 
		// hashtable operations such as add.  Having a prime guarantees that double 
		// hashing does not lead to infinite loops.  IE, your hash function will be 
		// h1(key) + i*h2(key), 0 <= i < size.  h2 and the size must be relatively prime.
		private static readonly int[] primes = {
			3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
			1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,
			17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,
			187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,
			1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369};

		private static int GetPrime(int minSize)
		{
			if (minSize < 0)
			{
				throw new ArgumentException("Arg_HTCapacityOverflow");
			}
			for (int i = 0; i < primes.Length; i++)
			{
				int size = primes[i];
				if (size >= minSize)
				{
					return size;
				}
			}
			throw new ArgumentException("Arg_HTCapacityOverflow");
		}

		// Deleted entries have their key set to buckets

		// The hash table data.
		// This cannot be serialised
		private struct bucket
		{
			internal int key;
			internal int hash_coll;   // Store hash code; sign bit means there was a collision.
			internal Object val;
		}

		private bucket[] buckets;

		// The total number of entries in the hash table.
		private int count;

		// The total number of collision bits set in the hashtable
		private int occupancy;

		private int loadsize;
		private int loadFactorPerc;    // 100 = 1.0

		private int version;

		// Constructs a new hashtable. The hashtable is created with an initial
		// capacity of zero and a load factor of 1.0.
		//| <include path='docs/doc[@for="IntHashTable.IntHashTable"]/*' />
		internal IntHashTable()
		  : this(0, 100)
		{
		}

		//// Constructs a new hashtable with the given initial capacity and a load
		//// factor of 1.0. The capacity argument serves as an indication of
		//// the number of entries the hashtable will contain. When this number (or
		//// an approximation) is known, specifying it in the constructor can
		//// eliminate a number of resizing operations that would otherwise be
		//// performed when elements are added to the hashtable.
		////
		////| <include path='docs/doc[@for="IntHashTable.IntHashTable1"]/*' />
		//internal IntHashTable(int capacity)
		//  : this(capacity, 100) {
		//}

		// Constructs a new hashtable with the given initial capacity and load
		// factor. The capacity argument serves as an indication of the
		// number of entries the hashtable will contain. When this number (or an
		// approximation) is known, specifying it in the constructor can eliminate
		// a number of resizing operations that would otherwise be performed when
		// elements are added to the hashtable. The loadFactorPerc argument
		// indicates the maximum ratio of hashtable entries to hashtable buckets.
		// Smaller load factors cause faster average lookup times at the cost of
		// increased memory consumption. A load factor of 1.0 generally provides
		// the best balance between speed and size.
		//
		//| <include path='docs/doc[@for="IntHashTable.IntHashTable3"]/*' />
		internal IntHashTable(int capacity, int loadFactorPerc)
		{
			if (capacity < 0)
				throw new ArgumentOutOfRangeException("capacity", "ArgumentOutOfRange_NeedNonNegNum");
			if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))
				throw new ArgumentOutOfRangeException("loadFactorPerc", String.Format("ArgumentOutOfRange_IntHashTableLoadFactor", 10, 100));

			// Based on perf work, .72 is the optimal load factor for this table.
			this.loadFactorPerc = (loadFactorPerc * 72) / 100;

			int hashsize = GetPrime((int)(capacity / this.loadFactorPerc));
			buckets = new bucket[hashsize];

			loadsize = (int)(this.loadFactorPerc * hashsize) / 100;
			if (loadsize >= hashsize)
				loadsize = hashsize - 1;
		}

		// Computes the hash function:  H(key, i) = h1(key) + i*h2(key, hashSize).
		// The out parameter seed is h1(key), while the out parameter
		// incr is h2(key, hashSize).  Callers of this function should
		// add incr each time through a loop.
		private static uint InitHash(int key, int hashsize, out uint seed, out uint incr)
		{
			// Hashcode must be positive.  Also, we must not use the sign bit, since
			// that is used for the collision bit.
			uint hashcode = (uint)key & 0x7FFFFFFF;
			seed = (uint)hashcode;
			// Restriction: incr MUST be between 1 and hashsize - 1, inclusive for
			// the modular arithmetic to work correctly.  This guarantees you'll
			// visit every bucket in the table exactly once within hashsize
			// iterations.  Violate this and it'll cause obscure bugs forever.
			// If you change this calculation for h2(key), update putEntry too!
			incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
			return hashcode;
		}

		// Adds an entry with the given key and value to this hashtable. An
		// ArgumentException is thrown if the key is null or if the key is already
		// present in the hashtable.
		//
		//| <include path='docs/doc[@for="IntHashTable.Add"]/*' />
		internal void Add(int key, Object value)
		{
			Insert(key, value, true);
		}

		//// Removes all entries from this hashtable.
		////| <include path='docs/doc[@for="IntHashTable.Clear"]/*' />
		//internal void Clear() {
		//  if (count == 0)
		//    return;

		//  for (int i = 0; i < buckets.Length; i++) {
		//    buckets[i].hash_coll = 0;
		//    buckets[i].key = -1;
		//    buckets[i].val = null;
		//  }

		//  count = 0;
		//  occupancy = 0;
		//}

		// Checks if this hashtable contains an entry with the given key.  This is
		// an O(1) operation.
		//
		//| <include path='docs/doc[@for="IntHashTable.Contains"]/*' />
		//internal bool Contains(int key) {
		//  if (key < 0) {
		//    throw new ArgumentException("Argument_KeyLessThanZero");
		//  }

		//  uint seed;
		//  uint incr;
		//  // Take a snapshot of buckets, in case another thread resizes table
		//  bucket[] lbuckets = buckets;
		//  uint hashcode = InitHash(key, lbuckets.Length, out seed, out incr);
		//  int ntry = 0;

		//  bucket b;
		//  do {
		//    int bucketNumber = (int)(seed % (uint)lbuckets.Length);
		//    b = lbuckets[bucketNumber];
		//    if (b.val == null) {
		//      return false;
		//    }
		//    if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && b.key == key) {
		//      return true;
		//    }
		//    seed += incr;
		//  } while (b.hash_coll < 0 && ++ntry < lbuckets.Length);
		//  return false;
		//}

		// Returns the value associated with the given key. If an entry with the
		// given key is not found, the returned value is null.
		//
		//| <include path='docs/doc[@for="IntHashTable.this"]/*' />
		internal Object this[int key]
		{
			get
			{
				if (key < 0)
				{
					throw new ArgumentException("Argument_KeyLessThanZero");
				}
				uint seed;
				uint incr;
				// Take a snapshot of buckets, in case another thread does a resize
				bucket[] lbuckets = buckets;
				uint hashcode = InitHash(key, lbuckets.Length, out seed, out incr);
				int ntry = 0;

				bucket b;
				do
				{
					int bucketNumber = (int)(seed % (uint)lbuckets.Length);
					b = lbuckets[bucketNumber];
					if (b.val == null)
					{
						return null;
					}
					if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && key == b.key)
					{
						return b.val;
					}
					seed += incr;
				} while (b.hash_coll < 0 && ++ntry < lbuckets.Length);
				return null;
			}
			//set {
			//  Insert(key, value, false);
			//}
		}

		// Increases the bucket count of this hashtable. This method is called from
		// the Insert method when the actual load factor of the hashtable reaches
		// the upper limit specified when the hashtable was constructed. The number
		// of buckets in the hashtable is increased to the smallest prime number
		// that is larger than twice the current number of buckets, and the entries
		// in the hashtable are redistributed into the new buckets using the cached
		// hashcodes.
		private void expand()
		{
			rehash(GetPrime(1 + buckets.Length * 2));
		}

		// We occationally need to rehash the table to clean up the collision bits.
		private void rehash()
		{
			rehash(buckets.Length);
		}

		private void rehash(int newsize)
		{

			// reset occupancy
			occupancy = 0;

			// Don't replace any internal state until we've finished adding to the
			// new bucket[].  This serves two purposes:
			//   1) Allow concurrent readers to see valid hashtable contents
			//      at all times
			//   2) Protect against an OutOfMemoryException while allocating this
			//      new bucket[].
			bucket[] newBuckets = new bucket[newsize];

			// rehash table into new buckets
			int nb;
			for (nb = 0; nb < buckets.Length; nb++)
			{
				bucket oldb = buckets[nb];
				if (oldb.val != null)
				{
					putEntry(newBuckets, oldb.key, oldb.val, oldb.hash_coll & 0x7FFFFFFF);
				}
			}

			// New bucket[] is good to go - replace buckets and other internal state.
			version++;
			buckets = newBuckets;
			loadsize = (int)(loadFactorPerc * newsize) / 100;

			if (loadsize >= newsize)
			{
				loadsize = newsize - 1;
			}

			return;
		}

		// Returns an enumerator for this hashtable.
		// If modifications made to the hashtable while an enumeration is
		// in progress, the MoveNext and Current methods of the
		// enumerator will throw an exception.
		//
		//| <include path='docs/doc[@for="IntHashTable.IEnumerable.GetEnumerator"]/*' />
		//IEnumerator IEnumerable.GetEnumerator() {
		//  return new IntHashTableEnumerator(this);
		//}

		// Internal method to compare two keys.
		//
		// Inserts an entry into this hashtable. This method is called from the Set
		// and Add methods. If the add parameter is true and the given key already
		// exists in the hashtable, an exception is thrown.
		private void Insert(int key, Object nvalue, bool add)
		{
			if (key < 0)
			{
				throw new ArgumentException("Argument_KeyLessThanZero");
			}
			if (nvalue == null)
			{
				throw new ArgumentNullException("nvalue", "ArgumentNull_Value");
			}
			if (count >= loadsize)
			{
				expand();
			}
			else if (occupancy > loadsize && count > 100)
			{
				rehash();
			}

			uint seed;
			uint incr;
			// Assume we only have one thread writing concurrently.  Modify
			// buckets to contain new data, as long as we insert in the right order.
			uint hashcode = InitHash(key, buckets.Length, out seed, out incr);
			int ntry = 0;
			int emptySlotNumber = -1; // We use the empty slot number to cache the first empty slot. We chose to reuse slots
									  // create by remove that have the collision bit set over using up new slots.

			do
			{
				int bucketNumber = (int)(seed % (uint)buckets.Length);

				// Set emptySlot number to current bucket if it is the first available bucket that we have seen
				// that once contained an entry and also has had a collision.
				// We need to search this entire collision chain because we have to ensure that there are no
				// duplicate entries in the table.

				// Insert the key/value pair into this bucket if this bucket is empty and has never contained an entry
				// OR
				// This bucket once contained an entry but there has never been a collision
				if (buckets[bucketNumber].val == null)
				{
					// If we have found an available bucket that has never had a collision, but we've seen an available
					// bucket in the past that has the collision bit set, use the previous bucket instead
					if (emptySlotNumber != -1)
					{ // Reuse slot
						bucketNumber = emptySlotNumber;
					}

					// We pretty much have to insert in this order.  Don't set hash
					// code until the value & key are set appropriately.
					buckets[bucketNumber].val = nvalue;
					buckets[bucketNumber].key = key;
					buckets[bucketNumber].hash_coll |= (int)hashcode;
					count++;
					version++;
					return;
				}

				// The current bucket is in use
				// OR
				// it is available, but has had the collision bit set and we have already found an available bucket
				if (((buckets[bucketNumber].hash_coll & 0x7FFFFFFF) == hashcode) &&
							key == buckets[bucketNumber].key)
				{
					if (add)
					{
						throw new ArgumentException("Argument_AddingDuplicate__" + buckets[bucketNumber].key);
					}
					buckets[bucketNumber].val = nvalue;
					version++;
					return;
				}

				// The current bucket is full, and we have therefore collided.  We need to set the collision bit
				// UNLESS
				// we have remembered an available slot previously.
				if (emptySlotNumber == -1)
				{// We don't need to set the collision bit here since we already have an empty slot
					if (buckets[bucketNumber].hash_coll >= 0)
					{
						buckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
						occupancy++;
					}
				}
				seed += incr;
			} while (++ntry < buckets.Length);

			// This code is here if and only if there were no buckets without a collision bit set in the entire table
			if (emptySlotNumber != -1)
			{
				// We pretty much have to insert in this order.  Don't set hash
				// code until the value & key are set appropriately.
				buckets[emptySlotNumber].val = nvalue;
				buckets[emptySlotNumber].key = key;
				buckets[emptySlotNumber].hash_coll |= (int)hashcode;
				count++;
				version++;
				return;

			}

			// If you see this assert, make sure load factor & count are reasonable.
			// Then verify that our double hash function (h2, described at top of file)
			// meets the requirements described above. You should never see this assert.
			throw new InvalidOperationException("InvalidOperation_HashInsertFailed");
		}

		private void putEntry(bucket[] newBuckets, int key, Object nvalue, int hashcode)
		{
			uint seed = (uint)hashcode;
			uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));

			do
			{
				int bucketNumber = (int)(seed % (uint)newBuckets.Length);

				if ((newBuckets[bucketNumber].val == null))
				{
					newBuckets[bucketNumber].val = nvalue;
					newBuckets[bucketNumber].key = key;
					newBuckets[bucketNumber].hash_coll |= hashcode;
					return;
				}

				if (newBuckets[bucketNumber].hash_coll >= 0)
				{
					newBuckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
					occupancy++;
				}
				seed += incr;
			} while (true);
		}

		// Returns the number of associations in this hashtable.
		//
		//| <include path='docs/doc[@for="IntHashTable.Count"]/*' />
		//internal int Count {
		//  get { return count; }
		//}

		// Implements an enumerator for a hashtable. The enumerator uses the
		// internal version number of the hashtabke to ensure that no modifications
		// are made to the hashtable while an enumeration is in progress.
		//private class IntHashTableEnumerator : IEnumerator {
		//  private IntHashTable hashtable;
		//  private int bucket;
		//  private int version;
		//  private bool current;
		//  //private int currentKey;
		//  private Object currentValue;

		//  internal IntHashTableEnumerator(IntHashTable hashtable) {
		//    this.hashtable = hashtable;
		//    bucket = hashtable.buckets.Length;
		//    version = hashtable.version;
		//  }

		//  public bool MoveNext() {
		//    if (version != hashtable.version)
		//      throw new InvalidOperationException("InvalidOperation_EnumFailedVersion");
		//    while (bucket > 0) {
		//      bucket--;
		//      Object val = hashtable.buckets[bucket].val;
		//      if (val != null) {
		//        //currentKey = hashtable.buckets[bucket].key;
		//        currentValue = val;
		//        current = true;
		//        return true;
		//      }
		//    }
		//    current = false;
		//    return false;
		//  }

		//  //internal int Key {
		//  //  get {
		//  //    if (current == false)
		//  //      throw new InvalidOperationException("InvalidOperation_EnumOpCantHappen");
		//  //    return currentKey;
		//  //  }
		//  //}

		//  public Object Current {
		//    get {
		//      if (current == false)
		//        throw new InvalidOperationException("InvalidOperation_EnumOpCantHappen");
		//      return currentValue;
		//    }
		//  }

		//  //public Object Value {
		//  //  get {
		//  //    if (version != hashtable.version)
		//  //      throw new InvalidOperationException("InvalidOperation_EnumFailedVersion");
		//  //    if (current == false)
		//  //      throw new InvalidOperationException("InvalidOperation_EnumOpCantHappen");
		//  //    return currentValue;
		//  //  }
		//  //}

		//  public void Reset() {
		//    if (version != hashtable.version) throw new InvalidOperationException("InvalidOperation_EnumFailedVersion");
		//    current = false;
		//    bucket = hashtable.buckets.Length;
		//    //currentKey = -1;
		//    currentValue = null;
		//  }
		//}
	}
}
// Author:
//   Juerg Billeter (j@bitron.ch)
//
// (C) 2008 Juerg Billeter
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.Pdb
{

	[Guid("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComImport]
	interface ISymUnmanagedDocumentWriter
	{
		void SetSource(uint sourceSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] source);
		void SetCheckSum(Guid algorithmId, uint checkSumSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] checkSum);
	}
}
//
// Author:
//   Juerg Billeter (j@bitron.ch)
//
// (C) 2008 Juerg Billeter
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Cecil.Pdb
{

	[Guid("0B97726E-9E6D-4f05-9A26-424022093CAA")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComImport]
	interface ISymUnmanagedWriter2
	{

		void DefineDocument(
			[In, MarshalAs(UnmanagedType.LPWStr)] string url,
			[In] ref Guid langauge,
			[In] ref Guid languageVendor,
			[In] ref Guid documentType,
			[Out, MarshalAs(UnmanagedType.Interface)] out ISymUnmanagedDocumentWriter pRetVal);
		void SetUserEntryPoint([In] int methodToken);
		void OpenMethod([In] int methodToken);
		void CloseMethod();
		void OpenScope([In] int startOffset, [Out] out int pRetVal);
		void CloseScope([In] int endOffset);
		void SetScopeRange_Placeholder();
		void DefineLocalVariable_Placeholder();
		void DefineParameter_Placeholder();
		void DefineField_Placeholder();
		void DefineGlobalVariable_Placeholder();
		void Close();
		void SetSymAttribute(uint parent, string name, uint data, IntPtr signature);
		void OpenNamespace([In, MarshalAs(UnmanagedType.LPWStr)] string name);
		void CloseNamespace();
		void UsingNamespace([In, MarshalAs(UnmanagedType.LPWStr)] string fullName);
		void SetMethodSourceRange_Placeholder();
		void Initialize(
			[In, MarshalAs(UnmanagedType.IUnknown)] object emitter,
			[In, MarshalAs(UnmanagedType.LPWStr)] string filename,
			[In] IStream pIStream,
			[In] bool fFullBuild);
		void GetDebugInfo(
			[Out] out ImageDebugDirectory pIDD,
			[In] int cData,
			[Out] out int pcData,
			[In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);
		void DefineSequencePoints(
			[In, MarshalAs(UnmanagedType.Interface)] ISymUnmanagedDocumentWriter document,
			[In] int spCount,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines,
			[In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);
		void RemapToken_Placeholder();
		void Initialize2_Placeholder();
		void DefineConstant_Placeholder();
		void Abort_Placeholder();

		void DefineLocalVariable2(
			[In, MarshalAs(UnmanagedType.LPWStr)] string name,
			[In] int attributes,
			[In] int sigToken,
			[In] int addrKind,
			[In] int addr1,
			[In] int addr2,
			[In] int addr3,
			[In] int startOffset,
			[In] int endOffset);

		void DefineGlobalVariable2_Placeholder();

		void DefineConstant2(
			[In, MarshalAs(UnmanagedType.LPWStr)] string name,
			[In, MarshalAs(UnmanagedType.Struct)] object variant,
			[In] int sigToken);
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public sealed class LinkedResource : Resource
	{

		internal byte[] hash;
		string file;

		public byte[] Hash
		{
			get { return hash; }
		}

		public string File
		{
			get { return file; }
			set { file = value; }
		}

		public override ResourceType ResourceType
		{
			get { return ResourceType.Linked; }
		}

		public LinkedResource(string name, ManifestResourceAttributes flags)
			: base(name, flags)
		{
		}

		public LinkedResource(string name, ManifestResourceAttributes flags, string file)
			: base(name, flags)
		{
			this.file = file;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum ManifestResourceAttributes : uint
	{
		VisibilityMask = 0x0007,
		Public = 0x0001,    // The resource is exported from the Assembly
		Private = 0x0002     // The resource is private to the Assembly
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public class MarshalInfo
	{

		internal NativeType native;

		public NativeType NativeType
		{
			get { return native; }
			set { native = value; }
		}

		public MarshalInfo(NativeType native)
		{
			this.native = native;
		}
	}

	public sealed class ArrayMarshalInfo : MarshalInfo
	{

		internal NativeType element_type;
		internal int size_parameter_index;
		internal int size;
		internal int size_parameter_multiplier;

		public NativeType ElementType
		{
			get { return element_type; }
			set { element_type = value; }
		}

		public int SizeParameterIndex
		{
			get { return size_parameter_index; }
			set { size_parameter_index = value; }
		}

		public int Size
		{
			get { return size; }
			set { size = value; }
		}

		public int SizeParameterMultiplier
		{
			get { return size_parameter_multiplier; }
			set { size_parameter_multiplier = value; }
		}

		public ArrayMarshalInfo()
			: base(NativeType.Array)
		{
			element_type = NativeType.None;
			size_parameter_index = -1;
			size = -1;
			size_parameter_multiplier = -1;
		}
	}

	public sealed class CustomMarshalInfo : MarshalInfo
	{

		internal Guid guid;
		internal string unmanaged_type;
		internal TypeReference managed_type;
		internal string cookie;

		public Guid Guid
		{
			get { return guid; }
			set { guid = value; }
		}

		public string UnmanagedType
		{
			get { return unmanaged_type; }
			set { unmanaged_type = value; }
		}

		public TypeReference ManagedType
		{
			get { return managed_type; }
			set { managed_type = value; }
		}

		public string Cookie
		{
			get { return cookie; }
			set { cookie = value; }
		}

		public CustomMarshalInfo()
			: base(NativeType.CustomMarshaler)
		{
		}
	}

	public sealed class SafeArrayMarshalInfo : MarshalInfo
	{

		internal VariantType element_type;

		public VariantType ElementType
		{
			get { return element_type; }
			set { element_type = value; }
		}

		public SafeArrayMarshalInfo()
			: base(NativeType.SafeArray)
		{
			element_type = VariantType.None;
		}
	}

	public sealed class FixedArrayMarshalInfo : MarshalInfo
	{

		internal NativeType element_type;
		internal int size;

		public NativeType ElementType
		{
			get { return element_type; }
			set { element_type = value; }
		}

		public int Size
		{
			get { return size; }
			set { size = value; }
		}

		public FixedArrayMarshalInfo()
			: base(NativeType.FixedArray)
		{
			element_type = NativeType.None;
		}
	}

	public sealed class FixedSysStringMarshalInfo : MarshalInfo
	{

		internal int size;

		public int Size
		{
			get { return size; }
			set { size = value; }
		}

		public FixedSysStringMarshalInfo()
			: base(NativeType.FixedSysString)
		{
			size = -1;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil.Mdb
{

	public sealed class MdbReaderProvider : ISymbolReaderProvider
	{

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			return new MdbReader(module, MonoSymbolFile.ReadSymbolFile(Mixin.GetMdbFileName(fileName)));
		}

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);

			return new MdbReader(module, MonoSymbolFile.ReadSymbolFile(symbolStream));
		}
	}

	public sealed class MdbReader : Mono.Cecil.Cil.ISymbolReader
	{

		readonly ModuleDefinition module;
		readonly MonoSymbolFile symbol_file;
		readonly Dictionary<string, Document> documents;

		public MdbReader(ModuleDefinition module, MonoSymbolFile symFile)
		{
			this.module = module;
			this.symbol_file = symFile;
			this.documents = new Dictionary<string, Document>();
		}

		public ISymbolWriterProvider GetWriterProvider()
		{
			return new MdbWriterProvider();
		}

		public bool ProcessDebugHeader(ImageDebugHeader header)
		{
			return symbol_file.Guid == module.Mvid;
		}

		public MethodDebugInformation Read(MethodDefinition method)
		{
			var method_token = method.MetadataToken;
			var entry = symbol_file.GetMethodByToken(method_token.ToInt32());
			if (entry == null)
				return null;

			var info = new MethodDebugInformation(method);
			info.code_size = ReadCodeSize(method);

			var scopes = ReadScopes(entry, info);
			ReadLineNumbers(entry, info);
			ReadLocalVariables(entry, scopes);

			return info;
		}

		static int ReadCodeSize(MethodDefinition method)
		{
			return method.Module.Read(method, (m, reader) => reader.ReadCodeSize(m));
		}

		static void ReadLocalVariables(MethodEntry entry, ScopeDebugInformation[] scopes)
		{
			var locals = entry.GetLocals();

			foreach (var local in locals)
			{
				var variable = new VariableDebugInformation(local.Index, local.Name);

				var index = local.BlockIndex;
				if (index < 0 || index >= scopes.Length)
					continue;

				var scope = scopes[index];
				if (scope == null)
					continue;

				scope.Variables.Add(variable);
			}
		}

		void ReadLineNumbers(MethodEntry entry, MethodDebugInformation info)
		{
			var table = entry.GetLineNumberTable();

			info.sequence_points = new Collection<SequencePoint>(table.LineNumbers.Length);

			for (var i = 0; i < table.LineNumbers.Length; i++)
			{
				var line = table.LineNumbers[i];
				if (i > 0 && table.LineNumbers[i - 1].Offset == line.Offset)
					continue;

				info.sequence_points.Add(LineToSequencePoint(line));
			}
		}

		Document GetDocument(SourceFileEntry file)
		{
			var file_name = file.FileName;

			Document document;
			if (documents.TryGetValue(file_name, out document))
				return document;

			document = new Document(file_name)
			{
				Hash = file.Checksum,
			};

			documents.Add(file_name, document);

			return document;
		}

		static ScopeDebugInformation[] ReadScopes(MethodEntry entry, MethodDebugInformation info)
		{
			var blocks = entry.GetCodeBlocks();
			var scopes = new ScopeDebugInformation[blocks.Length + 1];

			info.scope = scopes[0] = new ScopeDebugInformation
			{
				Start = new InstructionOffset(0),
				End = new InstructionOffset(info.code_size),
			};

			foreach (var block in blocks)
			{
				if (block.BlockType != CodeBlockEntry.Type.Lexical && block.BlockType != CodeBlockEntry.Type.CompilerGenerated)
					continue;

				var scope = new ScopeDebugInformation();
				scope.Start = new InstructionOffset(block.StartOffset);
				scope.End = new InstructionOffset(block.EndOffset);

				scopes[block.Index + 1] = scope;

				if (!AddScope(info.scope.Scopes, scope))
					info.scope.Scopes.Add(scope);
			}

			return scopes;
		}

		static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
		{
			foreach (var sub_scope in scopes)
			{
				if (sub_scope.HasScopes && AddScope(sub_scope.Scopes, scope))
					return true;

				if (scope.Start.Offset >= sub_scope.Start.Offset && scope.End.Offset <= sub_scope.End.Offset)
				{
					sub_scope.Scopes.Add(scope);
					return true;
				}
			}

			return false;
		}

		SequencePoint LineToSequencePoint(LineNumberEntry line)
		{
			var source = symbol_file.GetSourceFile(line.File);
			return new SequencePoint(line.Offset, GetDocument(source))
			{
				StartLine = line.Row,
				EndLine = line.EndRow,
				StartColumn = line.Column,
				EndColumn = line.EndColumn,
			};
		}

		public void Dispose()
		{
			symbol_file.Dispose();
		}
	}

	static class MethodEntryExtensions
	{

		public static bool HasColumnInfo(this MethodEntry entry)
		{
			return (entry.MethodFlags & MethodEntry.Flags.ColumnsInfoIncluded) != 0;
		}

		public static bool HasEndInfo(this MethodEntry entry)
		{
			return (entry.MethodFlags & MethodEntry.Flags.EndInfoIncluded) != 0;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil.Mdb
{

	public sealed class MdbWriterProvider : ISymbolWriterProvider
	{

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			return new MdbWriter(module, fileName);
		}

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			throw new NotImplementedException();
		}
	}

	public sealed class MdbWriter : Mono.Cecil.Cil.ISymbolWriter
	{

		readonly ModuleDefinition module;
		readonly MonoSymbolWriter writer;
		readonly Dictionary<string, SourceFile> source_files;

		public MdbWriter(ModuleDefinition module, string assembly)
		{
			this.module = module;
			this.writer = new MonoSymbolWriter(assembly);
			this.source_files = new Dictionary<string, SourceFile>();
		}

		public ISymbolReaderProvider GetReaderProvider()
		{
			return new MdbReaderProvider();
		}

		SourceFile GetSourceFile(Document document)
		{
			var url = document.Url;

			SourceFile source_file;
			if (source_files.TryGetValue(url, out source_file))
				return source_file;

			var entry = writer.DefineDocument(url, null, document.Hash != null && document.Hash.Length == 16 ? document.Hash : null);
			var compile_unit = writer.DefineCompilationUnit(entry);

			source_file = new SourceFile(compile_unit, entry);
			source_files.Add(url, source_file);
			return source_file;
		}

		void Populate(Collection<SequencePoint> sequencePoints, int[] offsets,
			int[] startRows, int[] endRows, int[] startCols, int[] endCols, out SourceFile file)
		{
			SourceFile source_file = null;

			for (int i = 0; i < sequencePoints.Count; i++)
			{
				var sequence_point = sequencePoints[i];
				offsets[i] = sequence_point.Offset;

				if (source_file == null)
					source_file = GetSourceFile(sequence_point.Document);

				startRows[i] = sequence_point.StartLine;
				endRows[i] = sequence_point.EndLine;
				startCols[i] = sequence_point.StartColumn;
				endCols[i] = sequence_point.EndColumn;
			}

			file = source_file;
		}

		public void Write(MethodDebugInformation info)
		{
			var method = new SourceMethod(info.method);

			var sequence_points = info.SequencePoints;
			int count = sequence_points.Count;
			if (count == 0)
				return;

			var offsets = new int[count];
			var start_rows = new int[count];
			var end_rows = new int[count];
			var start_cols = new int[count];
			var end_cols = new int[count];

			SourceFile file;
			Populate(sequence_points, offsets, start_rows, end_rows, start_cols, end_cols, out file);

			var builder = writer.OpenMethod(file.CompilationUnit, 0, method);

			for (int i = 0; i < count; i++)
			{
				builder.MarkSequencePoint(
					offsets[i],
					file.CompilationUnit.SourceFile,
					start_rows[i],
					start_cols[i],
					end_rows[i],
					end_cols[i],
					false);
			}

			if (info.scope != null)
				WriteRootScope(info.scope, info);

			writer.CloseMethod();
		}

		void WriteRootScope(ScopeDebugInformation scope, MethodDebugInformation info)
		{
			WriteScopeVariables(scope);

			if (scope.HasScopes)
				WriteScopes(scope.Scopes, info);
		}

		void WriteScope(ScopeDebugInformation scope, MethodDebugInformation info)
		{
			writer.OpenScope(scope.Start.Offset);

			WriteScopeVariables(scope);

			if (scope.HasScopes)
				WriteScopes(scope.Scopes, info);

			writer.CloseScope(scope.End.IsEndOfMethod ? info.code_size : scope.End.Offset);
		}

		void WriteScopes(Collection<ScopeDebugInformation> scopes, MethodDebugInformation info)
		{
			for (int i = 0; i < scopes.Count; i++)
				WriteScope(scopes[i], info);
		}

		void WriteScopeVariables(ScopeDebugInformation scope)
		{
			if (!scope.HasVariables)
				return;

			foreach (var variable in scope.variables)
				if (!string.IsNullOrEmpty(variable.Name))
					writer.DefineLocalVariable(variable.Index, variable.Name);
		}

		public ImageDebugHeader GetDebugHeader()
		{
			return new ImageDebugHeader();
		}

		public void Dispose()
		{
			writer.WriteSymbolFile(module.Mvid);
		}

		class SourceFile : ISourceFile
		{

			readonly CompileUnitEntry compilation_unit;
			readonly SourceFileEntry entry;

			public SourceFileEntry Entry
			{
				get { return entry; }
			}

			public CompileUnitEntry CompilationUnit
			{
				get { return compilation_unit; }
			}

			public SourceFile(CompileUnitEntry comp_unit, SourceFileEntry entry)
			{
				this.compilation_unit = comp_unit;
				this.entry = entry;
			}
		}

		class SourceMethod : IMethodDef
		{

			readonly MethodDefinition method;

			public string Name
			{
				get { return method.Name; }
			}

			public int Token
			{
				get { return method.MetadataToken.ToInt32(); }
			}

			public SourceMethod(MethodDefinition method)
			{
				this.method = method;
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	sealed class MemberDefinitionCollection<T> : Collection<T> where T : IMemberDefinition
	{

		TypeDefinition container;

		internal MemberDefinitionCollection(TypeDefinition container)
		{
			this.container = container;
		}

		internal MemberDefinitionCollection(TypeDefinition container, int capacity)
			: base(capacity)
		{
			this.container = container;
		}

		protected override void OnAdd(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnSet(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnInsert(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnRemove(T item, int index)
		{
			Detach(item);
		}

		protected sealed override void OnClear()
		{
			foreach (var definition in this)
				Detach(definition);
		}

		void Attach(T element)
		{
			if (element.DeclaringType == container)
				return;

			if (element.DeclaringType != null)
				throw new ArgumentException("Member already attached");

			element.DeclaringType = this.container;
		}

		static void Detach(T element)
		{
			element.DeclaringType = null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public abstract class MemberReference : IMetadataTokenProvider
	{

		string name;
		TypeReference declaring_type;

		internal MetadataToken token;
		internal object projection;

		public virtual string Name
		{
			get { return name; }
			set
			{
				if (IsWindowsRuntimeProjection && value != name)
					throw new InvalidOperationException();

				name = value;
			}
		}

		public abstract string FullName
		{
			get;
		}

		public virtual TypeReference DeclaringType
		{
			get { return declaring_type; }
			set { declaring_type = value; }
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		public bool IsWindowsRuntimeProjection
		{
			get { return projection != null; }
		}

		internal bool HasImage
		{
			get
			{
				var module = Module;
				if (module == null)
					return false;

				return module.HasImage;
			}
		}

		public virtual ModuleDefinition Module
		{
			get { return declaring_type != null ? declaring_type.Module : null; }
		}

		public virtual bool IsDefinition
		{
			get { return false; }
		}

		public virtual bool ContainsGenericParameter
		{
			get { return declaring_type != null && declaring_type.ContainsGenericParameter; }
		}

		internal MemberReference()
		{
		}

		internal MemberReference(string name)
		{
			this.name = name ?? string.Empty;
		}

		internal string MemberFullName()
		{
			if (declaring_type == null)
				return name;

			return declaring_type.FullName + "::" + name;
		}

		public IMemberDefinition Resolve()
		{
			return ResolveDefinition();
		}

		protected abstract IMemberDefinition ResolveDefinition();

		public override string ToString()
		{
			return FullName;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono
{

	class MergeSort<T>
	{
		private readonly T[] elements;
		private readonly T[] buffer;
		private readonly IComparer<T> comparer;

		private MergeSort(T[] elements, IComparer<T> comparer)
		{
			this.elements = elements;
			this.buffer = new T[elements.Length];
			Array.Copy(this.elements, this.buffer, elements.Length);
			this.comparer = comparer;
		}

		public static void Sort(T[] source, IComparer<T> comparer)
		{
			Sort(source, 0, source.Length, comparer);
		}

		public static void Sort(T[] source, int start, int length, IComparer<T> comparer)
		{
			new MergeSort<T>(source, comparer).Sort(start, length);
		}

		private void Sort(int start, int length)
		{
			TopDownSplitMerge(this.buffer, this.elements, start, length);
		}

		private void TopDownSplitMerge(T[] a, T[] b, int start, int end)
		{
			if (end - start < 2)
				return;

			int middle = (end + start) / 2;
			TopDownSplitMerge(b, a, start, middle);
			TopDownSplitMerge(b, a, middle, end);
			TopDownMerge(a, b, start, middle, end);
		}

		private void TopDownMerge(T[] a, T[] b, int start, int middle, int end)
		{
			for (int i = start, j = middle, k = start; k < end; k++)
			{
				if (i < middle && (j >= end || comparer.Compare(a[i], a[j]) <= 0))
				{
					b[k] = a[i++];
				}
				else
				{
					b[k] = a[j++];
				}
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public interface IAssemblyResolver : IDisposable
	{
		AssemblyDefinition Resolve(AssemblyNameReference name);
		AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
	}

	public interface IMetadataResolver
	{
		TypeDefinition Resolve(TypeReference type);
		FieldDefinition Resolve(FieldReference field);
		MethodDefinition Resolve(MethodReference method);
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class ResolutionException : Exception
	{

		readonly MemberReference member;

		public MemberReference Member
		{
			get { return member; }
		}

		public IMetadataScope Scope
		{
			get
			{
				var type = member as TypeReference;
				if (type != null)
					return type.Scope;

				var declaring_type = member.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Scope;

				throw new NotSupportedException();
			}
		}

		public ResolutionException(MemberReference member)
			: base("Failed to resolve " + member.FullName)
		{
			if (member == null)
				throw new ArgumentNullException("member");

			this.member = member;
		}

		public ResolutionException(MemberReference member, Exception innerException)
			: base("Failed to resolve " + member.FullName, innerException)
		{
			if (member == null)
				throw new ArgumentNullException("member");

			this.member = member;
		}

#if !NET_CORE
		ResolutionException(
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base(info, context)
		{
		}
#endif
	}

	public class MetadataResolver : IMetadataResolver
	{

		readonly IAssemblyResolver assembly_resolver;

		public IAssemblyResolver AssemblyResolver
		{
			get { return assembly_resolver; }
		}

		public MetadataResolver(IAssemblyResolver assemblyResolver)
		{
			if (assemblyResolver == null)
				throw new ArgumentNullException("assemblyResolver");

			assembly_resolver = assemblyResolver;
		}

		public virtual TypeDefinition Resolve(TypeReference type)
		{
			Mixin.CheckType(type);

			type = type.GetElementType();

			var scope = type.Scope;

			if (scope == null)
				return null;

			switch (scope.MetadataScopeType)
			{
				case MetadataScopeType.AssemblyNameReference:
					var assembly = assembly_resolver.Resolve((AssemblyNameReference)scope);
					if (assembly == null)
						return null;

					return GetType(assembly.MainModule, type);
				case MetadataScopeType.ModuleDefinition:
					return GetType((ModuleDefinition)scope, type);
				case MetadataScopeType.ModuleReference:
					if (type.Module.Assembly == null)
						return null;

					var modules = type.Module.Assembly.Modules;
					var module_ref = (ModuleReference)scope;
					for (int i = 0; i < modules.Count; i++)
					{
						var netmodule = modules[i];
						if (netmodule.Name == module_ref.Name)
							return GetType(netmodule, type);
					}
					break;
			}

			throw new NotSupportedException();
		}

		static TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
		{
			var type = GetTypeDefinition(module, reference);
			if (type != null)
				return type;

			if (!module.HasExportedTypes)
				return null;

			var exported_types = module.ExportedTypes;

			for (int i = 0; i < exported_types.Count; i++)
			{
				var exported_type = exported_types[i];
				if (exported_type.Name != reference.Name)
					continue;

				if (exported_type.Namespace != reference.Namespace)
					continue;

				return exported_type.Resolve();
			}

			return null;
		}

		static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
		{
			if (!type.IsNested)
				return module.GetType(type.Namespace, type.Name);

			var declaring_type = type.DeclaringType.Resolve();
			if (declaring_type == null)
				return null;

			return declaring_type.GetNestedType(type.TypeFullName());
		}

		public virtual FieldDefinition Resolve(FieldReference field)
		{
			Mixin.CheckField(field);

			var type = Resolve(field.DeclaringType);
			if (type == null)
				return null;

			if (!type.HasFields)
				return null;

			return GetField(type, field);
		}

		FieldDefinition GetField(TypeDefinition type, FieldReference reference)
		{
			while (type != null)
			{
				var field = GetField(type.Fields, reference);
				if (field != null)
					return field;

				if (type.BaseType == null)
					return null;

				type = Resolve(type.BaseType);
			}

			return null;
		}

		static FieldDefinition GetField(Collection<FieldDefinition> fields, FieldReference reference)
		{
			for (int i = 0; i < fields.Count; i++)
			{
				var field = fields[i];

				if (field.Name != reference.Name)
					continue;

				if (!AreSame(field.FieldType, reference.FieldType))
					continue;

				return field;
			}

			return null;
		}

		public virtual MethodDefinition Resolve(MethodReference method)
		{
			Mixin.CheckMethod(method);

			var type = Resolve(method.DeclaringType);
			if (type == null)
				return null;

			method = method.GetElementMethod();

			if (!type.HasMethods)
				return null;

			return GetMethod(type, method);
		}

		MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
		{
			while (type != null)
			{
				var method = GetMethod(type.Methods, reference);
				if (method != null)
					return method;

				if (type.BaseType == null)
					return null;

				type = Resolve(type.BaseType);
			}

			return null;
		}

		public static MethodDefinition GetMethod(Collection<MethodDefinition> methods, MethodReference reference)
		{
			for (int i = 0; i < methods.Count; i++)
			{
				var method = methods[i];

				if (method.Name != reference.Name)
					continue;

				if (method.HasGenericParameters != reference.HasGenericParameters)
					continue;

				if (method.HasGenericParameters && method.GenericParameters.Count != reference.GenericParameters.Count)
					continue;

				if (!AreSame(method.ReturnType, reference.ReturnType))
					continue;

				if (method.IsVarArg() != reference.IsVarArg())
					continue;

				if (method.IsVarArg() && IsVarArgCallTo(method, reference))
					return method;

				if (method.HasParameters != reference.HasParameters)
					continue;

				if (!method.HasParameters && !reference.HasParameters)
					return method;

				if (!AreSame(method.Parameters, reference.Parameters))
					continue;

				return method;
			}

			return null;
		}

		static bool AreSame(Collection<ParameterDefinition> a, Collection<ParameterDefinition> b)
		{
			var count = a.Count;

			if (count != b.Count)
				return false;

			if (count == 0)
				return true;

			for (int i = 0; i < count; i++)
				if (!AreSame(a[i].ParameterType, b[i].ParameterType))
					return false;

			return true;
		}

		static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference)
		{
			if (method.Parameters.Count >= reference.Parameters.Count)
				return false;

			if (reference.GetSentinelPosition() != method.Parameters.Count)
				return false;

			for (int i = 0; i < method.Parameters.Count; i++)
				if (!AreSame(method.Parameters[i].ParameterType, reference.Parameters[i].ParameterType))
					return false;

			return true;
		}

		static bool AreSame(TypeSpecification a, TypeSpecification b)
		{
			if (!AreSame(a.ElementType, b.ElementType))
				return false;

			if (a.IsGenericInstance)
				return AreSame((GenericInstanceType)a, (GenericInstanceType)b);

			if (a.IsRequiredModifier || a.IsOptionalModifier)
				return AreSame((IModifierType)a, (IModifierType)b);

			if (a.IsArray)
				return AreSame((ArrayType)a, (ArrayType)b);

			return true;
		}

		static bool AreSame(ArrayType a, ArrayType b)
		{
			if (a.Rank != b.Rank)
				return false;

			// TODO: dimensions

			return true;
		}

		static bool AreSame(IModifierType a, IModifierType b)
		{
			return AreSame(a.ModifierType, b.ModifierType);
		}

		static bool AreSame(GenericInstanceType a, GenericInstanceType b)
		{
			if (a.GenericArguments.Count != b.GenericArguments.Count)
				return false;

			for (int i = 0; i < a.GenericArguments.Count; i++)
				if (!AreSame(a.GenericArguments[i], b.GenericArguments[i]))
					return false;

			return true;
		}

		static bool AreSame(GenericParameter a, GenericParameter b)
		{
			return a.Position == b.Position;
		}

		static bool AreSame(TypeReference a, TypeReference b)
		{
			if (ReferenceEquals(a, b))
				return true;

			if (a == null || b == null)
				return false;

			if (a.etype != b.etype)
				return false;

			if (a.IsGenericParameter)
				return AreSame((GenericParameter)a, (GenericParameter)b);

			if (a.IsTypeSpecification())
				return AreSame((TypeSpecification)a, (TypeSpecification)b);

			if (a.Name != b.Name || a.Namespace != b.Namespace)
				return false;

			//TODO: check scope

			return AreSame(a.DeclaringType, b.DeclaringType);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil
{

	struct Range
	{
		public uint Start;
		public uint Length;

		public Range(uint index, uint length)
		{
			this.Start = index;
			this.Length = length;
		}
	}

	sealed class MetadataSystem
	{

		internal AssemblyNameReference[] AssemblyReferences;
		internal ModuleReference[] ModuleReferences;

		internal TypeDefinition[] Types;
		internal TypeReference[] TypeReferences;

		internal FieldDefinition[] Fields;
		internal MethodDefinition[] Methods;
		internal MemberReference[] MemberReferences;

		internal Dictionary<uint, Collection<uint>> NestedTypes;
		internal Dictionary<uint, uint> ReverseNestedTypes;
		internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> Interfaces;
		internal Dictionary<uint, Row<ushort, uint>> ClassLayouts;
		internal Dictionary<uint, uint> FieldLayouts;
		internal Dictionary<uint, uint> FieldRVAs;
		internal Dictionary<MetadataToken, uint> FieldMarshals;
		internal Dictionary<MetadataToken, Row<ElementType, uint>> Constants;
		internal Dictionary<uint, Collection<MetadataToken>> Overrides;
		internal Dictionary<MetadataToken, Range[]> CustomAttributes;
		internal Dictionary<MetadataToken, Range[]> SecurityDeclarations;
		internal Dictionary<uint, Range> Events;
		internal Dictionary<uint, Range> Properties;
		internal Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> Semantics;
		internal Dictionary<uint, Row<PInvokeAttributes, uint, uint>> PInvokes;
		internal Dictionary<MetadataToken, Range[]> GenericParameters;
		internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> GenericConstraints;

		internal Document[] Documents;
		internal Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>> LocalScopes;
		internal ImportDebugInformation[] ImportScopes;
		internal Dictionary<uint, uint> StateMachineMethods;
		internal Dictionary<MetadataToken, Row<Guid, uint, uint>[]> CustomDebugInformations;

		static Dictionary<string, Row<ElementType, bool>> primitive_value_types;

		static void InitializePrimitives()
		{
			var types = new Dictionary<string, Row<ElementType, bool>>(18, StringComparer.Ordinal) {
				{ "Void", new Row<ElementType, bool> (ElementType.Void, false) },
				{ "Boolean", new Row<ElementType, bool> (ElementType.Boolean, true) },
				{ "Char", new Row<ElementType, bool> (ElementType.Char, true) },
				{ "SByte", new Row<ElementType, bool> (ElementType.I1, true) },
				{ "Byte", new Row<ElementType, bool> (ElementType.U1, true) },
				{ "Int16", new Row<ElementType, bool> (ElementType.I2, true) },
				{ "UInt16", new Row<ElementType, bool> (ElementType.U2, true) },
				{ "Int32", new Row<ElementType, bool> (ElementType.I4, true) },
				{ "UInt32", new Row<ElementType, bool> (ElementType.U4, true) },
				{ "Int64", new Row<ElementType, bool> (ElementType.I8, true) },
				{ "UInt64", new Row<ElementType, bool> (ElementType.U8, true) },
				{ "Single", new Row<ElementType, bool> (ElementType.R4, true) },
				{ "Double", new Row<ElementType, bool> (ElementType.R8, true) },
				{ "String", new Row<ElementType, bool> (ElementType.String, false) },
				{ "TypedReference", new Row<ElementType, bool> (ElementType.TypedByRef, false) },
				{ "IntPtr", new Row<ElementType, bool> (ElementType.I, true) },
				{ "UIntPtr", new Row<ElementType, bool> (ElementType.U, true) },
				{ "Object", new Row<ElementType, bool> (ElementType.Object, false) },
			};

			Interlocked.CompareExchange(ref primitive_value_types, types, null);
		}

		public static void TryProcessPrimitiveTypeReference(TypeReference type)
		{
			if (type.Namespace != "System")
				return;

			var scope = type.scope;
			if (scope == null || scope.MetadataScopeType != MetadataScopeType.AssemblyNameReference)
				return;

			Row<ElementType, bool> primitive_data;
			if (!TryGetPrimitiveData(type, out primitive_data))
				return;

			type.etype = primitive_data.Col1;
			type.IsValueType = primitive_data.Col2;
		}

		public static bool TryGetPrimitiveElementType(TypeDefinition type, out ElementType etype)
		{
			etype = ElementType.None;

			if (type.Namespace != "System")
				return false;

			Row<ElementType, bool> primitive_data;
			if (TryGetPrimitiveData(type, out primitive_data))
			{
				etype = primitive_data.Col1;
				return true;
			}

			return false;
		}

		static bool TryGetPrimitiveData(TypeReference type, out Row<ElementType, bool> primitive_data)
		{
			if (primitive_value_types == null)
				InitializePrimitives();

			return primitive_value_types.TryGetValue(type.Name, out primitive_data);
		}

		public void Clear()
		{
			if (NestedTypes != null) NestedTypes = new Dictionary<uint, Collection<uint>>(capacity: 0);
			if (ReverseNestedTypes != null) ReverseNestedTypes = new Dictionary<uint, uint>(capacity: 0);
			if (Interfaces != null) Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(capacity: 0);
			if (ClassLayouts != null) ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(capacity: 0);
			if (FieldLayouts != null) FieldLayouts = new Dictionary<uint, uint>(capacity: 0);
			if (FieldRVAs != null) FieldRVAs = new Dictionary<uint, uint>(capacity: 0);
			if (FieldMarshals != null) FieldMarshals = new Dictionary<MetadataToken, uint>(capacity: 0);
			if (Constants != null) Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(capacity: 0);
			if (Overrides != null) Overrides = new Dictionary<uint, Collection<MetadataToken>>(capacity: 0);
			if (CustomAttributes != null) CustomAttributes = new Dictionary<MetadataToken, Range[]>(capacity: 0);
			if (SecurityDeclarations != null) SecurityDeclarations = new Dictionary<MetadataToken, Range[]>(capacity: 0);
			if (Events != null) Events = new Dictionary<uint, Range>(capacity: 0);
			if (Properties != null) Properties = new Dictionary<uint, Range>(capacity: 0);
			if (Semantics != null) Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(capacity: 0);
			if (PInvokes != null) PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(capacity: 0);
			if (GenericParameters != null) GenericParameters = new Dictionary<MetadataToken, Range[]>(capacity: 0);
			if (GenericConstraints != null) GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(capacity: 0);

			Documents = Empty<Document>.Array;
			ImportScopes = Empty<ImportDebugInformation>.Array;
			if (LocalScopes != null) LocalScopes = new Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>>(capacity: 0);
			if (StateMachineMethods != null) StateMachineMethods = new Dictionary<uint, uint>(capacity: 0);
		}

		public AssemblyNameReference GetAssemblyNameReference(uint rid)
		{
			if (rid < 1 || rid > AssemblyReferences.Length)
				return null;

			return AssemblyReferences[rid - 1];
		}

		public TypeDefinition GetTypeDefinition(uint rid)
		{
			if (rid < 1 || rid > Types.Length)
				return null;

			return Types[rid - 1];
		}

		public void AddTypeDefinition(TypeDefinition type)
		{
			Types[type.token.RID - 1] = type;
		}

		public TypeReference GetTypeReference(uint rid)
		{
			if (rid < 1 || rid > TypeReferences.Length)
				return null;

			return TypeReferences[rid - 1];
		}

		public void AddTypeReference(TypeReference type)
		{
			TypeReferences[type.token.RID - 1] = type;
		}

		public FieldDefinition GetFieldDefinition(uint rid)
		{
			if (rid < 1 || rid > Fields.Length)
				return null;

			return Fields[rid - 1];
		}

		public void AddFieldDefinition(FieldDefinition field)
		{
			Fields[field.token.RID - 1] = field;
		}

		public MethodDefinition GetMethodDefinition(uint rid)
		{
			if (rid < 1 || rid > Methods.Length)
				return null;

			return Methods[rid - 1];
		}

		public void AddMethodDefinition(MethodDefinition method)
		{
			Methods[method.token.RID - 1] = method;
		}

		public MemberReference GetMemberReference(uint rid)
		{
			if (rid < 1 || rid > MemberReferences.Length)
				return null;

			return MemberReferences[rid - 1];
		}

		public void AddMemberReference(MemberReference member)
		{
			MemberReferences[member.token.RID - 1] = member;
		}

		public bool TryGetNestedTypeMapping(TypeDefinition type, out Collection<uint> mapping)
		{
			return NestedTypes.TryGetValue(type.token.RID, out mapping);
		}

		public void SetNestedTypeMapping(uint type_rid, Collection<uint> mapping)
		{
			NestedTypes[type_rid] = mapping;
		}

		public void RemoveNestedTypeMapping(TypeDefinition type)
		{
			NestedTypes.Remove(type.token.RID);
		}

		public bool TryGetReverseNestedTypeMapping(TypeDefinition type, out uint declaring)
		{
			return ReverseNestedTypes.TryGetValue(type.token.RID, out declaring);
		}

		public void SetReverseNestedTypeMapping(uint nested, uint declaring)
		{
			ReverseNestedTypes[nested] = declaring;
		}

		public void RemoveReverseNestedTypeMapping(TypeDefinition type)
		{
			ReverseNestedTypes.Remove(type.token.RID);
		}

		public bool TryGetInterfaceMapping(TypeDefinition type, out Collection<Row<uint, MetadataToken>> mapping)
		{
			return Interfaces.TryGetValue(type.token.RID, out mapping);
		}

		public void SetInterfaceMapping(uint type_rid, Collection<Row<uint, MetadataToken>> mapping)
		{
			Interfaces[type_rid] = mapping;
		}

		public void RemoveInterfaceMapping(TypeDefinition type)
		{
			Interfaces.Remove(type.token.RID);
		}

		public void AddPropertiesRange(uint type_rid, Range range)
		{
			Properties.Add(type_rid, range);
		}

		public bool TryGetPropertiesRange(TypeDefinition type, out Range range)
		{
			return Properties.TryGetValue(type.token.RID, out range);
		}

		public void RemovePropertiesRange(TypeDefinition type)
		{
			Properties.Remove(type.token.RID);
		}

		public void AddEventsRange(uint type_rid, Range range)
		{
			Events.Add(type_rid, range);
		}

		public bool TryGetEventsRange(TypeDefinition type, out Range range)
		{
			return Events.TryGetValue(type.token.RID, out range);
		}

		public void RemoveEventsRange(TypeDefinition type)
		{
			Events.Remove(type.token.RID);
		}

		public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, out Range[] ranges)
		{
			return GenericParameters.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveGenericParameterRange(IGenericParameterProvider owner)
		{
			GenericParameters.Remove(owner.MetadataToken);
		}

		public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, out Range[] ranges)
		{
			return CustomAttributes.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveCustomAttributeRange(ICustomAttributeProvider owner)
		{
			CustomAttributes.Remove(owner.MetadataToken);
		}

		public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, out Range[] ranges)
		{
			return SecurityDeclarations.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner)
		{
			SecurityDeclarations.Remove(owner.MetadataToken);
		}

		public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, out Collection<Row<uint, MetadataToken>> mapping)
		{
			return GenericConstraints.TryGetValue(generic_parameter.token.RID, out mapping);
		}

		public void SetGenericConstraintMapping(uint gp_rid, Collection<Row<uint, MetadataToken>> mapping)
		{
			GenericConstraints[gp_rid] = mapping;
		}

		public void RemoveGenericConstraintMapping(GenericParameter generic_parameter)
		{
			GenericConstraints.Remove(generic_parameter.token.RID);
		}

		public bool TryGetOverrideMapping(MethodDefinition method, out Collection<MetadataToken> mapping)
		{
			return Overrides.TryGetValue(method.token.RID, out mapping);
		}

		public void SetOverrideMapping(uint rid, Collection<MetadataToken> mapping)
		{
			Overrides[rid] = mapping;
		}

		public void RemoveOverrideMapping(MethodDefinition method)
		{
			Overrides.Remove(method.token.RID);
		}

		public Document GetDocument(uint rid)
		{
			if (rid < 1 || rid > Documents.Length)
				return null;

			return Documents[rid - 1];
		}

		public bool TryGetLocalScopes(MethodDefinition method, out Collection<Row<uint, Range, Range, uint, uint, uint>> scopes)
		{
			return LocalScopes.TryGetValue(method.MetadataToken.RID, out scopes);
		}

		public void SetLocalScopes(uint method_rid, Collection<Row<uint, Range, Range, uint, uint, uint>> records)
		{
			LocalScopes[method_rid] = records;
		}

		public ImportDebugInformation GetImportScope(uint rid)
		{
			if (rid < 1 || rid > ImportScopes.Length)
				return null;

			return ImportScopes[rid - 1];
		}

		public bool TryGetStateMachineKickOffMethod(MethodDefinition method, out uint rid)
		{
			return StateMachineMethods.TryGetValue(method.MetadataToken.RID, out rid);
		}

		public TypeDefinition GetFieldDeclaringType(uint field_rid)
		{
			return BinaryRangeSearch(Types, field_rid, true);
		}

		public TypeDefinition GetMethodDeclaringType(uint method_rid)
		{
			return BinaryRangeSearch(Types, method_rid, false);
		}

		static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, uint rid, bool field)
		{
			int min = 0;
			int max = types.Length - 1;
			while (min <= max)
			{
				int mid = min + ((max - min) / 2);
				var type = types[mid];
				var range = field ? type.fields_range : type.methods_range;

				if (rid < range.Start)
					max = mid - 1;
				else if (rid >= range.Start + range.Length)
					min = mid + 1;
				else
					return type;
			}

			return null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public struct MetadataToken : IEquatable<MetadataToken>
	{

		readonly uint token;

		public uint RID
		{
			get { return token & 0x00ffffff; }
		}

		public TokenType TokenType
		{
			get { return (TokenType)(token & 0xff000000); }
		}

		public static readonly MetadataToken Zero = new MetadataToken((uint)0);

		public MetadataToken(uint token)
		{
			this.token = token;
		}

		public MetadataToken(TokenType type)
			: this(type, 0)
		{
		}

		public MetadataToken(TokenType type, uint rid)
		{
			token = (uint)type | rid;
		}

		public MetadataToken(TokenType type, int rid)
		{
			token = (uint)type | (uint)rid;
		}

		public int ToInt32()
		{
			return (int)token;
		}

		public uint ToUInt32()
		{
			return token;
		}

		public override int GetHashCode()
		{
			return (int)token;
		}

		public bool Equals(MetadataToken other)
		{
			return other.token == token;
		}

		public override bool Equals(object obj)
		{
			if (obj is MetadataToken)
			{
				var other = (MetadataToken)obj;
				return other.token == token;
			}

			return false;
		}

		public static bool operator ==(MetadataToken one, MetadataToken other)
		{
			return one.token == other.token;
		}

		public static bool operator !=(MetadataToken one, MetadataToken other)
		{
			return one.token != other.token;
		}

		public override string ToString()
		{
			return string.Format("[{0}:0x{1}]", TokenType, RID.ToString("x4"));
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum MethodAttributes : ushort
	{
		MemberAccessMask = 0x0007,
		CompilerControlled = 0x0000,    // Member not referenceable
		Private = 0x0001,   // Accessible only by the parent type
		FamANDAssem = 0x0002,   // Accessible by sub-types only in this Assembly
		Assembly = 0x0003,  // Accessibly by anyone in the Assembly
		Family = 0x0004,    // Accessible only by type and sub-types
		FamORAssem = 0x0005,    // Accessibly by sub-types anywhere, plus anyone in assembly
		Public = 0x0006,    // Accessibly by anyone who has visibility to this scope

		Static = 0x0010,    // Defined on type, else per instance
		Final = 0x0020, // Method may not be overridden
		Virtual = 0x0040,   // Method is virtual
		HideBySig = 0x0080, // Method hides by name+sig, else just by name

		VtableLayoutMask = 0x0100,  // Use this mask to retrieve vtable attributes
		ReuseSlot = 0x0000, // Method reuses existing slot in vtable
		NewSlot = 0x0100,   // Method always gets a new slot in the vtable

		CheckAccessOnOverride = 0x0200,   // Method can only be overriden if also accessible
		Abstract = 0x0400,  // Method does not provide an implementation
		SpecialName = 0x0800,   // Method is special

		// Interop Attributes
		PInvokeImpl = 0x2000,   // Implementation is forwarded through PInvoke
		UnmanagedExport = 0x0008,   // Reserved: shall be zero for conforming implementations

		// Additional flags
		RTSpecialName = 0x1000, // CLI provides 'special' behavior, depending upon the name of the method
		HasSecurity = 0x4000,   // Method has security associate with it
		RequireSecObject = 0x8000    // Method calls another method containing security code
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil.Cil
{

	public sealed class MethodBody
	{

		readonly internal MethodDefinition method;

		internal ParameterDefinition this_parameter;
		internal int max_stack_size;
		internal int code_size;
		internal bool init_locals;
		internal MetadataToken local_var_token;

		internal Collection<Instruction> instructions;
		internal Collection<ExceptionHandler> exceptions;
		internal Collection<VariableDefinition> variables;

		public MethodDefinition Method
		{
			get { return method; }
		}

		public int MaxStackSize
		{
			get { return max_stack_size; }
			set { max_stack_size = value; }
		}

		public int CodeSize
		{
			get { return code_size; }
		}

		public bool InitLocals
		{
			get { return init_locals; }
			set { init_locals = value; }
		}

		public MetadataToken LocalVarToken
		{
			get { return local_var_token; }
			set { local_var_token = value; }
		}

		public Collection<Instruction> Instructions
		{
			get
			{
				if (instructions == null)
					Interlocked.CompareExchange(ref instructions, new InstructionCollection(method), null);

				return instructions;
			}
		}

		public bool HasExceptionHandlers
		{
			get { return !exceptions.IsNullOrEmpty(); }
		}

		public Collection<ExceptionHandler> ExceptionHandlers
		{
			get
			{
				if (exceptions == null)
					Interlocked.CompareExchange(ref exceptions, new Collection<ExceptionHandler>(), null);

				return exceptions;
			}
		}

		public bool HasVariables
		{
			get { return !variables.IsNullOrEmpty(); }
		}

		public Collection<VariableDefinition> Variables
		{
			get
			{
				if (variables == null)
					Interlocked.CompareExchange(ref variables, new VariableDefinitionCollection(this.method), null);

				return variables;
			}
		}

		public ParameterDefinition ThisParameter
		{
			get
			{
				if (method == null || method.DeclaringType == null)
					throw new NotSupportedException();

				if (!method.HasThis)
					return null;

				if (this_parameter == null)
					Interlocked.CompareExchange(ref this_parameter, CreateThisParameter(method), null);

				return this_parameter;
			}
		}

		static ParameterDefinition CreateThisParameter(MethodDefinition method)
		{
			var parameter_type = method.DeclaringType as TypeReference;

			if (parameter_type.HasGenericParameters)
			{
				var instance = new GenericInstanceType(parameter_type, parameter_type.GenericParameters.Count);
				for (int i = 0; i < parameter_type.GenericParameters.Count; i++)
					instance.GenericArguments.Add(parameter_type.GenericParameters[i]);

				parameter_type = instance;

			}

			if (parameter_type.IsValueType || parameter_type.IsPrimitive)
				parameter_type = new ByReferenceType(parameter_type);

			return new ParameterDefinition(parameter_type, method);
		}

		public MethodBody(MethodDefinition method)
		{
			this.method = method;
		}

		public ILProcessor GetILProcessor()
		{
			return new ILProcessor(this);
		}
	}

	sealed class VariableDefinitionCollection : Collection<VariableDefinition>
	{

		readonly MethodDefinition method;

		internal VariableDefinitionCollection(MethodDefinition method)
		{
			this.method = method;
		}

		internal VariableDefinitionCollection(MethodDefinition method, int capacity)
			: base(capacity)
		{
			this.method = method;
		}

		protected override void OnAdd(VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnInsert(VariableDefinition item, int index)
		{
			item.index = index;
			UpdateVariableIndices(index, 1);
		}

		protected override void OnSet(VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnRemove(VariableDefinition item, int index)
		{
			UpdateVariableIndices(index + 1, -1, item);
			item.index = -1;
		}

		void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove = null)
		{
			for (int i = startIndex; i < size; i++)
				items[i].index = i + offset;

			var debug_info = method == null ? null : method.debug_info;
			if (debug_info == null || debug_info.Scope == null)
				return;

			foreach (var scope in debug_info.GetScopes())
			{
				if (!scope.HasVariables)
					continue;

				var variables = scope.Variables;
				int variableDebugInfoIndexToRemove = -1;
				for (int i = 0; i < variables.Count; i++)
				{
					var variable = variables[i];

					// If a variable is being removed detect if it has debug info counterpart, if so remove that as well.
					// Note that the debug info can be either resolved (has direct reference to the VariableDefinition)
					// or unresolved (has only the number index of the variable) - this needs to handle both cases.
					if (variableToRemove != null &&
						((variable.index.IsResolved && variable.index.ResolvedVariable == variableToRemove) ||
							(!variable.index.IsResolved && variable.Index == variableToRemove.Index)))
					{
						variableDebugInfoIndexToRemove = i;
						continue;
					}

					// For unresolved debug info updates indeces to keep them pointing to the same variable.
					if (!variable.index.IsResolved && variable.Index >= startIndex)
					{
						variable.index = new VariableIndex(variable.Index + offset);
					}
				}

				if (variableDebugInfoIndexToRemove >= 0)
					variables.RemoveAt(variableDebugInfoIndexToRemove);
			}
		}
	}

	class InstructionCollection : Collection<Instruction>
	{

		readonly MethodDefinition method;

		internal InstructionCollection(MethodDefinition method)
		{
			this.method = method;
		}

		internal InstructionCollection(MethodDefinition method, int capacity)
			: base(capacity)
		{
			this.method = method;
		}

		protected override void OnAdd(Instruction item, int index)
		{
			if (index == 0)
				return;

			var previous = items[index - 1];
			previous.next = item;
			item.previous = previous;
		}

		protected override void OnInsert(Instruction item, int index)
		{
			int startOffset = 0;
			if (size != 0)
			{
				var current = items[index];
				if (current == null)
				{
					var last = items[index - 1];
					last.next = item;
					item.previous = last;
					return;
				}

				startOffset = current.Offset;

				var previous = current.previous;
				if (previous != null)
				{
					previous.next = item;
					item.previous = previous;
				}

				current.previous = item;
				item.next = current;
			}

			UpdateLocalScopes(null, null);
		}

		protected override void OnSet(Instruction item, int index)
		{
			var current = items[index];

			item.previous = current.previous;
			item.next = current.next;

			current.previous = null;
			current.next = null;

			UpdateLocalScopes(item, current);
		}

		protected override void OnRemove(Instruction item, int index)
		{
			var previous = item.previous;
			if (previous != null)
				previous.next = item.next;

			var next = item.next;
			if (next != null)
				next.previous = item.previous;

			RemoveSequencePoint(item);
			UpdateLocalScopes(item, next ?? previous);

			item.previous = null;
			item.next = null;
		}

		void RemoveSequencePoint(Instruction instruction)
		{
			var debug_info = method.debug_info;
			if (debug_info == null || !debug_info.HasSequencePoints)
				return;

			var sequence_points = debug_info.sequence_points;
			for (int i = 0; i < sequence_points.Count; i++)
			{
				if (sequence_points[i].Offset == instruction.offset)
				{
					sequence_points.RemoveAt(i);
					return;
				}
			}
		}

		void UpdateLocalScopes(Instruction removedInstruction, Instruction existingInstruction)
		{
			var debug_info = method.debug_info;
			if (debug_info == null)
				return;

			// Local scopes store start/end pair of "instruction offsets". Instruction offset can be either resolved, in which case it 
			// has a reference to Instruction, or unresolved in which case it stores numerical offset (instruction offset in the body).
			// Typically local scopes loaded from PE/PDB files will be resolved, but it's not a requirement.
			// Each instruction has its own offset, which is populated on load, but never updated (this would be pretty expensive to do).
			// Instructions created during the editting will typically have offset 0 (so incorrect).
			// Local scopes created during editing will also likely be resolved (so no numerical offsets).
			// So while local scopes which are unresolved are relatively rare if they appear, manipulating them based
			// on the offsets allone is pretty hard (since we can't rely on correct offsets of instructions).
			// On the other hand resolved local scopes are easy to maintain, since they point to instructions and thus inserting
			// instructions is basically a no-op and removing instructions is as easy as changing the pointer.
			// For this reason the algorithm here is:
			//  - First make sure that all instruction offsets are resolved - if not - resolve them
			//     - First time this will be relatively expensinve as it will walk the entire method body to convert offsets to instruction pointers
			//       Almost all local scopes are stored in the "right" order (sequentially per start offsets), so the code uses a simple one-item
			//       cache instruction<->offset to avoid walking instructions multiple times (that would only happen for scopes which are out of order).
			//     - Subsequent calls should be cheap as it will only walk all local scopes without doing anything
			//     - If there was an edit on local scope which makes some of them unresolved, the cost is proportional
			//  - Then update as necessary by manipulaitng instruction references alone

			InstructionOffsetCache cache = new InstructionOffsetCache()
			{
				Offset = 0,
				Index = 0,
				Instruction = items[0]
			};

			UpdateLocalScope(debug_info.Scope, removedInstruction, existingInstruction, ref cache);
		}

		void UpdateLocalScope(ScopeDebugInformation scope, Instruction removedInstruction, Instruction existingInstruction, ref InstructionOffsetCache cache)
		{
			if (scope == null)
				return;

			if (!scope.Start.IsResolved)
				scope.Start = ResolveInstructionOffset(scope.Start, ref cache);

			if (!scope.Start.IsEndOfMethod && scope.Start.ResolvedInstruction == removedInstruction)
				scope.Start = new InstructionOffset(existingInstruction);

			if (scope.HasScopes)
			{
				foreach (var subScope in scope.Scopes)
					UpdateLocalScope(subScope, removedInstruction, existingInstruction, ref cache);
			}

			if (!scope.End.IsResolved)
				scope.End = ResolveInstructionOffset(scope.End, ref cache);

			if (!scope.End.IsEndOfMethod && scope.End.ResolvedInstruction == removedInstruction)
				scope.End = new InstructionOffset(existingInstruction);
		}

		struct InstructionOffsetCache
		{
			public int Offset;
			public int Index;
			public Instruction Instruction;
		}

		InstructionOffset ResolveInstructionOffset(InstructionOffset inputOffset, ref InstructionOffsetCache cache)
		{
			if (inputOffset.IsResolved)
				return inputOffset;

			int offset = inputOffset.Offset;

			if (cache.Offset == offset)
				return new InstructionOffset(cache.Instruction);

			if (cache.Offset > offset)
			{
				// This should be rare - we're resolving offset pointing to a place before the current cache position
				// resolve by walking the instructions from start and don't cache the result.
				int size = 0;
				for (int i = 0; i < items.Length; i++)
				{
					if (size == offset)
						return new InstructionOffset(items[i]);

					if (size > offset)
						return new InstructionOffset(items[i - 1]);

					size += items[i].GetSize();
				}

				// Offset is larger than the size of the body - so it points after the end
				return new InstructionOffset();
			}
			else
			{
				// The offset points after the current cache position - so continue counting and update the cache
				int size = cache.Offset;
				for (int i = cache.Index; i < items.Length; i++)
				{
					cache.Index = i;
					cache.Offset = size;

					var item = items[i];

					// Allow for trailing null values in the case of
					// instructions.Size < instructions.Capacity
					if (item == null)
						break;

					cache.Instruction = item;

					if (cache.Offset == offset)
						return new InstructionOffset(cache.Instruction);

					if (cache.Offset > offset)
						return new InstructionOffset(items[i - 1]);

					size += item.GetSize();
				}

				return new InstructionOffset();
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class MethodBodyRocks
	{

		public static void SimplifyMacros(this Mono.Cecil.Cil.MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			foreach (var instruction in self.Instructions)
			{
				if (instruction.OpCode.OpCodeType != Mono.Cecil.Cil.OpCodeType.Macro)
					continue;

				switch (instruction.OpCode.Code)
				{
					case Code.Ldarg_0:
						ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(0));
						break;
					case Code.Ldarg_1:
						ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(1));
						break;
					case Code.Ldarg_2:
						ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(2));
						break;
					case Code.Ldarg_3:
						ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(3));
						break;
					case Code.Ldloc_0:
						ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[0]);
						break;
					case Code.Ldloc_1:
						ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[1]);
						break;
					case Code.Ldloc_2:
						ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[2]);
						break;
					case Code.Ldloc_3:
						ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[3]);
						break;
					case Code.Stloc_0:
						ExpandMacro(instruction, OpCodes.Stloc, self.Variables[0]);
						break;
					case Code.Stloc_1:
						ExpandMacro(instruction, OpCodes.Stloc, self.Variables[1]);
						break;
					case Code.Stloc_2:
						ExpandMacro(instruction, OpCodes.Stloc, self.Variables[2]);
						break;
					case Code.Stloc_3:
						ExpandMacro(instruction, OpCodes.Stloc, self.Variables[3]);
						break;
					case Code.Ldarg_S:
						instruction.OpCode = OpCodes.Ldarg;
						break;
					case Code.Ldarga_S:
						instruction.OpCode = OpCodes.Ldarga;
						break;
					case Code.Starg_S:
						instruction.OpCode = OpCodes.Starg;
						break;
					case Code.Ldloc_S:
						instruction.OpCode = OpCodes.Ldloc;
						break;
					case Code.Ldloca_S:
						instruction.OpCode = OpCodes.Ldloca;
						break;
					case Code.Stloc_S:
						instruction.OpCode = OpCodes.Stloc;
						break;
					case Code.Ldc_I4_M1:
						ExpandMacro(instruction, OpCodes.Ldc_I4, -1);
						break;
					case Code.Ldc_I4_0:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 0);
						break;
					case Code.Ldc_I4_1:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 1);
						break;
					case Code.Ldc_I4_2:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 2);
						break;
					case Code.Ldc_I4_3:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 3);
						break;
					case Code.Ldc_I4_4:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 4);
						break;
					case Code.Ldc_I4_5:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 5);
						break;
					case Code.Ldc_I4_6:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 6);
						break;
					case Code.Ldc_I4_7:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 7);
						break;
					case Code.Ldc_I4_8:
						ExpandMacro(instruction, OpCodes.Ldc_I4, 8);
						break;
					case Code.Ldc_I4_S:
						ExpandMacro(instruction, OpCodes.Ldc_I4, (int)(sbyte)instruction.Operand);
						break;
					case Code.Br_S:
						instruction.OpCode = OpCodes.Br;
						break;
					case Code.Brfalse_S:
						instruction.OpCode = OpCodes.Brfalse;
						break;
					case Code.Brtrue_S:
						instruction.OpCode = OpCodes.Brtrue;
						break;
					case Code.Beq_S:
						instruction.OpCode = OpCodes.Beq;
						break;
					case Code.Bge_S:
						instruction.OpCode = OpCodes.Bge;
						break;
					case Code.Bgt_S:
						instruction.OpCode = OpCodes.Bgt;
						break;
					case Code.Ble_S:
						instruction.OpCode = OpCodes.Ble;
						break;
					case Code.Blt_S:
						instruction.OpCode = OpCodes.Blt;
						break;
					case Code.Bne_Un_S:
						instruction.OpCode = OpCodes.Bne_Un;
						break;
					case Code.Bge_Un_S:
						instruction.OpCode = OpCodes.Bge_Un;
						break;
					case Code.Bgt_Un_S:
						instruction.OpCode = OpCodes.Bgt_Un;
						break;
					case Code.Ble_Un_S:
						instruction.OpCode = OpCodes.Ble_Un;
						break;
					case Code.Blt_Un_S:
						instruction.OpCode = OpCodes.Blt_Un;
						break;
					case Code.Leave_S:
						instruction.OpCode = OpCodes.Leave;
						break;
				}
			}
		}

		static void ExpandMacro(Instruction instruction, OpCode opcode, object operand)
		{
			instruction.OpCode = opcode;
			instruction.Operand = operand;
		}

		static void MakeMacro(Instruction instruction, OpCode opcode)
		{
			instruction.OpCode = opcode;
			instruction.Operand = null;
		}

		public static void Optimize(this Mono.Cecil.Cil.MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			OptimizeLongs(self);
			OptimizeMacros(self);
		}

		static void OptimizeLongs(this Mono.Cecil.Cil.MethodBody self)
		{
			for (var i = 0; i < self.Instructions.Count; i++)
			{
				var instruction = self.Instructions[i];
				if (instruction.OpCode.Code != Code.Ldc_I8)
					continue;
				var l = (long)instruction.Operand;
				if (l >= int.MaxValue || l <= int.MinValue)
					continue;
				ExpandMacro(instruction, OpCodes.Ldc_I4, (int)l);
				self.Instructions.Insert(++i, Instruction.Create(OpCodes.Conv_I8));
			}
		}

		public static void OptimizeMacros(this Mono.Cecil.Cil.MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			var method = self.Method;

			foreach (var instruction in self.Instructions)
			{
				int index;
				switch (instruction.OpCode.Code)
				{
					case Code.Ldarg:
						index = ((ParameterDefinition)instruction.Operand).Index;
						if (index == -1 && instruction.Operand == self.ThisParameter)
							index = 0;
						else if (method.HasThis)
							index++;

						switch (index)
						{
							case 0:
								MakeMacro(instruction, OpCodes.Ldarg_0);
								break;
							case 1:
								MakeMacro(instruction, OpCodes.Ldarg_1);
								break;
							case 2:
								MakeMacro(instruction, OpCodes.Ldarg_2);
								break;
							case 3:
								MakeMacro(instruction, OpCodes.Ldarg_3);
								break;
							default:
								if (index < 256)
									ExpandMacro(instruction, OpCodes.Ldarg_S, instruction.Operand);
								break;
						}
						break;
					case Code.Ldloc:
						index = ((VariableDefinition)instruction.Operand).Index;
						switch (index)
						{
							case 0:
								MakeMacro(instruction, OpCodes.Ldloc_0);
								break;
							case 1:
								MakeMacro(instruction, OpCodes.Ldloc_1);
								break;
							case 2:
								MakeMacro(instruction, OpCodes.Ldloc_2);
								break;
							case 3:
								MakeMacro(instruction, OpCodes.Ldloc_3);
								break;
							default:
								if (index < 256)
									ExpandMacro(instruction, OpCodes.Ldloc_S, instruction.Operand);
								break;
						}
						break;
					case Code.Stloc:
						index = ((VariableDefinition)instruction.Operand).Index;
						switch (index)
						{
							case 0:
								MakeMacro(instruction, OpCodes.Stloc_0);
								break;
							case 1:
								MakeMacro(instruction, OpCodes.Stloc_1);
								break;
							case 2:
								MakeMacro(instruction, OpCodes.Stloc_2);
								break;
							case 3:
								MakeMacro(instruction, OpCodes.Stloc_3);
								break;
							default:
								if (index < 256)
									ExpandMacro(instruction, OpCodes.Stloc_S, instruction.Operand);
								break;
						}
						break;
					case Code.Ldarga:
						index = ((ParameterDefinition)instruction.Operand).Index;
						if (index == -1 && instruction.Operand == self.ThisParameter)
							index = 0;
						else if (method.HasThis)
							index++;
						if (index < 256)
							ExpandMacro(instruction, OpCodes.Ldarga_S, instruction.Operand);
						break;
					case Code.Ldloca:
						if (((VariableDefinition)instruction.Operand).Index < 256)
							ExpandMacro(instruction, OpCodes.Ldloca_S, instruction.Operand);
						break;
					case Code.Ldc_I4:
						int i = (int)instruction.Operand;
						switch (i)
						{
							case -1:
								MakeMacro(instruction, OpCodes.Ldc_I4_M1);
								break;
							case 0:
								MakeMacro(instruction, OpCodes.Ldc_I4_0);
								break;
							case 1:
								MakeMacro(instruction, OpCodes.Ldc_I4_1);
								break;
							case 2:
								MakeMacro(instruction, OpCodes.Ldc_I4_2);
								break;
							case 3:
								MakeMacro(instruction, OpCodes.Ldc_I4_3);
								break;
							case 4:
								MakeMacro(instruction, OpCodes.Ldc_I4_4);
								break;
							case 5:
								MakeMacro(instruction, OpCodes.Ldc_I4_5);
								break;
							case 6:
								MakeMacro(instruction, OpCodes.Ldc_I4_6);
								break;
							case 7:
								MakeMacro(instruction, OpCodes.Ldc_I4_7);
								break;
							case 8:
								MakeMacro(instruction, OpCodes.Ldc_I4_8);
								break;
							default:
								if (i >= -128 && i < 128)
									ExpandMacro(instruction, OpCodes.Ldc_I4_S, (sbyte)i);
								break;
						}
						break;
				}
			}

			OptimizeBranches(self);
		}

		static void OptimizeBranches(Mono.Cecil.Cil.MethodBody body)
		{
			ComputeOffsets(body);

			foreach (var instruction in body.Instructions)
			{
				if (instruction.OpCode.OperandType != Mono.Cecil.Cil.OperandType.InlineBrTarget)
					continue;

				if (OptimizeBranch(instruction))
					ComputeOffsets(body);
			}
		}

		static bool OptimizeBranch(Instruction instruction)
		{
			var offset = ((Instruction)instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
			if (!(offset >= -128 && offset <= 127))
				return false;

			switch (instruction.OpCode.Code)
			{
				case Code.Br:
					instruction.OpCode = OpCodes.Br_S;
					break;
				case Code.Brfalse:
					instruction.OpCode = OpCodes.Brfalse_S;
					break;
				case Code.Brtrue:
					instruction.OpCode = OpCodes.Brtrue_S;
					break;
				case Code.Beq:
					instruction.OpCode = OpCodes.Beq_S;
					break;
				case Code.Bge:
					instruction.OpCode = OpCodes.Bge_S;
					break;
				case Code.Bgt:
					instruction.OpCode = OpCodes.Bgt_S;
					break;
				case Code.Ble:
					instruction.OpCode = OpCodes.Ble_S;
					break;
				case Code.Blt:
					instruction.OpCode = OpCodes.Blt_S;
					break;
				case Code.Bne_Un:
					instruction.OpCode = OpCodes.Bne_Un_S;
					break;
				case Code.Bge_Un:
					instruction.OpCode = OpCodes.Bge_Un_S;
					break;
				case Code.Bgt_Un:
					instruction.OpCode = OpCodes.Bgt_Un_S;
					break;
				case Code.Ble_Un:
					instruction.OpCode = OpCodes.Ble_Un_S;
					break;
				case Code.Blt_Un:
					instruction.OpCode = OpCodes.Blt_Un_S;
					break;
				case Code.Leave:
					instruction.OpCode = OpCodes.Leave_S;
					break;
			}

			return true;
		}

		static void ComputeOffsets(Mono.Cecil.Cil.MethodBody body)
		{
			var offset = 0;
			foreach (var instruction in body.Instructions)
			{
				instruction.Offset = offset;
				offset += instruction.GetSize();
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum MethodCallingConvention : byte
	{
		Default = 0x0,
		C = 0x1,
		StdCall = 0x2,
		ThisCall = 0x3,
		FastCall = 0x4,
		VarArg = 0x5,
		Generic = 0x10,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//








namespace Mono.Cecil
{

	public sealed class MethodDefinition : MethodReference, IMemberDefinition, ISecurityDeclarationProvider, ICustomDebugInformationProvider
	{

		ushort attributes;
		ushort impl_attributes;
		internal volatile bool sem_attrs_ready;
		internal MethodSemanticsAttributes sem_attrs;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		internal RVA rva;
		internal PInvokeInfo pinvoke;
		Collection<MethodReference> overrides;

		internal Mono.Cecil.Cil.MethodBody body;
		internal MethodDebugInformation debug_info;
		internal Collection<CustomDebugInformation> custom_infos;

		public override string Name
		{
			get { return base.Name; }
			set
			{
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException();

				base.Name = value;
			}
		}

		public MethodAttributes Attributes
		{
			get { return (MethodAttributes)attributes; }
			set
			{
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException();

				attributes = (ushort)value;
			}
		}

		public MethodImplAttributes ImplAttributes
		{
			get { return (MethodImplAttributes)impl_attributes; }
			set
			{
				if (IsWindowsRuntimeProjection && (ushort)value != impl_attributes)
					throw new InvalidOperationException();

				impl_attributes = (ushort)value;
			}
		}

		public MethodSemanticsAttributes SemanticsAttributes
		{
			get
			{
				if (sem_attrs_ready)
					return sem_attrs;

				if (HasImage)
				{
					ReadSemantics();
					return sem_attrs;
				}

				sem_attrs = MethodSemanticsAttributes.None;
				sem_attrs_ready = true;
				return sem_attrs;
			}
			set { sem_attrs = value; }
		}

		internal MethodDefinitionProjection WindowsRuntimeProjection
		{
			get { return (MethodDefinitionProjection)projection; }
			set { projection = value; }
		}

		internal void ReadSemantics()
		{
			if (sem_attrs_ready)
				return;

			var module = this.Module;
			if (module == null)
				return;

			if (!module.HasImage)
				return;

			lock (module.SyncRoot)
			{
				if (sem_attrs_ready)
					return;

				module.Read(this, (method, reader) => reader.ReadAllSemantics(method));
			}
		}

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations(Module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations
		{
			get { return security_declarations ?? (this.GetSecurityDeclarations(ref security_declarations, Module)); }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		public int RVA
		{
			get { return (int)rva; }
		}

		public bool HasBody
		{
			get
			{
				return (attributes & (ushort)MethodAttributes.Abstract) == 0 &&
					(attributes & (ushort)MethodAttributes.PInvokeImpl) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.InternalCall) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Native) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Unmanaged) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Runtime) == 0;
			}
		}

		public Mono.Cecil.Cil.MethodBody Body
		{
			get
			{
				var local = this.body;
				if (local != null)
					return local;

				if (!HasBody)
					return null;

				if (HasImage && rva != 0)
					return Module.Read(ref body, this, (method, reader) => reader.ReadMethodBody(method));

				Interlocked.CompareExchange(ref body, new Mono.Cecil.Cil.MethodBody(this), null);

				return body;
			}
			set
			{
				var module = this.Module;
				if (module == null)
				{
					body = value;
					return;
				}

				// we reset Body to null in ILSpy to save memory; so we need that operation to be thread-safe
				lock (module.SyncRoot)
				{
					body = value;
					if (value == null)
						this.debug_info = null;
				}
			}
		}

		public MethodDebugInformation DebugInformation
		{
			get
			{
				Mixin.Read(Body);

				if (debug_info == null)
				{
					Interlocked.CompareExchange(ref debug_info, new MethodDebugInformation(this), null);
				}

				return debug_info;
			}
			set
			{
				debug_info = value;
			}
		}

		public bool HasPInvokeInfo
		{
			get
			{
				if (pinvoke != null)
					return true;

				return IsPInvokeImpl;
			}
		}

		public PInvokeInfo PInvokeInfo
		{
			get
			{
				if (pinvoke != null)
					return pinvoke;

				if (HasImage && IsPInvokeImpl)
					return Module.Read(ref pinvoke, this, (method, reader) => reader.ReadPInvokeInfo(method));

				return null;
			}
			set
			{
				IsPInvokeImpl = true;
				pinvoke = value;
			}
		}

		public bool HasOverrides
		{
			get
			{
				if (overrides != null)
					return overrides.Count > 0;

				return HasImage && Module.Read(this, (method, reader) => reader.HasOverrides(method));
			}
		}

		public Collection<MethodReference> Overrides
		{
			get
			{
				if (overrides != null)
					return overrides;

				if (HasImage)
					return Module.Read(ref overrides, this, (method, reader) => reader.ReadOverrides(method));

				Interlocked.CompareExchange(ref overrides, new Collection<MethodReference>(), null);

				return overrides;
			}
		}

		public override bool HasGenericParameters
		{
			get
			{
				if (generic_parameters != null)
					return generic_parameters.Count > 0;

				return this.GetHasGenericParameters(Module);
			}
		}

		public override Collection<GenericParameter> GenericParameters
		{
			get { return generic_parameters ?? (this.GetGenericParameters(ref generic_parameters, Module)); }
		}

		public bool HasCustomDebugInformations
		{
			get
			{
				Mixin.Read(Body);

				return !custom_infos.IsNullOrEmpty();
			}
		}

		public Collection<CustomDebugInformation> CustomDebugInformations
		{
			get
			{
				Mixin.Read(Body);

				if (custom_infos == null)
					Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);

				return custom_infos;
			}
		}

		#region MethodAttributes

		public bool IsCompilerControlled
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.CompilerControlled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.CompilerControlled, value); }
		}

		public bool IsPrivate
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Private, value); }
		}

		public bool IsFamilyAndAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamANDAssem, value); }
		}

		public bool IsAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Assembly); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Assembly, value); }
		}

		public bool IsFamily
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Family); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Family, value); }
		}

		public bool IsFamilyOrAssembly
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamORAssem); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamORAssem, value); }
		}

		public bool IsPublic
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Public, value); }
		}

		public bool IsStatic
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.Static); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.Static, value); }
		}

		public bool IsFinal
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.Final); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.Final, value); }
		}

		public bool IsVirtual
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.Virtual); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.Virtual, value); }
		}

		public bool IsHideBySig
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.HideBySig); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.HideBySig, value); }
		}

		public bool IsReuseSlot
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.ReuseSlot); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.ReuseSlot, value); }
		}

		public bool IsNewSlot
		{
			get { return attributes.GetMaskedAttributes((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.NewSlot); }
			set { attributes = attributes.SetMaskedAttributes((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.NewSlot, value); }
		}

		public bool IsCheckAccessOnOverride
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.CheckAccessOnOverride); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.CheckAccessOnOverride, value); }
		}

		public bool IsAbstract
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.Abstract); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.Abstract, value); }
		}

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.SpecialName, value); }
		}

		public bool IsPInvokeImpl
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.PInvokeImpl); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.PInvokeImpl, value); }
		}

		public bool IsUnmanagedExport
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.UnmanagedExport); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.UnmanagedExport, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity
		{
			get { return attributes.GetAttributes((ushort)MethodAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes((ushort)MethodAttributes.HasSecurity, value); }
		}

		#endregion

		#region MethodImplAttributes

		public bool IsIL
		{
			get { return impl_attributes.GetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.IL); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.IL, value); }
		}

		public bool IsNative
		{
			get { return impl_attributes.GetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Native); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Native, value); }
		}

		public bool IsRuntime
		{
			get { return impl_attributes.GetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Runtime); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Runtime, value); }
		}

		public bool IsUnmanaged
		{
			get { return impl_attributes.GetMaskedAttributes((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Unmanaged); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Unmanaged, value); }
		}

		public bool IsManaged
		{
			get { return impl_attributes.GetMaskedAttributes((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Managed); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Managed, value); }
		}

		public bool IsForwardRef
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.ForwardRef); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.ForwardRef, value); }
		}

		public bool IsPreserveSig
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.PreserveSig); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.PreserveSig, value); }
		}

		public bool IsInternalCall
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.InternalCall); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.InternalCall, value); }
		}

		public bool IsSynchronized
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.Synchronized); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.Synchronized, value); }
		}

		public bool NoInlining
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.NoInlining); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.NoInlining, value); }
		}

		public bool NoOptimization
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.NoOptimization); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.NoOptimization, value); }
		}

		public bool AggressiveInlining
		{
			get { return impl_attributes.GetAttributes((ushort)MethodImplAttributes.AggressiveInlining); }
			set { impl_attributes = impl_attributes.SetAttributes((ushort)MethodImplAttributes.AggressiveInlining, value); }
		}

		#endregion

		#region MethodSemanticsAttributes

		public bool IsSetter
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.Setter); }
			set { this.SetSemantics(MethodSemanticsAttributes.Setter, value); }
		}

		public bool IsGetter
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.Getter); }
			set { this.SetSemantics(MethodSemanticsAttributes.Getter, value); }
		}

		public bool IsOther
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.Other); }
			set { this.SetSemantics(MethodSemanticsAttributes.Other, value); }
		}

		public bool IsAddOn
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.AddOn); }
			set { this.SetSemantics(MethodSemanticsAttributes.AddOn, value); }
		}

		public bool IsRemoveOn
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.RemoveOn); }
			set { this.SetSemantics(MethodSemanticsAttributes.RemoveOn, value); }
		}

		public bool IsFire
		{
			get { return this.GetSemantics(MethodSemanticsAttributes.Fire); }
			set { this.SetSemantics(MethodSemanticsAttributes.Fire, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType
		{
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public bool IsConstructor
		{
			get
			{
				return this.IsRuntimeSpecialName
					&& this.IsSpecialName
					&& (this.Name == ".cctor" || this.Name == ".ctor");
			}
		}

		public override bool IsDefinition
		{
			get { return true; }
		}

		internal MethodDefinition()
		{
			this.token = new MetadataToken(TokenType.Method);
		}

		public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType)
			: base(name, returnType)
		{
			this.attributes = (ushort)attributes;
			this.HasThis = !this.IsStatic;
			this.token = new MetadataToken(TokenType.Method);
		}

		public override MethodDefinition Resolve()
		{
			return this;
		}
	}

	static partial class Mixin
	{

		public static ParameterDefinition GetParameter(this Mono.Cecil.Cil.MethodBody self, int index)
		{
			var method = self.method;

			if (method.HasThis)
			{
				if (index == 0)
					return self.ThisParameter;

				index--;
			}

			var parameters = method.Parameters;

			if (index < 0 || index >= parameters.size)
				return null;

			return parameters[index];
		}

		public static VariableDefinition GetVariable(this Mono.Cecil.Cil.MethodBody self, int index)
		{
			var variables = self.Variables;

			if (index < 0 || index >= variables.size)
				return null;

			return variables[index];
		}

		public static bool GetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics)
		{
			return (self.SemanticsAttributes & semantics) != 0;
		}

		public static void SetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
		{
			if (value)
				self.SemanticsAttributes |= semantics;
			else
				self.SemanticsAttributes &= ~semantics;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class MethodDefinitionRocks
	{

		public static MethodDefinition GetBaseMethod(this MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");
			if (!self.IsVirtual)
				return self;
			if (self.IsNewSlot)
				return self;

			var base_type = ResolveBaseType(self.DeclaringType);
			while (base_type != null)
			{
				var @base = GetMatchingMethod(base_type, self);
				if (@base != null)
					return @base;

				base_type = ResolveBaseType(base_type);
			}

			return self;
		}

		public static MethodDefinition GetOriginalBaseMethod(this MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			while (true)
			{
				var @base = self.GetBaseMethod();
				if (@base == self)
					return self;

				self = @base;
			}
		}

		static TypeDefinition ResolveBaseType(TypeDefinition type)
		{
			if (type == null)
				return null;

			var base_type = type.BaseType;
			if (base_type == null)
				return null;

			return base_type.Resolve();
		}

		static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
		{
			return MetadataResolver.GetMethod(type.Methods, method);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum MethodImplAttributes : ushort
	{
		CodeTypeMask = 0x0003,
		IL = 0x0000,    // Method impl is CIL
		Native = 0x0001,    // Method impl is native
		OPTIL = 0x0002, // Reserved: shall be zero in conforming implementations
		Runtime = 0x0003,   // Method impl is provided by the runtime

		ManagedMask = 0x0004,   // Flags specifying whether the code is managed or unmanaged
		Unmanaged = 0x0004, // Method impl is unmanaged, otherwise managed
		Managed = 0x0000,   // Method impl is managed

		// Implementation info and interop
		ForwardRef = 0x0010,    // Indicates method is defined; used primarily in merge scenarios
		PreserveSig = 0x0080,   // Reserved: conforming implementations may ignore
		InternalCall = 0x1000,  // Reserved: shall be zero in conforming implementations
		Synchronized = 0x0020,  // Method is single threaded through the body
		NoOptimization = 0x0040,    // Method is not optimized by the JIT.
		NoInlining = 0x0008,    // Method may not be inlined
		AggressiveInlining = 0x0100,   // Method should be inlined, if possible.
		All = CodeTypeMask | IL | Native | OPTIL | Runtime | ManagedMask | Unmanaged | Managed | ForwardRef | PreserveSig | InternalCall | Synchronized | NoOptimization | NoInlining | AggressiveInlining,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public class MethodReference : MemberReference, IMethodSignature, IGenericParameterProvider, IGenericContext
	{

		internal ParameterDefinitionCollection parameters;
		MethodReturnType return_type;

		bool has_this;
		bool explicit_this;
		MethodCallingConvention calling_convention;
		internal Collection<GenericParameter> generic_parameters;

		public virtual bool HasThis
		{
			get { return has_this; }
			set { has_this = value; }
		}

		public virtual bool ExplicitThis
		{
			get { return explicit_this; }
			set { explicit_this = value; }
		}

		public virtual MethodCallingConvention CallingConvention
		{
			get { return calling_convention; }
			set { calling_convention = value; }
		}

		public virtual bool HasParameters
		{
			get { return !parameters.IsNullOrEmpty(); }
		}

		public virtual Collection<ParameterDefinition> Parameters
		{
			get
			{
				if (parameters == null)
					Interlocked.CompareExchange(ref parameters, new ParameterDefinitionCollection(this), null);

				return parameters;
			}
		}

		IGenericParameterProvider IGenericContext.Type
		{
			get
			{
				var declaring_type = this.DeclaringType;
				var instance = declaring_type as GenericInstanceType;
				if (instance != null)
					return instance.ElementType;

				return declaring_type;
			}
		}

		IGenericParameterProvider IGenericContext.Method
		{
			get { return this; }
		}

		GenericParameterType IGenericParameterProvider.GenericParameterType
		{
			get { return GenericParameterType.Method; }
		}

		public virtual bool HasGenericParameters
		{
			get { return !generic_parameters.IsNullOrEmpty(); }
		}

		public virtual Collection<GenericParameter> GenericParameters
		{
			get
			{
				if (generic_parameters == null)
					Interlocked.CompareExchange(ref generic_parameters, new GenericParameterCollection(this), null);

				return generic_parameters;
			}
		}

		public TypeReference ReturnType
		{
			get
			{
				var return_type = MethodReturnType;
				return return_type != null ? return_type.ReturnType : null;
			}
			set
			{
				var return_type = MethodReturnType;
				if (return_type != null)
					return_type.ReturnType = value;
			}
		}

		public virtual MethodReturnType MethodReturnType
		{
			get { return return_type; }
			set { return_type = value; }
		}

		public override string FullName
		{
			get
			{
				var builder = new StringBuilder();
				builder.Append(ReturnType.FullName)
					.Append(" ")
					.Append(MemberFullName());
				this.MethodSignatureFullName(builder);
				return builder.ToString();
			}
		}

		public virtual bool IsGenericInstance
		{
			get { return false; }
		}

		public override bool ContainsGenericParameter
		{
			get
			{
				if (this.ReturnType.ContainsGenericParameter || base.ContainsGenericParameter)
					return true;

				if (!HasParameters)
					return false;

				var parameters = this.Parameters;

				for (int i = 0; i < parameters.Count; i++)
					if (parameters[i].ParameterType.ContainsGenericParameter)
						return true;

				return false;
			}
		}

		internal MethodReference()
		{
			this.return_type = new MethodReturnType(this);
			this.token = new MetadataToken(TokenType.MemberRef);
		}

		public MethodReference(string name, TypeReference returnType)
			: base(name)
		{
			Mixin.CheckType(returnType, Mixin.Argument.returnType);

			this.return_type = new MethodReturnType(this);
			this.return_type.ReturnType = returnType;
			this.token = new MetadataToken(TokenType.MemberRef);
		}

		public MethodReference(string name, TypeReference returnType, TypeReference declaringType)
			: this(name, returnType)
		{
			Mixin.CheckType(declaringType, Mixin.Argument.declaringType);

			this.DeclaringType = declaringType;
		}

		public virtual MethodReference GetElementMethod()
		{
			return this;
		}

		protected override IMemberDefinition ResolveDefinition()
		{
			return this.Resolve();
		}

		public new virtual MethodDefinition Resolve()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException();

			return module.Resolve(this);
		}
	}

	static partial class Mixin
	{

		public static bool IsVarArg(this IMethodSignature self)
		{
			return self.CallingConvention == MethodCallingConvention.VarArg;
		}

		public static int GetSentinelPosition(this IMethodSignature self)
		{
			if (!self.HasParameters)
				return -1;

			var parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
				if (parameters[i].ParameterType.IsSentinel)
					return i;

			return -1;
		}
	}
}



namespace Mono.Cecil
{
	internal sealed class MethodReferenceComparer : EqualityComparer<MethodReference>
	{
		// Initialized lazily for each thread
		[ThreadStatic]
		static List<MethodReference> xComparisonStack = null;

		[ThreadStatic]
		static List<MethodReference> yComparisonStack = null;

		public override bool Equals(MethodReference x, MethodReference y)
		{
			return AreEqual(x, y);
		}

		public override int GetHashCode(MethodReference obj)
		{
			return GetHashCodeFor(obj);
		}

		public static bool AreEqual(MethodReference x, MethodReference y)
		{
			if (ReferenceEquals(x, y))
				return true;

			if (x.HasThis != y.HasThis)
				return false;

			if (x.HasParameters != y.HasParameters)
				return false;

			if (x.HasGenericParameters != y.HasGenericParameters)
				return false;

			if (x.Parameters.Count != y.Parameters.Count)
				return false;

			if (x.Name != y.Name)
				return false;

			if (!TypeReferenceEqualityComparer.AreEqual(x.DeclaringType, y.DeclaringType))
				return false;

			var xGeneric = x as GenericInstanceMethod;
			var yGeneric = y as GenericInstanceMethod;
			if (xGeneric != null || yGeneric != null)
			{
				if (xGeneric == null || yGeneric == null)
					return false;

				if (xGeneric.GenericArguments.Count != yGeneric.GenericArguments.Count)
					return false;

				for (int i = 0; i < xGeneric.GenericArguments.Count; i++)
					if (!TypeReferenceEqualityComparer.AreEqual(xGeneric.GenericArguments[i], yGeneric.GenericArguments[i]))
						return false;
			}

			var xResolved = x.Resolve();
			var yResolved = y.Resolve();

			if (xResolved != yResolved)
				return false;

			if (xResolved == null)
			{
				// We couldn't resolve either method. In order for them to be equal, their parameter types _must_ match. But wait, there's a twist!
				// There exists a situation where we might get into a recursive state: parameter type comparison might lead to comparing the same
				// methods again if the parameter types are generic parameters whose owners are these methods. We guard against these by using a
				// thread static list of all our comparisons carried out in the stack so far, and if we're in progress of comparing them already,
				// we'll just say that they match.

				if (xComparisonStack == null)
					xComparisonStack = new List<MethodReference>();

				if (yComparisonStack == null)
					yComparisonStack = new List<MethodReference>();

				for (int i = 0; i < xComparisonStack.Count; i++)
				{
					if (xComparisonStack[i] == x && yComparisonStack[i] == y)
						return true;
				}

				xComparisonStack.Add(x);

				try
				{
					yComparisonStack.Add(y);

					try
					{
						for (int i = 0; i < x.Parameters.Count; i++)
						{
							if (!TypeReferenceEqualityComparer.AreEqual(x.Parameters[i].ParameterType, y.Parameters[i].ParameterType))
								return false;
						}
					}
					finally
					{
						yComparisonStack.RemoveAt(yComparisonStack.Count - 1);
					}
				}
				finally
				{
					xComparisonStack.RemoveAt(xComparisonStack.Count - 1);
				}
			}

			return true;
		}

		public static bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (x.HasThis != y.HasThis)
				return false;

			if (x.Parameters.Count != y.Parameters.Count)
				return false;

			if (x.GenericParameters.Count != y.GenericParameters.Count)
				return false;

			for (var i = 0; i < x.Parameters.Count; i++)
				if (!TypeReferenceEqualityComparer.AreEqual(x.Parameters[i].ParameterType, y.Parameters[i].ParameterType, comparisonMode))
					return false;

			if (!TypeReferenceEqualityComparer.AreEqual(x.ReturnType, y.ReturnType, comparisonMode))
				return false;

			return true;
		}

		public static int GetHashCodeFor(MethodReference obj)
		{
			// a very good prime number
			const int hashCodeMultiplier = 486187739;

			var genericInstanceMethod = obj as GenericInstanceMethod;
			if (genericInstanceMethod != null)
			{
				var hashCode = GetHashCodeFor(genericInstanceMethod.ElementMethod);
				for (var i = 0; i < genericInstanceMethod.GenericArguments.Count; i++)
					hashCode = hashCode * hashCodeMultiplier + TypeReferenceEqualityComparer.GetHashCodeFor(genericInstanceMethod.GenericArguments[i]);
				return hashCode;
			}

			return TypeReferenceEqualityComparer.GetHashCodeFor(obj.DeclaringType) * hashCodeMultiplier + obj.Name.GetHashCode();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class MethodReturnType : IConstantProvider, ICustomAttributeProvider, IMarshalInfoProvider
	{

		internal IMethodSignature method;
		internal ParameterDefinition parameter;
		TypeReference return_type;

		public IMethodSignature Method
		{
			get { return method; }
		}

		public TypeReference ReturnType
		{
			get { return return_type; }
			set { return_type = value; }
		}

		internal ParameterDefinition Parameter
		{
			get
			{
				if (parameter == null)
					Interlocked.CompareExchange(ref parameter, new ParameterDefinition(return_type, method), null);

				return parameter;
			}
		}

		public MetadataToken MetadataToken
		{
			get { return Parameter.MetadataToken; }
			set { Parameter.MetadataToken = value; }
		}

		public ParameterAttributes Attributes
		{
			get { return Parameter.Attributes; }
			set { Parameter.Attributes = value; }
		}

		public string Name
		{
			get { return Parameter.Name; }
			set { Parameter.Name = value; }
		}

		public bool HasCustomAttributes
		{
			get { return parameter != null && parameter.HasCustomAttributes; }
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return Parameter.CustomAttributes; }
		}

		public bool HasDefault
		{
			get { return parameter != null && parameter.HasDefault; }
			set { Parameter.HasDefault = value; }
		}

		public bool HasConstant
		{
			get { return parameter != null && parameter.HasConstant; }
			set { Parameter.HasConstant = value; }
		}

		public object Constant
		{
			get { return Parameter.Constant; }
			set { Parameter.Constant = value; }
		}

		public bool HasFieldMarshal
		{
			get { return parameter != null && parameter.HasFieldMarshal; }
			set { Parameter.HasFieldMarshal = value; }
		}

		public bool HasMarshalInfo
		{
			get { return parameter != null && parameter.HasMarshalInfo; }
		}

		public MarshalInfo MarshalInfo
		{
			get { return Parameter.MarshalInfo; }
			set { Parameter.MarshalInfo = value; }
		}

		public MethodReturnType(IMethodSignature method)
		{
			this.method = method;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum MethodSemanticsAttributes : ushort
	{
		None = 0x0000,
		Setter = 0x0001,    // Setter for property
		Getter = 0x0002,    // Getter for property
		Other = 0x0004, // Other method for property or event
		AddOn = 0x0008, // AddOn method for event
		RemoveOn = 0x0010,  // RemoveOn method for event
		Fire = 0x0020    // Fire method for event
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public abstract class MethodSpecification : MethodReference
	{

		readonly MethodReference method;

		public MethodReference ElementMethod
		{
			get { return method; }
		}

		public override string Name
		{
			get { return method.Name; }
			set { throw new InvalidOperationException(); }
		}

		public override MethodCallingConvention CallingConvention
		{
			get { return method.CallingConvention; }
			set { throw new InvalidOperationException(); }
		}

		public override bool HasThis
		{
			get { return method.HasThis; }
			set { throw new InvalidOperationException(); }
		}

		public override bool ExplicitThis
		{
			get { return method.ExplicitThis; }
			set { throw new InvalidOperationException(); }
		}

		public override MethodReturnType MethodReturnType
		{
			get { return method.MethodReturnType; }
			set { throw new InvalidOperationException(); }
		}

		public override TypeReference DeclaringType
		{
			get { return method.DeclaringType; }
			set { throw new InvalidOperationException(); }
		}

		public override ModuleDefinition Module
		{
			get { return method.Module; }
		}

		public override bool HasParameters
		{
			get { return method.HasParameters; }
		}

		public override Collection<ParameterDefinition> Parameters
		{
			get { return method.Parameters; }
		}

		public override bool ContainsGenericParameter
		{
			get { return method.ContainsGenericParameter; }
		}

		internal MethodSpecification(MethodReference method)
		{
			Mixin.CheckMethod(method);

			this.method = method;
			this.token = new MetadataToken(TokenType.MethodSpec);
		}

		public sealed override MethodReference GetElementMethod()
		{
			return method.GetElementMethod();
		}
	}
}
// #define MONOMOD_DBGLOG












// This class is included in every MonoMod assembly.
namespace MonoMod
{
	internal static class MMDbgLog
	{

		public static readonly string Tag = typeof(MMDbgLog).Assembly.GetName().Name;

		public static TextWriter Writer;

		public static bool Debugging;

		static MMDbgLog()
		{
			bool enabled =
#if MONOMOD_DBGLOG
                true;
#else
				Environment.GetEnvironmentVariable("MONOMOD_DBGLOG") == "1" ||
				(Environment.GetEnvironmentVariable("MONOMOD_DBGLOG")?.ToLower(CultureInfo.InvariantCulture)?.Contains(Tag.ToLower(CultureInfo.InvariantCulture), StringComparison.Ordinal) ?? false);
#endif

			if (enabled)
				Start();
		}

		public static void WaitForDebugger()
		{
			// When in doubt, enable this debugging helper block, add Debugger.Break() where needed and attach WinDbg quickly.
			if (!Debugging)
			{
				Debugging = true;
				// WinDbg doesn't trigger Debugger.IsAttached
				Debugger.Launch();
				Thread.Sleep(6000);
				Debugger.Break();
			}
		}

		public static void Start()
		{
			if (Writer != null)
				return;

			string path = Environment.GetEnvironmentVariable("MONOMOD_DBGLOG_PATH");
			if (path == "-")
			{
				Writer = Console.Out;
				return;
			}

			if (string.IsNullOrEmpty(path))
				path = "mmdbglog.txt";
			path = Path.GetFullPath($"{Path.GetFileNameWithoutExtension(path)}-{Tag}{Path.GetExtension(path)}");

			try
			{
				if (File.Exists(path))
					File.Delete(path);
			}
			catch { }
			try
			{
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				Writer = new StreamWriter(new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite | FileShare.Delete), Encoding.UTF8);
			}
			catch { }
		}

		public static void Log(string str)
		{
			TextWriter w = Writer;
			if (w == null)
				return;

			w.WriteLine(str);
			w.Flush();
		}

		public static T Log<T>(string str, T value)
		{
			TextWriter w = Writer;
			if (w == null)
				return value;

			w.WriteLine(string.Format(CultureInfo.InvariantCulture, str, value));
			w.Flush();
			return value;
		}

	}
}
#if !CECIL0_9














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class MMReflectionImporter : IReflectionImporter
	{

		private class _Provider : IReflectionImporterProvider
		{
			public bool? UseDefault;
			public IReflectionImporter GetReflectionImporter(ModuleDefinition module)
			{
				MMReflectionImporter importer = new MMReflectionImporter(module);
				if (UseDefault != null)
					importer.UseDefault = UseDefault.Value;
				return importer;
			}
		}

		// Not all generics are equal: in some cases a type with a generic parameter should be 
		// considered as a TypeReference with GenericParameters. For instance Bar<T> in
		//
		// class Foo<T> : Bar<T>
		//
		// In other cases, a type should be considered as a GenericInstanceType.
		// For instance `self` in
		//
		// class Foo<T> { static Foo<T> self; }
		//
		// Because in Reflection API both cases yield technically the same TypeInfo, we
		// differentiate then during resolving to allow proper resolving of the second example
		// The same thing is done in Cecil, so we port a simplified version of it
		private enum GenericImportKind
		{
			Open,
			Definition
		}

		public static readonly IReflectionImporterProvider Provider = new _Provider();
		public static readonly IReflectionImporterProvider ProviderNoDefault = new _Provider() { UseDefault = false };

		private readonly ModuleDefinition Module;
		private readonly DefaultReflectionImporter Default;

		private readonly Dictionary<Assembly, AssemblyNameReference> CachedAsms = new Dictionary<Assembly, AssemblyNameReference>();
		private readonly Dictionary<Module, TypeReference> CachedModuleTypes = new Dictionary<Module, TypeReference>();
		private readonly Dictionary<Type, TypeReference> CachedTypes = new Dictionary<Type, TypeReference>();
		private readonly Dictionary<FieldInfo, FieldReference> CachedFields = new Dictionary<FieldInfo, FieldReference>();
		private readonly Dictionary<MethodBase, MethodReference> CachedMethods = new Dictionary<MethodBase, MethodReference>();

		public bool UseDefault = false;

		private readonly Dictionary<Type, TypeReference> ElementTypes;

		public MMReflectionImporter(ModuleDefinition module)
		{
			Module = module;
			Default = new DefaultReflectionImporter(module);

			ElementTypes = new Dictionary<Type, TypeReference>() {
				{ typeof(void), module.TypeSystem.Void },
				{ typeof(bool), module.TypeSystem.Boolean },
				{ typeof(char), module.TypeSystem.Char },
				{ typeof(sbyte), module.TypeSystem.SByte },
				{ typeof(byte), module.TypeSystem.Byte },
				{ typeof(short), module.TypeSystem.Int16 },
				{ typeof(ushort), module.TypeSystem.UInt16 },
				{ typeof(int), module.TypeSystem.Int32 },
				{ typeof(uint), module.TypeSystem.UInt32 },
				{ typeof(long), module.TypeSystem.Int64 },
				{ typeof(ulong), module.TypeSystem.UInt64 },
				{ typeof(float), module.TypeSystem.Single },
				{ typeof(double), module.TypeSystem.Double },
				{ typeof(string), module.TypeSystem.String },
				{ typeof(TypedReference), module.TypeSystem.TypedReference },
				{ typeof(IntPtr), module.TypeSystem.IntPtr },
				{ typeof(UIntPtr), module.TypeSystem.UIntPtr },
				{ typeof(object), module.TypeSystem.Object },
			};
		}

		private bool TryGetCachedType(Type type, out TypeReference typeRef, GenericImportKind importKind)
		{
			if (importKind == GenericImportKind.Definition)
			{
				typeRef = null;
				return false;
			}

			return CachedTypes.TryGetValue(type, out typeRef);
		}

		private TypeReference SetCachedType(Type type, TypeReference typeRef, GenericImportKind importKind)
		{
			if (importKind == GenericImportKind.Definition)
				return typeRef;

			return CachedTypes[type] = typeRef;
		}

		[Obsolete("Please use the Assembly overload instead.")]
		public AssemblyNameReference ImportReference(AssemblyName asm)
		{
			// Multiple ALCs are pain and you should feel bad if you're not using the Assembly overload. - ade
			return Default.ImportReference(asm);
		}

		public AssemblyNameReference ImportReference(Assembly asm)
		{
			if (CachedAsms.TryGetValue(asm, out AssemblyNameReference asmRef))
				return asmRef;

			asmRef = Default.ImportReference(asm.GetName());
			// It's possible to load multiple assemblies with the same name but different contents!
			// Assembly load contexts are pain. (And this can even happen without ALCs!)
			asmRef.ApplyRuntimeHash(asm);
			return CachedAsms[asm] = asmRef;
		}

		public TypeReference ImportModuleType(Module module, IGenericParameterProvider context)
		{
			if (CachedModuleTypes.TryGetValue(module, out TypeReference typeRef))
				return typeRef;

			// See https://github.com/jbevain/cecil/blob/06da31930ff100cef48aef677c4ceeee858e6c04/Mono.Cecil/ModuleDefinition.cs#L1018
			return CachedModuleTypes[module] = new TypeReference(
				string.Empty,
				"<Module>",
				Module,
				ImportReference(module.Assembly)
			);
		}

		public TypeReference ImportReference(Type type, IGenericParameterProvider context)
		{
			return _ImportReference(type, context, context != null ? GenericImportKind.Open : GenericImportKind.Definition);
		}

		private bool _IsGenericInstance(Type type, GenericImportKind importKind)
		{
			return type.IsGenericType && !type.IsGenericTypeDefinition ||
				   type.IsGenericType && type.IsGenericTypeDefinition && importKind == GenericImportKind.Open;
		}

		private GenericInstanceType _ImportGenericInstance(Type type, IGenericParameterProvider context, TypeReference typeRef)
		{
			GenericInstanceType git = new GenericInstanceType(typeRef);
			foreach (Type arg in type.GetGenericArguments())
				git.GenericArguments.Add(_ImportReference(arg, context));
			return git;
		}

		private TypeReference _ImportReference(Type type, IGenericParameterProvider context, GenericImportKind importKind = GenericImportKind.Open)
		{
			if (TryGetCachedType(type, out TypeReference typeRef, importKind))
			{
				return _IsGenericInstance(type, importKind) ? _ImportGenericInstance(type, context, typeRef) : typeRef;
			}

			if (UseDefault)
				return SetCachedType(type, Default.ImportReference(type, context), importKind);

			if (type.HasElementType)
			{
				if (type.IsByRef)
					return SetCachedType(type, new ByReferenceType(_ImportReference(type.GetElementType(), context)), importKind);

				if (type.IsPointer)
					return SetCachedType(type, new PointerType(_ImportReference(type.GetElementType(), context)), importKind);

				if (type.IsArray)
				{
					ArrayType at = new ArrayType(_ImportReference(type.GetElementType(), context), type.GetArrayRank());
					if (type != type.GetElementType().MakeArrayType())
					{
						// Non-SzArray
						// TODO: Find a way to get the bounds without instantiating the array type!
						/*
                        Array a = Array.CreateInstance(type, new int[type.GetArrayRank()]);
                        if (
                            at.Rank > 1
                            && a.IsFixedSize
                        ) {
                            for (int i = 0; i < at.Rank; i++)
                                at.Dimensions[i] = new ArrayDimension(a.GetLowerBound(i), a.GetUpperBound(i));
                        }
                        */
						// For now, always assume [0...,0...,
						// Array.CreateInstance only accepts lower bounds anyway.
						for (int i = 0; i < at.Rank; i++)
							at.Dimensions[i] = new ArrayDimension(0, null);
					}
					return CachedTypes[type] = at;
				}
			}

			if (_IsGenericInstance(type, importKind))
			{
				return _ImportGenericInstance(type, context,
					_ImportReference(type.GetGenericTypeDefinition(), context, GenericImportKind.Definition));
			}

			if (type.IsGenericParameter)
				return SetCachedType(type, ImportGenericParameter(type, context), importKind);

			if (ElementTypes.TryGetValue(type, out typeRef))
				return SetCachedType(type, typeRef, importKind);

			typeRef = new TypeReference(
				string.Empty,
				type.Name,
				Module,
				ImportReference(type.Assembly),
				type.IsValueType
			);

			if (type.IsNested)
				typeRef.DeclaringType = _ImportReference(type.DeclaringType, context, importKind);
			else if (type.Namespace != null)
				typeRef.Namespace = type.Namespace;

			if (type.IsGenericType)
				foreach (Type param in type.GetGenericArguments())
					typeRef.GenericParameters.Add(new GenericParameter(param.Name, typeRef));

			return SetCachedType(type, typeRef, importKind);
		}

		private static TypeReference ImportGenericParameter(Type type, IGenericParameterProvider context)
		{
			if (context is MethodReference ctxMethodRef)
			{
				MethodBase dclMethod = type.DeclaringMethod;
				if (dclMethod != null)
				{
					return ctxMethodRef.GenericParameters[type.GenericParameterPosition];
				}
				else
				{
					context = ctxMethodRef.DeclaringType;
				}
			}

			Type dclType = type.DeclaringType;
			if (dclType == null)
				throw new InvalidOperationException();

			if (context is TypeReference ctxTypeRef)
			{
				while (ctxTypeRef != null)
				{
					TypeReference ctxTypeRefEl = ctxTypeRef.GetElementType();
					if (ctxTypeRefEl.Is(dclType))
						return ctxTypeRefEl.GenericParameters[type.GenericParameterPosition];

					if (ctxTypeRef.Is(dclType))
						return ctxTypeRef.GenericParameters[type.GenericParameterPosition];

					ctxTypeRef = ctxTypeRef.DeclaringType;
					continue;
				}
			}

			throw new NotSupportedException();
		}

		public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
		{
			if (CachedFields.TryGetValue(field, out FieldReference fieldRef))
				return fieldRef;

			if (UseDefault)
				return CachedFields[field] = Default.ImportReference(field, context);

			Type declType = field.DeclaringType;
			TypeReference declaringType = declType != null ? ImportReference(declType, context) : ImportModuleType(field.Module, context);

			FieldInfo fieldOrig = field;
			if (declType != null && declType.IsGenericType)
			{
				// In methods of generic types, all generic parameters are already filled in.
				// Meanwhile, cecil requires generic parameter references.
				// Luckily the metadata tokens match up.
				field = field.Module.ResolveField(field.MetadataToken);
			}

			return CachedFields[fieldOrig] = new FieldReference(
				field.Name,
				_ImportReference(field.FieldType, declaringType),
				declaringType
			);
		}

		public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
		{
			return _ImportReference(method, context,
				context != null ? GenericImportKind.Open : GenericImportKind.Definition);
		}

		private MethodReference _ImportReference(MethodBase method, IGenericParameterProvider context, GenericImportKind importKind)
		{
			if (CachedMethods.TryGetValue(method, out MethodReference methodRef) && importKind == GenericImportKind.Open)
				return methodRef;

			if (method is MethodInfo target && target.IsDynamicMethod())
				return new DynamicMethodReference(Module, target);

			if (UseDefault)
				return CachedMethods[method] = Default.ImportReference(method, context);

			if (method.IsGenericMethod && !method.IsGenericMethodDefinition ||
				method.IsGenericMethod && method.IsGenericMethodDefinition && importKind == GenericImportKind.Open)
			{
				GenericInstanceMethod gim = new GenericInstanceMethod(_ImportReference((method as MethodInfo).GetGenericMethodDefinition(), context, GenericImportKind.Definition));
				foreach (Type arg in method.GetGenericArguments())
					// Generic arguments for the generic instance are often given by the next higher provider.
					gim.GenericArguments.Add(_ImportReference(arg, context));

				return CachedMethods[method] = gim;
			}

			Type declType = method.DeclaringType;
			methodRef = new MethodReference(
				method.Name,
				_ImportReference(typeof(void), context),
				declType != null ? _ImportReference(declType, context, GenericImportKind.Definition) : ImportModuleType(method.Module, context)
			);

			methodRef.HasThis = (method.CallingConvention & CallingConventions.HasThis) != 0;
			methodRef.ExplicitThis = (method.CallingConvention & CallingConventions.ExplicitThis) != 0;
			if ((method.CallingConvention & CallingConventions.VarArgs) != 0)
				methodRef.CallingConvention = MethodCallingConvention.VarArg;

			MethodBase methodOrig = method;
			if (declType != null && declType.IsGenericType)
			{
				// In methods of generic types, all generic parameters are already filled in.
				// Meanwhile, cecil requires generic parameter references.
				// Luckily the metadata tokens match up.
				method = method.Module.ResolveMethod(method.MetadataToken);
			}

			if (method.IsGenericMethodDefinition)
				foreach (Type param in method.GetGenericArguments())
					methodRef.GenericParameters.Add(new GenericParameter(param.Name, methodRef));

			methodRef.ReturnType = _ImportReference((method as MethodInfo)?.ReturnType ?? typeof(void), methodRef);

			foreach (ParameterInfo param in method.GetParameters())
				methodRef.Parameters.Add(new ParameterDefinition(
					param.Name,
					(Mono.Cecil.ParameterAttributes)param.Attributes,
					_ImportReference(param.ParameterType, methodRef)
				));

			return CachedMethods[methodOrig] = methodRef;
		}

	}
}
#endif
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public interface IModifierType
	{
		TypeReference ModifierType { get; }
		TypeReference ElementType { get; }
	}

	public sealed class OptionalModifierType : TypeSpecification, IModifierType
	{

		TypeReference modifier_type;

		public TypeReference ModifierType
		{
			get { return modifier_type; }
			set { modifier_type = value; }
		}

		public override string Name
		{
			get { return base.Name + Suffix; }
		}

		public override string FullName
		{
			get { return base.FullName + Suffix; }
		}

		string Suffix
		{
			get { return " modopt(" + modifier_type + ")"; }
		}

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsOptionalModifier
		{
			get { return true; }
		}

		public override bool ContainsGenericParameter
		{
			get { return modifier_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		public OptionalModifierType(TypeReference modifierType, TypeReference type)
			: base(type)
		{
			if (modifierType == null)
				throw new ArgumentNullException(Mixin.Argument.modifierType.ToString());
			Mixin.CheckType(type);
			this.modifier_type = modifierType;
			this.etype = MD.ElementType.CModOpt;
		}
	}

	public sealed class RequiredModifierType : TypeSpecification, IModifierType
	{

		TypeReference modifier_type;

		public TypeReference ModifierType
		{
			get { return modifier_type; }
			set { modifier_type = value; }
		}

		public override string Name
		{
			get { return base.Name + Suffix; }
		}

		public override string FullName
		{
			get { return base.FullName + Suffix; }
		}

		string Suffix
		{
			get { return " modreq(" + modifier_type + ")"; }
		}

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsRequiredModifier
		{
			get { return true; }
		}

		public override bool ContainsGenericParameter
		{
			get { return modifier_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		public RequiredModifierType(TypeReference modifierType, TypeReference type)
			: base(type)
		{
			if (modifierType == null)
				throw new ArgumentNullException(Mixin.Argument.modifierType.ToString());
			Mixin.CheckType(type);
			this.modifier_type = modifierType;
			this.etype = MD.ElementType.CModReqD;
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//












namespace Mono.Cecil
{

	public enum ReadingMode
	{
		Immediate = 1,
		Deferred = 2,
	}

	public sealed class ReaderParameters
	{

		ReadingMode reading_mode;
		internal IAssemblyResolver assembly_resolver;
		internal IMetadataResolver metadata_resolver;
		internal IMetadataImporterProvider metadata_importer_provider;
		internal IReflectionImporterProvider reflection_importer_provider;
		Stream symbol_stream;
		ISymbolReaderProvider symbol_reader_provider;
		bool read_symbols;
		bool throw_symbols_mismatch;
		bool projections;
		bool in_memory;
		bool read_write;

		public ReadingMode ReadingMode
		{
			get { return reading_mode; }
			set { reading_mode = value; }
		}

		public bool InMemory
		{
			get { return in_memory; }
			set { in_memory = value; }
		}

		public IAssemblyResolver AssemblyResolver
		{
			get { return assembly_resolver; }
			set { assembly_resolver = value; }
		}

		public IMetadataResolver MetadataResolver
		{
			get { return metadata_resolver; }
			set { metadata_resolver = value; }
		}

		public IMetadataImporterProvider MetadataImporterProvider
		{
			get { return metadata_importer_provider; }
			set { metadata_importer_provider = value; }
		}

		public IReflectionImporterProvider ReflectionImporterProvider
		{
			get { return reflection_importer_provider; }
			set { reflection_importer_provider = value; }
		}

		public Stream SymbolStream
		{
			get { return symbol_stream; }
			set { symbol_stream = value; }
		}

		public ISymbolReaderProvider SymbolReaderProvider
		{
			get { return symbol_reader_provider; }
			set { symbol_reader_provider = value; }
		}

		public bool ReadSymbols
		{
			get { return read_symbols; }
			set { read_symbols = value; }
		}

		public bool ThrowIfSymbolsAreNotMatching
		{
			get { return throw_symbols_mismatch; }
			set { throw_symbols_mismatch = value; }
		}

		public bool ReadWrite
		{
			get { return read_write; }
			set { read_write = value; }
		}

		public bool ApplyWindowsRuntimeProjections
		{
			get { return projections; }
			set { projections = value; }
		}

		public ReaderParameters()
			: this(ReadingMode.Deferred)
		{
		}

		public ReaderParameters(ReadingMode readingMode)
		{
			this.reading_mode = readingMode;
			this.throw_symbols_mismatch = true;
		}
	}

	public sealed class ModuleParameters
	{

		ModuleKind kind;
		TargetRuntime runtime;
		uint? timestamp;
		TargetArchitecture architecture;
		IAssemblyResolver assembly_resolver;
		IMetadataResolver metadata_resolver;
		IMetadataImporterProvider metadata_importer_provider;
		IReflectionImporterProvider reflection_importer_provider;

		public ModuleKind Kind
		{
			get { return kind; }
			set { kind = value; }
		}

		public TargetRuntime Runtime
		{
			get { return runtime; }
			set { runtime = value; }
		}

		public uint? Timestamp
		{
			get { return timestamp; }
			set { timestamp = value; }
		}

		public TargetArchitecture Architecture
		{
			get { return architecture; }
			set { architecture = value; }
		}

		public IAssemblyResolver AssemblyResolver
		{
			get { return assembly_resolver; }
			set { assembly_resolver = value; }
		}

		public IMetadataResolver MetadataResolver
		{
			get { return metadata_resolver; }
			set { metadata_resolver = value; }
		}

		public IMetadataImporterProvider MetadataImporterProvider
		{
			get { return metadata_importer_provider; }
			set { metadata_importer_provider = value; }
		}

		public IReflectionImporterProvider ReflectionImporterProvider
		{
			get { return reflection_importer_provider; }
			set { reflection_importer_provider = value; }
		}

		public ModuleParameters()
		{
			this.kind = ModuleKind.Dll;
			this.Runtime = GetCurrentRuntime();
			this.architecture = TargetArchitecture.I386;
		}

		static TargetRuntime GetCurrentRuntime()
		{
			return typeof(object).Assembly.ImageRuntimeVersion.ParseRuntime();
		}
	}

	public sealed class WriterParameters
	{

		uint? timestamp;
		Stream symbol_stream;
		ISymbolWriterProvider symbol_writer_provider;
		bool write_symbols;
		byte[] key_blob;
		string key_container;
		SR.StrongNameKeyPair key_pair;

		public uint? Timestamp
		{
			get { return timestamp; }
			set { timestamp = value; }
		}

		public Stream SymbolStream
		{
			get { return symbol_stream; }
			set { symbol_stream = value; }
		}

		public ISymbolWriterProvider SymbolWriterProvider
		{
			get { return symbol_writer_provider; }
			set { symbol_writer_provider = value; }
		}

		public bool WriteSymbols
		{
			get { return write_symbols; }
			set { write_symbols = value; }
		}

		public bool HasStrongNameKey
		{
			get { return key_pair != null || key_blob != null || key_container != null; }
		}

		public byte[] StrongNameKeyBlob
		{
			get { return key_blob; }
			set { key_blob = value; }
		}

		public string StrongNameKeyContainer
		{
			get { return key_container; }
			set { key_container = value; }
		}

		public SR.StrongNameKeyPair StrongNameKeyPair
		{
			get { return key_pair; }
			set { key_pair = value; }
		}

		public bool DeterministicMvid { get; set; }
	}

	public sealed class ModuleDefinition : ModuleReference, ICustomAttributeProvider, ICustomDebugInformationProvider, IDisposable
	{

		internal Image Image;
		internal MetadataSystem MetadataSystem;
		internal ReadingMode ReadingMode;
		internal ISymbolReaderProvider SymbolReaderProvider;

		internal Mono.Cecil.Cil.ISymbolReader symbol_reader;
		internal Disposable<IAssemblyResolver> assembly_resolver;
		internal IMetadataResolver metadata_resolver;
		internal TypeSystem type_system;
		internal readonly MetadataReader reader;
		readonly string file_name;

		internal string runtime_version;
		internal ModuleKind kind;
		WindowsRuntimeProjections projections;
		MetadataKind metadata_kind;
		TargetRuntime runtime;
		TargetArchitecture architecture;
		ModuleAttributes attributes;
		ModuleCharacteristics characteristics;
		Guid mvid;

		internal ushort linker_version = 8;
		internal ushort subsystem_major = 4;
		internal ushort subsystem_minor = 0;
		internal uint timestamp;

		internal AssemblyDefinition assembly;
		MethodDefinition entry_point;
		bool entry_point_set;

		internal IReflectionImporter reflection_importer;
		internal IMetadataImporter metadata_importer;

		Collection<CustomAttribute> custom_attributes;
		Collection<AssemblyNameReference> references;
		Collection<ModuleReference> modules;
		Collection<Resource> resources;
		Collection<ExportedType> exported_types;
		TypeDefinitionCollection types;

		internal Collection<CustomDebugInformation> custom_infos;

		internal MetadataBuilder metadata_builder;

		public bool IsMain
		{
			get { return kind != ModuleKind.NetModule; }
		}

		public ModuleKind Kind
		{
			get { return kind; }
			set { kind = value; }
		}

		public MetadataKind MetadataKind
		{
			get { return metadata_kind; }
			set { metadata_kind = value; }
		}

		internal WindowsRuntimeProjections Projections
		{
			get
			{
				if (projections == null)
					Interlocked.CompareExchange(ref projections, new WindowsRuntimeProjections(this), null);

				return projections;
			}
		}

		public TargetRuntime Runtime
		{
			get { return runtime; }
			set
			{
				runtime = value;
				runtime_version = runtime.RuntimeVersionString();
			}
		}

		public string RuntimeVersion
		{
			get { return runtime_version; }
			set
			{
				runtime_version = value;
				runtime = runtime_version.ParseRuntime();
			}
		}

		public TargetArchitecture Architecture
		{
			get { return architecture; }
			set { architecture = value; }
		}

		public ModuleAttributes Attributes
		{
			get { return attributes; }
			set { attributes = value; }
		}

		public ModuleCharacteristics Characteristics
		{
			get { return characteristics; }
			set { characteristics = value; }
		}

		[Obsolete("Use FileName")]
		public string FullyQualifiedName
		{
			get { return file_name; }
		}

		public string FileName
		{
			get { return file_name; }
		}

		public Guid Mvid
		{
			get { return mvid; }
			set { mvid = value; }
		}

		internal bool HasImage
		{
			get { return Image != null; }
		}

		public bool HasSymbols
		{
			get { return symbol_reader != null; }
		}

		public Mono.Cecil.Cil.ISymbolReader SymbolReader
		{
			get { return symbol_reader; }
		}

		public override MetadataScopeType MetadataScopeType
		{
			get { return MetadataScopeType.ModuleDefinition; }
		}

		public AssemblyDefinition Assembly
		{
			get { return assembly; }
		}

		internal IReflectionImporter ReflectionImporter
		{
			get
			{
				if (reflection_importer == null)
					Interlocked.CompareExchange(ref reflection_importer, new DefaultReflectionImporter(this), null);

				return reflection_importer;
			}
		}

		internal IMetadataImporter MetadataImporter
		{
			get
			{
				if (metadata_importer == null)
					Interlocked.CompareExchange(ref metadata_importer, new DefaultMetadataImporter(this), null);

				return metadata_importer;
			}
		}

		public IAssemblyResolver AssemblyResolver
		{
			get
			{
				if (assembly_resolver.value == null)
				{
					lock (module_lock)
					{
						assembly_resolver = Disposable.Owned(new DefaultAssemblyResolver() as IAssemblyResolver);
					}
				}

				return assembly_resolver.value;
			}
		}

		public IMetadataResolver MetadataResolver
		{
			get
			{
				if (metadata_resolver == null)
					Interlocked.CompareExchange(ref metadata_resolver, new MetadataResolver(this.AssemblyResolver), null);

				return metadata_resolver;
			}
		}

		public TypeSystem TypeSystem
		{
			get
			{
				if (type_system == null)
					Interlocked.CompareExchange(ref type_system, TypeSystem.CreateTypeSystem(this), null);

				return type_system;
			}
		}

		public bool HasAssemblyReferences
		{
			get
			{
				if (references != null)
					return references.Count > 0;

				return HasImage && Image.HasTable(Table.AssemblyRef);
			}
		}

		public Collection<AssemblyNameReference> AssemblyReferences
		{
			get
			{
				if (references != null)
					return references;

				if (HasImage)
					return Read(ref references, this, (_, reader) => reader.ReadAssemblyReferences());

				Interlocked.CompareExchange(ref references, new Collection<AssemblyNameReference>(), null);
				return references;
			}
		}

		public bool HasModuleReferences
		{
			get
			{
				if (modules != null)
					return modules.Count > 0;

				return HasImage && Image.HasTable(Table.ModuleRef);
			}
		}

		public Collection<ModuleReference> ModuleReferences
		{
			get
			{
				if (modules != null)
					return modules;

				if (HasImage)
					return Read(ref modules, this, (_, reader) => reader.ReadModuleReferences());

				Interlocked.CompareExchange(ref modules, new Collection<ModuleReference>(), null);
				return modules;
			}
		}

		public bool HasResources
		{
			get
			{
				if (resources != null)
					return resources.Count > 0;

				if (HasImage)
					return Image.HasTable(Table.ManifestResource) || Read(this, (_, reader) => reader.HasFileResource());

				return false;
			}
		}

		public Collection<Resource> Resources
		{
			get
			{
				if (resources != null)
					return resources;

				if (HasImage)
					return Read(ref resources, this, (_, reader) => reader.ReadResources());

				Interlocked.CompareExchange(ref resources, new Collection<Resource>(), null);
				return resources;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(this);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, this)); }
		}

		public bool HasTypes
		{
			get
			{
				if (types != null)
					return types.Count > 0;

				return HasImage && Image.HasTable(Table.TypeDef);
			}
		}

		public Collection<TypeDefinition> Types
		{
			get
			{
				if (types != null)
					return types;

				if (HasImage)
					return Read(ref types, this, (_, reader) => reader.ReadTypes());

				Interlocked.CompareExchange(ref types, new TypeDefinitionCollection(this), null);
				return types;
			}
		}

		public bool HasExportedTypes
		{
			get
			{
				if (exported_types != null)
					return exported_types.Count > 0;

				return HasImage && Image.HasTable(Table.ExportedType);
			}
		}

		public Collection<ExportedType> ExportedTypes
		{
			get
			{
				if (exported_types != null)
					return exported_types;

				if (HasImage)
					return Read(ref exported_types, this, (_, reader) => reader.ReadExportedTypes());

				Interlocked.CompareExchange(ref exported_types, new Collection<ExportedType>(), null);
				return exported_types;
			}
		}

		public MethodDefinition EntryPoint
		{
			get
			{
				if (entry_point_set)
					return entry_point;

				if (HasImage)
					Read(ref entry_point, this, (_, reader) => reader.ReadEntryPoint());
				else
					entry_point = null;

				entry_point_set = true;
				return entry_point;
			}
			set
			{
				entry_point = value;
				entry_point_set = true;
			}
		}

		public bool HasCustomDebugInformations
		{
			get
			{
				return custom_infos != null && custom_infos.Count > 0;
			}
		}

		public Collection<CustomDebugInformation> CustomDebugInformations
		{
			get
			{
				if (custom_infos == null)
					Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);

				return custom_infos;
			}
		}

		internal ModuleDefinition()
		{
			this.MetadataSystem = new MetadataSystem();
			this.token = new MetadataToken(TokenType.Module, 1);
		}

		internal ModuleDefinition(Image image)
			: this()
		{
			this.Image = image;
			this.kind = image.Kind;
			this.RuntimeVersion = image.RuntimeVersion;
			this.architecture = image.Architecture;
			this.attributes = image.Attributes;
			this.characteristics = image.DllCharacteristics;
			this.linker_version = image.LinkerVersion;
			this.subsystem_major = image.SubSystemMajor;
			this.subsystem_minor = image.SubSystemMinor;
			this.file_name = image.FileName;
			this.timestamp = image.Timestamp;

			this.reader = new MetadataReader(this);
		}

		public void Dispose()
		{
			if (Image != null)
				Image.Dispose();

			if (symbol_reader != null)
				symbol_reader.Dispose();

			if (assembly_resolver.value != null)
				assembly_resolver.Dispose();
		}

		public bool HasTypeReference(string fullName)
		{
			return HasTypeReference(string.Empty, fullName);
		}

		public bool HasTypeReference(string scope, string fullName)
		{
			Mixin.CheckFullName(fullName);

			if (!HasImage)
				return false;

			return GetTypeReference(scope, fullName) != null;
		}

		public bool TryGetTypeReference(string fullName, out TypeReference type)
		{
			return TryGetTypeReference(string.Empty, fullName, out type);
		}

		public bool TryGetTypeReference(string scope, string fullName, out TypeReference type)
		{
			Mixin.CheckFullName(fullName);

			if (!HasImage)
			{
				type = null;
				return false;
			}

			return (type = GetTypeReference(scope, fullName)) != null;
		}

		TypeReference GetTypeReference(string scope, string fullname)
		{
			return Read(new Row<string, string>(scope, fullname), (row, reader) => reader.GetTypeReference(row.Col1, row.Col2));
		}

		public IEnumerable<TypeReference> GetTypeReferences()
		{
			if (!HasImage)
				return Empty<TypeReference>.Array;

			return Read(this, (_, reader) => reader.GetTypeReferences());
		}

		public IEnumerable<MemberReference> GetMemberReferences()
		{
			if (!HasImage)
				return Empty<MemberReference>.Array;

			return Read(this, (_, reader) => reader.GetMemberReferences());
		}

		public IEnumerable<CustomAttribute> GetCustomAttributes()
		{
			if (!HasImage)
				return Empty<CustomAttribute>.Array;

			return Read(this, (_, reader) => reader.GetCustomAttributes());
		}

		public TypeReference GetType(string fullName, bool runtimeName)
		{
			return runtimeName
				? TypeParser.ParseType(this, fullName, typeDefinitionOnly: true)
				: GetType(fullName);
		}

		public TypeDefinition GetType(string fullName)
		{
			Mixin.CheckFullName(fullName);

			var position = fullName.IndexOf('/');
			if (position > 0)
				return GetNestedType(fullName);

			return ((TypeDefinitionCollection)this.Types).GetType(fullName);
		}

		public TypeDefinition GetType(string @namespace, string name)
		{
			Mixin.CheckName(name);

			return ((TypeDefinitionCollection)this.Types).GetType(@namespace ?? string.Empty, name);
		}

		public IEnumerable<TypeDefinition> GetTypes()
		{
			return GetTypes(Types);
		}

		static IEnumerable<TypeDefinition> GetTypes(Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++)
			{
				var type = types[i];

				yield return type;

				if (!type.HasNestedTypes)
					continue;

				foreach (var nested in GetTypes(type.NestedTypes))
					yield return nested;
			}
		}

		TypeDefinition GetNestedType(string fullname)
		{
			var names = fullname.Split('/');
			var type = GetType(names[0]);

			if (type == null)
				return null;

			for (int i = 1; i < names.Length; i++)
			{
				var nested_type = type.GetNestedType(names[i]);
				if (nested_type == null)
					return null;

				type = nested_type;
			}

			return type;
		}

		internal FieldDefinition Resolve(FieldReference field)
		{
			return MetadataResolver.Resolve(field);
		}

		internal MethodDefinition Resolve(MethodReference method)
		{
			return MetadataResolver.Resolve(method);
		}

		internal TypeDefinition Resolve(TypeReference type)
		{
			return MetadataResolver.Resolve(type);
		}

		static void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
		{
			if (context == null)
				return;

			if (context.Module != module)
				throw new ArgumentException();
		}

		[Obsolete("Use ImportReference", error: false)]
		public TypeReference Import(Type type)
		{
			return ImportReference(type, null);
		}

		public TypeReference ImportReference(Type type)
		{
			return ImportReference(type, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public TypeReference Import(Type type, IGenericParameterProvider context)
		{
			return ImportReference(type, context);
		}

		public TypeReference ImportReference(Type type, IGenericParameterProvider context)
		{
			Mixin.CheckType(type);
			CheckContext(context, this);

			return ReflectionImporter.ImportReference(type, context);
		}

		[Obsolete("Use ImportReference", error: false)]
		public FieldReference Import(SR.FieldInfo field)
		{
			return ImportReference(field, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public FieldReference Import(SR.FieldInfo field, IGenericParameterProvider context)
		{
			return ImportReference(field, context);
		}

		public FieldReference ImportReference(SR.FieldInfo field)
		{
			return ImportReference(field, null);
		}

		public FieldReference ImportReference(SR.FieldInfo field, IGenericParameterProvider context)
		{
			Mixin.CheckField(field);
			CheckContext(context, this);

			return ReflectionImporter.ImportReference(field, context);
		}

		[Obsolete("Use ImportReference", error: false)]
		public MethodReference Import(SR.MethodBase method)
		{
			return ImportReference(method, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public MethodReference Import(SR.MethodBase method, IGenericParameterProvider context)
		{
			return ImportReference(method, context);
		}

		public MethodReference ImportReference(SR.MethodBase method)
		{
			return ImportReference(method, null);
		}

		public MethodReference ImportReference(SR.MethodBase method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod(method);
			CheckContext(context, this);

			return ReflectionImporter.ImportReference(method, context);
		}

		[Obsolete("Use ImportReference", error: false)]
		public TypeReference Import(TypeReference type)
		{
			return ImportReference(type, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public TypeReference Import(TypeReference type, IGenericParameterProvider context)
		{
			return ImportReference(type, context);
		}

		public TypeReference ImportReference(TypeReference type)
		{
			return ImportReference(type, null);
		}

		public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
		{
			Mixin.CheckType(type);

			if (type.Module == this)
				return type;

			CheckContext(context, this);

			return MetadataImporter.ImportReference(type, context);
		}

		[Obsolete("Use ImportReference", error: false)]
		public FieldReference Import(FieldReference field)
		{
			return ImportReference(field, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public FieldReference Import(FieldReference field, IGenericParameterProvider context)
		{
			return ImportReference(field, context);
		}

		public FieldReference ImportReference(FieldReference field)
		{
			return ImportReference(field, null);
		}

		public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
		{
			Mixin.CheckField(field);

			if (field.Module == this)
				return field;

			CheckContext(context, this);

			return MetadataImporter.ImportReference(field, context);
		}

		[Obsolete("Use ImportReference", error: false)]
		public MethodReference Import(MethodReference method)
		{
			return ImportReference(method, null);
		}

		[Obsolete("Use ImportReference", error: false)]
		public MethodReference Import(MethodReference method, IGenericParameterProvider context)
		{
			return ImportReference(method, context);
		}

		public MethodReference ImportReference(MethodReference method)
		{
			return ImportReference(method, null);
		}

		public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod(method);

			if (method.Module == this)
				return method;

			CheckContext(context, this);

			return MetadataImporter.ImportReference(method, context);
		}

		public IMetadataTokenProvider LookupToken(int token)
		{
			return LookupToken(new MetadataToken((uint)token));
		}

		public IMetadataTokenProvider LookupToken(MetadataToken token)
		{
			return Read(token, (t, reader) => reader.LookupToken(t));
		}

		public void ImmediateRead()
		{
			if (!HasImage)
				return;
			ReadingMode = ReadingMode.Immediate;
			var moduleReader = new ImmediateModuleReader(Image);
			moduleReader.ReadModule(this, resolve_attributes: true);
		}

		readonly object module_lock = new object();

		internal object SyncRoot
		{
			get { return module_lock; }
		}

		internal void Read<TItem>(TItem item, Action<TItem, MetadataReader> read)
		{
			lock (module_lock)
			{
				var position = reader.position;
				var context = reader.context;

				read(item, reader);

				reader.position = position;
				reader.context = context;
			}
		}

		internal TRet Read<TItem, TRet>(TItem item, Func<TItem, MetadataReader, TRet> read)
		{
			lock (module_lock)
			{
				var position = reader.position;
				var context = reader.context;

				var ret = read(item, reader);

				reader.position = position;
				reader.context = context;

				return ret;
			}
		}

		internal TRet Read<TItem, TRet>(ref TRet variable, TItem item, Func<TItem, MetadataReader, TRet> read) where TRet : class
		{
			lock (module_lock)
			{
				if (variable != null)
					return variable;

				var position = reader.position;
				var context = reader.context;

				var ret = read(item, reader);

				reader.position = position;
				reader.context = context;

				return variable = ret;
			}
		}

		public bool HasDebugHeader
		{
			get { return Image != null && Image.DebugHeader != null; }
		}

		public ImageDebugHeader GetDebugHeader()
		{
			return Image.DebugHeader ?? new ImageDebugHeader();
		}

		public static ModuleDefinition CreateModule(string name, ModuleKind kind)
		{
			return CreateModule(name, new ModuleParameters { Kind = kind });
		}

		public static ModuleDefinition CreateModule(string name, ModuleParameters parameters)
		{
			Mixin.CheckName(name);
			Mixin.CheckParameters(parameters);

			var module = new ModuleDefinition
			{
				Name = name,
				kind = parameters.Kind,
				timestamp = parameters.Timestamp ?? Mixin.GetTimestamp(),
				Runtime = parameters.Runtime,
				architecture = parameters.Architecture,
				mvid = Guid.NewGuid(),
				Attributes = ModuleAttributes.ILOnly,
				Characteristics = (ModuleCharacteristics)0x8540,
			};

			if (parameters.AssemblyResolver != null)
				module.assembly_resolver = Disposable.NotOwned(parameters.AssemblyResolver);

			if (parameters.MetadataResolver != null)
				module.metadata_resolver = parameters.MetadataResolver;

			if (parameters.MetadataImporterProvider != null)
				module.metadata_importer = parameters.MetadataImporterProvider.GetMetadataImporter(module);

			if (parameters.ReflectionImporterProvider != null)
				module.reflection_importer = parameters.ReflectionImporterProvider.GetReflectionImporter(module);

			if (parameters.Kind != ModuleKind.NetModule)
			{
				var assembly = new AssemblyDefinition();
				module.assembly = assembly;
				module.assembly.Name = CreateAssemblyName(name);
				assembly.main_module = module;
			}

			module.Types.Add(new TypeDefinition(string.Empty, "<Module>", TypeAttributes.NotPublic));

			return module;
		}

		static AssemblyNameDefinition CreateAssemblyName(string name)
		{
			if (name.EndsWith(".dll") || name.EndsWith(".exe"))
				name = name.Substring(0, name.Length - 4);

			return new AssemblyNameDefinition(name, Mixin.ZeroVersion);
		}

		public void ReadSymbols()
		{
			if (string.IsNullOrEmpty(file_name))
				throw new InvalidOperationException();

			var provider = new DefaultSymbolReaderProvider(throwIfNoSymbol: true);
			ReadSymbols(provider.GetSymbolReader(this, file_name), throwIfSymbolsAreNotMaching: true);
		}

		public void ReadSymbols(Mono.Cecil.Cil.ISymbolReader reader)
		{
			ReadSymbols(reader, throwIfSymbolsAreNotMaching: true);
		}

		public void ReadSymbols(Mono.Cecil.Cil.ISymbolReader reader, bool throwIfSymbolsAreNotMaching)
		{
			if (reader == null)
				throw new ArgumentNullException("reader");

			symbol_reader = reader;

			if (!symbol_reader.ProcessDebugHeader(GetDebugHeader()))
			{
				symbol_reader = null;

				if (throwIfSymbolsAreNotMaching)
					throw new SymbolsNotMatchingException("Symbols were found but are not matching the assembly");

				return;
			}

			if (HasImage && ReadingMode == ReadingMode.Immediate)
			{
				var immediate_reader = new ImmediateModuleReader(Image);
				immediate_reader.ReadSymbols(this);
			}
		}

		public static ModuleDefinition ReadModule(string fileName)
		{
			return ReadModule(fileName, new ReaderParameters(ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
		{
			var stream = GetFileStream(fileName, FileMode.Open, parameters.ReadWrite ? FileAccess.ReadWrite : FileAccess.Read, FileShare.Read);

			if (parameters.InMemory)
			{
				var memory = new MemoryStream(stream.CanSeek ? (int)stream.Length : 0);
				using (stream)
					stream.CopyTo(memory);

				memory.Position = 0;
				stream = memory;
			}

			try
			{
				return ReadModule(Disposable.Owned(stream), fileName, parameters);
			}
			catch (Exception)
			{
				stream.Dispose();
				throw;
			}
		}

		static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share)
		{
			Mixin.CheckFileName(fileName);

			return new FileStream(fileName, mode, access, share);
		}

		public static ModuleDefinition ReadModule(Stream stream)
		{
			return ReadModule(stream, new ReaderParameters(ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
		{
			Mixin.CheckStream(stream);
			Mixin.CheckReadSeek(stream);

			return ReadModule(Disposable.NotOwned(stream), stream.GetFileName(), parameters);
		}

		static ModuleDefinition ReadModule(Disposable<Stream> stream, string fileName, ReaderParameters parameters)
		{
			Mixin.CheckParameters(parameters);

			return ModuleReader.CreateModule(
				ImageReader.ReadImage(stream, fileName),
				parameters);
		}

		public void Write(string fileName)
		{
			Write(fileName, new WriterParameters());
		}

		public void Write(string fileName, WriterParameters parameters)
		{
			Mixin.CheckParameters(parameters);
			var file = GetFileStream(fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.Read);
			ModuleWriter.WriteModule(this, Disposable.Owned(file), parameters);
		}

		public void Write()
		{
			Write(new WriterParameters());
		}

		public void Write(WriterParameters parameters)
		{
			if (!HasImage)
				throw new InvalidOperationException();

			Write(Image.Stream.value, parameters);
		}

		public void Write(Stream stream)
		{
			Write(stream, new WriterParameters());
		}

		public void Write(Stream stream, WriterParameters parameters)
		{
			Mixin.CheckStream(stream);
			Mixin.CheckWriteSeek(stream);
			Mixin.CheckParameters(parameters);

			ModuleWriter.WriteModule(this, Disposable.NotOwned(stream), parameters);
		}
	}

	static partial class Mixin
	{

		public enum Argument
		{
			name,
			fileName,
			fullName,
			stream,
			type,
			method,
			field,
			parameters,
			module,
			modifierType,
			eventType,
			fieldType,
			declaringType,
			returnType,
			propertyType,
			interfaceType,
			constraintType,
		}

		public static void CheckName(object name)
		{
			if (name == null)
				throw new ArgumentNullException(Argument.name.ToString());
		}

		public static void CheckName(string name)
		{
			if (string.IsNullOrEmpty(name))
				throw new ArgumentNullOrEmptyException(Argument.name.ToString());
		}

		public static void CheckFileName(string fileName)
		{
			if (string.IsNullOrEmpty(fileName))
				throw new ArgumentNullOrEmptyException(Argument.fileName.ToString());
		}

		public static void CheckFullName(string fullName)
		{
			if (string.IsNullOrEmpty(fullName))
				throw new ArgumentNullOrEmptyException(Argument.fullName.ToString());
		}

		public static void CheckStream(object stream)
		{
			if (stream == null)
				throw new ArgumentNullException(Argument.stream.ToString());
		}

		public static void CheckWriteSeek(Stream stream)
		{
			if (!stream.CanWrite || !stream.CanSeek)
				throw new ArgumentException("Stream must be writable and seekable.");
		}

		public static void CheckReadSeek(Stream stream)
		{
			if (!stream.CanRead || !stream.CanSeek)
				throw new ArgumentException("Stream must be readable and seekable.");
		}

		public static void CheckType(object type)
		{
			if (type == null)
				throw new ArgumentNullException(Argument.type.ToString());
		}

		public static void CheckType(object type, Argument argument)
		{
			if (type == null)
				throw new ArgumentNullException(argument.ToString());
		}

		public static void CheckField(object field)
		{
			if (field == null)
				throw new ArgumentNullException(Argument.field.ToString());
		}

		public static void CheckMethod(object method)
		{
			if (method == null)
				throw new ArgumentNullException(Argument.method.ToString());
		}

		public static void CheckParameters(object parameters)
		{
			if (parameters == null)
				throw new ArgumentNullException(Argument.parameters.ToString());
		}

		public static uint GetTimestamp()
		{
			return (uint)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
		}

		public static bool HasImage(this ModuleDefinition self)
		{
			return self != null && self.HasImage;
		}

		public static string GetFileName(this Stream self)
		{
			var file_stream = self as FileStream;
			if (file_stream == null)
				return string.Empty;

			return Path.GetFullPath(file_stream.Name);
		}

		public static TargetRuntime ParseRuntime(this string self)
		{
			if (string.IsNullOrEmpty(self))
				return TargetRuntime.Net_4_0;

			switch (self[1])
			{
				case '1':
					return self[3] == '0'
						? TargetRuntime.Net_1_0
						: TargetRuntime.Net_1_1;
				case '2':
					return TargetRuntime.Net_2_0;
				case '4':
				default:
					return TargetRuntime.Net_4_0;
			}
		}

		public static string RuntimeVersionString(this TargetRuntime runtime)
		{
			switch (runtime)
			{
				case TargetRuntime.Net_1_0:
					return "v1.0.3705";
				case TargetRuntime.Net_1_1:
					return "v1.1.4322";
				case TargetRuntime.Net_2_0:
					return "v2.0.50727";
				case TargetRuntime.Net_4_0:
				default:
					return "v4.0.30319";
			}
		}

		public static bool IsWindowsMetadata(this ModuleDefinition module)
		{
			return module.MetadataKind != MetadataKind.Ecma335;
		}

		public static byte[] ReadAll(this Stream self)
		{
			int read;
			var memory = new MemoryStream((int)self.Length);
			var buffer = new byte[1024];

			while ((read = self.Read(buffer, 0, buffer.Length)) != 0)
				memory.Write(buffer, 0, read);

			return memory.ToArray();
		}

		public static void Read(object o)
		{
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class ModuleDefinitionRocks
	{

		public static IEnumerable<TypeDefinition> GetAllTypes(this ModuleDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			// it was fun to write, but we need a somewhat less convoluted implementation
			return self.Types.SelectMany(
				Functional.Y<TypeDefinition, IEnumerable<TypeDefinition>>(f => type => type.NestedTypes.SelectMany(f).Prepend(type)));
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public enum ModuleKind
	{
		Dll,
		Console,
		Windows,
		NetModule,
	}

	public enum MetadataKind
	{
		Ecma335,
		WindowsMetadata,
		ManagedWindowsMetadata,
	}

	public enum TargetArchitecture
	{
		I386 = 0x014c,
		AMD64 = 0x8664,
		IA64 = 0x0200,
		ARM = 0x01c0,
		ARMv7 = 0x01c4,
		ARM64 = 0xaa64,
	}

	[Flags]
	public enum ModuleAttributes
	{
		ILOnly = 1,
		Required32Bit = 2,
		ILLibrary = 4,
		StrongNameSigned = 8,
		Preferred32Bit = 0x00020000,
	}

	[Flags]
	public enum ModuleCharacteristics
	{
		HighEntropyVA = 0x0020,
		DynamicBase = 0x0040,
		NoSEH = 0x0400,
		NXCompat = 0x0100,
		AppContainer = 0x1000,
		TerminalServerAware = 0x8000,
	}
}





namespace Mono.Cecil.Pdb
{

	// WARNING: most methods should be reworked into PreserveSig methods

	[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
	unsafe interface IMetaDataEmit
	{
		void SetModuleProps(string szName);
		void Save(string szFile, uint dwSaveFlags);
		void SaveToStream(IntPtr pIStream, uint dwSaveFlags);
		uint GetSaveSize(uint fSave);
		uint DefineTypeDef(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements);
		uint DefineNestedType(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements, uint tdEncloser);
		void SetHandler([MarshalAs(UnmanagedType.IUnknown), In] object pUnk);
		uint DefineMethod(uint td, IntPtr zName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags);
		void DefineMethodImpl(uint td, uint tkBody, uint tkDecl);
		uint DefineTypeRefByName(uint tkResolutionScope, IntPtr szName);
		uint DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport,
		  uint tdImport, IntPtr pAssemEmit);
		uint DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob);
		uint DefineImportMember(IntPtr pAssemImport, IntPtr /* void* */ pbHashValue, uint cbHashValue,
		  IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent);
		uint DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr /* uint* */ rmdOtherMethods);
		void SetClassLayout(uint td, uint dwPackSize, IntPtr /*COR_FIELD_OFFSET**/ rFieldOffsets, uint ulClassSize);
		void DeleteClassLayout(uint td);
		void SetFieldMarshal(uint tk, IntPtr /* byte* */ pvNativeType, uint cbNativeType);
		void DeleteFieldMarshal(uint tk);
		uint DefinePermissionSet(uint tk, uint dwAction, IntPtr /* void* */ pvPermission, uint cbPermission);
		void SetRVA(uint md, uint ulRVA);
		uint GetTokenFromSig(IntPtr /* byte* */ pvSig, uint cbSig);
		uint DefineModuleRef(string szName);
		void SetParent(uint mr, uint tk);
		uint GetTokenFromTypeSpec(IntPtr /* byte* */ pvSig, uint cbSig);
		void SaveToMemory(IntPtr /* void* */ pbData, uint cbData);
		uint DefineUserString(string szString, uint cchString);
		void DeleteToken(uint tkObj);
		void SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags);
		void SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, IntPtr /* uint* */ rtkImplements);
		void SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr /* uint* */ rmdOtherMethods);
		uint SetPermissionSetProps(uint tk, uint dwAction, IntPtr /* void* */ pvPermission, uint cbPermission);
		void DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL);
		void SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL);
		void DeletePinvokeMap(uint tk);
		uint DefineCustomAttribute(uint tkObj, uint tkType, IntPtr /* void* */ pCustomAttribute, uint cbCustomAttribute);
		void SetCustomAttributeValue(uint pcv, IntPtr /* void* */ pCustomAttribute, uint cbCustomAttribute);
		uint DefineField(uint td, string szName, uint dwFieldFlags, IntPtr /* byte* */ pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr /* void* */ pValue, uint cchValue);
		uint DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr /* byte* */ pvSig, uint cbSig, uint dwCPlusTypeFlag,
		  IntPtr /* void* */ pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr /* uint*  */ rmdOtherMethods);
		uint DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr /* void* */ pValue, uint cchValue);
		void SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr /* void* */ pValue, uint cchValue);
		void SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr /* void* */ pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr /* uint* */ rmdOtherMethods);
		void SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr /* void* */ pValue, uint cchValue);
		uint DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs);
		void ApplyEditAndContinue([MarshalAs(UnmanagedType.IUnknown)] object pImport);
		uint TranslateSigWithScope(IntPtr pAssemImport, IntPtr /* void* */ pbHashValue, uint cbHashValue,
		  IMetaDataImport import, IntPtr /* byte* */ pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr /* byte* */ pvTranslatedSig, uint cbTranslatedSigMax);
		void SetMethodImplFlags(uint md, uint dwImplFlags);
		void SetFieldRVA(uint fd, uint ulRVA);
		void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, [MarshalAs(UnmanagedType.IUnknown)] object pHandler);
		void MergeEnd();
	}

	[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
	unsafe interface IMetaDataImport
	{
		[PreserveSig]
		void CloseEnum(uint hEnum);
		uint CountEnum(uint hEnum);
		void ResetEnum(uint hEnum, uint ulPos);
		uint EnumTypeDefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeDefs, uint cMax);
		uint EnumInterfaceImpls(ref uint phEnum, uint td, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rImpls, uint cMax);
		uint EnumTypeRefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeRefs, uint cMax);
		uint FindTypeDefByName(string szTypeDef, uint tkEnclosingClass);
		Guid GetScopeProps(StringBuilder szName, uint cchName, out uint pchName);
		uint GetModuleFromScope();

		[PreserveSig]
		uint GetTypeDefProps(uint td, char* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends);
		uint GetInterfaceImplProps(uint iiImpl, out uint pClass);
		uint GetTypeRefProps(uint tr, out uint ptkResolutionScope, StringBuilder szName, uint cchName);
		uint ResolveTypeRef(uint tr, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppIScope);
		uint EnumMembers(ref uint phEnum, uint cl, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMembers, uint cMax);
		uint EnumMembersWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMembers, uint cMax);
		uint EnumMethods(ref uint phEnum, uint cl, IntPtr /* uint* */ rMethods, uint cMax);
		uint EnumMethodsWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethods, uint cMax);
		uint EnumFields(ref uint phEnum, uint cl, IntPtr /* uint* */ rFields, uint cMax);
		uint EnumFieldsWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rFields, uint cMax);
		uint EnumParams(ref uint phEnum, uint mb, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rParams, uint cMax);
		uint EnumMemberRefs(ref uint phEnum, uint tkParent, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMemberRefs, uint cMax);
		uint EnumMethodImpls(ref uint phEnum, uint td, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethodBody,
		   [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethodDecl, uint cMax);
		uint EnumPermissionSets(ref uint phEnum, uint tk, uint dwActions, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rPermission,
		   uint cMax);
		uint FindMember(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);
		uint FindMethod(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);
		uint FindField(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);
		uint FindMemberRef(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);

		[PreserveSig]
		uint GetMethodProps(uint mb, uint* pClass, char* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags);
		uint GetMemberRefProps(uint mr, ref uint ptk, StringBuilder szMember, uint cchMember, out uint pchMember, out IntPtr /* byte* */ ppvSigBlob);
		uint EnumProperties(ref uint phEnum, uint td, IntPtr /* uint* */ rProperties, uint cMax);
		uint EnumEvents(ref uint phEnum, uint td, IntPtr /* uint* */ rEvents, uint cMax);
		uint GetEventProps(uint ev, out uint pClass, StringBuilder szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags,
		  out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire,
		  [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 11)] uint[] rmdOtherMethod, uint cMax);
		uint EnumMethodSemantics(ref uint phEnum, uint mb, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rEventProp, uint cMax);
		uint GetMethodSemantics(uint mb, uint tkEventProp);
		uint GetClassLayout(uint td, out uint pdwPackSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] IntPtr /*COR_FIELD_OFFSET **/ rFieldOffset, uint cMax, out uint pcFieldOffset);
		uint GetFieldMarshal(uint tk, out IntPtr /* byte* */ ppvNativeType);
		uint GetRVA(uint tk, out uint pulCodeRVA);
		uint GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr /* void* */ ppvPermission);
		uint GetSigFromToken(uint mdSig, out IntPtr /* byte* */ ppvSig);
		uint GetModuleRefProps(uint mur, StringBuilder szName, uint cchName);
		uint EnumModuleRefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rModuleRefs, uint cmax);
		uint GetTypeSpecFromToken(uint typespec, out IntPtr /* byte* */ ppvSig);
		uint GetNameFromToken(uint tk);
		uint EnumUnresolvedMethods(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rMethods, uint cMax);
		uint GetUserString(uint stk, StringBuilder szString, uint cchString);
		uint GetPinvokeMap(uint tk, out uint pdwMappingFlags, StringBuilder szImportName, uint cchImportName, out uint pchImportName);
		uint EnumSignatures(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rSignatures, uint cmax);
		uint EnumTypeSpecs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeSpecs, uint cmax);
		uint EnumUserStrings(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rStrings, uint cmax);
		[PreserveSig]
		int GetParamForMethodIndex(uint md, uint ulParamSeq, out uint pParam);
		uint EnumCustomAttributes(ref uint phEnum, uint tk, uint tkType, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rCustomAttributes, uint cMax);
		uint GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr /* void* */ ppBlob);
		uint FindTypeRef(uint tkResolutionScope, string szName);
		uint GetMemberProps(uint mb, out uint pClass, StringBuilder szMember, uint cchMember, out uint pchMember, out uint pdwAttr,
		  out IntPtr /* byte* */ ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr /* void* */ ppValue);
		uint GetFieldProps(uint mb, out uint pClass, StringBuilder szField, uint cchField, out uint pchField, out uint pdwAttr,
		  out IntPtr /* byte* */ ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr /* void* */ ppValue);
		uint GetPropertyProps(uint prop, out uint pClass, StringBuilder szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags,
		  out IntPtr /* byte* */ ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr /* void* */ ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter,
		  out uint pmdGetter, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 14)] uint[] rmdOtherMethod, uint cMax);
		uint GetParamProps(uint tk, out uint pmd, out uint pulSequence, StringBuilder szName, uint cchName, out uint pchName,
		  out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr /* void* */ ppValue);
		uint GetCustomAttributeByName(uint tkObj, string szName, out IntPtr /* void* */ ppData);
		[PreserveSig]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool IsValidToken(uint tk);
		[PreserveSig]
		uint GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass);
		uint GetNativeCallConvFromSig(IntPtr /* void* */ pvSig, uint cbSig);
		int IsGlobal(uint pd);
	}

	unsafe class ModuleMetadata : IMetaDataEmit, IMetaDataImport
	{

		readonly ModuleDefinition module;

		Dictionary<uint, TypeDefinition> types;
		Dictionary<uint, MethodDefinition> methods;

		const uint S_OK = 0x00000000;
		const uint E_FAIL = 0x80004005;

		public ModuleMetadata(ModuleDefinition module)
		{
			this.module = module;
		}

		bool TryGetType(uint token, out TypeDefinition type)
		{
			if (types == null)
				InitializeMetadata(module);

			return types.TryGetValue(token, out type);
		}

		bool TryGetMethod(uint token, out MethodDefinition method)
		{
			if (methods == null)
				InitializeMetadata(module);

			return methods.TryGetValue(token, out method);
		}

		void InitializeMetadata(ModuleDefinition module)
		{
			types = new Dictionary<uint, TypeDefinition>();
			methods = new Dictionary<uint, MethodDefinition>();

			foreach (var type in module.GetTypes())
			{
				types.Add(type.MetadataToken.ToUInt32(), type);
				InitializeMethods(type);
			}
		}

		void InitializeMethods(TypeDefinition type)
		{
			foreach (var method in type.Methods)
				methods.Add(method.MetadataToken.ToUInt32(), method);
		}

		public void SetModuleProps(string szName)
		{
			throw new NotImplementedException();
		}

		public void Save(string szFile, uint dwSaveFlags)
		{
			throw new NotImplementedException();
		}

		public void SaveToStream(IntPtr pIStream, uint dwSaveFlags)
		{
			throw new NotImplementedException();
		}

		public uint GetSaveSize(uint fSave)
		{
			throw new NotImplementedException();
		}

		public uint DefineTypeDef(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements)
		{
			throw new NotImplementedException();
		}

		public uint DefineNestedType(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements, uint tdEncloser)
		{
			throw new NotImplementedException();
		}

		public void SetHandler(object pUnk)
		{
			throw new NotImplementedException();
		}

		public uint DefineMethod(uint td, IntPtr zName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags)
		{
			throw new NotImplementedException();
		}

		public void DefineMethodImpl(uint td, uint tkBody, uint tkDecl)
		{
			throw new NotImplementedException();
		}

		public uint DefineTypeRefByName(uint tkResolutionScope, IntPtr szName)
		{
			throw new NotImplementedException();
		}

		public uint DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint tdImport, IntPtr pAssemEmit)
		{
			throw new NotImplementedException();
		}

		public uint DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent)
		{
			throw new NotImplementedException();
		}

		public uint DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods)
		{
			throw new NotImplementedException();
		}

		public void SetClassLayout(uint td, uint dwPackSize, IntPtr rFieldOffsets, uint ulClassSize)
		{
			throw new NotImplementedException();
		}

		public void DeleteClassLayout(uint td)
		{
			throw new NotImplementedException();
		}

		public void SetFieldMarshal(uint tk, IntPtr pvNativeType, uint cbNativeType)
		{
			throw new NotImplementedException();
		}

		public void DeleteFieldMarshal(uint tk)
		{
			throw new NotImplementedException();
		}

		public uint DefinePermissionSet(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission)
		{
			throw new NotImplementedException();
		}

		public void SetRVA(uint md, uint ulRVA)
		{
			throw new NotImplementedException();
		}

		public uint GetTokenFromSig(IntPtr pvSig, uint cbSig)
		{
			throw new NotImplementedException();
		}

		public uint DefineModuleRef(string szName)
		{
			throw new NotImplementedException();
		}

		public void SetParent(uint mr, uint tk)
		{
			throw new NotImplementedException();
		}

		public uint GetTokenFromTypeSpec(IntPtr pvSig, uint cbSig)
		{
			throw new NotImplementedException();
		}

		public void SaveToMemory(IntPtr pbData, uint cbData)
		{
			throw new NotImplementedException();
		}

		public uint DefineUserString(string szString, uint cchString)
		{
			throw new NotImplementedException();
		}

		public void DeleteToken(uint tkObj)
		{
			throw new NotImplementedException();
		}

		public void SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags)
		{
			throw new NotImplementedException();
		}

		public void SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements)
		{
			throw new NotImplementedException();
		}

		public void SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods)
		{
			throw new NotImplementedException();
		}

		public uint SetPermissionSetProps(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission)
		{
			throw new NotImplementedException();
		}

		public void DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL)
		{
			throw new NotImplementedException();
		}

		public void SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL)
		{
			throw new NotImplementedException();
		}

		public void DeletePinvokeMap(uint tk)
		{
			throw new NotImplementedException();
		}

		public uint DefineCustomAttribute(uint tkObj, uint tkType, IntPtr pCustomAttribute, uint cbCustomAttribute)
		{
			throw new NotImplementedException();
		}

		public void SetCustomAttributeValue(uint pcv, IntPtr pCustomAttribute, uint cbCustomAttribute)
		{
			throw new NotImplementedException();
		}

		public uint DefineField(uint td, string szName, uint dwFieldFlags, IntPtr pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
		{
			throw new NotImplementedException();
		}

		public uint DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr pvSig, uint cbSig, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods)
		{
			throw new NotImplementedException();
		}

		public uint DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
		{
			throw new NotImplementedException();
		}

		public void SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
		{
			throw new NotImplementedException();
		}

		public void SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods)
		{
			throw new NotImplementedException();
		}

		public void SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
		{
			throw new NotImplementedException();
		}

		public uint DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs)
		{
			throw new NotImplementedException();
		}

		public void ApplyEditAndContinue(object pImport)
		{
			throw new NotImplementedException();
		}

		public uint TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, uint cbTranslatedSigMax)
		{
			throw new NotImplementedException();
		}

		public void SetMethodImplFlags(uint md, uint dwImplFlags)
		{
			throw new NotImplementedException();
		}

		public void SetFieldRVA(uint fd, uint ulRVA)
		{
			throw new NotImplementedException();
		}

		public void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler)
		{
			throw new NotImplementedException();
		}

		public void MergeEnd()
		{
			throw new NotImplementedException();
		}

		public void CloseEnum(uint hEnum)
		{
			throw new NotImplementedException();
		}

		public uint CountEnum(uint hEnum)
		{
			throw new NotImplementedException();
		}

		public void ResetEnum(uint hEnum, uint ulPos)
		{
			throw new NotImplementedException();
		}

		public uint EnumTypeDefs(ref uint phEnum, uint[] rTypeDefs, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumInterfaceImpls(ref uint phEnum, uint td, uint[] rImpls, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumTypeRefs(ref uint phEnum, uint[] rTypeRefs, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint FindTypeDefByName(string szTypeDef, uint tkEnclosingClass)
		{
			throw new NotImplementedException();
		}

		public Guid GetScopeProps(StringBuilder szName, uint cchName, out uint pchName)
		{
			throw new NotImplementedException();
		}

		public uint GetModuleFromScope()
		{
			throw new NotImplementedException();
		}

		public uint GetTypeDefProps(uint td, char* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends)
		{
			TypeDefinition type;
			if (!TryGetType(td, out type))
				return E_FAIL;

			var name = type.IsNested ? type.Name : type.FullName;

			WriteNameBuffer(name, szTypeDef, cchTypeDef, pchTypeDef);

			if (pdwTypeDefFlags != null)
				*pdwTypeDefFlags = (uint)type.Attributes;
			if (ptkExtends != null)
				*ptkExtends = type.BaseType != null ? type.BaseType.MetadataToken.ToUInt32() : 0;

			return S_OK;
		}

		public uint GetInterfaceImplProps(uint iiImpl, out uint pClass)
		{
			throw new NotImplementedException();
		}

		public uint GetTypeRefProps(uint tr, out uint ptkResolutionScope, StringBuilder szName, uint cchName)
		{
			throw new NotImplementedException();
		}

		public uint ResolveTypeRef(uint tr, ref Guid riid, out object ppIScope)
		{
			throw new NotImplementedException();
		}

		public uint EnumMembers(ref uint phEnum, uint cl, uint[] rMembers, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMembersWithName(ref uint phEnum, uint cl, string szName, uint[] rMembers, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMethods(ref uint phEnum, uint cl, IntPtr rMethods, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMethodsWithName(ref uint phEnum, uint cl, string szName, uint[] rMethods, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumFields(ref uint phEnum, uint cl, IntPtr rFields, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumFieldsWithName(ref uint phEnum, uint cl, string szName, uint[] rFields, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumParams(ref uint phEnum, uint mb, uint[] rParams, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMemberRefs(ref uint phEnum, uint tkParent, uint[] rMemberRefs, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMethodImpls(ref uint phEnum, uint td, uint[] rMethodBody, uint[] rMethodDecl, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumPermissionSets(ref uint phEnum, uint tk, uint dwActions, uint[] rPermission, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint FindMember(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint FindMethod(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint FindField(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint FindMemberRef(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint GetMethodProps(uint mb, uint* pClass, char* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags)
		{
			MethodDefinition method;
			if (!TryGetMethod(mb, out method))
				return E_FAIL;

			if (pClass != null)
				*pClass = method.DeclaringType.MetadataToken.ToUInt32();

			WriteNameBuffer(method.Name, szMethod, cchMethod, pchMethod);

			if (pdwAttr != null)
				*pdwAttr = (uint)method.Attributes;
			if (pulCodeRVA != null)
				*pulCodeRVA = (uint)method.RVA;
			if (pdwImplFlags != null)
				*pdwImplFlags = (uint)method.ImplAttributes;

			return S_OK;
		}

		static void WriteNameBuffer(string name, char* buffer, uint bufferLength, uint* actualLength)
		{
			var length = Math.Min(name.Length, bufferLength - 1);
			if (actualLength != null)
				*actualLength = (uint)length;

			if (buffer != null && bufferLength > 0)
			{
				for (int i = 0; i < length; i++)
					buffer[i] = name[i];
				buffer[length + 1] = '\0';
			}
		}

		public uint GetMemberRefProps(uint mr, ref uint ptk, StringBuilder szMember, uint cchMember, out uint pchMember, out IntPtr ppvSigBlob)
		{
			throw new NotImplementedException();
		}

		public uint EnumProperties(ref uint phEnum, uint td, IntPtr rProperties, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumEvents(ref uint phEnum, uint td, IntPtr rEvents, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint GetEventProps(uint ev, out uint pClass, StringBuilder szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags, out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire, uint[] rmdOtherMethod, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint EnumMethodSemantics(ref uint phEnum, uint mb, uint[] rEventProp, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint GetMethodSemantics(uint mb, uint tkEventProp)
		{
			throw new NotImplementedException();
		}

		public uint GetClassLayout(uint td, out uint pdwPackSize, IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset)
		{
			throw new NotImplementedException();
		}

		public uint GetFieldMarshal(uint tk, out IntPtr ppvNativeType)
		{
			throw new NotImplementedException();
		}

		public uint GetRVA(uint tk, out uint pulCodeRVA)
		{
			throw new NotImplementedException();
		}

		public uint GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr ppvPermission)
		{
			throw new NotImplementedException();
		}

		public uint GetSigFromToken(uint mdSig, out IntPtr ppvSig)
		{
			throw new NotImplementedException();
		}

		public uint GetModuleRefProps(uint mur, StringBuilder szName, uint cchName)
		{
			throw new NotImplementedException();
		}

		public uint EnumModuleRefs(ref uint phEnum, uint[] rModuleRefs, uint cmax)
		{
			throw new NotImplementedException();
		}

		public uint GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig)
		{
			throw new NotImplementedException();
		}

		public uint GetNameFromToken(uint tk)
		{
			throw new NotImplementedException();
		}

		public uint EnumUnresolvedMethods(ref uint phEnum, uint[] rMethods, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint GetUserString(uint stk, StringBuilder szString, uint cchString)
		{
			throw new NotImplementedException();
		}

		public uint GetPinvokeMap(uint tk, out uint pdwMappingFlags, StringBuilder szImportName, uint cchImportName, out uint pchImportName)
		{
			throw new NotImplementedException();
		}

		public uint EnumSignatures(ref uint phEnum, uint[] rSignatures, uint cmax)
		{
			throw new NotImplementedException();
		}

		public uint EnumTypeSpecs(ref uint phEnum, uint[] rTypeSpecs, uint cmax)
		{
			throw new NotImplementedException();
		}

		public uint EnumUserStrings(ref uint phEnum, uint[] rStrings, uint cmax)
		{
			throw new NotImplementedException();
		}

		public int GetParamForMethodIndex(uint md, uint ulParamSeq, out uint pParam)
		{
			throw new NotImplementedException();
		}

		public uint EnumCustomAttributes(ref uint phEnum, uint tk, uint tkType, uint[] rCustomAttributes, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr ppBlob)
		{
			throw new NotImplementedException();
		}

		public uint FindTypeRef(uint tkResolutionScope, string szName)
		{
			throw new NotImplementedException();
		}

		public uint GetMemberProps(uint mb, out uint pClass, StringBuilder szMember, uint cchMember, out uint pchMember, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
		{
			throw new NotImplementedException();
		}

		public uint GetFieldProps(uint mb, out uint pClass, StringBuilder szField, uint cchField, out uint pchField, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
		{
			throw new NotImplementedException();
		}

		public uint GetPropertyProps(uint prop, out uint pClass, StringBuilder szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter, out uint pmdGetter, uint[] rmdOtherMethod, uint cMax)
		{
			throw new NotImplementedException();
		}

		public uint GetParamProps(uint tk, out uint pmd, out uint pulSequence, StringBuilder szName, uint cchName, out uint pchName, out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
		{
			throw new NotImplementedException();
		}

		public uint GetCustomAttributeByName(uint tkObj, string szName, out IntPtr ppData)
		{
			throw new NotImplementedException();
		}

		public bool IsValidToken(uint tk)
		{
			throw new NotImplementedException();
		}

		public uint GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass)
		{
			TypeDefinition type;
			if (!TryGetType(tdNestedClass, out type))
				return E_FAIL;

			if (ptdEnclosingClass != null)
				*ptdEnclosingClass = type.IsNested ? type.DeclaringType.MetadataToken.ToUInt32() : 0;

			return S_OK;
		}

		public uint GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig)
		{
			throw new NotImplementedException();
		}

		public int IsGlobal(uint pd)
		{
			throw new NotImplementedException();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public class ModuleReference : IMetadataScope
	{

		string name;

		internal MetadataToken token;

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public virtual MetadataScopeType MetadataScopeType
		{
			get { return MetadataScopeType.ModuleReference; }
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		internal ModuleReference()
		{
			this.token = new MetadataToken(TokenType.ModuleRef);
		}

		public ModuleReference(string name)
			: this()
		{
			this.name = name;
		}

		public override string ToString()
		{
			return name;
		}
	}
}
//
// MonoSymbolFile.cs
//
// Authors:
//   Martin Baulig (martin@ximian.com)
//   Marek Safar (marek.safar@gmail.com)
//
// (C) 2003 Ximian, Inc.  http://www.ximian.com
// Copyright (C) 2012 Xamarin Inc (http://www.xamarin.com)
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//






namespace Mono.CompilerServices.SymbolWriter
{
	public class MonoSymbolFileException : Exception
	{
		public MonoSymbolFileException()
			: base()
		{ }

		public MonoSymbolFileException(string message, params object[] args)
			: base(String.Format(message, args))
		{
		}

		public MonoSymbolFileException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}

	sealed class MyBinaryWriter : BinaryWriter
	{
		public MyBinaryWriter(Stream stream)
			: base(stream)
		{ }

		public void WriteLeb128(int value)
		{
			base.Write7BitEncodedInt(value);
		}
	}

	internal class MyBinaryReader : BinaryReader
	{
		public MyBinaryReader(Stream stream)
			: base(stream)
		{ }

		public int ReadLeb128()
		{
			return base.Read7BitEncodedInt();
		}

		public string ReadString(int offset)
		{
			long old_pos = BaseStream.Position;
			BaseStream.Position = offset;

			string text = ReadString();

			BaseStream.Position = old_pos;
			return text;
		}
	}

	public interface ISourceFile
	{
		SourceFileEntry Entry
		{
			get;
		}
	}

	public interface ICompileUnit
	{
		CompileUnitEntry Entry
		{
			get;
		}
	}

	public interface IMethodDef
	{
		string Name
		{
			get;
		}

		int Token
		{
			get;
		}
	}

	public class MonoSymbolFile : IDisposable
	{
		List<MethodEntry> methods = new List<MethodEntry>();
		List<SourceFileEntry> sources = new List<SourceFileEntry>();
		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry>();
		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;

		OffsetTable ot;
		int last_type_index;
		int last_method_index;
		int last_namespace_index;

		public readonly int MajorVersion = OffsetTable.MajorVersion;
		public readonly int MinorVersion = OffsetTable.MinorVersion;

		public int NumLineNumbers;

		public MonoSymbolFile()
		{
			ot = new OffsetTable();
		}

		public int AddSource(SourceFileEntry source)
		{
			sources.Add(source);
			return sources.Count;
		}

		public int AddCompileUnit(CompileUnitEntry entry)
		{
			comp_units.Add(entry);
			return comp_units.Count;
		}

		public void AddMethod(MethodEntry entry)
		{
			methods.Add(entry);
		}

		public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token,
						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
						 string real_name, MethodEntry.Flags flags,
						 int namespace_id)
		{
			if (reader != null)
				throw new InvalidOperationException();

			MethodEntry method = new MethodEntry(
				this, comp_unit, token, scope_vars, locals, lines, code_blocks,
				real_name, flags, namespace_id);
			AddMethod(method);
			return method;
		}

		internal void DefineAnonymousScope(int id)
		{
			if (reader != null)
				throw new InvalidOperationException();

			if (anonymous_scopes == null)
				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>();

			anonymous_scopes.Add(id, new AnonymousScopeEntry(id));
		}

		internal void DefineCapturedVariable(int scope_id, string name, string captured_name,
							  CapturedVariable.CapturedKind kind)
		{
			if (reader != null)
				throw new InvalidOperationException();

			AnonymousScopeEntry scope = anonymous_scopes[scope_id];
			scope.AddCapturedVariable(name, captured_name, kind);
		}

		internal void DefineCapturedScope(int scope_id, int id, string captured_name)
		{
			if (reader != null)
				throw new InvalidOperationException();

			AnonymousScopeEntry scope = anonymous_scopes[scope_id];
			scope.AddCapturedScope(id, captured_name);
		}

		internal int GetNextTypeIndex()
		{
			return ++last_type_index;
		}

		internal int GetNextMethodIndex()
		{
			return ++last_method_index;
		}

		internal int GetNextNamespaceIndex()
		{
			return ++last_namespace_index;
		}

		void Write(MyBinaryWriter bw, Guid guid)
		{
			// Magic number and file version.
			bw.Write(OffsetTable.Magic);
			bw.Write(MajorVersion);
			bw.Write(MinorVersion);

			bw.Write(guid.ToByteArray());

			//
			// Offsets of file sections; we must write this after we're done
			// writing the whole file, so we just reserve the space for it here.
			//
			long offset_table_offset = bw.BaseStream.Position;
			ot.Write(bw, MajorVersion, MinorVersion);

			//
			// Sort the methods according to their tokens and update their index.
			//
			methods.Sort();
			for (int i = 0; i < methods.Count; i++)
				methods[i].Index = i + 1;

			//
			// Write data sections.
			//
			ot.DataSectionOffset = (int)bw.BaseStream.Position;
			foreach (SourceFileEntry source in sources)
				source.WriteData(bw);
			foreach (CompileUnitEntry comp_unit in comp_units)
				comp_unit.WriteData(bw);
			foreach (MethodEntry method in methods)
				method.WriteData(this, bw);
			ot.DataSectionSize = (int)bw.BaseStream.Position - ot.DataSectionOffset;

			//
			// Write the method index table.
			//
			ot.MethodTableOffset = (int)bw.BaseStream.Position;
			for (int i = 0; i < methods.Count; i++)
			{
				MethodEntry entry = methods[i];
				entry.Write(bw);
			}
			ot.MethodTableSize = (int)bw.BaseStream.Position - ot.MethodTableOffset;

			//
			// Write source table.
			//
			ot.SourceTableOffset = (int)bw.BaseStream.Position;
			for (int i = 0; i < sources.Count; i++)
			{
				SourceFileEntry source = sources[i];
				source.Write(bw);
			}
			ot.SourceTableSize = (int)bw.BaseStream.Position - ot.SourceTableOffset;

			//
			// Write compilation unit table.
			//
			ot.CompileUnitTableOffset = (int)bw.BaseStream.Position;
			for (int i = 0; i < comp_units.Count; i++)
			{
				CompileUnitEntry unit = comp_units[i];
				unit.Write(bw);
			}
			ot.CompileUnitTableSize = (int)bw.BaseStream.Position - ot.CompileUnitTableOffset;

			//
			// Write anonymous scope table.
			//
			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count : 0;
			ot.AnonymousScopeTableOffset = (int)bw.BaseStream.Position;
			if (anonymous_scopes != null)
			{
				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
					scope.Write(bw);
			}
			ot.AnonymousScopeTableSize = (int)bw.BaseStream.Position - ot.AnonymousScopeTableOffset;

			//
			// Fixup offset table.
			//
			ot.TypeCount = last_type_index;
			ot.MethodCount = methods.Count;
			ot.SourceCount = sources.Count;
			ot.CompileUnitCount = comp_units.Count;

			//
			// Write offset table.
			//
			ot.TotalFileSize = (int)bw.BaseStream.Position;
			bw.Seek((int)offset_table_offset, SeekOrigin.Begin);
			ot.Write(bw, MajorVersion, MinorVersion);
			bw.Seek(0, SeekOrigin.End);

#if false
			Console.WriteLine ("TOTAL: {0} line numbes, {1} bytes, extended {2} bytes, " +
					   "{3} methods.", NumLineNumbers, LineNumberSize,
					   ExtendedLineNumberSize, methods.Count);
#endif
		}

		public void CreateSymbolFile(Guid guid, FileStream fs)
		{
			if (reader != null)
				throw new InvalidOperationException();

			Write(new MyBinaryWriter(fs), guid);
		}

		MyBinaryReader reader;
		Dictionary<int, SourceFileEntry> source_file_hash;
		Dictionary<int, CompileUnitEntry> compile_unit_hash;

		List<MethodEntry> method_list;
		Dictionary<int, MethodEntry> method_token_hash;
		Dictionary<string, int> source_name_hash;

		Guid guid;

		MonoSymbolFile(Stream stream)
		{
			reader = new MyBinaryReader(stream);

			try
			{
				long magic = reader.ReadInt64();
				int major_version = reader.ReadInt32();
				int minor_version = reader.ReadInt32();

				if (magic != OffsetTable.Magic)
					throw new MonoSymbolFileException("Symbol file is not a valid");
				if (major_version != OffsetTable.MajorVersion)
					throw new MonoSymbolFileException(
						"Symbol file has version {0} but expected {1}", major_version, OffsetTable.MajorVersion);
				if (minor_version != OffsetTable.MinorVersion)
					throw new MonoSymbolFileException("Symbol file has version {0}.{1} but expected {2}.{3}",
						major_version, minor_version,
						OffsetTable.MajorVersion, OffsetTable.MinorVersion);

				MajorVersion = major_version;
				MinorVersion = minor_version;
				guid = new Guid(reader.ReadBytes(16));

				ot = new OffsetTable(reader, major_version, minor_version);
			}
			catch (Exception e)
			{
				throw new MonoSymbolFileException("Cannot read symbol file", e);
			}

			source_file_hash = new Dictionary<int, SourceFileEntry>();
			compile_unit_hash = new Dictionary<int, CompileUnitEntry>();
		}

#if !NET_CORE
		public static MonoSymbolFile ReadSymbolFile(Assembly assembly)
		{
			string filename = assembly.Location;
			string name = filename + ".mdb";

			Module[] modules = assembly.GetModules();
			Guid assembly_guid = modules[0].ModuleVersionId;

			return ReadSymbolFile(name, assembly_guid);
		}
#endif

		public static MonoSymbolFile ReadSymbolFile(string mdbFilename)
		{
			return ReadSymbolFile(new FileStream(mdbFilename, FileMode.Open, FileAccess.Read));
		}

		public static MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid)
		{
			var sf = ReadSymbolFile(mdbFilename);
			if (assemblyGuid != sf.guid)
				throw new MonoSymbolFileException("Symbol file `{0}' does not match assembly", mdbFilename);

			return sf;
		}

		public static MonoSymbolFile ReadSymbolFile(Stream stream)
		{
			return new MonoSymbolFile(stream);
		}

		public int CompileUnitCount
		{
			get { return ot.CompileUnitCount; }
		}

		public int SourceCount
		{
			get { return ot.SourceCount; }
		}

		public int MethodCount
		{
			get { return ot.MethodCount; }
		}

		public int TypeCount
		{
			get { return ot.TypeCount; }
		}

		public int AnonymousScopeCount
		{
			get { return ot.AnonymousScopeCount; }
		}

		public int NamespaceCount
		{
			get { return last_namespace_index; }
		}

		public Guid Guid
		{
			get { return guid; }
		}

		public OffsetTable OffsetTable
		{
			get { return ot; }
		}

		internal int LineNumberCount = 0;
		internal int LocalCount = 0;
		internal int StringSize = 0;

		internal int LineNumberSize = 0;
		internal int ExtendedLineNumberSize = 0;

		public SourceFileEntry GetSourceFile(int index)
		{
			if ((index < 1) || (index > ot.SourceCount))
				throw new ArgumentException();
			if (reader == null)
				throw new InvalidOperationException();

			lock (this)
			{
				SourceFileEntry source;
				if (source_file_hash.TryGetValue(index, out source))
					return source;

				long old_pos = reader.BaseStream.Position;

				reader.BaseStream.Position = ot.SourceTableOffset +
					SourceFileEntry.Size * (index - 1);
				source = new SourceFileEntry(this, reader);
				source_file_hash.Add(index, source);

				reader.BaseStream.Position = old_pos;
				return source;
			}
		}

		public SourceFileEntry[] Sources
		{
			get
			{
				if (reader == null)
					throw new InvalidOperationException();

				SourceFileEntry[] retval = new SourceFileEntry[SourceCount];
				for (int i = 0; i < SourceCount; i++)
					retval[i] = GetSourceFile(i + 1);
				return retval;
			}
		}

		public CompileUnitEntry GetCompileUnit(int index)
		{
			if ((index < 1) || (index > ot.CompileUnitCount))
				throw new ArgumentException();
			if (reader == null)
				throw new InvalidOperationException();

			lock (this)
			{
				CompileUnitEntry unit;
				if (compile_unit_hash.TryGetValue(index, out unit))
					return unit;

				long old_pos = reader.BaseStream.Position;

				reader.BaseStream.Position = ot.CompileUnitTableOffset +
					CompileUnitEntry.Size * (index - 1);
				unit = new CompileUnitEntry(this, reader);
				compile_unit_hash.Add(index, unit);

				reader.BaseStream.Position = old_pos;
				return unit;
			}
		}

		public CompileUnitEntry[] CompileUnits
		{
			get
			{
				if (reader == null)
					throw new InvalidOperationException();

				CompileUnitEntry[] retval = new CompileUnitEntry[CompileUnitCount];
				for (int i = 0; i < CompileUnitCount; i++)
					retval[i] = GetCompileUnit(i + 1);
				return retval;
			}
		}

		void read_methods()
		{
			lock (this)
			{
				if (method_token_hash != null)
					return;

				method_token_hash = new Dictionary<int, MethodEntry>();
				method_list = new List<MethodEntry>();

				long old_pos = reader.BaseStream.Position;
				reader.BaseStream.Position = ot.MethodTableOffset;

				for (int i = 0; i < MethodCount; i++)
				{
					MethodEntry entry = new MethodEntry(this, reader, i + 1);
					method_token_hash.Add(entry.Token, entry);
					method_list.Add(entry);
				}

				reader.BaseStream.Position = old_pos;
			}
		}

		public MethodEntry GetMethodByToken(int token)
		{
			if (reader == null)
				throw new InvalidOperationException();

			lock (this)
			{
				read_methods();
				MethodEntry me;
				method_token_hash.TryGetValue(token, out me);
				return me;
			}
		}

		public MethodEntry GetMethod(int index)
		{
			if ((index < 1) || (index > ot.MethodCount))
				throw new ArgumentException();
			if (reader == null)
				throw new InvalidOperationException();

			lock (this)
			{
				read_methods();
				return method_list[index - 1];
			}
		}

		public MethodEntry[] Methods
		{
			get
			{
				if (reader == null)
					throw new InvalidOperationException();

				lock (this)
				{
					read_methods();
					MethodEntry[] retval = new MethodEntry[MethodCount];
					method_list.CopyTo(retval, 0);
					return retval;
				}
			}
		}

		public int FindSource(string file_name)
		{
			if (reader == null)
				throw new InvalidOperationException();

			lock (this)
			{
				if (source_name_hash == null)
				{
					source_name_hash = new Dictionary<string, int>();

					for (int i = 0; i < ot.SourceCount; i++)
					{
						SourceFileEntry source = GetSourceFile(i + 1);
						source_name_hash.Add(source.FileName, i);
					}
				}

				int value;
				if (!source_name_hash.TryGetValue(file_name, out value))
					return -1;
				return value;
			}
		}

		public AnonymousScopeEntry GetAnonymousScope(int id)
		{
			if (reader == null)
				throw new InvalidOperationException();

			AnonymousScopeEntry scope;
			lock (this)
			{
				if (anonymous_scopes != null)
				{
					anonymous_scopes.TryGetValue(id, out scope);
					return scope;
				}

				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>();
				reader.BaseStream.Position = ot.AnonymousScopeTableOffset;
				for (int i = 0; i < ot.AnonymousScopeCount; i++)
				{
					scope = new AnonymousScopeEntry(reader);
					anonymous_scopes.Add(scope.ID, scope);
				}

				return anonymous_scopes[id];
			}
		}

		internal MyBinaryReader BinaryReader
		{
			get
			{
				if (reader == null)
					throw new InvalidOperationException();

				return reader;
			}
		}

		public void Dispose()
		{
			Dispose(true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (reader != null)
				{
#if NET_CORE
					reader.Dispose ();
#else
					reader.Close();
#endif
					reader = null;
				}
			}
		}
	}
}
//
// Mono.CSharp.Debugger/MonoSymbolTable.cs
//
// Author:
//   Martin Baulig (martin@ximian.com)
//
// (C) 2002 Ximian, Inc.  http://www.ximian.com
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//







//
// Parts which are actually written into the symbol file are marked with
//
//         #region This is actually written to the symbol file
//         #endregion
//
// Please do not modify these regions without previously talking to me.
//
// All changes to the file format must be synchronized in several places:
//
// a) The fields in these regions (and their order) must match the actual
//    contents of the symbol file.
//
//    This helps people to understand the symbol file format without reading
//    too much source code, ie. you look at the appropriate region and then
//    you know what's actually in the file.
//
//    It is also required to help me enforce b).
//
// b) The regions must be kept in sync with the unmanaged code in
//    mono/metadata/debug-mono-symfile.h
//
// When making changes to the file format, you must also increase two version
// numbers:
//
// i)  OffsetTable.Version in this file.
// ii) MONO_SYMBOL_FILE_VERSION in mono/metadata/debug-mono-symfile.h
//
// After doing so, recompile everything, including the debugger.  Symbol files
// with different versions are incompatible to each other and the debugger and
// the runtime enfore this, so you need to recompile all your assemblies after
// changing the file format.
//

namespace Mono.CompilerServices.SymbolWriter
{
	public class OffsetTable
	{
		public const int MajorVersion = 50;
		public const int MinorVersion = 0;
		public const long Magic = 0x45e82623fd7fa614;

		#region This is actually written to the symbol file
		public int TotalFileSize;
		public int DataSectionOffset;
		public int DataSectionSize;
		public int CompileUnitCount;
		public int CompileUnitTableOffset;
		public int CompileUnitTableSize;
		public int SourceCount;
		public int SourceTableOffset;
		public int SourceTableSize;
		public int MethodCount;
		public int MethodTableOffset;
		public int MethodTableSize;
		public int TypeCount;
		public int AnonymousScopeCount;
		public int AnonymousScopeTableOffset;
		public int AnonymousScopeTableSize;

		[Flags]
		public enum Flags
		{
			IsAspxSource = 1,
			WindowsFileNames = 2
		}

		public Flags FileFlags;

		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
		#endregion

		internal OffsetTable()
		{
#if !NET_CORE
			int platform = (int)Environment.OSVersion.Platform;
			if ((platform != 4) && (platform != 128))
				FileFlags |= Flags.WindowsFileNames;
#endif
		}

		internal OffsetTable(BinaryReader reader, int major_version, int minor_version)
		{
			TotalFileSize = reader.ReadInt32();
			DataSectionOffset = reader.ReadInt32();
			DataSectionSize = reader.ReadInt32();
			CompileUnitCount = reader.ReadInt32();
			CompileUnitTableOffset = reader.ReadInt32();
			CompileUnitTableSize = reader.ReadInt32();
			SourceCount = reader.ReadInt32();
			SourceTableOffset = reader.ReadInt32();
			SourceTableSize = reader.ReadInt32();
			MethodCount = reader.ReadInt32();
			MethodTableOffset = reader.ReadInt32();
			MethodTableSize = reader.ReadInt32();
			TypeCount = reader.ReadInt32();

			AnonymousScopeCount = reader.ReadInt32();
			AnonymousScopeTableOffset = reader.ReadInt32();
			AnonymousScopeTableSize = reader.ReadInt32();

			LineNumberTable_LineBase = reader.ReadInt32();
			LineNumberTable_LineRange = reader.ReadInt32();
			LineNumberTable_OpcodeBase = reader.ReadInt32();

			FileFlags = (Flags)reader.ReadInt32();
		}

		internal void Write(BinaryWriter bw, int major_version, int minor_version)
		{
			bw.Write(TotalFileSize);
			bw.Write(DataSectionOffset);
			bw.Write(DataSectionSize);
			bw.Write(CompileUnitCount);
			bw.Write(CompileUnitTableOffset);
			bw.Write(CompileUnitTableSize);
			bw.Write(SourceCount);
			bw.Write(SourceTableOffset);
			bw.Write(SourceTableSize);
			bw.Write(MethodCount);
			bw.Write(MethodTableOffset);
			bw.Write(MethodTableSize);
			bw.Write(TypeCount);

			bw.Write(AnonymousScopeCount);
			bw.Write(AnonymousScopeTableOffset);
			bw.Write(AnonymousScopeTableSize);

			bw.Write(LineNumberTable_LineBase);
			bw.Write(LineNumberTable_LineRange);
			bw.Write(LineNumberTable_OpcodeBase);

			bw.Write((int)FileFlags);
		}

		public override string ToString()
		{
			return String.Format(
				"OffsetTable [{0} - {1}:{2} - {3}:{4}:{5} - {6}:{7}:{8} - {9}]",
				TotalFileSize, DataSectionOffset, DataSectionSize, SourceCount,
				SourceTableOffset, SourceTableSize, MethodCount, MethodTableOffset,
				MethodTableSize, TypeCount);
		}
	}

	public class LineNumberEntry
	{
		#region This is actually written to the symbol file
		public readonly int Row;
		public int Column;
		public int EndRow, EndColumn;
		public readonly int File;
		public readonly int Offset;
		public readonly bool IsHidden;  // Obsolete is never used
		#endregion

		public sealed class LocationComparer : IComparer<LineNumberEntry>
		{
			public static readonly LocationComparer Default = new LocationComparer();

			public int Compare(LineNumberEntry l1, LineNumberEntry l2)
			{
				return l1.Row == l2.Row ?
					l1.Column.CompareTo(l2.Column) :
					l1.Row.CompareTo(l2.Row);
			}
		}

		public static readonly LineNumberEntry Null = new LineNumberEntry(0, 0, 0, 0);

		public LineNumberEntry(int file, int row, int column, int offset)
			: this(file, row, column, offset, false)
		{
		}

		public LineNumberEntry(int file, int row, int offset)
			: this(file, row, -1, offset, false)
		{
		}

		public LineNumberEntry(int file, int row, int column, int offset, bool is_hidden)
		: this(file, row, column, -1, -1, offset, is_hidden)
		{
		}

		public LineNumberEntry(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden)
		{
			this.File = file;
			this.Row = row;
			this.Column = column;
			this.EndRow = end_row;
			this.EndColumn = end_column;
			this.Offset = offset;
			this.IsHidden = is_hidden;
		}

		public override string ToString()
		{
			return String.Format("[Line {0}:{1},{2}-{3},{4}:{5}]", File, Row, Column, EndRow, EndColumn, Offset);
		}
	}

	public class CodeBlockEntry
	{
		public int Index;
		#region This is actually written to the symbol file
		public int Parent;
		public Type BlockType;
		public int StartOffset;
		public int EndOffset;
		#endregion

		public enum Type
		{
			Lexical = 1,
			CompilerGenerated = 2,
			IteratorBody = 3,
			IteratorDispatcher = 4
		}

		public CodeBlockEntry(int index, int parent, Type type, int start_offset)
		{
			this.Index = index;
			this.Parent = parent;
			this.BlockType = type;
			this.StartOffset = start_offset;
		}

		internal CodeBlockEntry(int index, MyBinaryReader reader)
		{
			this.Index = index;
			int type_flag = reader.ReadLeb128();
			BlockType = (Type)(type_flag & 0x3f);
			this.Parent = reader.ReadLeb128();
			this.StartOffset = reader.ReadLeb128();
			this.EndOffset = reader.ReadLeb128();

			/* Reserved for future extensions. */
			if ((type_flag & 0x40) != 0)
			{
				int data_size = reader.ReadInt16();
				reader.BaseStream.Position += data_size;
			}
		}

		public void Close(int end_offset)
		{
			this.EndOffset = end_offset;
		}

		internal void Write(MyBinaryWriter bw)
		{
			bw.WriteLeb128((int)BlockType);
			bw.WriteLeb128(Parent);
			bw.WriteLeb128(StartOffset);
			bw.WriteLeb128(EndOffset);
		}

		public override string ToString()
		{
			return String.Format("[CodeBlock {0}:{1}:{2}:{3}:{4}]",
						  Index, Parent, BlockType, StartOffset, EndOffset);
		}
	}

	public struct LocalVariableEntry
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		public readonly string Name;
		public readonly int BlockIndex;
		#endregion

		public LocalVariableEntry(int index, string name, int block)
		{
			this.Index = index;
			this.Name = name;
			this.BlockIndex = block;
		}

		internal LocalVariableEntry(MonoSymbolFile file, MyBinaryReader reader)
		{
			Index = reader.ReadLeb128();
			Name = reader.ReadString();
			BlockIndex = reader.ReadLeb128();
		}

		internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
		{
			bw.WriteLeb128(Index);
			bw.Write(Name);
			bw.WriteLeb128(BlockIndex);
		}

		public override string ToString()
		{
			return String.Format("[LocalVariable {0}:{1}:{2}]",
						  Name, Index, BlockIndex - 1);
		}
	}

	public struct CapturedVariable
	{
		#region This is actually written to the symbol file
		public readonly string Name;
		public readonly string CapturedName;
		public readonly CapturedKind Kind;
		#endregion

		public enum CapturedKind : byte
		{
			Local,
			Parameter,
			This
		}

		public CapturedVariable(string name, string captured_name,
					 CapturedKind kind)
		{
			this.Name = name;
			this.CapturedName = captured_name;
			this.Kind = kind;
		}

		internal CapturedVariable(MyBinaryReader reader)
		{
			Name = reader.ReadString();
			CapturedName = reader.ReadString();
			Kind = (CapturedKind)reader.ReadByte();
		}

		internal void Write(MyBinaryWriter bw)
		{
			bw.Write(Name);
			bw.Write(CapturedName);
			bw.Write((byte)Kind);
		}

		public override string ToString()
		{
			return String.Format("[CapturedVariable {0}:{1}:{2}]",
						  Name, CapturedName, Kind);
		}
	}

	public struct CapturedScope
	{
		#region This is actually written to the symbol file
		public readonly int Scope;
		public readonly string CapturedName;
		#endregion

		public CapturedScope(int scope, string captured_name)
		{
			this.Scope = scope;
			this.CapturedName = captured_name;
		}

		internal CapturedScope(MyBinaryReader reader)
		{
			Scope = reader.ReadLeb128();
			CapturedName = reader.ReadString();
		}

		internal void Write(MyBinaryWriter bw)
		{
			bw.WriteLeb128(Scope);
			bw.Write(CapturedName);
		}

		public override string ToString()
		{
			return String.Format("[CapturedScope {0}:{1}]",
						  Scope, CapturedName);
		}
	}

	public struct ScopeVariable
	{
		#region This is actually written to the symbol file
		public readonly int Scope;
		public readonly int Index;
		#endregion

		public ScopeVariable(int scope, int index)
		{
			this.Scope = scope;
			this.Index = index;
		}

		internal ScopeVariable(MyBinaryReader reader)
		{
			Scope = reader.ReadLeb128();
			Index = reader.ReadLeb128();
		}

		internal void Write(MyBinaryWriter bw)
		{
			bw.WriteLeb128(Scope);
			bw.WriteLeb128(Index);
		}

		public override string ToString()
		{
			return String.Format("[ScopeVariable {0}:{1}]", Scope, Index);
		}
	}

	public class AnonymousScopeEntry
	{
		#region This is actually written to the symbol file
		public readonly int ID;
		#endregion

		List<CapturedVariable> captured_vars = new List<CapturedVariable>();
		List<CapturedScope> captured_scopes = new List<CapturedScope>();

		public AnonymousScopeEntry(int id)
		{
			this.ID = id;
		}

		internal AnonymousScopeEntry(MyBinaryReader reader)
		{
			ID = reader.ReadLeb128();

			int num_captured_vars = reader.ReadLeb128();
			for (int i = 0; i < num_captured_vars; i++)
				captured_vars.Add(new CapturedVariable(reader));

			int num_captured_scopes = reader.ReadLeb128();
			for (int i = 0; i < num_captured_scopes; i++)
				captured_scopes.Add(new CapturedScope(reader));
		}

		internal void AddCapturedVariable(string name, string captured_name,
						   CapturedVariable.CapturedKind kind)
		{
			captured_vars.Add(new CapturedVariable(name, captured_name, kind));
		}

		public CapturedVariable[] CapturedVariables
		{
			get
			{
				CapturedVariable[] retval = new CapturedVariable[captured_vars.Count];
				captured_vars.CopyTo(retval, 0);
				return retval;
			}
		}

		internal void AddCapturedScope(int scope, string captured_name)
		{
			captured_scopes.Add(new CapturedScope(scope, captured_name));
		}

		public CapturedScope[] CapturedScopes
		{
			get
			{
				CapturedScope[] retval = new CapturedScope[captured_scopes.Count];
				captured_scopes.CopyTo(retval, 0);
				return retval;
			}
		}

		internal void Write(MyBinaryWriter bw)
		{
			bw.WriteLeb128(ID);

			bw.WriteLeb128(captured_vars.Count);
			foreach (CapturedVariable cv in captured_vars)
				cv.Write(bw);

			bw.WriteLeb128(captured_scopes.Count);
			foreach (CapturedScope cs in captured_scopes)
				cs.Write(bw);
		}

		public override string ToString()
		{
			return String.Format("[AnonymousScope {0}]", ID);
		}
	}

	public class CompileUnitEntry : ICompileUnit
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		int DataOffset;
		#endregion

		MonoSymbolFile file;
		SourceFileEntry source;
		List<SourceFileEntry> include_files;
		List<NamespaceEntry> namespaces;

		bool creating;

		public static int Size
		{
			get { return 8; }
		}

		CompileUnitEntry ICompileUnit.Entry
		{
			get { return this; }
		}

		public CompileUnitEntry(MonoSymbolFile file, SourceFileEntry source)
		{
			this.file = file;
			this.source = source;

			this.Index = file.AddCompileUnit(this);

			creating = true;
			namespaces = new List<NamespaceEntry>();
		}

		public void AddFile(SourceFileEntry file)
		{
			if (!creating)
				throw new InvalidOperationException();

			if (include_files == null)
				include_files = new List<SourceFileEntry>();

			include_files.Add(file);
		}

		public SourceFileEntry SourceFile
		{
			get
			{
				if (creating)
					return source;

				ReadData();
				return source;
			}
		}

		public int DefineNamespace(string name, string[] using_clauses, int parent)
		{
			if (!creating)
				throw new InvalidOperationException();

			int index = file.GetNextNamespaceIndex();
			NamespaceEntry ns = new NamespaceEntry(name, index, using_clauses, parent);
			namespaces.Add(ns);
			return index;
		}

		internal void WriteData(MyBinaryWriter bw)
		{
			DataOffset = (int)bw.BaseStream.Position;
			bw.WriteLeb128(source.Index);

			int count_includes = include_files != null ? include_files.Count : 0;
			bw.WriteLeb128(count_includes);
			if (include_files != null)
			{
				foreach (SourceFileEntry entry in include_files)
					bw.WriteLeb128(entry.Index);
			}

			bw.WriteLeb128(namespaces.Count);
			foreach (NamespaceEntry ns in namespaces)
				ns.Write(file, bw);
		}

		internal void Write(BinaryWriter bw)
		{
			bw.Write(Index);
			bw.Write(DataOffset);
		}

		internal CompileUnitEntry(MonoSymbolFile file, MyBinaryReader reader)
		{
			this.file = file;

			Index = reader.ReadInt32();
			DataOffset = reader.ReadInt32();
		}

		public void ReadAll()
		{
			ReadData();
		}

		void ReadData()
		{
			if (creating)
				throw new InvalidOperationException();

			lock (file)
			{
				if (namespaces != null)
					return;

				MyBinaryReader reader = file.BinaryReader;
				int old_pos = (int)reader.BaseStream.Position;

				reader.BaseStream.Position = DataOffset;

				int source_idx = reader.ReadLeb128();
				source = file.GetSourceFile(source_idx);

				int count_includes = reader.ReadLeb128();
				if (count_includes > 0)
				{
					include_files = new List<SourceFileEntry>();
					for (int i = 0; i < count_includes; i++)
						include_files.Add(file.GetSourceFile(reader.ReadLeb128()));
				}

				int count_ns = reader.ReadLeb128();
				namespaces = new List<NamespaceEntry>();
				for (int i = 0; i < count_ns; i++)
					namespaces.Add(new NamespaceEntry(file, reader));

				reader.BaseStream.Position = old_pos;
			}
		}

		public NamespaceEntry[] Namespaces
		{
			get
			{
				ReadData();
				NamespaceEntry[] retval = new NamespaceEntry[namespaces.Count];
				namespaces.CopyTo(retval, 0);
				return retval;
			}
		}

		public SourceFileEntry[] IncludeFiles
		{
			get
			{
				ReadData();
				if (include_files == null)
					return new SourceFileEntry[0];

				SourceFileEntry[] retval = new SourceFileEntry[include_files.Count];
				include_files.CopyTo(retval, 0);
				return retval;
			}
		}
	}

	public class SourceFileEntry
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		int DataOffset;
		#endregion

		MonoSymbolFile file;
		string file_name;
		byte[] guid;
		byte[] hash;
		bool creating;
		bool auto_generated;
		readonly string sourceFile;

		public static int Size
		{
			get { return 8; }
		}

		public SourceFileEntry(MonoSymbolFile file, string file_name)
		{
			this.file = file;
			this.file_name = file_name;
			this.Index = file.AddSource(this);

			creating = true;
		}

		public SourceFileEntry(MonoSymbolFile file, string sourceFile, byte[] guid, byte[] checksum)
			: this(file, sourceFile, sourceFile, guid, checksum)
		{
		}

		public SourceFileEntry(MonoSymbolFile file, string fileName, string sourceFile, byte[] guid, byte[] checksum)
			: this(file, fileName)
		{
			this.guid = guid;
			this.hash = checksum;
			this.sourceFile = sourceFile;
		}

		public byte[] Checksum
		{
			get
			{
				return hash;
			}
		}

		internal void WriteData(MyBinaryWriter bw)
		{
			DataOffset = (int)bw.BaseStream.Position;
			bw.Write(file_name);

			if (guid == null)
				guid = new byte[16];

			if (hash == null)
			{
				try
				{
					using (FileStream fs = new FileStream(sourceFile, FileMode.Open, FileAccess.Read))
					{
						MD5 md5 = MD5.Create();
						hash = md5.ComputeHash(fs);
					}
				}
				catch
				{
					hash = new byte[16];
				}
			}

			bw.Write(guid);
			bw.Write(hash);
			bw.Write((byte)(auto_generated ? 1 : 0));
		}

		internal void Write(BinaryWriter bw)
		{
			bw.Write(Index);
			bw.Write(DataOffset);
		}

		internal SourceFileEntry(MonoSymbolFile file, MyBinaryReader reader)
		{
			this.file = file;

			Index = reader.ReadInt32();
			DataOffset = reader.ReadInt32();

			int old_pos = (int)reader.BaseStream.Position;
			reader.BaseStream.Position = DataOffset;

			sourceFile = file_name = reader.ReadString();
			guid = reader.ReadBytes(16);
			hash = reader.ReadBytes(16);
			auto_generated = reader.ReadByte() == 1;

			reader.BaseStream.Position = old_pos;
		}

		public string FileName
		{
			get { return file_name; }
			set { file_name = value; }
		}

		public bool AutoGenerated
		{
			get { return auto_generated; }
		}

		public void SetAutoGenerated()
		{
			if (!creating)
				throw new InvalidOperationException();

			auto_generated = true;
			file.OffsetTable.FileFlags |= OffsetTable.Flags.IsAspxSource;
		}

		public bool CheckChecksum()
		{
			try
			{
				using (FileStream fs = new FileStream(sourceFile, FileMode.Open))
				{
					MD5 md5 = MD5.Create();
					byte[] data = md5.ComputeHash(fs);
					for (int i = 0; i < 16; i++)
						if (data[i] != hash[i])
							return false;
					return true;
				}
			}
			catch
			{
				return false;
			}
		}

		public override string ToString()
		{
			return String.Format("SourceFileEntry ({0}:{1})", Index, DataOffset);
		}
	}

	public class LineNumberTable
	{
		protected LineNumberEntry[] _line_numbers;
		public LineNumberEntry[] LineNumbers
		{
			get { return _line_numbers; }
		}

		public readonly int LineBase;
		public readonly int LineRange;
		public readonly byte OpcodeBase;
		public readonly int MaxAddressIncrement;

		#region Configurable constants
		public const int Default_LineBase = -1;
		public const int Default_LineRange = 8;
		public const byte Default_OpcodeBase = 9;

		#endregion

		public const byte DW_LNS_copy = 1;
		public const byte DW_LNS_advance_pc = 2;
		public const byte DW_LNS_advance_line = 3;
		public const byte DW_LNS_set_file = 4;
		public const byte DW_LNS_const_add_pc = 8;

		public const byte DW_LNE_end_sequence = 1;

		// MONO extensions.
		public const byte DW_LNE_MONO_negate_is_hidden = 0x40;

		internal const byte DW_LNE_MONO__extensions_start = 0x40;
		internal const byte DW_LNE_MONO__extensions_end = 0x7f;

		protected LineNumberTable(MonoSymbolFile file)
		{
			this.LineBase = file.OffsetTable.LineNumberTable_LineBase;
			this.LineRange = file.OffsetTable.LineNumberTable_LineRange;
			this.OpcodeBase = (byte)file.OffsetTable.LineNumberTable_OpcodeBase;
			this.MaxAddressIncrement = (255 - OpcodeBase) / LineRange;
		}

		internal LineNumberTable(MonoSymbolFile file, LineNumberEntry[] lines)
			: this(file)
		{
			this._line_numbers = lines;
		}

		internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo)
		{
			int start = (int)bw.BaseStream.Position;

			bool last_is_hidden = false;
			int last_line = 1, last_offset = 0, last_file = 1;
			for (int i = 0; i < LineNumbers.Length; i++)
			{
				int line_inc = LineNumbers[i].Row - last_line;
				int offset_inc = LineNumbers[i].Offset - last_offset;

				if (LineNumbers[i].File != last_file)
				{
					bw.Write(DW_LNS_set_file);
					bw.WriteLeb128(LineNumbers[i].File);
					last_file = LineNumbers[i].File;
				}

				if (LineNumbers[i].IsHidden != last_is_hidden)
				{
					bw.Write((byte)0);
					bw.Write((byte)1);
					bw.Write(DW_LNE_MONO_negate_is_hidden);
					last_is_hidden = LineNumbers[i].IsHidden;
				}

				if (offset_inc >= MaxAddressIncrement)
				{
					if (offset_inc < 2 * MaxAddressIncrement)
					{
						bw.Write(DW_LNS_const_add_pc);
						offset_inc -= MaxAddressIncrement;
					}
					else
					{
						bw.Write(DW_LNS_advance_pc);
						bw.WriteLeb128(offset_inc);
						offset_inc = 0;
					}
				}

				if ((line_inc < LineBase) || (line_inc >= LineBase + LineRange))
				{
					bw.Write(DW_LNS_advance_line);
					bw.WriteLeb128(line_inc);
					if (offset_inc != 0)
					{
						bw.Write(DW_LNS_advance_pc);
						bw.WriteLeb128(offset_inc);
					}
					bw.Write(DW_LNS_copy);
				}
				else
				{
					byte opcode;
					opcode = (byte)(line_inc - LineBase + (LineRange * offset_inc) +
							 OpcodeBase);
					bw.Write(opcode);
				}

				last_line = LineNumbers[i].Row;
				last_offset = LineNumbers[i].Offset;
			}

			bw.Write((byte)0);
			bw.Write((byte)1);
			bw.Write(DW_LNE_end_sequence);

			if (hasColumnsInfo)
			{
				for (int i = 0; i < LineNumbers.Length; i++)
				{
					var ln = LineNumbers[i];
					if (ln.Row >= 0)
						bw.WriteLeb128(ln.Column);
				}
			}

			if (hasEndInfo)
			{
				for (int i = 0; i < LineNumbers.Length; i++)
				{
					var ln = LineNumbers[i];
					if (ln.EndRow == -1 || ln.EndColumn == -1 || ln.Row > ln.EndRow)
					{
						bw.WriteLeb128(0xffffff);
					}
					else
					{
						bw.WriteLeb128(ln.EndRow - ln.Row);
						bw.WriteLeb128(ln.EndColumn);
					}
				}
			}

			file.ExtendedLineNumberSize += (int)bw.BaseStream.Position - start;
		}

		internal static LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo)
		{
			LineNumberTable lnt = new LineNumberTable(file);
			lnt.DoRead(file, br, readColumnsInfo, readEndInfo);
			return lnt;
		}

		void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds)
		{
			var lines = new List<LineNumberEntry>();

			bool is_hidden = false, modified = false;
			int stm_line = 1, stm_offset = 0, stm_file = 1;
			while (true)
			{
				byte opcode = br.ReadByte();

				if (opcode == 0)
				{
					byte size = br.ReadByte();
					long end_pos = br.BaseStream.Position + size;
					opcode = br.ReadByte();

					if (opcode == DW_LNE_end_sequence)
					{
						if (modified)
							lines.Add(new LineNumberEntry(
								stm_file, stm_line, -1, stm_offset, is_hidden));
						break;
					}
					else if (opcode == DW_LNE_MONO_negate_is_hidden)
					{
						is_hidden = !is_hidden;
						modified = true;
					}
					else if ((opcode >= DW_LNE_MONO__extensions_start) &&
						 (opcode <= DW_LNE_MONO__extensions_end))
					{
						; // reserved for future extensions
					}
					else
					{
						throw new MonoSymbolFileException("Unknown extended opcode {0:x}", opcode);
					}

					br.BaseStream.Position = end_pos;
					continue;
				}
				else if (opcode < OpcodeBase)
				{
					switch (opcode)
					{
						case DW_LNS_copy:
							lines.Add(new LineNumberEntry(
								stm_file, stm_line, -1, stm_offset, is_hidden));
							modified = false;
							break;
						case DW_LNS_advance_pc:
							stm_offset += br.ReadLeb128();
							modified = true;
							break;
						case DW_LNS_advance_line:
							stm_line += br.ReadLeb128();
							modified = true;
							break;
						case DW_LNS_set_file:
							stm_file = br.ReadLeb128();
							modified = true;
							break;
						case DW_LNS_const_add_pc:
							stm_offset += MaxAddressIncrement;
							modified = true;
							break;
						default:
							throw new MonoSymbolFileException(
								"Unknown standard opcode {0:x} in LNT",
								opcode);
					}
				}
				else
				{
					opcode -= OpcodeBase;

					stm_offset += opcode / LineRange;
					stm_line += LineBase + (opcode % LineRange);
					lines.Add(new LineNumberEntry(
						stm_file, stm_line, -1, stm_offset, is_hidden));
					modified = false;
				}
			}

			_line_numbers = lines.ToArray();

			if (includesColumns)
			{
				for (int i = 0; i < _line_numbers.Length; ++i)
				{
					var ln = _line_numbers[i];
					if (ln.Row >= 0)
						ln.Column = br.ReadLeb128();
				}
			}
			if (includesEnds)
			{
				for (int i = 0; i < _line_numbers.Length; ++i)
				{
					var ln = _line_numbers[i];

					int row = br.ReadLeb128();
					if (row == 0xffffff)
					{
						ln.EndRow = -1;
						ln.EndColumn = -1;
					}
					else
					{
						ln.EndRow = ln.Row + row;
						ln.EndColumn = br.ReadLeb128();
					}
				}
			}
		}

		public bool GetMethodBounds(out LineNumberEntry start, out LineNumberEntry end)
		{
			if (_line_numbers.Length > 1)
			{
				start = _line_numbers[0];
				end = _line_numbers[_line_numbers.Length - 1];
				return true;
			}

			start = LineNumberEntry.Null;
			end = LineNumberEntry.Null;
			return false;
		}
	}

	public class MethodEntry : IComparable
	{
		#region This is actually written to the symbol file
		public readonly int CompileUnitIndex;
		public readonly int Token;
		public readonly int NamespaceID;

		int DataOffset;
		int LocalVariableTableOffset;
		int LineNumberTableOffset;
		int CodeBlockTableOffset;
		int ScopeVariableTableOffset;
		int RealNameOffset;
		Flags flags;
		#endregion

		int index;

		public Flags MethodFlags
		{
			get { return flags; }
		}

		public readonly CompileUnitEntry CompileUnit;

		LocalVariableEntry[] locals;
		CodeBlockEntry[] code_blocks;
		ScopeVariable[] scope_vars;
		LineNumberTable lnt;
		string real_name;

		public readonly MonoSymbolFile SymbolFile;

		public int Index
		{
			get { return index; }
			set { index = value; }
		}

		[Flags]
		public enum Flags
		{
			LocalNamesAmbiguous = 1,
			ColumnsInfoIncluded = 1 << 1,
			EndInfoIncluded = 1 << 2
		}

		public const int Size = 12;

		internal MethodEntry(MonoSymbolFile file, MyBinaryReader reader, int index)
		{
			this.SymbolFile = file;
			this.index = index;

			Token = reader.ReadInt32();
			DataOffset = reader.ReadInt32();
			LineNumberTableOffset = reader.ReadInt32();

			long old_pos = reader.BaseStream.Position;
			reader.BaseStream.Position = DataOffset;

			CompileUnitIndex = reader.ReadLeb128();
			LocalVariableTableOffset = reader.ReadLeb128();
			NamespaceID = reader.ReadLeb128();

			CodeBlockTableOffset = reader.ReadLeb128();
			ScopeVariableTableOffset = reader.ReadLeb128();

			RealNameOffset = reader.ReadLeb128();

			flags = (Flags)reader.ReadLeb128();

			reader.BaseStream.Position = old_pos;

			CompileUnit = file.GetCompileUnit(CompileUnitIndex);
		}

		internal MethodEntry(MonoSymbolFile file, CompileUnitEntry comp_unit,
					  int token, ScopeVariable[] scope_vars,
					  LocalVariableEntry[] locals, LineNumberEntry[] lines,
					  CodeBlockEntry[] code_blocks, string real_name,
					  Flags flags, int namespace_id)
		{
			this.SymbolFile = file;
			this.real_name = real_name;
			this.locals = locals;
			this.code_blocks = code_blocks;
			this.scope_vars = scope_vars;
			this.flags = flags;

			index = -1;

			Token = token;
			CompileUnitIndex = comp_unit.Index;
			CompileUnit = comp_unit;
			NamespaceID = namespace_id;

			CheckLineNumberTable(lines);
			lnt = new LineNumberTable(file, lines);
			file.NumLineNumbers += lines.Length;

			int num_locals = locals != null ? locals.Length : 0;

			if (num_locals <= 32)
			{
				// Most of the time, the O(n^2) factor is actually
				// less than the cost of allocating the hash table,
				// 32 is a rough number obtained through some testing.

				for (int i = 0; i < num_locals; i++)
				{
					string nm = locals[i].Name;

					for (int j = i + 1; j < num_locals; j++)
					{
						if (locals[j].Name == nm)
						{
							flags |= Flags.LocalNamesAmbiguous;
							goto locals_check_done;
						}
					}
				}
			locals_check_done:
				;
			}
			else
			{
				var local_names = new Dictionary<string, LocalVariableEntry>();
				foreach (LocalVariableEntry local in locals)
				{
					if (local_names.ContainsKey(local.Name))
					{
						flags |= Flags.LocalNamesAmbiguous;
						break;
					}
					local_names.Add(local.Name, local);
				}
			}
		}

		static void CheckLineNumberTable(LineNumberEntry[] line_numbers)
		{
			int last_offset = -1;
			int last_row = -1;

			if (line_numbers == null)
				return;

			for (int i = 0; i < line_numbers.Length; i++)
			{
				LineNumberEntry line = line_numbers[i];

				if (line.Equals(LineNumberEntry.Null))
					throw new MonoSymbolFileException();

				if (line.Offset < last_offset)
					throw new MonoSymbolFileException();

				if (line.Offset > last_offset)
				{
					last_row = line.Row;
					last_offset = line.Offset;
				}
				else if (line.Row > last_row)
				{
					last_row = line.Row;
				}
			}
		}

		internal void Write(MyBinaryWriter bw)
		{
			if ((index <= 0) || (DataOffset == 0))
				throw new InvalidOperationException();

			bw.Write(Token);
			bw.Write(DataOffset);
			bw.Write(LineNumberTableOffset);
		}

		internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw)
		{
			if (index <= 0)
				throw new InvalidOperationException();

			LocalVariableTableOffset = (int)bw.BaseStream.Position;
			int num_locals = locals != null ? locals.Length : 0;
			bw.WriteLeb128(num_locals);
			for (int i = 0; i < num_locals; i++)
				locals[i].Write(file, bw);
			file.LocalCount += num_locals;

			CodeBlockTableOffset = (int)bw.BaseStream.Position;
			int num_code_blocks = code_blocks != null ? code_blocks.Length : 0;
			bw.WriteLeb128(num_code_blocks);
			for (int i = 0; i < num_code_blocks; i++)
				code_blocks[i].Write(bw);

			ScopeVariableTableOffset = (int)bw.BaseStream.Position;
			int num_scope_vars = scope_vars != null ? scope_vars.Length : 0;
			bw.WriteLeb128(num_scope_vars);
			for (int i = 0; i < num_scope_vars; i++)
				scope_vars[i].Write(bw);

			if (real_name != null)
			{
				RealNameOffset = (int)bw.BaseStream.Position;
				bw.Write(real_name);
			}

			foreach (var lne in lnt.LineNumbers)
			{
				if (lne.EndRow != -1 || lne.EndColumn != -1)
					flags |= Flags.EndInfoIncluded;
			}

			LineNumberTableOffset = (int)bw.BaseStream.Position;
			lnt.Write(file, bw, (flags & Flags.ColumnsInfoIncluded) != 0, (flags & Flags.EndInfoIncluded) != 0);

			DataOffset = (int)bw.BaseStream.Position;

			bw.WriteLeb128(CompileUnitIndex);
			bw.WriteLeb128(LocalVariableTableOffset);
			bw.WriteLeb128(NamespaceID);

			bw.WriteLeb128(CodeBlockTableOffset);
			bw.WriteLeb128(ScopeVariableTableOffset);

			bw.WriteLeb128(RealNameOffset);
			bw.WriteLeb128((int)flags);
		}

		public void ReadAll()
		{
			GetLineNumberTable();
			GetLocals();
			GetCodeBlocks();
			GetScopeVariables();
			GetRealName();
		}

		public LineNumberTable GetLineNumberTable()
		{
			lock (SymbolFile)
			{
				if (lnt != null)
					return lnt;

				if (LineNumberTableOffset == 0)
					return null;

				MyBinaryReader reader = SymbolFile.BinaryReader;
				long old_pos = reader.BaseStream.Position;
				reader.BaseStream.Position = LineNumberTableOffset;

				lnt = LineNumberTable.Read(SymbolFile, reader, (flags & Flags.ColumnsInfoIncluded) != 0, (flags & Flags.EndInfoIncluded) != 0);

				reader.BaseStream.Position = old_pos;
				return lnt;
			}
		}

		public LocalVariableEntry[] GetLocals()
		{
			lock (SymbolFile)
			{
				if (locals != null)
					return locals;

				if (LocalVariableTableOffset == 0)
					return null;

				MyBinaryReader reader = SymbolFile.BinaryReader;
				long old_pos = reader.BaseStream.Position;
				reader.BaseStream.Position = LocalVariableTableOffset;

				int num_locals = reader.ReadLeb128();
				locals = new LocalVariableEntry[num_locals];

				for (int i = 0; i < num_locals; i++)
					locals[i] = new LocalVariableEntry(SymbolFile, reader);

				reader.BaseStream.Position = old_pos;
				return locals;
			}
		}

		public CodeBlockEntry[] GetCodeBlocks()
		{
			lock (SymbolFile)
			{
				if (code_blocks != null)
					return code_blocks;

				if (CodeBlockTableOffset == 0)
					return null;

				MyBinaryReader reader = SymbolFile.BinaryReader;
				long old_pos = reader.BaseStream.Position;
				reader.BaseStream.Position = CodeBlockTableOffset;

				int num_code_blocks = reader.ReadLeb128();
				code_blocks = new CodeBlockEntry[num_code_blocks];

				for (int i = 0; i < num_code_blocks; i++)
					code_blocks[i] = new CodeBlockEntry(i, reader);

				reader.BaseStream.Position = old_pos;
				return code_blocks;
			}
		}

		public ScopeVariable[] GetScopeVariables()
		{
			lock (SymbolFile)
			{
				if (scope_vars != null)
					return scope_vars;

				if (ScopeVariableTableOffset == 0)
					return null;

				MyBinaryReader reader = SymbolFile.BinaryReader;
				long old_pos = reader.BaseStream.Position;
				reader.BaseStream.Position = ScopeVariableTableOffset;

				int num_scope_vars = reader.ReadLeb128();
				scope_vars = new ScopeVariable[num_scope_vars];

				for (int i = 0; i < num_scope_vars; i++)
					scope_vars[i] = new ScopeVariable(reader);

				reader.BaseStream.Position = old_pos;
				return scope_vars;
			}
		}

		public string GetRealName()
		{
			lock (SymbolFile)
			{
				if (real_name != null)
					return real_name;

				if (RealNameOffset == 0)
					return null;

				real_name = SymbolFile.BinaryReader.ReadString(RealNameOffset);
				return real_name;
			}
		}

		public int CompareTo(object obj)
		{
			MethodEntry method = (MethodEntry)obj;

			if (method.Token < Token)
				return 1;
			else if (method.Token > Token)
				return -1;
			else
				return 0;
		}

		public override string ToString()
		{
			return String.Format("[Method {0}:{1:x}:{2}:{3}]",
						  index, Token, CompileUnitIndex, CompileUnit);
		}
	}

	public struct NamespaceEntry
	{
		#region This is actually written to the symbol file
		public readonly string Name;
		public readonly int Index;
		public readonly int Parent;
		public readonly string[] UsingClauses;
		#endregion

		public NamespaceEntry(string name, int index, string[] using_clauses, int parent)
		{
			this.Name = name;
			this.Index = index;
			this.Parent = parent;
			this.UsingClauses = using_clauses != null ? using_clauses : new string[0];
		}

		internal NamespaceEntry(MonoSymbolFile file, MyBinaryReader reader)
		{
			Name = reader.ReadString();
			Index = reader.ReadLeb128();
			Parent = reader.ReadLeb128();

			int count = reader.ReadLeb128();
			UsingClauses = new string[count];
			for (int i = 0; i < count; i++)
				UsingClauses[i] = reader.ReadString();
		}

		internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
		{
			bw.Write(Name);
			bw.WriteLeb128(Index);
			bw.WriteLeb128(Parent);
			bw.WriteLeb128(UsingClauses.Length);
			foreach (string uc in UsingClauses)
				bw.Write(uc);
		}

		public override string ToString()
		{
			return String.Format("[Namespace {0}:{1}:{2}]", Name, Index, Parent);
		}
	}
}
//
// Mono.CSharp.Debugger/MonoSymbolWriter.cs
//
// Author:
//   Martin Baulig (martin@ximian.com)
//
// This is the default implementation of the System.Diagnostics.SymbolStore.ISymbolWriter
// interface.
//
// (C) 2002 Ximian, Inc.  http://www.ximian.com
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//






namespace Mono.CompilerServices.SymbolWriter
{
	public class MonoSymbolWriter
	{
		List<SourceMethodBuilder> methods;
		List<SourceFileEntry> sources;
		List<CompileUnitEntry> comp_units;
		protected readonly MonoSymbolFile file;
		string filename;

		private SourceMethodBuilder current_method;
		Stack<SourceMethodBuilder> current_method_stack = new Stack<SourceMethodBuilder>();

		public MonoSymbolWriter(string filename)
		{
			this.methods = new List<SourceMethodBuilder>();
			this.sources = new List<SourceFileEntry>();
			this.comp_units = new List<CompileUnitEntry>();
			this.file = new MonoSymbolFile();

			this.filename = filename + ".mdb";
		}

		public MonoSymbolFile SymbolFile
		{
			get { return file; }
		}

		public void CloseNamespace()
		{ }

		public void DefineLocalVariable(int index, string name)
		{
			if (current_method == null)
				return;

			current_method.AddLocal(index, name);
		}

		public void DefineCapturedLocal(int scope_id, string name, string captured_name)
		{
			file.DefineCapturedVariable(scope_id, name, captured_name,
							 CapturedVariable.CapturedKind.Local);
		}

		public void DefineCapturedParameter(int scope_id, string name, string captured_name)
		{
			file.DefineCapturedVariable(scope_id, name, captured_name,
							 CapturedVariable.CapturedKind.Parameter);
		}

		public void DefineCapturedThis(int scope_id, string captured_name)
		{
			file.DefineCapturedVariable(scope_id, "this", captured_name,
							 CapturedVariable.CapturedKind.This);
		}

		public void DefineCapturedScope(int scope_id, int id, string captured_name)
		{
			file.DefineCapturedScope(scope_id, id, captured_name);
		}

		public void DefineScopeVariable(int scope, int index)
		{
			if (current_method == null)
				return;

			current_method.AddScopeVariable(scope, index);
		}

		public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column,
						   bool is_hidden)
		{
			if (current_method == null)
				return;

			current_method.MarkSequencePoint(offset, file, line, column, is_hidden);
		}

		public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method)
		{
			SourceMethodBuilder builder = new SourceMethodBuilder(file, ns_id, method);
			current_method_stack.Push(current_method);
			current_method = builder;
			methods.Add(current_method);
			return builder;
		}

		public void CloseMethod()
		{
			current_method = (SourceMethodBuilder)current_method_stack.Pop();
		}

		public SourceFileEntry DefineDocument(string url)
		{
			SourceFileEntry entry = new SourceFileEntry(file, url);
			sources.Add(entry);
			return entry;
		}

		public SourceFileEntry DefineDocument(string url, byte[] guid, byte[] checksum)
		{
			SourceFileEntry entry = new SourceFileEntry(file, url, guid, checksum);
			sources.Add(entry);
			return entry;
		}

		public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source)
		{
			CompileUnitEntry entry = new CompileUnitEntry(file, source);
			comp_units.Add(entry);
			return entry;
		}

		public int DefineNamespace(string name, CompileUnitEntry unit,
						string[] using_clauses, int parent)
		{
			if ((unit == null) || (using_clauses == null))
				throw new NullReferenceException();

			return unit.DefineNamespace(name, using_clauses, parent);
		}

		public int OpenScope(int start_offset)
		{
			if (current_method == null)
				return 0;

			current_method.StartBlock(CodeBlockEntry.Type.Lexical, start_offset);
			return 0;
		}

		public void CloseScope(int end_offset)
		{
			if (current_method == null)
				return;

			current_method.EndBlock(end_offset);
		}

		public void OpenCompilerGeneratedBlock(int start_offset)
		{
			if (current_method == null)
				return;

			current_method.StartBlock(CodeBlockEntry.Type.CompilerGenerated,
						   start_offset);
		}

		public void CloseCompilerGeneratedBlock(int end_offset)
		{
			if (current_method == null)
				return;

			current_method.EndBlock(end_offset);
		}

		public void StartIteratorBody(int start_offset)
		{
			current_method.StartBlock(CodeBlockEntry.Type.IteratorBody,
						   start_offset);
		}

		public void EndIteratorBody(int end_offset)
		{
			current_method.EndBlock(end_offset);
		}

		public void StartIteratorDispatcher(int start_offset)
		{
			current_method.StartBlock(CodeBlockEntry.Type.IteratorDispatcher,
						   start_offset);
		}

		public void EndIteratorDispatcher(int end_offset)
		{
			current_method.EndBlock(end_offset);
		}

		public void DefineAnonymousScope(int id)
		{
			file.DefineAnonymousScope(id);
		}

		public void WriteSymbolFile(Guid guid)
		{
			foreach (SourceMethodBuilder method in methods)
				method.DefineMethod(file);

			try
			{
				// We mmap the file, so unlink the previous version since it may be in use
				File.Delete(filename);
			}
			catch
			{
				// We can safely ignore
			}
			using (FileStream fs = new FileStream(filename, FileMode.Create, FileAccess.Write))
			{
				file.CreateSymbolFile(guid, fs);
			}
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class MsfDirectory
	{
		internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits)
		{
			int pages = reader.PagesFromSize(head.directorySize);

			// 0..n in page of directory pages.
			bits.MinCapacity(head.directorySize);
			int directoryRootPages = head.directoryRoot.Length;
			int pagesPerPage = head.pageSize / 4;
			int pagesToGo = pages;
			for (int i = 0; i < directoryRootPages; i++)
			{
				int pagesInThisPage = pagesToGo <= pagesPerPage ? pagesToGo : pagesPerPage;
				reader.Seek(head.directoryRoot[i], 0);
				bits.Append(reader.reader, pagesInThisPage * 4);
				pagesToGo -= pagesInThisPage;
			}
			bits.Position = 0;

			DataStream stream = new DataStream(head.directorySize, bits, pages);
			bits.MinCapacity(head.directorySize);
			stream.Read(reader, bits);

			// 0..3 in directory pages
			int count;
			bits.ReadInt32(out count);

			// 4..n
			int[] sizes = new int[count];
			bits.ReadInt32(sizes);

			// n..m
			streams = new DataStream[count];
			for (int i = 0; i < count; i++)
			{
				if (sizes[i] <= 0)
				{
					streams[i] = new DataStream();
				}
				else
				{
					streams[i] = new DataStream(sizes[i], bits,
												reader.PagesFromSize(sizes[i]));
				}
			}
		}

		internal DataStream[] streams;
	}

}









/* This class is included in every MonoMod assembly.
 * As far as I know, methods aren't guaranteed to be inlined
 * across assembly boundaries.
 * -ade
 */
static class MultiTargetShims
{

	private static readonly object[] _NoArgs = new object[0];

	// Can't use the globalization-aware overloads on old .NET targets...
	// Weirdly enough this is very spotty, and the compiler will only *fall back* to extension methods,
	// thus keeping this un-#if'd is zero perf cost and zero maintenance cost.

	public static string Replace(this string self, string oldValue, string newValue, StringComparison comparison)
		=> self.Replace(oldValue, newValue);

	public static bool Contains(this string self, string value, StringComparison comparison)
		=> self.Contains(value);

	public static int GetHashCode(this string self, StringComparison comparison)
		=> self.GetHashCode();

	public static int IndexOf(this string self, char value, StringComparison comparison)
		=> self.IndexOf(value);

	public static int IndexOf(this string self, string value, StringComparison comparison)
		=> self.IndexOf(value);


#if NETSTANDARD

    public static Module[] GetModules(this Assembly asm)
        => asm.Modules.ToArray();
    public static Module GetModule(this Assembly asm, string name)
        => asm.Modules.FirstOrDefault(module => module.Name == name);

    public static byte[] GetBuffer(this MemoryStream ms) {
        long posPrev = ms.Position;
        byte[] data = new byte[ms.Length];
        ms.Read(data, 0, data.Length);
        ms.Position = posPrev;
        return data;
    }

#endif

#if CECIL0_10
    public static TypeReference GetConstraintType(this TypeReference type)
        => type;
#else
	public static TypeReference GetConstraintType(this GenericParameterConstraint constraint)
		=> constraint.ConstraintType;
#endif

}






namespace MonoMod.RuntimeDetour
{
	/// <summary>
	/// The data forming a "raw" native detour, created and consumed by DetourManager.Native.
	/// </summary>
#if !MONOMOD_INTERNAL
	public
#endif
	struct NativeDetourData
	{
		/// <summary>
		/// The method to detour from. Set when the structure is created by the IDetourNativePlatform.
		/// </summary>
		public IntPtr Method;
		/// <summary>
		/// The target method to be called instead. Set when the structure is created by the IDetourNativePlatform.
		/// </summary>
		public IntPtr Target;

		/// <summary>
		/// The type of the detour. Determined when the structure is created by the IDetourNativePlatform.
		/// </summary>
		public byte Type;

		/// <summary>
		/// The size of the detour. Calculated when the structure is created by the IDetourNativePlatform.
		/// </summary>
		public uint Size;

		/// <summary>
		/// DetourManager.Native-specific data.
		/// </summary>
		public IntPtr Extra;
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//











namespace Mono.Cecil.Pdb
{

	public class NativePdbReader : Mono.Cecil.Cil.ISymbolReader
	{

		readonly Disposable<Stream> pdb_file;
		readonly Dictionary<string, Document> documents = new Dictionary<string, Document>();
		readonly Dictionary<uint, PdbFunction> functions = new Dictionary<uint, PdbFunction>();
		readonly Dictionary<PdbScope, ImportDebugInformation> imports = new Dictionary<PdbScope, ImportDebugInformation>();

		internal NativePdbReader(Disposable<Stream> file)
		{
			this.pdb_file = file;
		}

		public ISymbolWriterProvider GetWriterProvider()
		{
			return new NativePdbWriterProvider();
		}

		/*
		uint Magic = 0x53445352;
		Guid Signature;
		uint Age;
		string FileName;
		 */

		public bool ProcessDebugHeader(ImageDebugHeader header)
		{
			if (!header.HasEntries)
				return false;

			using (pdb_file)
			{
				var info = PdbFile.LoadFunctions(pdb_file.value);

				foreach (var entry in header.Entries)
				{
					if (!IsMatchingEntry(info, entry))
						continue;

					foreach (var function in info.Functions)
						functions.Add(function.token, function);

					return true;
				}
			}

			return false;
		}

		static bool IsMatchingEntry(PdbInfo info, ImageDebugHeaderEntry entry)
		{
			if (entry.Directory.Type != ImageDebugType.CodeView)
				return false;

			var data = entry.Data;

			if (data.Length < 24)
				return false;

			var magic = ReadInt32(data, 0);
			if (magic != 0x53445352)
				return false;

			var guid_bytes = new byte[16];
			Buffer.BlockCopy(data, 4, guid_bytes, 0, 16);

			return info.Guid == new Guid(guid_bytes);
		}

		static int ReadInt32(byte[] bytes, int start)
		{
			return (bytes[start]
				| (bytes[start + 1] << 8)
				| (bytes[start + 2] << 16)
				| (bytes[start + 3] << 24));
		}


		public MethodDebugInformation Read(MethodDefinition method)
		{
			var method_token = method.MetadataToken;

			PdbFunction function;
			if (!functions.TryGetValue(method_token.ToUInt32(), out function))
				return null;

			var symbol = new MethodDebugInformation(method);

			ReadSequencePoints(function, symbol);

			symbol.scope = !function.scopes.IsNullOrEmpty()
				? ReadScopeAndLocals(function.scopes[0], symbol)
				: new ScopeDebugInformation { Start = new InstructionOffset(0), End = new InstructionOffset((int)function.length) };

			if (function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != method.MetadataToken.ToUInt32() && function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != 0)
				symbol.scope.import = GetImport(function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod, method.Module);

			if (function.scopes.Length > 1)
			{
				for (int i = 1; i < function.scopes.Length; i++)
				{
					var s = ReadScopeAndLocals(function.scopes[i], symbol);
					if (!AddScope(symbol.scope.Scopes, s))
						symbol.scope.Scopes.Add(s);
				}
			}

			if (function.iteratorScopes != null)
			{
				var state_machine = new StateMachineScopeDebugInformation();

				foreach (var iterator_scope in function.iteratorScopes)
				{
					state_machine.Scopes.Add(new StateMachineScope((int)iterator_scope.Offset, (int)(iterator_scope.Offset + iterator_scope.Length + 1)));
				}

				symbol.CustomDebugInformations.Add(state_machine);
			}

			if (function.synchronizationInformation != null)
			{
				var async_debug_info = new AsyncMethodBodyDebugInformation((int)function.synchronizationInformation.GeneratedCatchHandlerOffset);

				foreach (var synchronization_point in function.synchronizationInformation.synchronizationPoints)
				{
					async_debug_info.Yields.Add(new InstructionOffset((int)synchronization_point.SynchronizeOffset));
					async_debug_info.Resumes.Add(new InstructionOffset((int)synchronization_point.ContinuationOffset));
					async_debug_info.ResumeMethods.Add(method);
				}

				symbol.CustomDebugInformations.Add(async_debug_info);

				symbol.StateMachineKickOffMethod = (MethodDefinition)method.Module.LookupToken((int)function.synchronizationInformation.kickoffMethodToken);
			}

			return symbol;
		}

		Collection<ScopeDebugInformation> ReadScopeAndLocals(PdbScope[] scopes, MethodDebugInformation info)
		{
			var symbols = new Collection<ScopeDebugInformation>(scopes.Length);

			foreach (PdbScope scope in scopes)
				if (scope != null)
					symbols.Add(ReadScopeAndLocals(scope, info));

			return symbols;
		}

		ScopeDebugInformation ReadScopeAndLocals(PdbScope scope, MethodDebugInformation info)
		{
			var parent = new ScopeDebugInformation();
			parent.Start = new InstructionOffset((int)scope.offset);
			parent.End = new InstructionOffset((int)(scope.offset + scope.length));

			if (!scope.slots.IsNullOrEmpty())
			{
				parent.variables = new Collection<VariableDebugInformation>(scope.slots.Length);

				foreach (PdbSlot slot in scope.slots)
				{
					if ((slot.flags & 1) != 0) // parameter names
						continue;

					var index = (int)slot.slot;
					var variable = new VariableDebugInformation(index, slot.name);
					if ((slot.flags & 4) != 0)
						variable.IsDebuggerHidden = true;
					parent.variables.Add(variable);
				}
			}

			if (!scope.constants.IsNullOrEmpty())
			{
				parent.constants = new Collection<ConstantDebugInformation>(scope.constants.Length);

				foreach (var constant in scope.constants)
				{
					var type = info.Method.Module.Read(constant, (c, r) => r.ReadConstantSignature(new MetadataToken(c.token)));
					var value = constant.value;

					// Object "null" is encoded as integer
					if (type != null && !type.IsValueType && value is int && (int)value == 0)
						value = null;

					parent.constants.Add(new ConstantDebugInformation(constant.name, type, value));
				}
			}

			if (!scope.usedNamespaces.IsNullOrEmpty())
			{
				ImportDebugInformation import;
				if (imports.TryGetValue(scope, out import))
				{
					parent.import = import;
				}
				else
				{
					import = GetImport(scope, info.Method.Module);
					imports.Add(scope, import);
					parent.import = import;
				}
			}

			parent.scopes = ReadScopeAndLocals(scope.scopes, info);

			return parent;
		}

		static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
		{
			foreach (var sub_scope in scopes)
			{
				if (sub_scope.HasScopes && AddScope(sub_scope.Scopes, scope))
					return true;

				if (scope.Start.Offset >= sub_scope.Start.Offset && scope.End.Offset <= sub_scope.End.Offset)
				{
					sub_scope.Scopes.Add(scope);
					return true;
				}
			}

			return false;
		}

		ImportDebugInformation GetImport(uint token, ModuleDefinition module)
		{
			PdbFunction function;
			if (!functions.TryGetValue(token, out function))
				return null;

			if (function.scopes.Length != 1)
				return null;

			var scope = function.scopes[0];

			ImportDebugInformation import;
			if (imports.TryGetValue(scope, out import))
				return import;

			import = GetImport(scope, module);
			imports.Add(scope, import);
			return import;
		}

		static ImportDebugInformation GetImport(PdbScope scope, ModuleDefinition module)
		{
			if (scope.usedNamespaces.IsNullOrEmpty())
				return null;

			var import = new ImportDebugInformation();

			foreach (var used_namespace in scope.usedNamespaces)
			{
				if (string.IsNullOrEmpty(used_namespace))
					continue;

				ImportTarget target = null;
				var value = used_namespace.Substring(1);
				switch (used_namespace[0])
				{
					case 'U':
						target = new ImportTarget(ImportTargetKind.ImportNamespace) { @namespace = value };
						break;
					case 'T':
						{
							var type = TypeParser.ParseType(module, value);
							if (type != null)
								target = new ImportTarget(ImportTargetKind.ImportType) { type = type };
							break;
						}
					case 'A':
						var index = used_namespace.IndexOf(' ');
						if (index < 0)
						{
							target = new ImportTarget(ImportTargetKind.ImportNamespace) { @namespace = used_namespace };
							break;
						}
						var alias_value = used_namespace.Substring(1, index - 1);
						var alias_target_value = used_namespace.Substring(index + 2);
						switch (used_namespace[index + 1])
						{
							case 'U':
								target = new ImportTarget(ImportTargetKind.DefineNamespaceAlias) { alias = alias_value, @namespace = alias_target_value };
								break;
							case 'T':
								var type = TypeParser.ParseType(module, alias_target_value);
								if (type != null)
									target = new ImportTarget(ImportTargetKind.DefineTypeAlias) { alias = alias_value, type = type };
								break;
						}
						break;
					case '*':
						target = new ImportTarget(ImportTargetKind.ImportNamespace) { @namespace = value };
						break;
					case '@':
						if (!value.StartsWith("P:"))
							continue;

						target = new ImportTarget(ImportTargetKind.ImportNamespace) { @namespace = value.Substring(2) };
						break;
				}

				if (target != null)
					import.Targets.Add(target);
			}

			return import;
		}

		void ReadSequencePoints(PdbFunction function, MethodDebugInformation info)
		{
			if (function.lines == null)
				return;

			info.sequence_points = new Collection<SequencePoint>();

			foreach (PdbLines lines in function.lines)
				ReadLines(lines, info);
		}

		void ReadLines(PdbLines lines, MethodDebugInformation info)
		{
			var document = GetDocument(lines.file);

			foreach (var line in lines.lines)
				ReadLine(line, document, info);
		}

		static void ReadLine(PdbLine line, Document document, MethodDebugInformation info)
		{
			var sequence_point = new SequencePoint((int)line.offset, document);
			sequence_point.StartLine = (int)line.lineBegin;
			sequence_point.StartColumn = (int)line.colBegin;
			sequence_point.EndLine = (int)line.lineEnd;
			sequence_point.EndColumn = (int)line.colEnd;

			info.sequence_points.Add(sequence_point);
		}

		Document GetDocument(PdbSource source)
		{
			string name = source.name;
			Document document;
			if (documents.TryGetValue(name, out document))
				return document;

			document = new Document(name)
			{
				LanguageGuid = source.language,
				LanguageVendorGuid = source.vendor,
				TypeGuid = source.doctype,
				HashAlgorithmGuid = source.checksumAlgorithm,
				Hash = source.checksum,
			};
			documents.Add(name, document);
			return document;
		}

		public void Dispose()
		{
			pdb_file.Dispose();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//











namespace Mono.Cecil.Pdb
{

	public class NativePdbWriter : Mono.Cecil.Cil.ISymbolWriter
	{

		readonly ModuleDefinition module;
		readonly MetadataBuilder metadata;
		readonly SymWriter writer;
		readonly Dictionary<string, SymDocumentWriter> documents;
		readonly Dictionary<ImportDebugInformation, MetadataToken> import_info_to_parent;

		internal NativePdbWriter(ModuleDefinition module, SymWriter writer)
		{
			this.module = module;
			this.metadata = module.metadata_builder;
			this.writer = writer;
			this.documents = new Dictionary<string, SymDocumentWriter>();
			this.import_info_to_parent = new Dictionary<ImportDebugInformation, MetadataToken>();
		}

		public ISymbolReaderProvider GetReaderProvider()
		{
			return new NativePdbReaderProvider();
		}

		public ImageDebugHeader GetDebugHeader()
		{
			ImageDebugDirectory directory;
			var data = writer.GetDebugInfo(out directory);
			directory.TimeDateStamp = (int)module.timestamp;
			return new ImageDebugHeader(new ImageDebugHeaderEntry(directory, data));
		}

		public void Write(MethodDebugInformation info)
		{
			var method_token = info.method.MetadataToken;
			var sym_token = method_token.ToInt32();

			if (!info.HasSequencePoints && info.scope == null && !info.HasCustomDebugInformations && info.StateMachineKickOffMethod == null)
				return;

			writer.OpenMethod(sym_token);

			if (!info.sequence_points.IsNullOrEmpty())
				DefineSequencePoints(info.sequence_points);

			var import_parent = new MetadataToken();

			if (info.scope != null)
				DefineScope(info.scope, info, out import_parent);

			DefineCustomMetadata(info, import_parent);

			writer.CloseMethod();
		}

		void DefineCustomMetadata(MethodDebugInformation info, MetadataToken import_parent)
		{
			var metadata = new CustomMetadataWriter(this.writer);

			if (import_parent.RID != 0)
			{
				metadata.WriteForwardInfo(import_parent);
			}
			else if (info.scope != null && info.scope.Import != null && info.scope.Import.HasTargets)
			{
				metadata.WriteUsingInfo(info.scope.Import);
			}

			if (info.Method.HasCustomAttributes)
			{
				foreach (var attribute in info.Method.CustomAttributes)
				{
					const string compiler_services = "System.Runtime.CompilerServices";
					var attribute_type = attribute.AttributeType;

					if (!attribute_type.IsTypeOf(compiler_services, "IteratorStateMachineAttribute") && !attribute_type.IsTypeOf(compiler_services, "AsyncStateMachineAttribute"))
						continue;

					var type = attribute.ConstructorArguments[0].Value as TypeReference;
					if (type == null)
						continue;

					metadata.WriteForwardIterator(type);
				}
			}

			if (info.HasCustomDebugInformations)
			{
				var state_machine = info.CustomDebugInformations.FirstOrDefault(cdi => cdi.Kind == CustomDebugInformationKind.StateMachineScope) as StateMachineScopeDebugInformation;

				if (state_machine != null)
					metadata.WriteIteratorScopes(state_machine, info);
			}

			metadata.WriteCustomMetadata();

			DefineAsyncCustomMetadata(info);
		}

		void DefineAsyncCustomMetadata(MethodDebugInformation info)
		{
			if (!info.HasCustomDebugInformations)
				return;

			foreach (var custom_info in info.CustomDebugInformations)
			{
				var async_debug_info = custom_info as AsyncMethodBodyDebugInformation;
				if (async_debug_info == null)
					continue;

				using (var stream = new MemoryStream())
				{
					var async_metadata = new BinaryStreamWriter(stream);
					async_metadata.WriteUInt32(info.StateMachineKickOffMethod != null ? info.StateMachineKickOffMethod.MetadataToken.ToUInt32() : 0);
					async_metadata.WriteUInt32((uint)async_debug_info.CatchHandler.Offset);
					async_metadata.WriteUInt32((uint)async_debug_info.Resumes.Count);
					for (int i = 0; i < async_debug_info.Resumes.Count; ++i)
					{
						async_metadata.WriteUInt32((uint)async_debug_info.Yields[i].Offset);
						async_metadata.WriteUInt32(async_debug_info.resume_methods[i].MetadataToken.ToUInt32());
						async_metadata.WriteUInt32((uint)async_debug_info.Resumes[i].Offset);
					}

					writer.DefineCustomMetadata("asyncMethodInfo", stream.ToArray());
				}
			}
		}

		void DefineScope(ScopeDebugInformation scope, MethodDebugInformation info, out MetadataToken import_parent)
		{
			var start_offset = scope.Start.Offset;
			var end_offset = scope.End.IsEndOfMethod
				? info.code_size
				: scope.End.Offset;

			import_parent = new MetadataToken(0u);

			writer.OpenScope(start_offset);

			if (scope.Import != null && scope.Import.HasTargets && !import_info_to_parent.TryGetValue(info.scope.Import, out import_parent))
			{
				foreach (var target in scope.Import.Targets)
				{
					switch (target.Kind)
					{
						case ImportTargetKind.ImportNamespace:
							writer.UsingNamespace("U" + target.@namespace);
							break;
						case ImportTargetKind.ImportType:
							writer.UsingNamespace("T" + TypeParser.ToParseable(target.type));
							break;
						case ImportTargetKind.DefineNamespaceAlias:
							writer.UsingNamespace("A" + target.Alias + " U" + target.@namespace);
							break;
						case ImportTargetKind.DefineTypeAlias:
							writer.UsingNamespace("A" + target.Alias + " T" + TypeParser.ToParseable(target.type));
							break;
					}
				}

				import_info_to_parent.Add(info.scope.Import, info.method.MetadataToken);
			}

			var sym_token = info.local_var_token.ToInt32();

			if (!scope.variables.IsNullOrEmpty())
			{
				for (int i = 0; i < scope.variables.Count; i++)
				{
					var variable = scope.variables[i];
					DefineLocalVariable(variable, sym_token, start_offset, end_offset);
				}
			}

			if (!scope.constants.IsNullOrEmpty())
			{
				for (int i = 0; i < scope.constants.Count; i++)
				{
					var constant = scope.constants[i];
					DefineConstant(constant);
				}
			}

			if (!scope.scopes.IsNullOrEmpty())
			{
				for (int i = 0; i < scope.scopes.Count; i++)
				{
					MetadataToken _;
					DefineScope(scope.scopes[i], info, out _);
				}
			}

			writer.CloseScope(end_offset);
		}

		void DefineSequencePoints(Collection<SequencePoint> sequence_points)
		{
			for (int i = 0; i < sequence_points.Count; i++)
			{
				var sequence_point = sequence_points[i];

				writer.DefineSequencePoints(
					GetDocument(sequence_point.Document),
					new[] { sequence_point.Offset },
					new[] { sequence_point.StartLine },
					new[] { sequence_point.StartColumn },
					new[] { sequence_point.EndLine },
					new[] { sequence_point.EndColumn });
			}
		}

		void DefineLocalVariable(VariableDebugInformation variable, int local_var_token, int start_offset, int end_offset)
		{
			writer.DefineLocalVariable2(
				variable.Name,
				variable.Attributes,
				local_var_token,
				variable.Index,
				0,
				0,
				start_offset,
				end_offset);
		}

		void DefineConstant(ConstantDebugInformation constant)
		{
			var row = metadata.AddStandAloneSignature(metadata.GetConstantTypeBlobIndex(constant.ConstantType));
			var token = new MetadataToken(TokenType.Signature, row);

			writer.DefineConstant2(constant.Name, constant.Value, token.ToInt32());
		}

		SymDocumentWriter GetDocument(Document document)
		{
			if (document == null)
				return null;

			SymDocumentWriter doc_writer;
			if (documents.TryGetValue(document.Url, out doc_writer))
				return doc_writer;

			doc_writer = writer.DefineDocument(
				document.Url,
				document.LanguageGuid,
				document.LanguageVendorGuid,
				document.TypeGuid);

			if (!document.Hash.IsNullOrEmpty())
				doc_writer.SetCheckSum(document.HashAlgorithmGuid, document.Hash);

			documents[document.Url] = doc_writer;
			return doc_writer;
		}

		public void Dispose()
		{
			var entry_point = module.EntryPoint;
			if (entry_point != null)
				writer.SetUserEntryPoint(entry_point.MetadataToken.ToInt32());

			writer.Close();
		}
	}

	enum CustomMetadataType : byte
	{
		UsingInfo = 0,
		ForwardInfo = 1,
		IteratorScopes = 3,
		ForwardIterator = 4,
	}

	class CustomMetadataWriter : IDisposable
	{

		readonly SymWriter sym_writer;
		readonly MemoryStream stream;
		readonly BinaryStreamWriter writer;

		int count;

		const byte version = 4;

		public CustomMetadataWriter(SymWriter sym_writer)
		{
			this.sym_writer = sym_writer;
			this.stream = new MemoryStream();
			this.writer = new BinaryStreamWriter(stream);

			writer.WriteByte(version);
			writer.WriteByte(0); // count
			writer.Align(4);
		}

		public void WriteUsingInfo(ImportDebugInformation import_info)
		{
			Write(CustomMetadataType.UsingInfo, () => {
				writer.WriteUInt16((ushort)1);
				writer.WriteUInt16((ushort)import_info.Targets.Count);
			});
		}

		public void WriteForwardInfo(MetadataToken import_parent)
		{
			Write(CustomMetadataType.ForwardInfo, () => writer.WriteUInt32(import_parent.ToUInt32()));
		}

		public void WriteIteratorScopes(StateMachineScopeDebugInformation state_machine, MethodDebugInformation debug_info)
		{
			Write(CustomMetadataType.IteratorScopes, () => {
				var scopes = state_machine.Scopes;
				writer.WriteInt32(scopes.Count);
				foreach (var scope in scopes)
				{
					var start = scope.Start.Offset;
					var end = scope.End.IsEndOfMethod ? debug_info.code_size : scope.End.Offset;
					writer.WriteInt32(start);
					writer.WriteInt32(end - 1);
				}
			});
		}

		public void WriteForwardIterator(TypeReference type)
		{
			Write(CustomMetadataType.ForwardIterator, () => writer.WriteBytes(Encoding.Unicode.GetBytes(type.Name)));
		}

		void Write(CustomMetadataType type, Action write)
		{
			count++;
			writer.WriteByte(version);
			writer.WriteByte((byte)type);
			writer.Align(4);

			var length_position = writer.Position;
			writer.WriteUInt32(0);

			write();
			writer.Align(4);

			var end = writer.Position;
			var length = end - length_position + 4; // header is 4 bytes long

			writer.Position = length_position;
			writer.WriteInt32(length);

			writer.Position = end;
		}

		public void WriteCustomMetadata()
		{
			if (count == 0)
				return;

			writer.BaseStream.Position = 1;
			writer.WriteByte((byte)count);
			writer.Flush();

			sym_writer.DefineCustomMetadata("MD2", stream.ToArray());
		}

		public void Dispose()
		{
			stream.Dispose();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum NativeType
	{
		None = 0x66,

		Boolean = 0x02,
		I1 = 0x03,
		U1 = 0x04,
		I2 = 0x05,
		U2 = 0x06,
		I4 = 0x07,
		U4 = 0x08,
		I8 = 0x09,
		U8 = 0x0a,
		R4 = 0x0b,
		R8 = 0x0c,
		LPStr = 0x14,
		Int = 0x1f,
		UInt = 0x20,
		Func = 0x26,
		Array = 0x2a,

		// Msft specific
		Currency = 0x0f,
		BStr = 0x13,
		LPWStr = 0x15,
		LPTStr = 0x16,
		FixedSysString = 0x17,
		IUnknown = 0x19,
		IDispatch = 0x1a,
		Struct = 0x1b,
		IntF = 0x1c,
		SafeArray = 0x1d,
		FixedArray = 0x1e,
		ByValStr = 0x22,
		ANSIBStr = 0x23,
		TBStr = 0x24,
		VariantBool = 0x25,
		ASAny = 0x28,
		LPStruct = 0x2b,
		CustomMarshaler = 0x2c,
		Error = 0x2d,
		Max = 0x50
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Cil
{

	public enum FlowControl
	{
		Branch,
		Break,
		Call,
		Cond_Branch,
		Meta,
		Next,
		Phi,
		Return,
		Throw,
	}

	public enum OpCodeType
	{
		Annotation,
		Macro,
		Nternal,
		Objmodel,
		Prefix,
		Primitive,
	}

	public enum OperandType
	{
		InlineBrTarget,
		InlineField,
		InlineI,
		InlineI8,
		InlineMethod,
		InlineNone,
		InlinePhi,
		InlineR,
		InlineSig,
		InlineString,
		InlineSwitch,
		InlineTok,
		InlineType,
		InlineVar,
		InlineArg,
		ShortInlineBrTarget,
		ShortInlineI,
		ShortInlineR,
		ShortInlineVar,
		ShortInlineArg,
	}

	public enum StackBehaviour
	{
		Pop0,
		Pop1,
		Pop1_pop1,
		Popi,
		Popi_pop1,
		Popi_popi,
		Popi_popi8,
		Popi_popi_popi,
		Popi_popr4,
		Popi_popr8,
		Popref,
		Popref_pop1,
		Popref_popi,
		Popref_popi_popi,
		Popref_popi_popi8,
		Popref_popi_popr4,
		Popref_popi_popr8,
		Popref_popi_popref,
		PopAll,
		Push0,
		Push1,
		Push1_push1,
		Pushi,
		Pushi8,
		Pushr4,
		Pushr8,
		Pushref,
		Varpop,
		Varpush,
	}

	public struct OpCode : IEquatable<OpCode>
	{

		readonly byte op1;
		readonly byte op2;
		readonly byte code;
		readonly byte flow_control;
		readonly byte opcode_type;
		readonly byte operand_type;
		readonly byte stack_behavior_pop;
		readonly byte stack_behavior_push;

		public string Name
		{
			get { return OpCodeNames.names[(int)Code]; }
		}

		public int Size
		{
			get { return op1 == 0xff ? 1 : 2; }
		}

		public byte Op1
		{
			get { return op1; }
		}

		public byte Op2
		{
			get { return op2; }
		}

		public short Value
		{
			get { return op1 == 0xff ? op2 : (short)((op1 << 8) | op2); }
		}

		public Code Code
		{
			get { return (Code)code; }
		}

		public FlowControl FlowControl
		{
			get { return (FlowControl)flow_control; }
		}

		public OpCodeType OpCodeType
		{
			get { return (OpCodeType)opcode_type; }
		}

		public OperandType OperandType
		{
			get { return (OperandType)operand_type; }
		}

		public StackBehaviour StackBehaviourPop
		{
			get { return (StackBehaviour)stack_behavior_pop; }
		}

		public StackBehaviour StackBehaviourPush
		{
			get { return (StackBehaviour)stack_behavior_push; }
		}

		internal OpCode(int x, int y)
		{
			this.op1 = (byte)((x >> 0) & 0xff);
			this.op2 = (byte)((x >> 8) & 0xff);
			this.code = (byte)((x >> 16) & 0xff);
			this.flow_control = (byte)((x >> 24) & 0xff);

			this.opcode_type = (byte)((y >> 0) & 0xff);
			this.operand_type = (byte)((y >> 8) & 0xff);
			this.stack_behavior_pop = (byte)((y >> 16) & 0xff);
			this.stack_behavior_push = (byte)((y >> 24) & 0xff);

			if (op1 == 0xff)
				OpCodes.OneByteOpCode[op2] = this;
			else
				OpCodes.TwoBytesOpCode[op2] = this;
		}

		public override int GetHashCode()
		{
			return Value;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is OpCode))
				return false;

			var opcode = (OpCode)obj;
			return op1 == opcode.op1 && op2 == opcode.op2;
		}

		public bool Equals(OpCode opcode)
		{
			return op1 == opcode.op1 && op2 == opcode.op2;
		}

		public static bool operator ==(OpCode one, OpCode other)
		{
			return one.op1 == other.op1 && one.op2 == other.op2;
		}

		public static bool operator !=(OpCode one, OpCode other)
		{
			return one.op1 != other.op1 || one.op2 != other.op2;
		}

		public override string ToString()
		{
			return Name;
		}
	}

	static class OpCodeNames
	{

		internal static readonly string[] names;

		static OpCodeNames()
		{
			var table = new byte[] {
				3, 110, 111, 112,
				5, 98, 114, 101, 97, 107,
				7, 108, 100, 97, 114, 103, 46, 48,
				7, 108, 100, 97, 114, 103, 46, 49,
				7, 108, 100, 97, 114, 103, 46, 50,
				7, 108, 100, 97, 114, 103, 46, 51,
				7, 108, 100, 108, 111, 99, 46, 48,
				7, 108, 100, 108, 111, 99, 46, 49,
				7, 108, 100, 108, 111, 99, 46, 50,
				7, 108, 100, 108, 111, 99, 46, 51,
				7, 115, 116, 108, 111, 99, 46, 48,
				7, 115, 116, 108, 111, 99, 46, 49,
				7, 115, 116, 108, 111, 99, 46, 50,
				7, 115, 116, 108, 111, 99, 46, 51,
				7, 108, 100, 97, 114, 103, 46, 115,
				8, 108, 100, 97, 114, 103, 97, 46, 115,
				7, 115, 116, 97, 114, 103, 46, 115,
				7, 108, 100, 108, 111, 99, 46, 115,
				8, 108, 100, 108, 111, 99, 97, 46, 115,
				7, 115, 116, 108, 111, 99, 46, 115,
				6, 108, 100, 110, 117, 108, 108,
				9, 108, 100, 99, 46, 105, 52, 46, 109, 49,
				8, 108, 100, 99, 46, 105, 52, 46, 48,
				8, 108, 100, 99, 46, 105, 52, 46, 49,
				8, 108, 100, 99, 46, 105, 52, 46, 50,
				8, 108, 100, 99, 46, 105, 52, 46, 51,
				8, 108, 100, 99, 46, 105, 52, 46, 52,
				8, 108, 100, 99, 46, 105, 52, 46, 53,
				8, 108, 100, 99, 46, 105, 52, 46, 54,
				8, 108, 100, 99, 46, 105, 52, 46, 55,
				8, 108, 100, 99, 46, 105, 52, 46, 56,
				8, 108, 100, 99, 46, 105, 52, 46, 115,
				6, 108, 100, 99, 46, 105, 52,
				6, 108, 100, 99, 46, 105, 56,
				6, 108, 100, 99, 46, 114, 52,
				6, 108, 100, 99, 46, 114, 56,
				3, 100, 117, 112,
				3, 112, 111, 112,
				3, 106, 109, 112,
				4, 99, 97, 108, 108,
				5, 99, 97, 108, 108, 105,
				3, 114, 101, 116,
				4, 98, 114, 46, 115,
				9, 98, 114, 102, 97, 108, 115, 101, 46, 115,
				8, 98, 114, 116, 114, 117, 101, 46, 115,
				5, 98, 101, 113, 46, 115,
				5, 98, 103, 101, 46, 115,
				5, 98, 103, 116, 46, 115,
				5, 98, 108, 101, 46, 115,
				5, 98, 108, 116, 46, 115,
				8, 98, 110, 101, 46, 117, 110, 46, 115,
				8, 98, 103, 101, 46, 117, 110, 46, 115,
				8, 98, 103, 116, 46, 117, 110, 46, 115,
				8, 98, 108, 101, 46, 117, 110, 46, 115,
				8, 98, 108, 116, 46, 117, 110, 46, 115,
				2, 98, 114,
				7, 98, 114, 102, 97, 108, 115, 101,
				6, 98, 114, 116, 114, 117, 101,
				3, 98, 101, 113,
				3, 98, 103, 101,
				3, 98, 103, 116,
				3, 98, 108, 101,
				3, 98, 108, 116,
				6, 98, 110, 101, 46, 117, 110,
				6, 98, 103, 101, 46, 117, 110,
				6, 98, 103, 116, 46, 117, 110,
				6, 98, 108, 101, 46, 117, 110,
				6, 98, 108, 116, 46, 117, 110,
				6, 115, 119, 105, 116, 99, 104,
				8, 108, 100, 105, 110, 100, 46, 105, 49,
				8, 108, 100, 105, 110, 100, 46, 117, 49,
				8, 108, 100, 105, 110, 100, 46, 105, 50,
				8, 108, 100, 105, 110, 100, 46, 117, 50,
				8, 108, 100, 105, 110, 100, 46, 105, 52,
				8, 108, 100, 105, 110, 100, 46, 117, 52,
				8, 108, 100, 105, 110, 100, 46, 105, 56,
				7, 108, 100, 105, 110, 100, 46, 105,
				8, 108, 100, 105, 110, 100, 46, 114, 52,
				8, 108, 100, 105, 110, 100, 46, 114, 56,
				9, 108, 100, 105, 110, 100, 46, 114, 101, 102,
				9, 115, 116, 105, 110, 100, 46, 114, 101, 102,
				8, 115, 116, 105, 110, 100, 46, 105, 49,
				8, 115, 116, 105, 110, 100, 46, 105, 50,
				8, 115, 116, 105, 110, 100, 46, 105, 52,
				8, 115, 116, 105, 110, 100, 46, 105, 56,
				8, 115, 116, 105, 110, 100, 46, 114, 52,
				8, 115, 116, 105, 110, 100, 46, 114, 56,
				3, 97, 100, 100,
				3, 115, 117, 98,
				3, 109, 117, 108,
				3, 100, 105, 118,
				6, 100, 105, 118, 46, 117, 110,
				3, 114, 101, 109,
				6, 114, 101, 109, 46, 117, 110,
				3, 97, 110, 100,
				2, 111, 114,
				3, 120, 111, 114,
				3, 115, 104, 108,
				3, 115, 104, 114,
				6, 115, 104, 114, 46, 117, 110,
				3, 110, 101, 103,
				3, 110, 111, 116,
				7, 99, 111, 110, 118, 46, 105, 49,
				7, 99, 111, 110, 118, 46, 105, 50,
				7, 99, 111, 110, 118, 46, 105, 52,
				7, 99, 111, 110, 118, 46, 105, 56,
				7, 99, 111, 110, 118, 46, 114, 52,
				7, 99, 111, 110, 118, 46, 114, 56,
				7, 99, 111, 110, 118, 46, 117, 52,
				7, 99, 111, 110, 118, 46, 117, 56,
				8, 99, 97, 108, 108, 118, 105, 114, 116,
				5, 99, 112, 111, 98, 106,
				5, 108, 100, 111, 98, 106,
				5, 108, 100, 115, 116, 114,
				6, 110, 101, 119, 111, 98, 106,
				9, 99, 97, 115, 116, 99, 108, 97, 115, 115,
				6, 105, 115, 105, 110, 115, 116,
				9, 99, 111, 110, 118, 46, 114, 46, 117, 110,
				5, 117, 110, 98, 111, 120,
				5, 116, 104, 114, 111, 119,
				5, 108, 100, 102, 108, 100,
				6, 108, 100, 102, 108, 100, 97,
				5, 115, 116, 102, 108, 100,
				6, 108, 100, 115, 102, 108, 100,
				7, 108, 100, 115, 102, 108, 100, 97,
				6, 115, 116, 115, 102, 108, 100,
				5, 115, 116, 111, 98, 106,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 49, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 50, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 52, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 56, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 49, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 50, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 52, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 56, 46, 117, 110,
				13, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 46, 117, 110,
				13, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 46, 117, 110,
				3, 98, 111, 120,
				6, 110, 101, 119, 97, 114, 114,
				5, 108, 100, 108, 101, 110,
				7, 108, 100, 101, 108, 101, 109, 97,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 49,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 49,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 50,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 50,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 56,
				8, 108, 100, 101, 108, 101, 109, 46, 105,
				9, 108, 100, 101, 108, 101, 109, 46, 114, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 114, 56,
				10, 108, 100, 101, 108, 101, 109, 46, 114, 101, 102,
				8, 115, 116, 101, 108, 101, 109, 46, 105,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 49,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 50,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 52,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 56,
				9, 115, 116, 101, 108, 101, 109, 46, 114, 52,
				9, 115, 116, 101, 108, 101, 109, 46, 114, 56,
				10, 115, 116, 101, 108, 101, 109, 46, 114, 101, 102,
				10, 108, 100, 101, 108, 101, 109, 46, 97, 110, 121,
				10, 115, 116, 101, 108, 101, 109, 46, 97, 110, 121,
				9, 117, 110, 98, 111, 120, 46, 97, 110, 121,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 49,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 49,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 50,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 50,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 52,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 52,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 56,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 56,
				9, 114, 101, 102, 97, 110, 121, 118, 97, 108,
				8, 99, 107, 102, 105, 110, 105, 116, 101,
				8, 109, 107, 114, 101, 102, 97, 110, 121,
				7, 108, 100, 116, 111, 107, 101, 110,
				7, 99, 111, 110, 118, 46, 117, 50,
				7, 99, 111, 110, 118, 46, 117, 49,
				6, 99, 111, 110, 118, 46, 105,
				10, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105,
				10, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117,
				7, 97, 100, 100, 46, 111, 118, 102,
				10, 97, 100, 100, 46, 111, 118, 102, 46, 117, 110,
				7, 109, 117, 108, 46, 111, 118, 102,
				10, 109, 117, 108, 46, 111, 118, 102, 46, 117, 110,
				7, 115, 117, 98, 46, 111, 118, 102,
				10, 115, 117, 98, 46, 111, 118, 102, 46, 117, 110,
				10, 101, 110, 100, 102, 105, 110, 97, 108, 108, 121,
				5, 108, 101, 97, 118, 101,
				7, 108, 101, 97, 118, 101, 46, 115,
				7, 115, 116, 105, 110, 100, 46, 105,
				6, 99, 111, 110, 118, 46, 117,
				7, 97, 114, 103, 108, 105, 115, 116,
				3, 99, 101, 113,
				3, 99, 103, 116,
				6, 99, 103, 116, 46, 117, 110,
				3, 99, 108, 116,
				6, 99, 108, 116, 46, 117, 110,
				5, 108, 100, 102, 116, 110,
				9, 108, 100, 118, 105, 114, 116, 102, 116, 110,
				5, 108, 100, 97, 114, 103,
				6, 108, 100, 97, 114, 103, 97,
				5, 115, 116, 97, 114, 103,
				5, 108, 100, 108, 111, 99,
				6, 108, 100, 108, 111, 99, 97,
				5, 115, 116, 108, 111, 99,
				8, 108, 111, 99, 97, 108, 108, 111, 99,
				9, 101, 110, 100, 102, 105, 108, 116, 101, 114,
				10, 117, 110, 97, 108, 105, 103, 110, 101, 100, 46,
				9, 118, 111, 108, 97, 116, 105, 108, 101, 46,
				5, 116, 97, 105, 108, 46,
				7, 105, 110, 105, 116, 111, 98, 106,
				12, 99, 111, 110, 115, 116, 114, 97, 105, 110, 101, 100, 46,
				5, 99, 112, 98, 108, 107,
				7, 105, 110, 105, 116, 98, 108, 107,
				3, 110, 111, 46,
				7, 114, 101, 116, 104, 114, 111, 119,
				6, 115, 105, 122, 101, 111, 102,
				10, 114, 101, 102, 97, 110, 121, 116, 121, 112, 101,
				9, 114, 101, 97, 100, 111, 110, 108, 121, 46,
			};

			names = new string[219];

			for (int i = 0, p = 0; i < names.Length; i++)
			{
				var buffer = new char[table[p++]];

				for (int j = 0; j < buffer.Length; j++)
					buffer[j] = (char)table[p++];

				names[i] = new string(buffer);
			}
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Cil
{

	public static class OpCodes
	{

		internal static readonly OpCode[] OneByteOpCode = new OpCode[0xe0 + 1];
		internal static readonly OpCode[] TwoBytesOpCode = new OpCode[0x1e + 1];

		public static readonly OpCode Nop = new OpCode(
			0xff << 0 | 0x00 << 8 | (byte)Code.Nop << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Break = new OpCode(
			0xff << 0 | 0x01 << 8 | (byte)Code.Break << 16 | (byte)FlowControl.Break << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldarg_0 = new OpCode(
			0xff << 0 | 0x02 << 8 | (byte)Code.Ldarg_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_1 = new OpCode(
			0xff << 0 | 0x03 << 8 | (byte)Code.Ldarg_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_2 = new OpCode(
			0xff << 0 | 0x04 << 8 | (byte)Code.Ldarg_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_3 = new OpCode(
			0xff << 0 | 0x05 << 8 | (byte)Code.Ldarg_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_0 = new OpCode(
			0xff << 0 | 0x06 << 8 | (byte)Code.Ldloc_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_1 = new OpCode(
			0xff << 0 | 0x07 << 8 | (byte)Code.Ldloc_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_2 = new OpCode(
			0xff << 0 | 0x08 << 8 | (byte)Code.Ldloc_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_3 = new OpCode(
			0xff << 0 | 0x09 << 8 | (byte)Code.Ldloc_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Stloc_0 = new OpCode(
			0xff << 0 | 0x0a << 8 | (byte)Code.Stloc_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_1 = new OpCode(
			0xff << 0 | 0x0b << 8 | (byte)Code.Stloc_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_2 = new OpCode(
			0xff << 0 | 0x0c << 8 | (byte)Code.Stloc_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_3 = new OpCode(
			0xff << 0 | 0x0d << 8 | (byte)Code.Stloc_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldarg_S = new OpCode(
			0xff << 0 | 0x0e << 8 | (byte)Code.Ldarg_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarga_S = new OpCode(
			0xff << 0 | 0x0f << 8 | (byte)Code.Ldarga_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Starg_S = new OpCode(
			0xff << 0 | 0x10 << 8 | (byte)Code.Starg_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldloc_S = new OpCode(
			0xff << 0 | 0x11 << 8 | (byte)Code.Ldloc_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloca_S = new OpCode(
			0xff << 0 | 0x12 << 8 | (byte)Code.Ldloca_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stloc_S = new OpCode(
			0xff << 0 | 0x13 << 8 | (byte)Code.Stloc_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldnull = new OpCode(
			0xff << 0 | 0x14 << 8 | (byte)Code.Ldnull << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Ldc_I4_M1 = new OpCode(
			0xff << 0 | 0x15 << 8 | (byte)Code.Ldc_I4_M1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_0 = new OpCode(
			0xff << 0 | 0x16 << 8 | (byte)Code.Ldc_I4_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_1 = new OpCode(
			0xff << 0 | 0x17 << 8 | (byte)Code.Ldc_I4_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_2 = new OpCode(
			0xff << 0 | 0x18 << 8 | (byte)Code.Ldc_I4_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_3 = new OpCode(
			0xff << 0 | 0x19 << 8 | (byte)Code.Ldc_I4_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_4 = new OpCode(
			0xff << 0 | 0x1a << 8 | (byte)Code.Ldc_I4_4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_5 = new OpCode(
			0xff << 0 | 0x1b << 8 | (byte)Code.Ldc_I4_5 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_6 = new OpCode(
			0xff << 0 | 0x1c << 8 | (byte)Code.Ldc_I4_6 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_7 = new OpCode(
			0xff << 0 | 0x1d << 8 | (byte)Code.Ldc_I4_7 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_8 = new OpCode(
			0xff << 0 | 0x1e << 8 | (byte)Code.Ldc_I4_8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_S = new OpCode(
			0xff << 0 | 0x1f << 8 | (byte)Code.Ldc_I4_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4 = new OpCode(
			0xff << 0 | 0x20 << 8 | (byte)Code.Ldc_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I8 = new OpCode(
			0xff << 0 | 0x21 << 8 | (byte)Code.Ldc_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineI8 << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldc_R4 = new OpCode(
			0xff << 0 | 0x22 << 8 | (byte)Code.Ldc_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.ShortInlineR << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldc_R8 = new OpCode(
			0xff << 0 | 0x23 << 8 | (byte)Code.Ldc_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineR << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Dup = new OpCode(
			0xff << 0 | 0x25 << 8 | (byte)Code.Dup << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1_push1 << 24);

		public static readonly OpCode Pop = new OpCode(
			0xff << 0 | 0x26 << 8 | (byte)Code.Pop << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Jmp = new OpCode(
			0xff << 0 | 0x27 << 8 | (byte)Code.Jmp << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Call = new OpCode(
			0xff << 0 | 0x28 << 8 | (byte)Code.Call << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Calli = new OpCode(
			0xff << 0 | 0x29 << 8 | (byte)Code.Calli << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineSig << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Ret = new OpCode(
			0xff << 0 | 0x2a << 8 | (byte)Code.Ret << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Br_S = new OpCode(
			0xff << 0 | 0x2b << 8 | (byte)Code.Br_S << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brfalse_S = new OpCode(
			0xff << 0 | 0x2c << 8 | (byte)Code.Brfalse_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brtrue_S = new OpCode(
			0xff << 0 | 0x2d << 8 | (byte)Code.Brtrue_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Beq_S = new OpCode(
			0xff << 0 | 0x2e << 8 | (byte)Code.Beq_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_S = new OpCode(
			0xff << 0 | 0x2f << 8 | (byte)Code.Bge_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_S = new OpCode(
			0xff << 0 | 0x30 << 8 | (byte)Code.Bgt_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_S = new OpCode(
			0xff << 0 | 0x31 << 8 | (byte)Code.Ble_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_S = new OpCode(
			0xff << 0 | 0x32 << 8 | (byte)Code.Blt_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bne_Un_S = new OpCode(
			0xff << 0 | 0x33 << 8 | (byte)Code.Bne_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_Un_S = new OpCode(
			0xff << 0 | 0x34 << 8 | (byte)Code.Bge_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_Un_S = new OpCode(
			0xff << 0 | 0x35 << 8 | (byte)Code.Bgt_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_Un_S = new OpCode(
			0xff << 0 | 0x36 << 8 | (byte)Code.Ble_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_Un_S = new OpCode(
			0xff << 0 | 0x37 << 8 | (byte)Code.Blt_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Br = new OpCode(
			0xff << 0 | 0x38 << 8 | (byte)Code.Br << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brfalse = new OpCode(
			0xff << 0 | 0x39 << 8 | (byte)Code.Brfalse << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brtrue = new OpCode(
			0xff << 0 | 0x3a << 8 | (byte)Code.Brtrue << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Beq = new OpCode(
			0xff << 0 | 0x3b << 8 | (byte)Code.Beq << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge = new OpCode(
			0xff << 0 | 0x3c << 8 | (byte)Code.Bge << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt = new OpCode(
			0xff << 0 | 0x3d << 8 | (byte)Code.Bgt << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble = new OpCode(
			0xff << 0 | 0x3e << 8 | (byte)Code.Ble << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt = new OpCode(
			0xff << 0 | 0x3f << 8 | (byte)Code.Blt << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bne_Un = new OpCode(
			0xff << 0 | 0x40 << 8 | (byte)Code.Bne_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_Un = new OpCode(
			0xff << 0 | 0x41 << 8 | (byte)Code.Bge_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_Un = new OpCode(
			0xff << 0 | 0x42 << 8 | (byte)Code.Bgt_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_Un = new OpCode(
			0xff << 0 | 0x43 << 8 | (byte)Code.Ble_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_Un = new OpCode(
			0xff << 0 | 0x44 << 8 | (byte)Code.Blt_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Switch = new OpCode(
			0xff << 0 | 0x45 << 8 | (byte)Code.Switch << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineSwitch << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldind_I1 = new OpCode(
			0xff << 0 | 0x46 << 8 | (byte)Code.Ldind_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U1 = new OpCode(
			0xff << 0 | 0x47 << 8 | (byte)Code.Ldind_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I2 = new OpCode(
			0xff << 0 | 0x48 << 8 | (byte)Code.Ldind_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U2 = new OpCode(
			0xff << 0 | 0x49 << 8 | (byte)Code.Ldind_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I4 = new OpCode(
			0xff << 0 | 0x4a << 8 | (byte)Code.Ldind_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U4 = new OpCode(
			0xff << 0 | 0x4b << 8 | (byte)Code.Ldind_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I8 = new OpCode(
			0xff << 0 | 0x4c << 8 | (byte)Code.Ldind_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldind_I = new OpCode(
			0xff << 0 | 0x4d << 8 | (byte)Code.Ldind_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_R4 = new OpCode(
			0xff << 0 | 0x4e << 8 | (byte)Code.Ldind_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldind_R8 = new OpCode(
			0xff << 0 | 0x4f << 8 | (byte)Code.Ldind_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Ldind_Ref = new OpCode(
			0xff << 0 | 0x50 << 8 | (byte)Code.Ldind_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Stind_Ref = new OpCode(
			0xff << 0 | 0x51 << 8 | (byte)Code.Stind_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I1 = new OpCode(
			0xff << 0 | 0x52 << 8 | (byte)Code.Stind_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I2 = new OpCode(
			0xff << 0 | 0x53 << 8 | (byte)Code.Stind_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I4 = new OpCode(
			0xff << 0 | 0x54 << 8 | (byte)Code.Stind_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I8 = new OpCode(
			0xff << 0 | 0x55 << 8 | (byte)Code.Stind_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_R4 = new OpCode(
			0xff << 0 | 0x56 << 8 | (byte)Code.Stind_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popr4 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_R8 = new OpCode(
			0xff << 0 | 0x57 << 8 | (byte)Code.Stind_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popr8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Add = new OpCode(
			0xff << 0 | 0x58 << 8 | (byte)Code.Add << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub = new OpCode(
			0xff << 0 | 0x59 << 8 | (byte)Code.Sub << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul = new OpCode(
			0xff << 0 | 0x5a << 8 | (byte)Code.Mul << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Div = new OpCode(
			0xff << 0 | 0x5b << 8 | (byte)Code.Div << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Div_Un = new OpCode(
			0xff << 0 | 0x5c << 8 | (byte)Code.Div_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Rem = new OpCode(
			0xff << 0 | 0x5d << 8 | (byte)Code.Rem << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Rem_Un = new OpCode(
			0xff << 0 | 0x5e << 8 | (byte)Code.Rem_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode And = new OpCode(
			0xff << 0 | 0x5f << 8 | (byte)Code.And << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Or = new OpCode(
			0xff << 0 | 0x60 << 8 | (byte)Code.Or << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Xor = new OpCode(
			0xff << 0 | 0x61 << 8 | (byte)Code.Xor << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shl = new OpCode(
			0xff << 0 | 0x62 << 8 | (byte)Code.Shl << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shr = new OpCode(
			0xff << 0 | 0x63 << 8 | (byte)Code.Shr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shr_Un = new OpCode(
			0xff << 0 | 0x64 << 8 | (byte)Code.Shr_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Neg = new OpCode(
			0xff << 0 | 0x65 << 8 | (byte)Code.Neg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Not = new OpCode(
			0xff << 0 | 0x66 << 8 | (byte)Code.Not << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Conv_I1 = new OpCode(
			0xff << 0 | 0x67 << 8 | (byte)Code.Conv_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I2 = new OpCode(
			0xff << 0 | 0x68 << 8 | (byte)Code.Conv_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I4 = new OpCode(
			0xff << 0 | 0x69 << 8 | (byte)Code.Conv_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I8 = new OpCode(
			0xff << 0 | 0x6a << 8 | (byte)Code.Conv_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_R4 = new OpCode(
			0xff << 0 | 0x6b << 8 | (byte)Code.Conv_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Conv_R8 = new OpCode(
			0xff << 0 | 0x6c << 8 | (byte)Code.Conv_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Conv_U4 = new OpCode(
			0xff << 0 | 0x6d << 8 | (byte)Code.Conv_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U8 = new OpCode(
			0xff << 0 | 0x6e << 8 | (byte)Code.Conv_U8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Callvirt = new OpCode(
			0xff << 0 | 0x6f << 8 | (byte)Code.Callvirt << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Cpobj = new OpCode(
			0xff << 0 | 0x70 << 8 | (byte)Code.Cpobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldobj = new OpCode(
			0xff << 0 | 0x71 << 8 | (byte)Code.Ldobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldstr = new OpCode(
			0xff << 0 | 0x72 << 8 | (byte)Code.Ldstr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineString << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Newobj = new OpCode(
			0xff << 0 | 0x73 << 8 | (byte)Code.Newobj << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Castclass = new OpCode(
			0xff << 0 | 0x74 << 8 | (byte)Code.Castclass << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Isinst = new OpCode(
			0xff << 0 | 0x75 << 8 | (byte)Code.Isinst << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_R_Un = new OpCode(
			0xff << 0 | 0x76 << 8 | (byte)Code.Conv_R_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Unbox = new OpCode(
			0xff << 0 | 0x79 << 8 | (byte)Code.Unbox << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Throw = new OpCode(
			0xff << 0 | 0x7a << 8 | (byte)Code.Throw << 16 | (byte)FlowControl.Throw << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldfld = new OpCode(
			0xff << 0 | 0x7b << 8 | (byte)Code.Ldfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldflda = new OpCode(
			0xff << 0 | 0x7c << 8 | (byte)Code.Ldflda << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stfld = new OpCode(
			0xff << 0 | 0x7d << 8 | (byte)Code.Stfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldsfld = new OpCode(
			0xff << 0 | 0x7e << 8 | (byte)Code.Ldsfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldsflda = new OpCode(
			0xff << 0 | 0x7f << 8 | (byte)Code.Ldsflda << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stsfld = new OpCode(
			0xff << 0 | 0x80 << 8 | (byte)Code.Stsfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stobj = new OpCode(
			0xff << 0 | 0x81 << 8 | (byte)Code.Stobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Conv_Ovf_I1_Un = new OpCode(
			0xff << 0 | 0x82 << 8 | (byte)Code.Conv_Ovf_I1_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I2_Un = new OpCode(
			0xff << 0 | 0x83 << 8 | (byte)Code.Conv_Ovf_I2_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I4_Un = new OpCode(
			0xff << 0 | 0x84 << 8 | (byte)Code.Conv_Ovf_I4_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I8_Un = new OpCode(
			0xff << 0 | 0x85 << 8 | (byte)Code.Conv_Ovf_I8_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_U1_Un = new OpCode(
			0xff << 0 | 0x86 << 8 | (byte)Code.Conv_Ovf_U1_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U2_Un = new OpCode(
			0xff << 0 | 0x87 << 8 | (byte)Code.Conv_Ovf_U2_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U4_Un = new OpCode(
			0xff << 0 | 0x88 << 8 | (byte)Code.Conv_Ovf_U4_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U8_Un = new OpCode(
			0xff << 0 | 0x89 << 8 | (byte)Code.Conv_Ovf_U8_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_I_Un = new OpCode(
			0xff << 0 | 0x8a << 8 | (byte)Code.Conv_Ovf_I_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U_Un = new OpCode(
			0xff << 0 | 0x8b << 8 | (byte)Code.Conv_Ovf_U_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Box = new OpCode(
			0xff << 0 | 0x8c << 8 | (byte)Code.Box << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Newarr = new OpCode(
			0xff << 0 | 0x8d << 8 | (byte)Code.Newarr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Ldlen = new OpCode(
			0xff << 0 | 0x8e << 8 | (byte)Code.Ldlen << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelema = new OpCode(
			0xff << 0 | 0x8f << 8 | (byte)Code.Ldelema << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I1 = new OpCode(
			0xff << 0 | 0x90 << 8 | (byte)Code.Ldelem_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U1 = new OpCode(
			0xff << 0 | 0x91 << 8 | (byte)Code.Ldelem_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I2 = new OpCode(
			0xff << 0 | 0x92 << 8 | (byte)Code.Ldelem_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U2 = new OpCode(
			0xff << 0 | 0x93 << 8 | (byte)Code.Ldelem_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I4 = new OpCode(
			0xff << 0 | 0x94 << 8 | (byte)Code.Ldelem_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U4 = new OpCode(
			0xff << 0 | 0x95 << 8 | (byte)Code.Ldelem_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I8 = new OpCode(
			0xff << 0 | 0x96 << 8 | (byte)Code.Ldelem_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldelem_I = new OpCode(
			0xff << 0 | 0x97 << 8 | (byte)Code.Ldelem_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_R4 = new OpCode(
			0xff << 0 | 0x98 << 8 | (byte)Code.Ldelem_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldelem_R8 = new OpCode(
			0xff << 0 | 0x99 << 8 | (byte)Code.Ldelem_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Ldelem_Ref = new OpCode(
			0xff << 0 | 0x9a << 8 | (byte)Code.Ldelem_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Stelem_I = new OpCode(
			0xff << 0 | 0x9b << 8 | (byte)Code.Stelem_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I1 = new OpCode(
			0xff << 0 | 0x9c << 8 | (byte)Code.Stelem_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I2 = new OpCode(
			0xff << 0 | 0x9d << 8 | (byte)Code.Stelem_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I4 = new OpCode(
			0xff << 0 | 0x9e << 8 | (byte)Code.Stelem_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I8 = new OpCode(
			0xff << 0 | 0x9f << 8 | (byte)Code.Stelem_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_R4 = new OpCode(
			0xff << 0 | 0xa0 << 8 | (byte)Code.Stelem_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popr4 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_R8 = new OpCode(
			0xff << 0 | 0xa1 << 8 | (byte)Code.Stelem_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popr8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_Ref = new OpCode(
			0xff << 0 | 0xa2 << 8 | (byte)Code.Stelem_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldelem_Any = new OpCode(
			0xff << 0 | 0xa3 << 8 | (byte)Code.Ldelem_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Stelem_Any = new OpCode(
			0xff << 0 | 0xa4 << 8 | (byte)Code.Stelem_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi_popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Unbox_Any = new OpCode(
			0xff << 0 | 0xa5 << 8 | (byte)Code.Unbox_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Conv_Ovf_I1 = new OpCode(
			0xff << 0 | 0xb3 << 8 | (byte)Code.Conv_Ovf_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U1 = new OpCode(
			0xff << 0 | 0xb4 << 8 | (byte)Code.Conv_Ovf_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I2 = new OpCode(
			0xff << 0 | 0xb5 << 8 | (byte)Code.Conv_Ovf_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U2 = new OpCode(
			0xff << 0 | 0xb6 << 8 | (byte)Code.Conv_Ovf_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I4 = new OpCode(
			0xff << 0 | 0xb7 << 8 | (byte)Code.Conv_Ovf_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U4 = new OpCode(
			0xff << 0 | 0xb8 << 8 | (byte)Code.Conv_Ovf_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I8 = new OpCode(
			0xff << 0 | 0xb9 << 8 | (byte)Code.Conv_Ovf_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_U8 = new OpCode(
			0xff << 0 | 0xba << 8 | (byte)Code.Conv_Ovf_U8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Refanyval = new OpCode(
			0xff << 0 | 0xc2 << 8 | (byte)Code.Refanyval << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ckfinite = new OpCode(
			0xff << 0 | 0xc3 << 8 | (byte)Code.Ckfinite << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Mkrefany = new OpCode(
			0xff << 0 | 0xc6 << 8 | (byte)Code.Mkrefany << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldtoken = new OpCode(
			0xff << 0 | 0xd0 << 8 | (byte)Code.Ldtoken << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineTok << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U2 = new OpCode(
			0xff << 0 | 0xd1 << 8 | (byte)Code.Conv_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U1 = new OpCode(
			0xff << 0 | 0xd2 << 8 | (byte)Code.Conv_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I = new OpCode(
			0xff << 0 | 0xd3 << 8 | (byte)Code.Conv_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I = new OpCode(
			0xff << 0 | 0xd4 << 8 | (byte)Code.Conv_Ovf_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U = new OpCode(
			0xff << 0 | 0xd5 << 8 | (byte)Code.Conv_Ovf_U << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Add_Ovf = new OpCode(
			0xff << 0 | 0xd6 << 8 | (byte)Code.Add_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Add_Ovf_Un = new OpCode(
			0xff << 0 | 0xd7 << 8 | (byte)Code.Add_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul_Ovf = new OpCode(
			0xff << 0 | 0xd8 << 8 | (byte)Code.Mul_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul_Ovf_Un = new OpCode(
			0xff << 0 | 0xd9 << 8 | (byte)Code.Mul_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub_Ovf = new OpCode(
			0xff << 0 | 0xda << 8 | (byte)Code.Sub_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub_Ovf_Un = new OpCode(
			0xff << 0 | 0xdb << 8 | (byte)Code.Sub_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Endfinally = new OpCode(
			0xff << 0 | 0xdc << 8 | (byte)Code.Endfinally << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Leave = new OpCode(
			0xff << 0 | 0xdd << 8 | (byte)Code.Leave << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.PopAll << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Leave_S = new OpCode(
			0xff << 0 | 0xde << 8 | (byte)Code.Leave_S << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.PopAll << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I = new OpCode(
			0xff << 0 | 0xdf << 8 | (byte)Code.Stind_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Conv_U = new OpCode(
			0xff << 0 | 0xe0 << 8 | (byte)Code.Conv_U << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Arglist = new OpCode(
			0xfe << 0 | 0x00 << 8 | (byte)Code.Arglist << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ceq = new OpCode(
			0xfe << 0 | 0x01 << 8 | (byte)Code.Ceq << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Cgt = new OpCode(
			0xfe << 0 | 0x02 << 8 | (byte)Code.Cgt << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Cgt_Un = new OpCode(
			0xfe << 0 | 0x03 << 8 | (byte)Code.Cgt_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Clt = new OpCode(
			0xfe << 0 | 0x04 << 8 | (byte)Code.Clt << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Clt_Un = new OpCode(
			0xfe << 0 | 0x05 << 8 | (byte)Code.Clt_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldftn = new OpCode(
			0xfe << 0 | 0x06 << 8 | (byte)Code.Ldftn << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldvirtftn = new OpCode(
			0xfe << 0 | 0x07 << 8 | (byte)Code.Ldvirtftn << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldarg = new OpCode(
			0xfe << 0 | 0x09 << 8 | (byte)Code.Ldarg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarga = new OpCode(
			0xfe << 0 | 0x0a << 8 | (byte)Code.Ldarga << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Starg = new OpCode(
			0xfe << 0 | 0x0b << 8 | (byte)Code.Starg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldloc = new OpCode(
			0xfe << 0 | 0x0c << 8 | (byte)Code.Ldloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloca = new OpCode(
			0xfe << 0 | 0x0d << 8 | (byte)Code.Ldloca << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stloc = new OpCode(
			0xfe << 0 | 0x0e << 8 | (byte)Code.Stloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Localloc = new OpCode(
			0xfe << 0 | 0x0f << 8 | (byte)Code.Localloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Endfilter = new OpCode(
			0xfe << 0 | 0x11 << 8 | (byte)Code.Endfilter << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Unaligned = new OpCode(
			0xfe << 0 | 0x12 << 8 | (byte)Code.Unaligned << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Volatile = new OpCode(
			0xfe << 0 | 0x13 << 8 | (byte)Code.Volatile << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Tail = new OpCode(
			0xfe << 0 | 0x14 << 8 | (byte)Code.Tail << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Initobj = new OpCode(
			0xfe << 0 | 0x15 << 8 | (byte)Code.Initobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Constrained = new OpCode(
			0xfe << 0 | 0x16 << 8 | (byte)Code.Constrained << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Cpblk = new OpCode(
			0xfe << 0 | 0x17 << 8 | (byte)Code.Cpblk << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Initblk = new OpCode(
			0xfe << 0 | 0x18 << 8 | (byte)Code.Initblk << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode No = new OpCode(
			0xfe << 0 | 0x19 << 8 | (byte)Code.No << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Rethrow = new OpCode(
			0xfe << 0 | 0x1a << 8 | (byte)Code.Rethrow << 16 | (byte)FlowControl.Throw << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Sizeof = new OpCode(
			0xfe << 0 | 0x1c << 8 | (byte)Code.Sizeof << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Refanytype = new OpCode(
			0xfe << 0 | 0x1d << 8 | (byte)Code.Refanytype << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Readonly = new OpCode(
			0xfe << 0 | 0x1e << 8 | (byte)Code.Readonly << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum ParameterAttributes : ushort
	{
		None = 0x0000,
		In = 0x0001,    // Param is [In]
		Out = 0x0002,   // Param is [Out]
		Lcid = 0x0004,
		Retval = 0x0008,
		Optional = 0x0010,  // Param is optional
		HasDefault = 0x1000,    // Param has default value
		HasFieldMarshal = 0x2000,   // Param has field marshal
		Unused = 0xcfe0  // Reserved: shall be zero in a conforming implementation
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public sealed class ParameterDefinition : ParameterReference, ICustomAttributeProvider, IConstantProvider, IMarshalInfoProvider
	{

		ushort attributes;

		internal IMethodSignature method;

		object constant = Mixin.NotResolved;
		Collection<CustomAttribute> custom_attributes;
		MarshalInfo marshal_info;

		public ParameterAttributes Attributes
		{
			get { return (ParameterAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public IMethodSignature Method
		{
			get { return method; }
		}

		public int Sequence
		{
			get
			{
				if (method == null)
					return -1;

				return method.HasImplicitThis() ? index + 1 : index;
			}
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, parameter_type.Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant
		{
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(parameter_type.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, parameter_type.Module)); }
		}

		public bool HasMarshalInfo
		{
			get
			{
				if (marshal_info != null)
					return true;

				return this.GetHasMarshalInfo(parameter_type.Module);
			}
		}

		public MarshalInfo MarshalInfo
		{
			get { return marshal_info ?? (this.GetMarshalInfo(ref marshal_info, parameter_type.Module)); }
			set { marshal_info = value; }
		}

		#region ParameterAttributes

		public bool IsIn
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.In); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.In, value); }
		}

		public bool IsOut
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.Out); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.Out, value); }
		}

		public bool IsLcid
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.Lcid); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.Lcid, value); }
		}

		public bool IsReturnValue
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.Retval); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.Retval, value); }
		}

		public bool IsOptional
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.Optional); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.Optional, value); }
		}

		public bool HasDefault
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.HasDefault, value); }
		}

		public bool HasFieldMarshal
		{
			get { return attributes.GetAttributes((ushort)ParameterAttributes.HasFieldMarshal); }
			set { attributes = attributes.SetAttributes((ushort)ParameterAttributes.HasFieldMarshal, value); }
		}

		#endregion

		internal ParameterDefinition(TypeReference parameterType, IMethodSignature method)
			: this(string.Empty, ParameterAttributes.None, parameterType)
		{
			this.method = method;
		}

		public ParameterDefinition(TypeReference parameterType)
			: this(string.Empty, ParameterAttributes.None, parameterType)
		{
		}

		public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType)
			: base(name, parameterType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken(TokenType.Param);
		}

		public override ParameterDefinition Resolve()
		{
			return this;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	sealed class ParameterDefinitionCollection : Collection<ParameterDefinition>
	{

		readonly IMethodSignature method;

		internal ParameterDefinitionCollection(IMethodSignature method)
		{
			this.method = method;
		}

		internal ParameterDefinitionCollection(IMethodSignature method, int capacity)
			: base(capacity)
		{
			this.method = method;
		}

		protected override void OnAdd(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnInsert(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;

			for (int i = index; i < size; i++)
				items[i].index = i + 1;
		}

		protected override void OnSet(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnRemove(ParameterDefinition item, int index)
		{
			item.method = null;
			item.index = -1;

			for (int i = index + 1; i < size; i++)
				items[i].index = i - 1;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	public abstract class ParameterReference : IMetadataTokenProvider
	{

		string name;
		internal int index = -1;
		protected TypeReference parameter_type;
		internal MetadataToken token;

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public int Index
		{
			get { return index; }
		}

		public TypeReference ParameterType
		{
			get { return parameter_type; }
			set { parameter_type = value; }
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		internal ParameterReference(string name, TypeReference parameterType)
		{
			if (parameterType == null)
				throw new ArgumentNullException("parameterType");

			this.name = name ?? string.Empty;
			this.parameter_type = parameterType;
		}

		public override string ToString()
		{
			return name;
		}

		public abstract ParameterDefinition Resolve();
	}
}

namespace Mono.Cecil.Rocks
{

	public static class ParameterReferenceRocks
	{

		public static int GetSequence(this ParameterReference self)
		{
			return self.Index + 1;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	/// <summary />
	internal class PdbConstant
	{
		internal string name;
		internal uint token;
		internal object value;

		internal PdbConstant(string name, uint token, object value)
		{
			this.name = name;
			this.token = token;
			this.value = value;
		}

		internal PdbConstant(BitAccess bits)
		{
			bits.ReadUInt32(out this.token);
			byte tag1;
			bits.ReadUInt8(out tag1);
			byte tag2;
			bits.ReadUInt8(out tag2);
			if (tag2 == 0)
			{
				this.value = tag1;
			}
			else if (tag2 == 0x80)
			{
				switch (tag1)
				{
					case 0x00: //sbyte
						sbyte sb;
						bits.ReadInt8(out sb);
						this.value = sb;
						break;
					case 0x01: //short
						short s;
						bits.ReadInt16(out s);
						this.value = s;
						break;
					case 0x02: //ushort
						ushort us;
						bits.ReadUInt16(out us);
						this.value = us;
						break;
					case 0x03: //int
						int i;
						bits.ReadInt32(out i);
						this.value = i;
						break;
					case 0x04: //uint
						uint ui;
						bits.ReadUInt32(out ui);
						this.value = ui;
						break;
					case 0x05: //float
						this.value = bits.ReadFloat();
						break;
					case 0x06: //double
						this.value = bits.ReadDouble();
						break;
					case 0x09: //long
						long sl;
						bits.ReadInt64(out sl);
						this.value = sl;
						break;
					case 0x0a: //ulong
						ulong ul;
						bits.ReadUInt64(out ul);
						this.value = ul;
						break;
					case 0x10: //string
						string str;
						bits.ReadBString(out str);
						this.value = str;
						break;
					case 0x19: //decimal
						this.value = bits.ReadDecimal();
						break;
					default:
						//TODO: error
						break;
				}
			}
			else
			{
				//TODO: error
			}
			bits.ReadCString(out name);
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	internal class PdbDebugException : IOException
	{
		internal PdbDebugException(String format, params object[] args)
		  : base(String.Format(format, args))
		{
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	internal class PdbException : IOException
	{
		internal PdbException(String format, params object[] args)
		  : base(String.Format(format, args))
		{
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.






namespace Microsoft.Cci.Pdb
{

	internal class PdbFile
	{

		/// <summary>
		/// GUID of the Basic source language.
		/// </summary>
		private static readonly Guid BasicLanguageGuid = new Guid(974311608, -15764, 4560, 180, 66, 0, 160, 36, 74, 29, 210);

		private PdbFile()   // This class can't be instantiated.
		{
		}

		static void LoadInjectedSourceInformation(BitAccess bits, out Guid doctype, out Guid language, out Guid vendor, out Guid checksumAlgo, out byte[] checksum)
		{
			int checksumSize;
			int injectedSourceSize;
			checksum = null;

			bits.ReadGuid(out language);
			bits.ReadGuid(out vendor);
			bits.ReadGuid(out doctype);
			bits.ReadGuid(out checksumAlgo);
			bits.ReadInt32(out checksumSize);
			bits.ReadInt32(out injectedSourceSize);

			if (checksumSize > 0)
			{
				checksum = new byte[checksumSize];
				bits.ReadBytes(checksum);
			}
		}

		static Dictionary<string, int> LoadNameIndex(BitAccess bits, out int age, out Guid guid)
		{
			Dictionary<string, int> result = new Dictionary<string, int>();
			int ver;
			int sig;
			bits.ReadInt32(out ver);    //  0..3  Version
			bits.ReadInt32(out sig);    //  4..7  Signature
			bits.ReadInt32(out age);    //  8..11 Age
			bits.ReadGuid(out guid);       // 12..27 GUID

			//if (ver != 20000404) {
			//  throw new PdbDebugException("Unsupported PDB Stream version {0}", ver);
			//}

			// Read string buffer.
			int buf;
			bits.ReadInt32(out buf);    // 28..31 Bytes of Strings

			int beg = bits.Position;
			int nxt = bits.Position + buf;

			bits.Position = nxt;

			// Read map index.
			int cnt;        // n+0..3 hash size.
			int max;        // n+4..7 maximum ni.

			bits.ReadInt32(out cnt);
			bits.ReadInt32(out max);

			BitSet present = new BitSet(bits);
			BitSet deleted = new BitSet(bits);
			if (!deleted.IsEmpty)
			{
				throw new PdbDebugException("Unsupported PDB deleted bitset is not empty.");
			}

			int j = 0;
			for (int i = 0; i < max; i++)
			{
				if (present.IsSet(i))
				{
					int ns;
					int ni;
					bits.ReadInt32(out ns);
					bits.ReadInt32(out ni);

					string name;
					int saved = bits.Position;
					bits.Position = beg + ns;
					bits.ReadCString(out name);
					bits.Position = saved;

					result.Add(name.ToUpperInvariant(), ni);
					j++;
				}
			}
			if (j != cnt)
			{
				throw new PdbDebugException("Count mismatch. ({0} != {1})", j, cnt);
			}
			return result;
		}

		static IntHashTable LoadNameStream(BitAccess bits)
		{
			IntHashTable ht = new IntHashTable();

			uint sig;
			int ver;
			bits.ReadUInt32(out sig);   //  0..3  Signature
			bits.ReadInt32(out ver);    //  4..7  Version

			// Read (or skip) string buffer.
			int buf;
			bits.ReadInt32(out buf);    //  8..11 Bytes of Strings

			if (sig != 0xeffeeffe || ver != 1)
			{
				throw new PdbDebugException("Unsupported Name Stream version. " +
													"(sig={0:x8}, ver={1})",
											sig, ver);
			}
			int beg = bits.Position;
			int nxt = bits.Position + buf;
			bits.Position = nxt;

			// Read hash table.
			int siz;
			bits.ReadInt32(out siz);    // n+0..3 Number of hash buckets.
			nxt = bits.Position;

			for (int i = 0; i < siz; i++)
			{
				int ni;
				string name;

				bits.ReadInt32(out ni);

				if (ni != 0)
				{
					int saved = bits.Position;
					bits.Position = beg + ni;
					bits.ReadCString(out name);
					bits.Position = saved;

					ht.Add(ni, name);
				}
			}
			bits.Position = nxt;

			return ht;
		}

		private static int FindFunction(PdbFunction[] funcs, ushort sec, uint off)
		{
			var match = new PdbFunction
			{
				segment = sec,
				address = off
			};

			return Array.BinarySearch(funcs, match, PdbFunction.byAddress);
		}

		static void LoadManagedLines(PdbFunction[] funcs,
									 IntHashTable names,
									 BitAccess bits,
									 MsfDirectory dir,
									 Dictionary<string, int> nameIndex,
									 PdbReader reader,
									 uint limit,
									 Dictionary<string, PdbSource> sourceCache)
		{
			Array.Sort(funcs, PdbFunction.byAddressAndToken);

			int begin = bits.Position;
			IntHashTable checks = ReadSourceFileInfo(bits, limit, names, dir, nameIndex, reader, sourceCache);

			// Read the lines next.
			bits.Position = begin;
			while (bits.Position < limit)
			{
				int sig;
				int siz;
				bits.ReadInt32(out sig);
				bits.ReadInt32(out siz);
				int endSym = bits.Position + siz;

				switch ((DEBUG_S_SUBSECTION)sig)
				{
					case DEBUG_S_SUBSECTION.LINES:
						{
							CV_LineSection sec;

							bits.ReadUInt32(out sec.off);
							bits.ReadUInt16(out sec.sec);
							bits.ReadUInt16(out sec.flags);
							bits.ReadUInt32(out sec.cod);
							int funcIndex = FindFunction(funcs, sec.sec, sec.off);
							if (funcIndex < 0) break;
							var func = funcs[funcIndex];
							if (func.lines == null)
							{
								while (funcIndex > 0)
								{
									var f = funcs[funcIndex - 1];
									if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;
									func = f;
									funcIndex--;
								}
							}
							else
							{
								while (funcIndex < funcs.Length - 1 && func.lines != null)
								{
									var f = funcs[funcIndex + 1];
									if (f.segment != sec.sec || f.address != sec.off) break;
									func = f;
									funcIndex++;
								}
							}
							if (func.lines != null) break;

							// Count the line blocks.
							int begSym = bits.Position;
							int blocks = 0;
							while (bits.Position < endSym)
							{
								CV_SourceFile file;
								bits.ReadUInt32(out file.index);
								bits.ReadUInt32(out file.count);
								bits.ReadUInt32(out file.linsiz);   // Size of payload.
								int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));
								bits.Position += linsiz;
								blocks++;
							}

							func.lines = new PdbLines[blocks];
							int block = 0;

							bits.Position = begSym;
							while (bits.Position < endSym)
							{
								CV_SourceFile file;
								bits.ReadUInt32(out file.index);
								bits.ReadUInt32(out file.count);
								bits.ReadUInt32(out file.linsiz);   // Size of payload.

								PdbSource src = (PdbSource)checks[(int)file.index];
								if (src.language.Equals(BasicLanguageGuid))
								{
									func.AdjustVisualBasicScopes();
								}

								PdbLines tmp = new PdbLines(src, file.count);
								func.lines[block++] = tmp;
								PdbLine[] lines = tmp.lines;

								int plin = bits.Position;
								int pcol = bits.Position + 8 * (int)file.count;

								for (int i = 0; i < file.count; i++)
								{
									CV_Line line;
									CV_Column column = new CV_Column();

									bits.Position = plin + 8 * i;
									bits.ReadUInt32(out line.offset);
									bits.ReadUInt32(out line.flags);

									uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;
									uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;
									//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);
									if ((sec.flags & 1) != 0)
									{
										bits.Position = pcol + 4 * i;
										bits.ReadUInt16(out column.offColumnStart);
										bits.ReadUInt16(out column.offColumnEnd);
									}

									lines[i] = new PdbLine(line.offset,
														   lineBegin,
														   column.offColumnStart,
														   lineBegin + delta,
														   column.offColumnEnd);
								}
							}
							break;
						}
				}
				bits.Position = endSym;
			}
		}

		static void LoadFuncsFromDbiModule(BitAccess bits,
										   DbiModuleInfo info,
										   IntHashTable names,
										   List<PdbFunction> funcList,
										   bool readStrings,
										   MsfDirectory dir,
										   Dictionary<string, int> nameIndex,
										   PdbReader reader,
										   Dictionary<string, PdbSource> sourceCache)
		{
			PdbFunction[] funcs = null;

			bits.Position = 0;
			int sig;
			bits.ReadInt32(out sig);
			if (sig != 4)
			{
				throw new PdbDebugException("Invalid signature. (sig={0})", sig);
			}

			bits.Position = 4;
			// Console.WriteLine("{0}:", info.moduleName);
			funcs = PdbFunction.LoadManagedFunctions(/*info.moduleName,*/
													 bits, (uint)info.cbSyms,
													 readStrings);
			if (funcs != null)
			{
				bits.Position = info.cbSyms + info.cbOldLines;
				LoadManagedLines(funcs, names, bits, dir, nameIndex, reader,
								 (uint)(info.cbSyms + info.cbOldLines + info.cbLines),
								 sourceCache);

				for (int i = 0; i < funcs.Length; i++)
				{
					funcList.Add(funcs[i]);
				}
			}
		}

		static void LoadDbiStream(BitAccess bits,
								  out DbiModuleInfo[] modules,
								  out DbiDbgHdr header,
								  bool readStrings)
		{
			DbiHeader dh = new DbiHeader(bits);
			header = new DbiDbgHdr();

			//if (dh.sig != -1 || dh.ver != 19990903) {
			//  throw new PdbException("Unsupported DBI Stream version, sig={0}, ver={1}",
			//                         dh.sig, dh.ver);
			//}

			// Read gpmod section.
			List<DbiModuleInfo> modList = new List<DbiModuleInfo>();
			int end = bits.Position + dh.gpmodiSize;
			while (bits.Position < end)
			{
				DbiModuleInfo mod = new DbiModuleInfo(bits, readStrings);
				modList.Add(mod);
			}
			if (bits.Position != end)
			{
				throw new PdbDebugException("Error reading DBI stream, pos={0} != {1}",
											bits.Position, end);
			}

			if (modList.Count > 0)
			{
				modules = modList.ToArray();
			}
			else
			{
				modules = null;
			}

			// Skip the Section Contribution substream.
			bits.Position += dh.secconSize;

			// Skip the Section Map substream.
			bits.Position += dh.secmapSize;

			// Skip the File Info substream.
			bits.Position += dh.filinfSize;

			// Skip the TSM substream.
			bits.Position += dh.tsmapSize;

			// Skip the EC substream.
			bits.Position += dh.ecinfoSize;

			// Read the optional header.
			end = bits.Position + dh.dbghdrSize;
			if (dh.dbghdrSize > 0)
			{
				header = new DbiDbgHdr(bits);
			}
			bits.Position = end;
		}

		internal static PdbInfo LoadFunctions(Stream read)
		{
			PdbInfo pdbInfo = new PdbInfo();

			pdbInfo.TokenToSourceMapping = new Dictionary<uint, PdbTokenLine>();
			BitAccess bits = new BitAccess(64 * 1024);
			PdbFileHeader head = new PdbFileHeader(read, bits);
			PdbReader reader = new PdbReader(read, head.pageSize);
			MsfDirectory dir = new MsfDirectory(reader, head, bits);
			DbiModuleInfo[] modules = null;
			DbiDbgHdr header;
			Dictionary<string, PdbSource> sourceCache = new Dictionary<string, PdbSource>();

			dir.streams[1].Read(reader, bits);
			Dictionary<string, int> nameIndex = LoadNameIndex(bits, out pdbInfo.Age, out pdbInfo.Guid);
			int nameStream;
			if (!nameIndex.TryGetValue("/NAMES", out nameStream))
			{
				throw new PdbException("Could not find the '/NAMES' stream: the PDB file may be a public symbol file instead of a private symbol file");
			}
			dir.streams[nameStream].Read(reader, bits);
			IntHashTable names = LoadNameStream(bits);

			int srcsrvStream;
			if (!nameIndex.TryGetValue("SRCSRV", out srcsrvStream))
				pdbInfo.SourceServerData = string.Empty;
			else
			{
				DataStream dataStream = dir.streams[srcsrvStream];
				byte[] bytes = new byte[dataStream.contentSize];
				dataStream.Read(reader, bits);
				pdbInfo.SourceServerData = bits.ReadBString(bytes.Length);
			}

			int sourceLinkStream;
			if (nameIndex.TryGetValue("SOURCELINK", out sourceLinkStream))
			{
				DataStream dataStream = dir.streams[sourceLinkStream];
				pdbInfo.SourceLinkData = new byte[dataStream.contentSize];
				dataStream.Read(reader, bits);
				bits.ReadBytes(pdbInfo.SourceLinkData);
			}

			dir.streams[3].Read(reader, bits);
			LoadDbiStream(bits, out modules, out header, true);

			List<PdbFunction> funcList = new List<PdbFunction>();

			if (modules != null)
			{
				for (int m = 0; m < modules.Length; m++)
				{
					var module = modules[m];
					if (module.stream > 0)
					{
						dir.streams[module.stream].Read(reader, bits);
						if (module.moduleName == "TokenSourceLineInfo")
						{
							LoadTokenToSourceInfo(bits, module, names, dir, nameIndex, reader, pdbInfo.TokenToSourceMapping, sourceCache);
							continue;
						}
						LoadFuncsFromDbiModule(bits, module, names, funcList, true, dir, nameIndex, reader, sourceCache);
					}
				}
			}

			PdbFunction[] funcs = funcList.ToArray();

			// After reading the functions, apply the token remapping table if it exists.
			if (header.snTokenRidMap != 0 && header.snTokenRidMap != 0xffff)
			{
				dir.streams[header.snTokenRidMap].Read(reader, bits);
				uint[] ridMap = new uint[dir.streams[header.snTokenRidMap].Length / 4];
				bits.ReadUInt32(ridMap);

				foreach (PdbFunction func in funcs)
				{
					func.token = 0x06000000 | ridMap[func.token & 0xffffff];
				}
			}

			//
			Array.Sort(funcs, PdbFunction.byAddressAndToken);
			//Array.Sort(funcs, PdbFunction.byToken);
			pdbInfo.Functions = funcs;
			return pdbInfo;
		}

		private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir,
		  Dictionary<string, int> nameIndex, PdbReader reader, Dictionary<uint, PdbTokenLine> tokenToSourceMapping, Dictionary<string, PdbSource> sourceCache)
		{
			bits.Position = 0;
			int sig;
			bits.ReadInt32(out sig);
			if (sig != 4)
			{
				throw new PdbDebugException("Invalid signature. (sig={0})", sig);
			}

			bits.Position = 4;

			while (bits.Position < module.cbSyms)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.Position = star;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{
					case SYM.S_OEM:
						OemSymbol oem;

						bits.ReadGuid(out oem.idOem);
						bits.ReadUInt32(out oem.typind);
						// internal byte[]   rgl;        // user data, force 4-byte alignment

						if (oem.idOem == PdbFunction.msilMetaData)
						{
							string name = bits.ReadString();
							if (name == "TSLI")
							{
								uint token;
								uint file_id;
								uint line;
								uint column;
								uint endLine;
								uint endColumn;
								bits.ReadUInt32(out token);
								bits.ReadUInt32(out file_id);
								bits.ReadUInt32(out line);
								bits.ReadUInt32(out column);
								bits.ReadUInt32(out endLine);
								bits.ReadUInt32(out endColumn);
								PdbTokenLine tokenLine;
								if (!tokenToSourceMapping.TryGetValue(token, out tokenLine))
									tokenToSourceMapping.Add(token, new PdbTokenLine(token, file_id, line, column, endLine, endColumn));
								else
								{
									while (tokenLine.nextLine != null) tokenLine = tokenLine.nextLine;
									tokenLine.nextLine = new PdbTokenLine(token, file_id, line, column, endLine, endColumn);
								}
							}
							bits.Position = stop;
							break;
						}
						else
						{
							throw new PdbDebugException("OEM section: guid={0} ti={1}",
														oem.idOem, oem.typind);
							// bits.Position = stop;
						}

					case SYM.S_END:
						bits.Position = stop;
						break;

					default:
						//Console.WriteLine("{0,6}: {1:x2} {2}",
						//                  bits.Position, rec, (SYM)rec);
						bits.Position = stop;
						break;
				}
			}

			bits.Position = module.cbSyms + module.cbOldLines;
			int limit = module.cbSyms + module.cbOldLines + module.cbLines;
			IntHashTable sourceFiles = ReadSourceFileInfo(bits, (uint)limit, names, dir, nameIndex, reader, sourceCache);
			foreach (var tokenLine in tokenToSourceMapping.Values)
			{
				tokenLine.sourceFile = (PdbSource)sourceFiles[(int)tokenLine.file_id];
			}

		}

		public static readonly Guid SymDocumentType_Text = new Guid(1518771467, 26129, 4563, 189, 42, 0, 0, 248, 8, 73, 189);

		private static IntHashTable ReadSourceFileInfo(BitAccess bits, uint limit, IntHashTable names, MsfDirectory dir,
		  Dictionary<string, int> nameIndex, PdbReader reader, Dictionary<string, PdbSource> sourceCache)
		{
			IntHashTable checks = new IntHashTable();

			int begin = bits.Position;
			while (bits.Position < limit)
			{
				int sig;
				int siz;
				bits.ReadInt32(out sig);
				bits.ReadInt32(out siz);
				int place = bits.Position;
				int endSym = bits.Position + siz;

				switch ((DEBUG_S_SUBSECTION)sig)
				{
					case DEBUG_S_SUBSECTION.FILECHKSMS:
						while (bits.Position < endSym)
						{
							CV_FileCheckSum chk;

							int ni = bits.Position - place;
							bits.ReadUInt32(out chk.name);
							bits.ReadUInt8(out chk.len);
							bits.ReadUInt8(out chk.type);

							string name = (string)names[(int)chk.name];

							PdbSource src;
							if (!sourceCache.TryGetValue(name, out src))
							{
								int guidStream;
								Guid doctypeGuid = SymDocumentType_Text;
								Guid languageGuid = Guid.Empty;
								Guid vendorGuid = Guid.Empty;
								Guid checksumAlgoGuid = Guid.Empty;
								byte[] checksum = null;
								if (nameIndex.TryGetValue("/SRC/FILES/" + name.ToUpperInvariant(), out guidStream))
								{
									var guidBits = new BitAccess(0x100);
									dir.streams[guidStream].Read(reader, guidBits);
									LoadInjectedSourceInformation(guidBits, out doctypeGuid, out languageGuid, out vendorGuid, out checksumAlgoGuid, out checksum);
								}

								src = new PdbSource(name, doctypeGuid, languageGuid, vendorGuid, checksumAlgoGuid, checksum);
								sourceCache.Add(name, src);
							}
							checks.Add(ni, src);
							bits.Position += chk.len;
							bits.Align(4);
						}
						bits.Position = endSym;
						break;

					default:
						bits.Position = endSym;
						break;
				}
			}
			return checks;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.






namespace Microsoft.Cci.Pdb
{
	internal class PdbFileHeader
	{
		private readonly byte[] windowsPdbMagic = new byte[32] {
				  0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, // "Microsof"
                  0x74, 0x20, 0x43, 0x2F, 0x43, 0x2B, 0x2B, 0x20, // "t C/C++ "
                  0x4D, 0x53, 0x46, 0x20, 0x37, 0x2E, 0x30, 0x30, // "MSF 7.00"
                  0x0D, 0x0A, 0x1A, 0x44, 0x53, 0x00, 0x00, 0x00  // "^^^DS^^^"
    };

		//internal PdbFileHeader(int pageSize) {
		//  this.magic = new byte[32] {
		//            0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, // "Microsof"
		//            0x74, 0x20, 0x43, 0x2F, 0x43, 0x2B, 0x2B, 0x20, // "t C/C++ "
		//            0x4D, 0x53, 0x46, 0x20, 0x37, 0x2E, 0x30, 0x30, // "MSF 7.00"
		//            0x0D, 0x0A, 0x1A, 0x44, 0x53, 0x00, 0x00, 0x00  // "^^^DS^^^"
		//        };
		//  this.pageSize = pageSize;
		//}

		internal PdbFileHeader(Stream reader, BitAccess bits)
		{
			bits.MinCapacity(56);
			reader.Seek(0, SeekOrigin.Begin);
			bits.FillBuffer(reader, 52);

			this.magic = new byte[32];
			bits.ReadBytes(this.magic);                 //   0..31
			bits.ReadInt32(out this.pageSize);          //  32..35
			bits.ReadInt32(out this.freePageMap);       //  36..39
			bits.ReadInt32(out this.pagesUsed);         //  40..43
			bits.ReadInt32(out this.directorySize);     //  44..47
			bits.ReadInt32(out this.zero);              //  48..51

			if (!this.magic.SequenceEqual(windowsPdbMagic))
			{
				throw new PdbException("The PDB file is not recognized as a Windows PDB file");
			}

			int directoryPages = ((((directorySize + pageSize - 1) / pageSize) * 4) + pageSize - 1) / pageSize;
			this.directoryRoot = new int[directoryPages];
			bits.FillBuffer(reader, directoryPages * 4);
			bits.ReadInt32(this.directoryRoot);
		}

		//internal string Magic {
		//  get { return StringFromBytesUTF8(magic); }
		//}

		//internal void Write(Stream writer, BitAccess bits) {
		//  bits.MinCapacity(pageSize);
		//  bits.WriteBytes(magic);                     //   0..31
		//  bits.WriteInt32(pageSize);                  //  32..35
		//  bits.WriteInt32(freePageMap);               //  36..39
		//  bits.WriteInt32(pagesUsed);                 //  40..43
		//  bits.WriteInt32(directorySize);             //  44..47
		//  bits.WriteInt32(zero);                      //  48..51
		//  bits.WriteInt32(directoryRoot);             //  52..55

		//  writer.Seek(0, SeekOrigin.Begin);
		//  bits.WriteBuffer(writer, pageSize);
		//}

		//////////////////////////////////////////////////// Helper Functions.
		//
		//internal static string StringFromBytesUTF8(byte[] bytes) {
		//  return StringFromBytesUTF8(bytes, 0, bytes.Length);
		//}

		//internal static string StringFromBytesUTF8(byte[] bytes, int offset, int length) {
		//  for (int i = 0; i < length; i++) {
		//    if (bytes[offset + i] < ' ') {
		//      length = i;
		//    }
		//  }
		//  return Encoding.UTF8.GetString(bytes, offset, length);
		//}

		////////////////////////////////////////////////////////////// Fields.
		//
		internal readonly byte[] magic;
		internal readonly int pageSize;
		internal int freePageMap;
		internal int pagesUsed;
		internal int directorySize;
		internal readonly int zero;
		internal int[] directoryRoot;
	}

}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.





#pragma warning disable 1591 // TODO: doc comments

namespace Microsoft.Cci.Pdb
{
	internal class PdbFunction
	{
		static internal readonly Guid msilMetaData = new Guid(0xc6ea3fc9, 0x59b3, 0x49d6, 0xbc, 0x25,
															0x09, 0x02, 0xbb, 0xab, 0xb4, 0x60);
		static internal readonly IComparer byAddress = new PdbFunctionsByAddress();
		static internal readonly IComparer byAddressAndToken = new PdbFunctionsByAddressAndToken();
		//static internal readonly IComparer byToken = new PdbFunctionsByToken();

		internal uint token;
		internal uint slotToken;
		internal uint tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
		//internal string name;
		//internal string module;
		//internal ushort flags;

		internal uint segment;
		internal uint address;
		internal uint length;

		//internal byte[] metadata;
		internal PdbScope[] scopes;
		internal PdbSlot[] slots;
		internal PdbConstant[] constants;
		internal string[] usedNamespaces;
		internal PdbLines[] lines;
		internal ushort[]/*?*/ usingCounts;
		internal IEnumerable<INamespaceScope>/*?*/ namespaceScopes = null;
		internal string/*?*/ iteratorClass;
		internal List<ILocalScope>/*?*/ iteratorScopes;
		internal PdbSynchronizationInformation/*?*/ synchronizationInformation;

		/// <summary>
		/// Flag saying whether the method has been identified as a product of VB compilation using
		/// the legacy Windows PDB symbol format, in which case scope ends need to be shifted by 1
		/// due to different semantics of scope limits in VB and C# compilers.
		/// </summary>
		private bool visualBasicScopesAdjusted = false;

		private static string StripNamespace(string module)
		{
			int li = module.LastIndexOf('.');
			if (li > 0)
			{
				return module.Substring(li + 1);
			}
			return module;
		}

		/// <summary>
		/// When the Windows PDB reader identifies a PdbFunction as having 'Basic' as its source language,
		/// it calls this method which adjusts all scopes by adding 1 to their lengths to compensate
		/// for different behavior of VB vs. the C# compiler w.r.t. emission of scope info.
		/// </summary>
		internal void AdjustVisualBasicScopes()
		{
			if (!visualBasicScopesAdjusted)
			{
				visualBasicScopesAdjusted = true;

				// Don't adjust root scope as that one is correct
				foreach (PdbScope scope in scopes)
				{
					AdjustVisualBasicScopes(scope.scopes);
				}
			}
		}

		/// <summary>
		/// Recursively update the entire scope tree by adding 1 to the length of each scope.
		/// </summary>
		private void AdjustVisualBasicScopes(PdbScope[] scopes)
		{
			foreach (PdbScope scope in scopes)
			{
				scope.length++;
				AdjustVisualBasicScopes(scope.scopes);
			}
		}

		internal static PdbFunction[] LoadManagedFunctions(/*string module,*/
														   BitAccess bits, uint limit,
														   bool readStrings)
		{
			//string mod = StripNamespace(module);
			int begin = bits.Position;
			int count = 0;

			while (bits.Position < limit)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.Position = star;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{
					case SYM.S_GMANPROC:
					case SYM.S_LMANPROC:
						ManProcSym proc;
						bits.ReadUInt32(out proc.parent);
						bits.ReadUInt32(out proc.end);
						bits.Position = (int)proc.end;
						count++;
						break;

					case SYM.S_END:
						bits.Position = stop;
						break;

					default:
						//Console.WriteLine("{0,6}: {1:x2} {2}",
						//                  bits.Position, rec, (SYM)rec);
						bits.Position = stop;
						break;
				}
			}
			if (count == 0)
			{
				return null;
			}

			bits.Position = begin;
			PdbFunction[] funcs = new PdbFunction[count];
			int func = 0;

			while (bits.Position < limit)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{

					case SYM.S_GMANPROC:
					case SYM.S_LMANPROC:
						ManProcSym proc;
						//int offset = bits.Position;

						bits.ReadUInt32(out proc.parent);
						bits.ReadUInt32(out proc.end);
						bits.ReadUInt32(out proc.next);
						bits.ReadUInt32(out proc.len);
						bits.ReadUInt32(out proc.dbgStart);
						bits.ReadUInt32(out proc.dbgEnd);
						bits.ReadUInt32(out proc.token);
						bits.ReadUInt32(out proc.off);
						bits.ReadUInt16(out proc.seg);
						bits.ReadUInt8(out proc.flags);
						bits.ReadUInt16(out proc.retReg);
						if (readStrings)
						{
							bits.ReadCString(out proc.name);
						}
						else
						{
							bits.SkipCString(out proc.name);
						}
						//Console.WriteLine("token={0:X8} [{1}::{2}]", proc.token, module, proc.name);

						bits.Position = stop;
						funcs[func++] = new PdbFunction(/*module,*/ proc, bits);
						break;

					default:
						{
							//throw new PdbDebugException("Unknown SYMREC {0}", (SYM)rec);
							bits.Position = stop;
							break;
						}
				}
			}
			return funcs;
		}

		internal static void CountScopesAndSlots(BitAccess bits, uint limit,
												 out int constants, out int scopes, out int slots, out int usedNamespaces)
		{
			int pos = bits.Position;
			BlockSym32 block;
			constants = 0;
			slots = 0;
			scopes = 0;
			usedNamespaces = 0;

			while (bits.Position < limit)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.Position = star;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{
					case SYM.S_BLOCK32:
						{
							bits.ReadUInt32(out block.parent);
							bits.ReadUInt32(out block.end);

							scopes++;
							bits.Position = (int)block.end;
							break;
						}

					case SYM.S_MANSLOT:
						slots++;
						bits.Position = stop;
						break;

					case SYM.S_UNAMESPACE:
						usedNamespaces++;
						bits.Position = stop;
						break;

					case SYM.S_MANCONSTANT:
						constants++;
						bits.Position = stop;
						break;

					default:
						bits.Position = stop;
						break;
				}
			}
			bits.Position = pos;
		}

		internal PdbFunction()
		{
		}

		internal PdbFunction(/*string module, */ManProcSym proc, BitAccess bits)
		{
			this.token = proc.token;
			//this.module = module;
			//this.name = proc.name;
			//this.flags = proc.flags;
			this.segment = proc.seg;
			this.address = proc.off;
			this.length = proc.len;

			if (proc.seg != 1)
			{
				throw new PdbDebugException("Segment is {0}, not 1.", proc.seg);
			}
			if (proc.parent != 0 || proc.next != 0)
			{
				throw new PdbDebugException("Warning parent={0}, next={1}",
											proc.parent, proc.next);
			}
			//if (proc.dbgStart != 0 || proc.dbgEnd != 0) {
			//  throw new PdbDebugException("Warning DBG start={0}, end={1}",
			//                              proc.dbgStart, proc.dbgEnd);
			//}

			int constantCount;
			int scopeCount;
			int slotCount;
			int usedNamespacesCount;
			CountScopesAndSlots(bits, proc.end, out constantCount, out scopeCount, out slotCount, out usedNamespacesCount);
			int scope = constantCount > 0 || slotCount > 0 || usedNamespacesCount > 0 ? 1 : 0;
			int slot = 0;
			int constant = 0;
			int usedNs = 0;
			scopes = new PdbScope[scopeCount + scope];
			slots = new PdbSlot[slotCount];
			constants = new PdbConstant[constantCount];
			usedNamespaces = new string[usedNamespacesCount];

			if (scope > 0)
				scopes[0] = new PdbScope(this.address, proc.len, slots, constants, usedNamespaces);

			while (bits.Position < proc.end)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.Position = star;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{
					case SYM.S_OEM:
						{          // 0x0404
							OemSymbol oem;

							bits.ReadGuid(out oem.idOem);
							bits.ReadUInt32(out oem.typind);
							// internal byte[]   rgl;        // user data, force 4-byte alignment

							if (oem.idOem == msilMetaData)
							{
								string name = bits.ReadString();
								if (name == "MD2")
								{
									ReadMD2CustomMetadata(bits);
								}
								else if (name == "asyncMethodInfo")
								{
									this.synchronizationInformation = new PdbSynchronizationInformation(bits);
								}
								bits.Position = stop;
								break;
							}
							else
							{
								throw new PdbDebugException("OEM section: guid={0} ti={1}",
															oem.idOem, oem.typind);
								// bits.Position = stop;
							}
						}

					case SYM.S_BLOCK32:
						{
							BlockSym32 block = new BlockSym32();

							bits.ReadUInt32(out block.parent);
							bits.ReadUInt32(out block.end);
							bits.ReadUInt32(out block.len);
							bits.ReadUInt32(out block.off);
							bits.ReadUInt16(out block.seg);
							bits.SkipCString(out block.name);
							bits.Position = stop;

							scopes[scope++] = new PdbScope(this.address, block, bits, out slotToken);
							bits.Position = (int)block.end;
							break;
						}

					case SYM.S_MANSLOT:
						slots[slot++] = new PdbSlot(bits);
						bits.Position = stop;
						break;

					case SYM.S_MANCONSTANT:
						constants[constant++] = new PdbConstant(bits);
						bits.Position = stop;
						break;

					case SYM.S_UNAMESPACE:
						bits.ReadCString(out usedNamespaces[usedNs++]);
						bits.Position = stop;
						break;

					case SYM.S_END:
						bits.Position = stop;
						break;

					default:
						{
							//throw new PdbDebugException("Unknown SYM: {0}", (SYM)rec);
							bits.Position = stop;
							break;
						}
				}
			}

			if (bits.Position != proc.end)
			{
				throw new PdbDebugException("Not at S_END");
			}

			ushort esiz;
			ushort erec;
			bits.ReadUInt16(out esiz);
			bits.ReadUInt16(out erec);

			if (erec != (ushort)SYM.S_END)
			{
				throw new PdbDebugException("Missing S_END");
			}
		}

		internal void ReadMD2CustomMetadata(BitAccess bits)
		{
			byte version;
			bits.ReadUInt8(out version);
			if (version == 4)
			{
				byte count;
				bits.ReadUInt8(out count);
				bits.Align(4);
				while (count-- > 0)
					this.ReadCustomMetadata(bits);
			}
		}

		private void ReadCustomMetadata(BitAccess bits)
		{
			int savedPosition = bits.Position;
			byte version;
			bits.ReadUInt8(out version);
			byte kind;
			bits.ReadUInt8(out kind);
			bits.Position += 2;   // 2-bytes padding
			uint numberOfBytesInItem;
			bits.ReadUInt32(out numberOfBytesInItem);
			if (version == 4)
			{
				switch (kind)
				{
					case 0: this.ReadUsingInfo(bits); break;
					case 1: this.ReadForwardInfo(bits); break;
					case 2: break; // this.ReadForwardedToModuleInfo(bits); break;
					case 3: this.ReadIteratorLocals(bits); break;
					case 4: this.ReadForwardIterator(bits); break;
					case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs,a3031f7681d76e93
					case 6: break; // EnC data
					case 7: break; // EnC data for lambdas and closures
								   // ignore any other unknown record types that may be added in future, instead of throwing an exception
								   // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md
					default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}", kind);
				}
			}
			bits.Position = savedPosition + (int)numberOfBytesInItem;
		}

		private void ReadForwardIterator(BitAccess bits)
		{
			this.iteratorClass = bits.ReadString();
		}

		private void ReadIteratorLocals(BitAccess bits)
		{
			uint numberOfLocals;
			bits.ReadUInt32(out numberOfLocals);
			this.iteratorScopes = new List<ILocalScope>((int)numberOfLocals);
			while (numberOfLocals-- > 0)
			{
				uint ilStartOffset;
				uint ilEndOffset;
				bits.ReadUInt32(out ilStartOffset);
				bits.ReadUInt32(out ilEndOffset);
				this.iteratorScopes.Add(new PdbIteratorScope(ilStartOffset, ilEndOffset - ilStartOffset));
			}
		}

		//private void ReadForwardedToModuleInfo(BitAccess bits) {
		//}

		private void ReadForwardInfo(BitAccess bits)
		{
			bits.ReadUInt32(out this.tokenOfMethodWhoseUsingInfoAppliesToThisMethod);
		}

		private void ReadUsingInfo(BitAccess bits)
		{
			ushort numberOfNamespaces;
			bits.ReadUInt16(out numberOfNamespaces);
			this.usingCounts = new ushort[numberOfNamespaces];
			for (ushort i = 0; i < numberOfNamespaces; i++)
			{
				bits.ReadUInt16(out this.usingCounts[i]);
			}
		}

		internal class PdbFunctionsByAddress : IComparer
		{
			public int Compare(Object x, Object y)
			{
				PdbFunction fx = (PdbFunction)x;
				PdbFunction fy = (PdbFunction)y;

				if (fx.segment < fy.segment)
				{
					return -1;
				}
				else if (fx.segment > fy.segment)
				{
					return 1;
				}
				else if (fx.address < fy.address)
				{
					return -1;
				}
				else if (fx.address > fy.address)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}
		}

		internal class PdbFunctionsByAddressAndToken : IComparer
		{
			public int Compare(Object x, Object y)
			{
				PdbFunction fx = (PdbFunction)x;
				PdbFunction fy = (PdbFunction)y;

				if (fx.segment < fy.segment)
				{
					return -1;
				}
				else if (fx.segment > fy.segment)
				{
					return 1;
				}
				else if (fx.address < fy.address)
				{
					return -1;
				}
				else if (fx.address > fy.address)
				{
					return 1;
				}
				else
				{
					if (fx.token < fy.token)
						return -1;
					else if (fx.token > fy.token)
						return 1;
					else
						return 0;
				}
			}
		}

		//internal class PdbFunctionsByToken : IComparer {
		//  public int Compare(Object x, Object y) {
		//    PdbFunction fx = (PdbFunction)x;
		//    PdbFunction fy = (PdbFunction)y;

		//    if (fx.token < fy.token) {
		//      return -1;
		//    } else if (fx.token > fy.token) {
		//      return 1;
		//    } else {
		//      return 0;
		//    }
		//  }

		//}
	}

	internal class PdbSynchronizationInformation
	{
		internal uint kickoffMethodToken;
		internal uint generatedCatchHandlerIlOffset;
		internal PdbSynchronizationPoint[] synchronizationPoints;

		internal PdbSynchronizationInformation(BitAccess bits)
		{
			uint asyncStepInfoCount;
			bits.ReadUInt32(out this.kickoffMethodToken);
			bits.ReadUInt32(out this.generatedCatchHandlerIlOffset);
			bits.ReadUInt32(out asyncStepInfoCount);
			this.synchronizationPoints = new PdbSynchronizationPoint[asyncStepInfoCount];
			for (uint i = 0; i < asyncStepInfoCount; i += 1)
			{
				this.synchronizationPoints[i] = new PdbSynchronizationPoint(bits);
			}
		}

		public uint GeneratedCatchHandlerOffset
		{
			get { return this.generatedCatchHandlerIlOffset; }
		}
	}

	internal class PdbSynchronizationPoint
	{
		internal uint synchronizeOffset;
		internal uint continuationMethodToken;
		internal uint continuationOffset;

		internal PdbSynchronizationPoint(BitAccess bits)
		{
			bits.ReadUInt32(out this.synchronizeOffset);
			bits.ReadUInt32(out this.continuationMethodToken);
			bits.ReadUInt32(out this.continuationOffset);
		}

		public uint SynchronizeOffset
		{
			get { return this.synchronizeOffset; }
		}

		public uint ContinuationOffset
		{
			get { return this.continuationOffset; }
		}
	}

}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Metadata
{

	sealed class PdbHeap : Heap
	{

		public byte[] Id;
		public RID EntryPoint;
		public long TypeSystemTables;
		public uint[] TypeSystemTableRows;

		public PdbHeap(byte[] data)
			: base(data)
		{
		}

		public bool HasTable(Table table)
		{
			return (TypeSystemTables & (1L << (int)table)) != 0;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil.Pdb
{

	public sealed class NativePdbReaderProvider : ISymbolReaderProvider
	{

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			return new NativePdbReader(Disposable.Owned(File.OpenRead(Mixin.GetPdbFileName(fileName)) as Stream));
		}

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);

			return new NativePdbReader(Disposable.NotOwned(symbolStream));
		}
	}

	public sealed class PdbReaderProvider : ISymbolReaderProvider
	{

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);

			if (module.HasDebugHeader)
			{
				var header = module.GetDebugHeader();
				var entry = header.GetEmbeddedPortablePdbEntry();
				if (entry != null)
					return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, fileName);
			}

			Mixin.CheckFileName(fileName);

			return Mixin.IsPortablePdb(Mixin.GetPdbFileName(fileName))
				? new PortablePdbReaderProvider().GetSymbolReader(module, fileName)
				: new NativePdbReaderProvider().GetSymbolReader(module, fileName);
		}

		public Mono.Cecil.Cil.ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);
			Mixin.CheckReadSeek(symbolStream);

			return Mixin.IsPortablePdb(symbolStream)
				? new PortablePdbReaderProvider().GetSymbolReader(module, symbolStream)
				: new NativePdbReaderProvider().GetSymbolReader(module, symbolStream);
		}
	}

	public sealed class NativePdbWriterProvider : ISymbolWriterProvider
	{

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			return new NativePdbWriter(module, CreateWriter(module, Mixin.GetPdbFileName(fileName)));
		}

		static SymWriter CreateWriter(ModuleDefinition module, string pdb)
		{
			var writer = new SymWriter();

			if (File.Exists(pdb))
				File.Delete(pdb);

			writer.Initialize(new ModuleMetadata(module), pdb, true);

			return writer;
		}

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			throw new NotImplementedException();
		}
	}

	public sealed class PdbWriterProvider : ISymbolWriterProvider
	{

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			if (HasPortablePdbSymbols(module))
				return new PortablePdbWriterProvider().GetSymbolWriter(module, fileName);

			return new NativePdbWriterProvider().GetSymbolWriter(module, fileName);
		}

		static bool HasPortablePdbSymbols(ModuleDefinition module)
		{
			return module.symbol_reader != null && module.symbol_reader is PortablePdbReader;
		}

		public Mono.Cecil.Cil.ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);
			Mixin.CheckReadSeek(symbolStream);

			if (HasPortablePdbSymbols(module))
				return new PortablePdbWriterProvider().GetSymbolWriter(module, symbolStream);

			return new NativePdbWriterProvider().GetSymbolWriter(module, symbolStream);
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{

	/// <summary>
	/// This class represents the information read from a PDB file (both legacy Windows and Portable).
	/// </summary>
	internal class PdbInfo
	{
		/// <summary>
		/// Enumeration of per-function information contained in the PDB file.
		/// </summary>
		public PdbFunction[] Functions;

		/// <summary>
		/// Mapping from tokens to source files and line numbers.
		/// </summary>
		public Dictionary<uint, PdbTokenLine> TokenToSourceMapping;

		/// <summary>
		/// Source server data information.
		/// </summary>
		public string SourceServerData;

		/// <summary>
		/// Age of the PDB file is used to match the PDB against the PE binary.
		/// </summary>
		public int Age;

		/// <summary>
		/// GUID of the PDB file is used to match the PDB against the PE binary.
		/// </summary>
		public Guid Guid;

		/// <summary>
		/// Source link data information.
		/// </summary>
		public byte[] SourceLinkData;
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal struct PdbLine
	{
		internal uint offset;
		internal uint lineBegin;
		internal uint lineEnd;
		internal ushort colBegin;
		internal ushort colEnd;

		internal PdbLine(uint offset, uint lineBegin, ushort colBegin, uint lineEnd, ushort colEnd)
		{
			this.offset = offset;
			this.lineBegin = lineBegin;
			this.colBegin = colBegin;
			this.lineEnd = lineEnd;
			this.colEnd = colEnd;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class PdbLines
	{
		internal PdbSource file;
		internal PdbLine[] lines;

		internal PdbLines(PdbSource file, uint count)
		{
			this.file = file;
			this.lines = new PdbLine[count];
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.




namespace Microsoft.Cci.Pdb
{
	internal class PdbReader
	{
		internal PdbReader(Stream reader, int pageSize)
		{
			this.pageSize = pageSize;
			this.reader = reader;
		}

		internal void Seek(int page, int offset)
		{
			reader.Seek(page * pageSize + offset, SeekOrigin.Begin);
		}

		internal void Read(byte[] bytes, int offset, int count)
		{
			reader.Read(bytes, offset, count);
		}

		internal int PagesFromSize(int size)
		{
			return (size + pageSize - 1) / (pageSize);
		}

		//internal int PageSize {
		//  get { return pageSize; }
		//}

		internal readonly int pageSize;
		internal readonly Stream reader;
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class PdbScope
	{
		internal PdbConstant[] constants;
		internal PdbSlot[] slots;
		internal PdbScope[] scopes;
		internal string[] usedNamespaces;

		//internal uint segment;
		internal uint address;
		internal uint offset;
		internal uint length;

		internal PdbScope(uint address, uint offset, uint length, PdbSlot[] slots, PdbConstant[] constants, string[] usedNamespaces)
		{
			this.constants = constants;
			this.slots = slots;
			this.scopes = new PdbScope[0];
			this.usedNamespaces = usedNamespaces;
			this.address = address;
			this.offset = offset;
			this.length = length;
		}

		internal PdbScope(uint address, uint length, PdbSlot[] slots, PdbConstant[] constants, string[] usedNamespaces)
		  : this(address, 0, length, slots, constants, usedNamespaces)
		{
		}

		internal PdbScope(uint funcOffset, BlockSym32 block, BitAccess bits, out uint typind)
		{
			//this.segment = block.seg;
			this.address = block.off;
			this.offset = block.off - funcOffset;
			this.length = block.len;
			typind = 0;

			int constantCount;
			int scopeCount;
			int slotCount;
			int namespaceCount;
			PdbFunction.CountScopesAndSlots(bits, block.end, out constantCount, out scopeCount, out slotCount, out namespaceCount);
			constants = new PdbConstant[constantCount];
			scopes = new PdbScope[scopeCount];
			slots = new PdbSlot[slotCount];
			usedNamespaces = new string[namespaceCount];
			int constant = 0;
			int scope = 0;
			int slot = 0;
			int usedNs = 0;

			while (bits.Position < block.end)
			{
				ushort siz;
				ushort rec;

				bits.ReadUInt16(out siz);
				int star = bits.Position;
				int stop = bits.Position + siz;
				bits.Position = star;
				bits.ReadUInt16(out rec);

				switch ((SYM)rec)
				{
					case SYM.S_BLOCK32:
						{
							BlockSym32 sub = new BlockSym32();

							bits.ReadUInt32(out sub.parent);
							bits.ReadUInt32(out sub.end);
							bits.ReadUInt32(out sub.len);
							bits.ReadUInt32(out sub.off);
							bits.ReadUInt16(out sub.seg);
							bits.SkipCString(out sub.name);

							bits.Position = stop;
							scopes[scope++] = new PdbScope(funcOffset, sub, bits, out typind);
							break;
						}

					case SYM.S_MANSLOT:
						slots[slot++] = new PdbSlot(bits);
						bits.Position = stop;
						break;

					case SYM.S_UNAMESPACE:
						bits.ReadCString(out usedNamespaces[usedNs++]);
						bits.Position = stop;
						break;

					case SYM.S_END:
						bits.Position = stop;
						break;

					case SYM.S_MANCONSTANT:
						constants[constant++] = new PdbConstant(bits);
						bits.Position = stop;
						break;

					default:
						//throw new PdbException("Unknown SYM in scope {0}", (SYM)rec);
						bits.Position = stop;
						break;
				}
			}

			if (bits.Position != block.end)
			{
				throw new Exception("Not at S_END");
			}

			ushort esiz;
			ushort erec;
			bits.ReadUInt16(out esiz);
			bits.ReadUInt16(out erec);

			if (erec != (ushort)SYM.S_END)
			{
				throw new Exception("Missing S_END");
			}
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class PdbSlot
	{
		internal uint slot;
		internal uint typeToken;
		internal string name;
		internal ushort flags;
		//internal uint segment;
		//internal uint address;

		internal PdbSlot(uint slot, uint typeToken, string name, ushort flags)
		{
			this.slot = slot;
			this.typeToken = typeToken;
			this.name = name;
			this.flags = flags;
		}

		internal PdbSlot(BitAccess bits)
		{
			AttrSlotSym slot;

			bits.ReadUInt32(out slot.index);
			bits.ReadUInt32(out slot.typind);
			bits.ReadUInt32(out slot.offCod);
			bits.ReadUInt16(out slot.segCod);
			bits.ReadUInt16(out slot.flags);
			bits.ReadCString(out slot.name);

			this.slot = slot.index;
			this.typeToken = slot.typind;
			this.name = slot.name;
			this.flags = slot.flags;
			//this.segment = slot.segCod;
			//this.address = slot.offCod;

		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class PdbSource
	{
		//internal uint index;
		internal string name;
		internal Guid doctype;
		internal Guid language;
		internal Guid vendor;
		internal Guid checksumAlgorithm;
		internal byte[] checksum;

		internal PdbSource(/*uint index, */string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, byte[] checksum)
		{
			//this.index = index;
			this.name = name;
			this.doctype = doctype;
			this.language = language;
			this.vendor = vendor;
			this.checksumAlgorithm = checksumAlgorithm;
			this.checksum = checksum;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.



namespace Microsoft.Cci.Pdb
{
	internal class PdbTokenLine
	{
		internal uint token;
		internal uint file_id;
		internal uint line;
		internal uint column;
		internal uint endLine;
		internal uint endColumn;
		internal PdbSource sourceFile;
		internal PdbTokenLine/*?*/ nextLine;

		internal PdbTokenLine(uint token, uint file_id, uint line, uint column, uint endLine, uint endColumn)
		{
			this.token = token;
			this.file_id = file_id;
			this.line = line;
			this.column = column;
			this.endLine = endLine;
			this.endColumn = endColumn;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class PinnedType : TypeSpecification
	{

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsPinned
		{
			get { return true; }
		}

		public PinnedType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			this.etype = MD.ElementType.Pinned;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum PInvokeAttributes : ushort
	{
		NoMangle = 0x0001,  // PInvoke is to use the member name as specified

		// Character set
		CharSetMask = 0x0006,
		CharSetNotSpec = 0x0000,
		CharSetAnsi = 0x0002,
		CharSetUnicode = 0x0004,
		CharSetAuto = 0x0006,

		SupportsLastError = 0x0040, // Information about target function. Not relevant for fields

		// Calling convetion
		CallConvMask = 0x0700,
		CallConvWinapi = 0x0100,
		CallConvCdecl = 0x0200,
		CallConvStdCall = 0x0300,
		CallConvThiscall = 0x0400,
		CallConvFastcall = 0x0500,

		BestFitMask = 0x0030,
		BestFitEnabled = 0x0010,
		BestFitDisabled = 0x0020,

		ThrowOnUnmappableCharMask = 0x3000,
		ThrowOnUnmappableCharEnabled = 0x1000,
		ThrowOnUnmappableCharDisabled = 0x2000,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public sealed class PInvokeInfo
	{

		ushort attributes;
		string entry_point;
		ModuleReference module;

		public PInvokeAttributes Attributes
		{
			get { return (PInvokeAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public string EntryPoint
		{
			get { return entry_point; }
			set { entry_point = value; }
		}

		public ModuleReference Module
		{
			get { return module; }
			set { module = value; }
		}

		#region PInvokeAttributes

		public bool IsNoMangle
		{
			get { return attributes.GetAttributes((ushort)PInvokeAttributes.NoMangle); }
			set { attributes = attributes.SetAttributes((ushort)PInvokeAttributes.NoMangle, value); }
		}

		public bool IsCharSetNotSpec
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetNotSpec); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetNotSpec, value); }
		}

		public bool IsCharSetAnsi
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAnsi); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAnsi, value); }
		}

		public bool IsCharSetUnicode
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetUnicode); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetUnicode, value); }
		}

		public bool IsCharSetAuto
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAuto); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAuto, value); }
		}

		public bool SupportsLastError
		{
			get { return attributes.GetAttributes((ushort)PInvokeAttributes.SupportsLastError); }
			set { attributes = attributes.SetAttributes((ushort)PInvokeAttributes.SupportsLastError, value); }
		}

		public bool IsCallConvWinapi
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvWinapi); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvWinapi, value); }
		}

		public bool IsCallConvCdecl
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvCdecl); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvCdecl, value); }
		}

		public bool IsCallConvStdCall
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvStdCall); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvStdCall, value); }
		}

		public bool IsCallConvThiscall
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvThiscall); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvThiscall, value); }
		}

		public bool IsCallConvFastcall
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvFastcall); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvFastcall, value); }
		}

		public bool IsBestFitEnabled
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitEnabled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitEnabled, value); }
		}

		public bool IsBestFitDisabled
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitDisabled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitDisabled, value); }
		}

		public bool IsThrowOnUnmappableCharEnabled
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharEnabled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharEnabled, value); }
		}

		public bool IsThrowOnUnmappableCharDisabled
		{
			get { return attributes.GetMaskedAttributes((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharDisabled); }
			set { attributes = attributes.SetMaskedAttributes((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharDisabled, value); }
		}

		#endregion

		public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
		{
			this.attributes = (ushort)attributes;
			this.entry_point = entryPoint;
			this.module = module;
		}
	}
}


namespace MonoMod.Utils
{
	/// <summary>
	/// Generic platform enum.
	/// </summary>
	[Flags]
	public enum MonoPlatform : int
	{
		/// <summary>
		/// Bit applied to all OSes (Unknown, Windows, MacOS, ...). 
		/// </summary>
		OS = 1 << 0,

		/// <summary>
		/// On demand 64-bit platform bit.
		/// </summary>
		Bits64 = 1 << 1,

		/// <summary>
		/// Applied to all NT and NT-oid platforms (Windows).
		/// </summary>
		NT = 1 << 2,
		/// <summary>
		/// Applied to all Unix and Unix-oid platforms (macOS, Linux, ...).
		/// </summary>
		Unix = 1 << 3,

		/// <summary>
		/// On demand ARM platform bit.
		/// </summary>
		ARM = 1 << 16,

		/// <summary>
		/// On demand Wine bit. DON'T RELY ON THIS.
		/// </summary>
		Wine = 1 << 17,

		/// <summary>
		/// Unknown OS.
		/// </summary>
		Unknown = OS | (1 << 4),
		/// <summary>
		/// Windows, using the NT kernel.
		/// </summary>
		Windows = OS | NT | (1 << 5),
		/// <summary>
		/// macOS, using the Darwin kernel.
		/// </summary>
		MacOS = OS | Unix | (1 << 6),
		/// <summary>
		/// Linux.
		/// </summary>
		Linux = OS | Unix | (1 << 7),
		/// <summary>
		/// Android, using the Linux kernel.
		/// </summary>
		Android = Linux | (1 << 8),
		/// <summary>
		/// iOS, sharing components with macOS.
		/// </summary>
		iOS = MacOS | (1 << 9),
	}
}







namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static class PlatformHelper
	{

		private static void DeterminePlatform()
		{
			_current = MonoPlatform.Unknown;

#if NETSTANDARD
            // RuntimeInformation.IsOSPlatform is lying: https://github.com/dotnet/corefx/issues/3032
            // Determine the platform based on the path.
            string windir = Environment.GetEnvironmentVariable("windir");
            if (!string.IsNullOrEmpty(windir) && windir.Contains(@"\", StringComparison.Ordinal) && Directory.Exists(windir)) {
                _current = Platform.Windows;

            } else if (File.Exists("/proc/sys/kernel/ostype")) {
                string osType = File.ReadAllText("/proc/sys/kernel/ostype");
                if (osType.StartsWith("Linux", StringComparison.OrdinalIgnoreCase)) {
                    _current = Platform.Linux;
                } else {
                    _current = Platform.Unix;
                }

            } else if (File.Exists("/System/Library/CoreServices/SystemVersion.plist")) {
                _current = Platform.MacOS;
            }

#else
			// For old Mono, get from a private property to accurately get the platform.
			// static extern PlatformID Platform
			PropertyInfo p_Platform = typeof(Environment).GetProperty("Platform", BindingFlags.NonPublic | BindingFlags.Static);
			string platID;
			if (p_Platform != null)
			{
				platID = p_Platform.GetValue(null, new object[0]).ToString();
			}
			else
			{
				// For .NET and newer Mono, use the usual value.
				platID = Environment.OSVersion.Platform.ToString();
			}
			platID = platID.ToLower(CultureInfo.InvariantCulture);

			if (platID.Contains("win"))
			{
				_current = MonoPlatform.Windows;
			}
			else if (platID.Contains("mac") || platID.Contains("osx"))
			{
				_current = MonoPlatform.MacOS;
			}
			else if (platID.Contains("lin") || platID.Contains("unix"))
			{
				_current = MonoPlatform.Linux;
			}
#endif

			if (Is(MonoPlatform.Linux) &&
				Directory.Exists("/data") && File.Exists("/system/build.prop")
			)
			{
				_current = MonoPlatform.Android;

			}
			else if (Is(MonoPlatform.Unix) &&
			  Directory.Exists("/Applications") && Directory.Exists("/System") &&
			  Directory.Exists("/User") && !Directory.Exists("/Users")
		  )
			{
				_current = MonoPlatform.iOS;

			}
			else if (Is(MonoPlatform.Windows) &&
			  CheckWine()
		  )
			{
				// Sorry, Wine devs, but you might want to look at DetourRuntimeNETPlatform.
				_current |= MonoPlatform.Wine;
			}

			// Is64BitOperatingSystem has been added in .NET Framework 4.0
			MethodInfo m_get_Is64BitOperatingSystem = typeof(Environment).GetProperty("Is64BitOperatingSystem")?.GetGetMethod();
			if (m_get_Is64BitOperatingSystem != null)
				_current |= (((bool)m_get_Is64BitOperatingSystem.Invoke(null, new object[0])) ? MonoPlatform.Bits64 : 0);
			else
				_current |= (IntPtr.Size >= 8 ? MonoPlatform.Bits64 : 0);

#if NETSTANDARD
            // Detect ARM based on RuntimeInformation.
            if (RuntimeInformation.ProcessArchitecture.HasFlag(Architecture.Arm) ||
                RuntimeInformation.OSArchitecture.HasFlag(Architecture.Arm))
                _current |= Platform.ARM;
#else
			if ((Is(MonoPlatform.Unix) || Is(MonoPlatform.Unknown)) && Type.GetType("Mono.Runtime") != null)
			{
				/* I'd love to use RuntimeInformation, but it returns X64 up until...
                 * https://github.com/mono/mono/commit/396559769d0e4ca72837e44bcf837b7c91596414
                 * ... and that commit still hasn't reached Mono 5.16 on Debian, dated
                 * tarball Mon Nov 26 17:21:35 UTC 2018
                 * There's also the possibility to [DllImport("libc.so.6")]
                 * -ade
                 */
				try
				{
					string arch;
					using (Process uname = Process.Start(new ProcessStartInfo("uname", "-m")
					{
						UseShellExecute = false,
						RedirectStandardOutput = true
					}))
					{
						arch = uname.StandardOutput.ReadLine().Trim();
					}

					if (arch.StartsWith("aarch", StringComparison.Ordinal) || arch.StartsWith("arm", StringComparison.Ordinal))
						_current |= MonoPlatform.ARM;
				}
				catch (Exception)
				{
					// Starting a process can fail for various reasons. One of them being...
					/* System.MissingMethodException: Method 'MonoIO.CreatePipe' not found.
                     * at System.Diagnostics.Process.StartWithCreateProcess (System.Diagnostics.ProcessStartInfo startInfo) <0x414ceb20 + 0x0061f> in <filename unknown>:0 
                     */
				}

			}
			else
			{
				// Detect ARM based on PE info or uname.
				typeof(object).Module.GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine);
				if (machine == (ImageFileMachine)0x01C4 /* ARM, .NET Framework 4.5 */)
					_current |= MonoPlatform.ARM;
			}
#endif
		}

		private static MonoPlatform _current = MonoPlatform.Unknown;

		private static bool _currentLocked = false;

		public static MonoPlatform Current
		{
			get
			{
				if (!_currentLocked)
				{
					if (_current == MonoPlatform.Unknown)
					{
						DeterminePlatform();
					}

					_currentLocked = true;
				}

				return _current;
			}
			set
			{
				if (_currentLocked)
					throw new InvalidOperationException("Cannot set the value of PlatformHelper.Current once it has been accessed.");

				_current = value;
			}
		}


		private static string _librarySuffix;

		public static string LibrarySuffix
		{
			get
			{
				if (_librarySuffix == null)
				{
					_librarySuffix =
						Is(MonoPlatform.MacOS) ? "dylib" :
						Is(MonoPlatform.Unix) ? "so" :
						"dll";
				}

				return _librarySuffix;
			}
		}

		public static bool Is(MonoPlatform platform)
			=> (Current & platform) == platform;

		// Separated method so that this P/Invoke mess doesn't error out on non-Windows.
		private static bool CheckWine()
		{
			// wine_get_version can be missing because of course it can.
			// General purpose env var.
			string env = Environment.GetEnvironmentVariable("MONOMOD_WINE");
			if (env == "1")
				return true;
			if (env == "0")
				return false;

			// The "Dalamud" plugin loader for FFXIV uses Runtime, coreclr and wine. What a nice combo!
			// At least they went ahead and provide an environment variable for everyone to check.
			// See https://github.com/goatcorp/FFXIVQuickLauncher/blob/8685db4a0e8ec53235fb08cd88aded7c7061d9fb/src/XIVLauncher/Settings/EnvironmentSettings.cs
			env = Environment.GetEnvironmentVariable("XL_WINEONLINUX")?.ToLower(CultureInfo.InvariantCulture);
			if (env == "true")
				return true;
			if (env == "false")
				return false;

			IntPtr ntdll = GetModuleHandle("ntdll.dll");
			if (ntdll != IntPtr.Zero && GetProcAddress(ntdll, "wine_get_version") != IntPtr.Zero)
				return true;

			return false;
		}

		[DllImport("kernel32", SetLastError = true)]
		private static extern IntPtr GetModuleHandle(string lpModuleName);
		[DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class PointerType : TypeSpecification
	{

		public override string Name
		{
			get { return base.Name + "*"; }
		}

		public override string FullName
		{
			get { return base.FullName + "*"; }
		}

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsPointer
		{
			get { return true; }
		}

		public PointerType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			this.etype = MD.ElementType.Ptr;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//









namespace Mono.Cecil.Cil
{

	public sealed class PortablePdbReaderProvider : ISymbolReaderProvider
	{

		public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			var file = File.OpenRead(Mixin.GetPdbFileName(fileName));
			return GetSymbolReader(module, Disposable.Owned(file as Stream), file.Name);
		}

		public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);

			return GetSymbolReader(module, Disposable.NotOwned(symbolStream), symbolStream.GetFileName());
		}

		ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable<Stream> symbolStream, string fileName)
		{
			return new PortablePdbReader(ImageReader.ReadPortablePdb(symbolStream, fileName), module);
		}
	}

	public sealed class PortablePdbReader : ISymbolReader
	{

		readonly Image image;
		readonly ModuleDefinition module;
		readonly MetadataReader reader;
		readonly MetadataReader debug_reader;

		bool IsEmbedded { get { return reader.image == debug_reader.image; } }

		internal PortablePdbReader(Image image, ModuleDefinition module)
		{
			this.image = image;
			this.module = module;
			this.reader = module.reader;
			this.debug_reader = new MetadataReader(image, module, this.reader);
		}

		public ISymbolWriterProvider GetWriterProvider()
		{
			return new PortablePdbWriterProvider();
		}

		public bool ProcessDebugHeader(ImageDebugHeader header)
		{
			if (image == module.Image)
				return true;

			foreach (var entry in header.Entries)
			{
				if (!IsMatchingEntry(image.PdbHeap, entry))
					continue;

				ReadModule();
				return true;
			}

			return false;
		}

		static bool IsMatchingEntry(PdbHeap heap, ImageDebugHeaderEntry entry)
		{
			if (entry.Directory.Type != ImageDebugType.CodeView)
				return false;

			var data = entry.Data;

			if (data.Length < 24)
				return false;

			var magic = ReadInt32(data, 0);
			if (magic != 0x53445352)
				return false;

			var buffer = new byte[16];
			Buffer.BlockCopy(data, 4, buffer, 0, 16);

			var module_guid = new Guid(buffer);

			Buffer.BlockCopy(heap.Id, 0, buffer, 0, 16);

			var pdb_guid = new Guid(buffer);

			return module_guid == pdb_guid;
		}

		static int ReadInt32(byte[] bytes, int start)
		{
			return (bytes[start]
				| (bytes[start + 1] << 8)
				| (bytes[start + 2] << 16)
				| (bytes[start + 3] << 24));
		}

		void ReadModule()
		{
			module.custom_infos = debug_reader.GetCustomDebugInformation(module);
		}

		public MethodDebugInformation Read(MethodDefinition method)
		{
			var info = new MethodDebugInformation(method);
			ReadSequencePoints(info);
			ReadScope(info);
			ReadStateMachineKickOffMethod(info);
			ReadCustomDebugInformations(info);
			return info;
		}

		void ReadSequencePoints(MethodDebugInformation method_info)
		{
			method_info.sequence_points = debug_reader.ReadSequencePoints(method_info.method);
		}

		void ReadScope(MethodDebugInformation method_info)
		{
			method_info.scope = debug_reader.ReadScope(method_info.method);
		}

		void ReadStateMachineKickOffMethod(MethodDebugInformation method_info)
		{
			method_info.kickoff_method = debug_reader.ReadStateMachineKickoffMethod(method_info.method);
		}

		void ReadCustomDebugInformations(MethodDebugInformation info)
		{
			info.method.custom_infos = debug_reader.GetCustomDebugInformation(info.method);
		}

		public void Dispose()
		{
			if (IsEmbedded)
				return;

			image.Dispose();
		}
	}

	public sealed class EmbeddedPortablePdbReaderProvider : ISymbolReaderProvider
	{

		public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);

			var header = module.GetDebugHeader();
			var entry = header.GetEmbeddedPortablePdbEntry();
			if (entry == null)
				throw new InvalidOperationException();

			return new EmbeddedPortablePdbReader(
				(PortablePdbReader)new PortablePdbReaderProvider().GetSymbolReader(module, GetPortablePdbStream(entry)));
		}

		static Stream GetPortablePdbStream(ImageDebugHeaderEntry entry)
		{
			var compressed_stream = new MemoryStream(entry.Data);
			var reader = new BinaryStreamReader(compressed_stream);
			reader.ReadInt32(); // signature
			var length = reader.ReadInt32();
			var decompressed_stream = new MemoryStream(length);

			using (var deflate_stream = new DeflateStream(compressed_stream, CompressionMode.Decompress, leaveOpen: true))
				deflate_stream.CopyTo(decompressed_stream);

			return decompressed_stream;
		}

		public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException();
		}
	}

	public sealed class EmbeddedPortablePdbReader : ISymbolReader
	{
		private readonly PortablePdbReader reader;

		internal EmbeddedPortablePdbReader(PortablePdbReader reader)
		{
			if (reader == null)
				throw new ArgumentNullException();

			this.reader = reader;
		}

		public ISymbolWriterProvider GetWriterProvider()
		{
			return new EmbeddedPortablePdbWriterProvider();
		}

		public bool ProcessDebugHeader(ImageDebugHeader header)
		{
			return reader.ProcessDebugHeader(header);
		}

		public MethodDebugInformation Read(MethodDefinition method)
		{
			return reader.Read(method);
		}

		public void Dispose()
		{
			reader.Dispose();
		}
	}

	public sealed class PortablePdbWriterProvider : ISymbolWriterProvider
	{
		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			var file = File.OpenWrite(Mixin.GetPdbFileName(fileName));
			return GetSymbolWriter(module, Disposable.Owned(file as Stream));
		}

		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule(module);
			Mixin.CheckStream(symbolStream);

			return GetSymbolWriter(module, Disposable.NotOwned(symbolStream));
		}

		ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable<Stream> stream)
		{
			var metadata = new MetadataBuilder(module, this);
			var writer = ImageWriter.CreateDebugWriter(module, metadata, stream);

			return new PortablePdbWriter(metadata, module, writer);
		}
	}

	public sealed class PortablePdbWriter : ISymbolWriter
	{

		readonly MetadataBuilder pdb_metadata;
		readonly ModuleDefinition module;
		readonly ImageWriter writer;

		MetadataBuilder module_metadata;

		bool IsEmbedded { get { return writer == null; } }

		internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module)
		{
			this.pdb_metadata = pdb_metadata;
			this.module = module;

			this.module_metadata = module.metadata_builder;

			if (module_metadata != pdb_metadata)
				this.pdb_metadata.metadata_builder = this.module_metadata;

			pdb_metadata.AddCustomDebugInformations(module);
		}

		internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer)
			: this(pdb_metadata, module)
		{
			this.writer = writer;
		}

		public ISymbolReaderProvider GetReaderProvider()
		{
			return new PortablePdbReaderProvider();
		}

		public ImageDebugHeader GetDebugHeader()
		{
			if (IsEmbedded)
				return new ImageDebugHeader();

			var directory = new ImageDebugDirectory()
			{
				MajorVersion = 256,
				MinorVersion = 20557,
				Type = ImageDebugType.CodeView,
				TimeDateStamp = (int)module.timestamp,
			};

			var buffer = new ByteBuffer();
			// RSDS
			buffer.WriteUInt32(0x53445352);
			// Module ID
			buffer.WriteBytes(module.Mvid.ToByteArray());
			// PDB Age
			buffer.WriteUInt32(1);
			// PDB Path
			var fileName = writer.BaseStream.GetFileName();
			if (string.IsNullOrEmpty(fileName))
			{
				fileName = module.Assembly.Name.Name + ".pdb";
			}
			buffer.WriteBytes(System.Text.Encoding.UTF8.GetBytes(fileName));
			buffer.WriteByte(0);

			var data = new byte[buffer.length];
			Buffer.BlockCopy(buffer.buffer, 0, data, 0, buffer.length);
			directory.SizeOfData = data.Length;

			return new ImageDebugHeader(new ImageDebugHeaderEntry(directory, data));
		}

		public void Write(MethodDebugInformation info)
		{
			CheckMethodDebugInformationTable();

			pdb_metadata.AddMethodDebugInformation(info);
		}

		void CheckMethodDebugInformationTable()
		{
			var mdi = pdb_metadata.table_heap.GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
			if (mdi.length > 0)
				return;

			// The MethodDebugInformation table has the same length as the Method table
			mdi.rows = new Row<uint, uint>[module_metadata.method_rid - 1];
			mdi.length = mdi.rows.Length;
		}

		public void Dispose()
		{
			if (IsEmbedded)
				return;

			WritePdbFile();
		}

		void WritePdbFile()
		{
			WritePdbHeap();

			WriteTableHeap();

			writer.BuildMetadataTextMap();
			writer.WriteMetadataHeader();
			writer.WriteMetadata();

			writer.Flush();
			writer.stream.Dispose();
		}

		void WritePdbHeap()
		{
			var pdb_heap = pdb_metadata.pdb_heap;

			pdb_heap.WriteBytes(module.Mvid.ToByteArray());
			pdb_heap.WriteUInt32(module_metadata.timestamp);

			pdb_heap.WriteUInt32(module_metadata.entry_point.ToUInt32());

			var table_heap = module_metadata.table_heap;
			var tables = table_heap.tables;

			ulong valid = 0;
			for (int i = 0; i < tables.Length; i++)
			{
				if (tables[i] == null || tables[i].Length == 0)
					continue;

				valid |= (1UL << i);
			}

			pdb_heap.WriteUInt64(valid);

			for (int i = 0; i < tables.Length; i++)
			{
				if (tables[i] == null || tables[i].Length == 0)
					continue;

				pdb_heap.WriteUInt32((uint)tables[i].Length);
			}
		}

		void WriteTableHeap()
		{
			pdb_metadata.table_heap.string_offsets = pdb_metadata.string_heap.WriteStrings();
			pdb_metadata.table_heap.ComputeTableInformations();
			pdb_metadata.table_heap.WriteTableHeap();
		}
	}

	public sealed class EmbeddedPortablePdbWriterProvider : ISymbolWriterProvider
	{

		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule(module);
			Mixin.CheckFileName(fileName);

			var stream = new MemoryStream();
			var pdb_writer = (PortablePdbWriter)new PortablePdbWriterProvider().GetSymbolWriter(module, stream);
			return new EmbeddedPortablePdbWriter(stream, pdb_writer);
		}

		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException();
		}
	}

	public sealed class EmbeddedPortablePdbWriter : ISymbolWriter
	{

		readonly Stream stream;
		readonly PortablePdbWriter writer;

		internal EmbeddedPortablePdbWriter(Stream stream, PortablePdbWriter writer)
		{
			this.stream = stream;
			this.writer = writer;
		}

		public ISymbolReaderProvider GetReaderProvider()
		{
			return new EmbeddedPortablePdbReaderProvider();
		}

		public ImageDebugHeader GetDebugHeader()
		{
			writer.Dispose();

			var directory = new ImageDebugDirectory
			{
				Type = ImageDebugType.EmbeddedPortablePdb,
				MajorVersion = 0x0100,
				MinorVersion = 0x0100,
			};

			var data = new MemoryStream();

			var w = new BinaryStreamWriter(data);
			w.WriteByte(0x4d);
			w.WriteByte(0x50);
			w.WriteByte(0x44);
			w.WriteByte(0x42);

			w.WriteInt32((int)stream.Length);

			stream.Position = 0;

			using (var compress_stream = new DeflateStream(data, CompressionMode.Compress, leaveOpen: true))
				stream.CopyTo(compress_stream);

			directory.SizeOfData = (int)data.Length;

			return new ImageDebugHeader(new[] {
				writer.GetDebugHeader ().Entries [0],
				new ImageDebugHeaderEntry (directory, data.ToArray ())
			});
		}

		public void Write(MethodDebugInformation info)
		{
			writer.Write(info);
		}

		public void Dispose()
		{
		}
	}

	static class PdbGuidMapping
	{

		static readonly Dictionary<Guid, DocumentLanguage> guid_language = new Dictionary<Guid, DocumentLanguage>();
		static readonly Dictionary<DocumentLanguage, Guid> language_guid = new Dictionary<DocumentLanguage, Guid>();

		static PdbGuidMapping()
		{
			AddMapping(DocumentLanguage.C, new Guid("63a08714-fc37-11d2-904c-00c04fa302a1"));
			AddMapping(DocumentLanguage.Cpp, new Guid("3a12d0b7-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping(DocumentLanguage.CSharp, new Guid("3f5162f8-07c6-11d3-9053-00c04fa302a1"));
			AddMapping(DocumentLanguage.Basic, new Guid("3a12d0b8-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping(DocumentLanguage.Java, new Guid("3a12d0b4-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping(DocumentLanguage.Cobol, new Guid("af046cd1-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping(DocumentLanguage.Pascal, new Guid("af046cd2-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping(DocumentLanguage.Cil, new Guid("af046cd3-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping(DocumentLanguage.JScript, new Guid("3a12d0b6-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping(DocumentLanguage.Smc, new Guid("0d9b9f7b-6611-11d3-bd2a-0000f80849bd"));
			AddMapping(DocumentLanguage.MCpp, new Guid("4b35fde8-07c6-11d3-9053-00c04fa302a1"));
			AddMapping(DocumentLanguage.FSharp, new Guid("ab4f38c9-b6e6-43ba-be3b-58080b2ccce3"));
		}

		static void AddMapping(DocumentLanguage language, Guid guid)
		{
			guid_language.Add(guid, language);
			language_guid.Add(language, guid);
		}

		static readonly Guid type_text = new Guid("5a869d0b-6611-11d3-bd2a-0000f80849bd");

		public static DocumentType ToType(this Guid guid)
		{
			if (guid == type_text)
				return DocumentType.Text;

			return DocumentType.Other;
		}

		public static Guid ToGuid(this DocumentType type)
		{
			if (type == DocumentType.Text)
				return type_text;

			return new Guid();
		}

		static readonly Guid hash_md5 = new Guid("406ea660-64cf-4c82-b6f0-42d48172a799");
		static readonly Guid hash_sha1 = new Guid("ff1816ec-aa5e-4d10-87f7-6f4963833460");
		static readonly Guid hash_sha256 = new Guid("8829d00f-11b8-4213-878b-770e8597ac16");

		public static DocumentHashAlgorithm ToHashAlgorithm(this Guid guid)
		{
			if (guid == hash_md5)
				return DocumentHashAlgorithm.MD5;

			if (guid == hash_sha1)
				return DocumentHashAlgorithm.SHA1;

			if (guid == hash_sha256)
				return DocumentHashAlgorithm.SHA256;

			return DocumentHashAlgorithm.None;
		}

		public static Guid ToGuid(this DocumentHashAlgorithm hash_algo)
		{
			if (hash_algo == DocumentHashAlgorithm.MD5)
				return hash_md5;

			if (hash_algo == DocumentHashAlgorithm.SHA1)
				return hash_sha1;

			if (hash_algo == DocumentHashAlgorithm.SHA256)
				return hash_sha256;

			return new Guid();
		}

		public static DocumentLanguage ToLanguage(this Guid guid)
		{
			DocumentLanguage language;
			if (!guid_language.TryGetValue(guid, out language))
				return DocumentLanguage.Other;

			return language;
		}

		public static Guid ToGuid(this DocumentLanguage language)
		{
			Guid guid;
			if (!language_guid.TryGetValue(language, out guid))
				return new Guid();

			return guid;
		}

		static readonly Guid vendor_ms = new Guid("994b45c4-e6e9-11d2-903f-00c04fa302a1");

		public static DocumentLanguageVendor ToVendor(this Guid guid)
		{
			if (guid == vendor_ms)
				return DocumentLanguageVendor.Microsoft;

			return DocumentLanguageVendor.Other;
		}

		public static Guid ToGuid(this DocumentLanguageVendor vendor)
		{
			if (vendor == DocumentLanguageVendor.Microsoft)
				return vendor_ms;

			return new Guid();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum PropertyAttributes : ushort
	{
		None = 0x0000,
		SpecialName = 0x0200,   // Property is special
		RTSpecialName = 0x0400, // Runtime(metadata internal APIs) should check name encoding
		HasDefault = 0x1000,    // Property has default
		Unused = 0xe9ff  // Reserved: shall be zero in a conforming implementation
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class PropertyDefinition : PropertyReference, IMemberDefinition, IConstantProvider
	{

		bool? has_this;
		ushort attributes;

		Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition get_method;
		internal MethodDefinition set_method;
		internal Collection<MethodDefinition> other_methods;

		object constant = Mixin.NotResolved;

		public PropertyAttributes Attributes
		{
			get { return (PropertyAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public bool HasThis
		{
			get
			{
				if (has_this.HasValue)
					return has_this.Value;

				if (GetMethod != null)
					return get_method.HasThis;

				if (SetMethod != null)
					return set_method.HasThis;

				return false;
			}
			set { has_this = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		public MethodDefinition GetMethod
		{
			get
			{
				if (get_method != null)
					return get_method;

				InitializeMethods();
				return get_method;
			}
			set { get_method = value; }
		}

		public MethodDefinition SetMethod
		{
			get
			{
				if (set_method != null)
					return set_method;

				InitializeMethods();
				return set_method;
			}
			set { set_method = value; }
		}

		public bool HasOtherMethods
		{
			get
			{
				if (other_methods != null)
					return other_methods.Count > 0;

				InitializeMethods();
				return !other_methods.IsNullOrEmpty();
			}
		}

		public Collection<MethodDefinition> OtherMethods
		{
			get
			{
				if (other_methods != null)
					return other_methods;

				InitializeMethods();

				if (other_methods != null)
					return other_methods;

				Interlocked.CompareExchange(ref other_methods, new Collection<MethodDefinition>(), null);
				return other_methods;
			}
		}

		public bool HasParameters
		{
			get
			{
				InitializeMethods();

				if (get_method != null)
					return get_method.HasParameters;

				if (set_method != null)
					return set_method.HasParameters && set_method.Parameters.Count > 1;

				return false;
			}
		}

		public override Collection<ParameterDefinition> Parameters
		{
			get
			{
				InitializeMethods();

				if (get_method != null)
					return MirrorParameters(get_method, 0);

				if (set_method != null)
					return MirrorParameters(set_method, 1);

				return new Collection<ParameterDefinition>();
			}
		}

		static Collection<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
		{
			var parameters = new Collection<ParameterDefinition>();
			if (!method.HasParameters)
				return parameters;

			var original_parameters = method.Parameters;
			var end = original_parameters.Count - bound;

			for (int i = 0; i < end; i++)
				parameters.Add(original_parameters[i]);

			return parameters;
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant
		{
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		#region PropertyAttributes

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((ushort)PropertyAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((ushort)PropertyAttributes.SpecialName, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((ushort)PropertyAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((ushort)PropertyAttributes.RTSpecialName, value); }
		}

		public bool HasDefault
		{
			get { return attributes.GetAttributes((ushort)PropertyAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes((ushort)PropertyAttributes.HasDefault, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType
		{
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public override bool IsDefinition
		{
			get { return true; }
		}

		public override string FullName
		{
			get
			{
				var builder = new StringBuilder();
				builder.Append(PropertyType.ToString());
				builder.Append(' ');
				builder.Append(MemberFullName());
				builder.Append('(');
				if (HasParameters)
				{
					var parameters = Parameters;
					for (int i = 0; i < parameters.Count; i++)
					{
						if (i > 0)
							builder.Append(',');
						builder.Append(parameters[i].ParameterType.FullName);
					}
				}
				builder.Append(')');
				return builder.ToString();
			}
		}

		public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType)
			: base(name, propertyType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken(TokenType.Property);
		}

		void InitializeMethods()
		{
			var module = this.Module;
			if (module == null)
				return;

			lock (module.SyncRoot)
			{
				if (get_method != null || set_method != null)
					return;

				if (!module.HasImage())
					return;

				module.Read(this, (property, reader) => reader.ReadMethods(property));
			}
		}

		public override PropertyDefinition Resolve()
		{
			return this;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public abstract class PropertyReference : MemberReference
	{

		TypeReference property_type;

		public TypeReference PropertyType
		{
			get { return property_type; }
			set { property_type = value; }
		}

		public abstract Collection<ParameterDefinition> Parameters
		{
			get;
		}

		internal PropertyReference(string name, TypeReference propertyType)
			: base(name)
		{
			Mixin.CheckType(propertyType, Mixin.Argument.propertyType);

			property_type = propertyType;
		}

		protected override IMemberDefinition ResolveDefinition()
		{
			return this.Resolve();
		}

		public new abstract PropertyDefinition Resolve();
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Collections.Generic
{

	public sealed class ReadOnlyCollection<T> : Collection<T>, ICollection<T>, IList
	{

		static ReadOnlyCollection<T> empty;

		public static ReadOnlyCollection<T> Empty
		{
			get
			{
				if (empty != null)
					return empty;

				Interlocked.CompareExchange(ref empty, new ReadOnlyCollection<T>(), null);
				return empty;
			}
		}

		bool ICollection<T>.IsReadOnly
		{
			get { return true; }
		}

		bool IList.IsFixedSize
		{
			get { return true; }
		}

		bool IList.IsReadOnly
		{
			get { return true; }
		}

		ReadOnlyCollection()
		{
		}

		public ReadOnlyCollection(T[] array)
		{
			if (array == null)
				throw new ArgumentNullException();

			Initialize(array, array.Length);
		}

		public ReadOnlyCollection(Collection<T> collection)
		{
			if (collection == null)
				throw new ArgumentNullException();

			Initialize(collection.items, collection.size);
		}

		void Initialize(T[] items, int size)
		{
			this.items = new T[size];
			Array.Copy(items, 0, this.items, 0, size);
			this.size = size;
		}

		internal override void Grow(int desired)
		{
			throw new InvalidOperationException();
		}

		protected override void OnAdd(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnClear()
		{
			throw new InvalidOperationException();
		}

		protected override void OnInsert(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnRemove(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnSet(T item, int index)
		{
			throw new InvalidOperationException();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class ByReferenceType : TypeSpecification
	{

		public override string Name
		{
			get { return base.Name + "&"; }
		}

		public override string FullName
		{
			get { return base.FullName + "&"; }
		}

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsByReference
		{
			get { return true; }
		}

		public ByReferenceType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			this.etype = MD.ElementType.ByRef;
		}
	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class ReflectionHelper
	{

		private static readonly object[] _NoArgs = new object[0];

		internal static readonly Dictionary<string, WeakReference/*<Assembly>*/> AssemblyCache = new Dictionary<string, WeakReference>();
		internal static readonly Dictionary<string, WeakReference/*<Assembly>*/[]> AssembliesCache = new Dictionary<string, WeakReference[]>();
		internal static readonly Dictionary<string, WeakReference/*<MemberInfo>*/> ResolveReflectionCache = new Dictionary<string, WeakReference>();

		public readonly static byte[] AssemblyHashPrefix = new UTF8Encoding(false).GetBytes("MonoModRefl").Concat(new byte[1]).ToArray();
		public readonly static string AssemblyHashNameTag = "@#";

		private const BindingFlags _BindingFlagsAll = (BindingFlags)(-1);

		private static MemberInfo _Cache(string cacheKey, MemberInfo value)
		{
			if (cacheKey != null && value == null)
			{
				MMDbgLog.Log($"ResolveRefl failure: {cacheKey}");
			}
			if (cacheKey != null && value != null)
			{
				lock (ResolveReflectionCache)
				{
					ResolveReflectionCache[cacheKey] = new WeakReference(value);
				}
			}
			return value;
		}

		public static Assembly Load(ModuleDefinition module)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				module.Write(stream);
				stream.Seek(0, SeekOrigin.Begin);
				return Load(stream);
			}
		}

		public static Assembly Load(Stream stream)
		{
			Assembly asm;

			if (stream is MemoryStream ms)
			{
				asm = Assembly.Load(ms.GetBuffer());
			}
			else
			{
				using (MemoryStream copy = new MemoryStream())
				{

#if NETFRAMEWORK
                    byte[] buffer = new byte[4096];
                    int read;
                    while (0 < (read = stream.Read(buffer, 0, buffer.Length))) {
                        copy.Write(buffer, 0, read);
                    }
#else
					stream.CopyTo(copy);
#endif

					copy.Seek(0, SeekOrigin.Begin);
					asm = Assembly.Load(copy.GetBuffer());
				}
			}

			AppDomain.CurrentDomain.AssemblyResolve +=
				(s, e) => e.Name == asm.FullName ? asm : null;

			return asm;
		}

		public static Type GetType(string name)
		{
			if (string.IsNullOrEmpty(name))
				return null;

			Type type = Type.GetType(name);
			if (type != null)
				return type;

			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				type = asm.GetType(name);
				if (type != null)
					return type;
			}

			return null;
		}

		public static void ApplyRuntimeHash(this AssemblyNameReference asmRef, Assembly asm)
		{
			// Mono.Cecil ignores the hash for the most part, allowing us to store whatever we want in it.
			byte[] hash = new byte[AssemblyHashPrefix.Length + 4];
			Array.Copy(AssemblyHashPrefix, 0, hash, 0, AssemblyHashPrefix.Length);
			Array.Copy(BitConverter.GetBytes(asm.GetHashCode()), 0, hash, AssemblyHashPrefix.Length, 4);
			asmRef.HashAlgorithm = unchecked((AssemblyHashAlgorithm)(-1));
			asmRef.Hash = hash;
		}

		public static string GetRuntimeHashedFullName(this Assembly asm)
		{
			return $"{asm.FullName}{AssemblyHashNameTag}{asm.GetHashCode()}";
		}

		public static string GetRuntimeHashedFullName(this AssemblyNameReference asm)
		{
			if (asm.HashAlgorithm != unchecked((AssemblyHashAlgorithm)(-1)))
				return asm.FullName;

			byte[] hash = asm.Hash;
			if (hash.Length != AssemblyHashPrefix.Length + 4)
				return asm.FullName;

			for (int i = 0; i < AssemblyHashPrefix.Length; i++)
				if (hash[i] != AssemblyHashPrefix[i])
					return asm.FullName;

			return $"{asm.FullName}{AssemblyHashNameTag}{BitConverter.ToInt32(hash, AssemblyHashPrefix.Length)}";
		}

		public static Type ResolveReflection(this TypeReference mref)
			=> _ResolveReflection(mref, null) as Type;
		public static MethodBase ResolveReflection(this MethodReference mref)
			=> _ResolveReflection(mref, null) as MethodBase;
		public static FieldInfo ResolveReflection(this FieldReference mref)
			=> _ResolveReflection(mref, null) as FieldInfo;
		public static PropertyInfo ResolveReflection(this PropertyReference mref)
			=> _ResolveReflection(mref, null) as PropertyInfo;
		public static EventInfo ResolveReflection(this EventReference mref)
			=> _ResolveReflection(mref, null) as EventInfo;

		public static MemberInfo ResolveReflection(this MemberReference mref)
			=> _ResolveReflection(mref, null);

		private static MemberInfo _ResolveReflection(MemberReference mref, Module[] modules)
		{
			if (mref == null)
				return null;

			if (mref is DynamicMethodReference dmref)
				return dmref.DynamicMethod;

			string cacheKey = (mref as MethodReference)?.GetID() ?? mref.FullName;

			/* Even though member references are not supposed to exist more
             * than once, some environments (f.e. tModLoader) reload updated
             * versions of assemblies with differing assembly names.
             * 
             * Adding the assembly name should take care of preventing any further
             * "accidental" collisions that would not occur "normally".
             * 
             * Ideally the mref hash code could be part of the cache key,
             * but that part changes with every new Cecil reference context, if not
             * even more often than that.
             */

			TypeReference tscope =
				mref.DeclaringType ??
				mref as TypeReference ??
				null;

			string asmName;
			string moduleName;

			switch (tscope?.Scope)
			{
				case AssemblyNameReference asmNameRef:
					asmName = asmNameRef.GetRuntimeHashedFullName();
					moduleName = null;
					break;

				case ModuleDefinition moduleDef:
					asmName = moduleDef.Assembly.Name.GetRuntimeHashedFullName();
					moduleName = moduleDef.Name;
					break;

				case ModuleReference moduleRef:
					// TODO: Is this correct? It's what cecil itself is doing...
					asmName = tscope.Module.Assembly.Name.GetRuntimeHashedFullName();
					moduleName = tscope.Module.Name;
					break;

				case null:
				default:
					asmName = null;
					moduleName = null;
					break;
			}

			cacheKey = $"{cacheKey} | {asmName ?? "NOASSEMBLY"}, {moduleName ?? "NOMODULE"}";

			lock (ResolveReflectionCache)
			{
				if (ResolveReflectionCache.TryGetValue(cacheKey, out WeakReference cachedRef) &&
					cachedRef != null && cachedRef.SafeGetTarget() is MemberInfo cached)
					return cached;
			}

			Type type;

			// Special cases.
			if (mref is GenericParameter genParam)
			{
				// TODO: Handle GenericParameter in ResolveReflection.
				throw new NotSupportedException("ResolveReflection on GenericParameter currently not supported");
			}

			if (mref is MethodReference method && mref.DeclaringType is ArrayType)
			{
				// ArrayType holds special methods.
				type = _ResolveReflection(mref.DeclaringType, modules) as Type;
				// ... but all of the methods have the same MetadataToken. We couldn't compare it anyway.

				string methodID = method.GetID(withType: false);
				MethodBase found =
					type.GetMethods(_BindingFlagsAll).Cast<MethodBase>()
					.Concat(type.GetConstructors(_BindingFlagsAll))
					.FirstOrDefault(m => m.GetID(withType: false) == methodID);
				if (found != null)
					return _Cache(cacheKey, found);
			}


			// Typeless references aren't supported.
			if (tscope == null)
				throw new ArgumentException("MemberReference hasn't got a DeclaringType / isn't a TypeReference in itself");
			if (asmName == null && moduleName == null)
				throw new NotSupportedException($"Unsupported scope type {tscope.Scope.GetType().FullName}");

			bool tryAssemblyCache = true;
			bool refetchingModules = false;
			bool nullifyModules = false;

			goto FetchModules;

		RefetchModules:
			refetchingModules = true;

		FetchModules:

			if (nullifyModules)
				modules = null;
			nullifyModules = true;

			if (modules == null)
			{
				Assembly[] asms = null;

				if (tryAssemblyCache && refetchingModules)
				{
					refetchingModules = false;
					tryAssemblyCache = false;
				}

				if (tryAssemblyCache)
					lock (AssemblyCache)
						if (AssemblyCache.TryGetValue(asmName, out WeakReference asmRef) &&
							asmRef.SafeGetTarget() is Assembly asm)
							asms = new Assembly[] { asm };

				if (asms == null)
				{
					if (!refetchingModules)
						lock (AssembliesCache)
							if (AssembliesCache.TryGetValue(asmName, out WeakReference[] asmRefs))
								asms = asmRefs
									.Select(asmRef => asmRef.SafeGetTarget() as Assembly)
									.Where(asm => asm != null)
									.ToArray();
				}

				if (asms == null)
				{
					/* Assembly load contexts are pain.
                     * Let's try things in the following order:
                     * - If a possible embedded hash code exists, check by hash code.
                     * - Check by full name.
                     * - Check by short name.
                     * - Try to load the assembly.
                     * - Give up.
                     *
                     * The hash code could be extracted from the cecil assembly name reference's Hash property,
                     * but maybe it'll be necessary to be passed via the name in the future once ^ gets used by Cecil.
                     * In addition to that, the hash must become part of the cache key string anyway.
                     * This can be microoptimized when necessary.
                     * - ade
                     */

					int split = asmName.IndexOf(AssemblyHashNameTag, StringComparison.Ordinal);
					if (split != -1 && int.TryParse(asmName.Substring(split + 2), out int hash))
					{
						asms = AppDomain.CurrentDomain.GetAssemblies().Where(other => other.GetHashCode() == hash).ToArray();
						if (asms.Length == 0)
							asms = null;
						asmName = asmName.Substring(0, split);
					}

					if (asms == null)
					{
						asms = AppDomain.CurrentDomain.GetAssemblies().Where(other => other.GetName().FullName == asmName).ToArray();
						if (asms.Length == 0)
							asms = AppDomain.CurrentDomain.GetAssemblies().Where(other => other.GetName().Name == asmName).ToArray();

						if (asms.Length == 0 && Assembly.Load(new AssemblyName(asmName)) is Assembly loaded)
							asms = new Assembly[] { loaded };
					}

					if (asms.Length != 0)
						lock (AssembliesCache)
							AssembliesCache[asmName] = asms.Select(asm => new WeakReference(asm)).ToArray();
				}

				modules =
					(string.IsNullOrEmpty(moduleName) ?
						asms.SelectMany(asm => asm.GetModules()) :
						asms.Select(asm => asm.GetModule(moduleName))
					).Where(mod => mod != null).ToArray();

				if (modules.Length == 0)
					throw new Exception($"Cannot resolve assembly / module {asmName} / {moduleName}");
			}

			if (mref is TypeReference tref)
			{
				if (tref.FullName == "<Module>")
					throw new ArgumentException("Type <Module> cannot be resolved to a runtime reflection type");

				if (mref is TypeSpecification ts)
				{
					type = _ResolveReflection(ts.ElementType, null) as Type;
					if (type == null)
						return null;

					if (ts.IsByReference)
						return _Cache(cacheKey, type.MakeByRefType());

					if (ts.IsPointer)
						return _Cache(cacheKey, type.MakePointerType());

					if (ts.IsArray)
						return _Cache(cacheKey, (ts as ArrayType).IsVector ? type.MakeArrayType() : type.MakeArrayType((ts as ArrayType).Dimensions.Count));

					if (ts.IsGenericInstance)
						return _Cache(cacheKey, type.MakeGenericType((ts as GenericInstanceType).GenericArguments.Select(arg => _ResolveReflection(arg, null) as Type).ToArray()));

				}
				else
				{
					type = modules
						.Select(module => module.GetType(mref.FullName.Replace("/", "+", StringComparison.Ordinal), false, false))
						.FirstOrDefault(m => m != null);
					if (type == null)
						type = modules
							.Select(module => module.GetTypes().FirstOrDefault(m => mref.Is(m)))
							.FirstOrDefault(m => m != null);
					if (type == null && !refetchingModules)
						goto RefetchModules;
				}

				return _Cache(cacheKey, type);
			}

			bool typeless = mref.DeclaringType.FullName == "<Module>";

			MemberInfo member;

			if (mref is GenericInstanceMethod mrefGenMethod)
			{
				member = _ResolveReflection(mrefGenMethod.ElementMethod, modules);
				member = (member as MethodInfo)?.MakeGenericMethod(mrefGenMethod.GenericArguments.Select(arg => _ResolveReflection(arg, null) as Type).ToArray());

			}
			else if (typeless)
			{
				if (mref is MethodReference)
					member = modules
						.Select(module => module.GetMethods(_BindingFlagsAll).FirstOrDefault(m => mref.Is(m)))
						.FirstOrDefault(m => m != null);
				else if (mref is FieldReference)
					member = modules
						.Select(module => module.GetFields(_BindingFlagsAll).FirstOrDefault(m => mref.Is(m)))
						.FirstOrDefault(m => m != null);
				else
					throw new NotSupportedException($"Unsupported <Module> member type {mref.GetType().FullName}");

			}
			else
			{
				Type declType = _ResolveReflection(mref.DeclaringType, modules) as Type;

				if (mref is MethodReference)
					member = declType
						.GetMethods(_BindingFlagsAll).Cast<MethodBase>()
						.Concat(declType.GetConstructors(_BindingFlagsAll))
						.FirstOrDefault(m => mref.Is(m));
				else if (mref is FieldReference)
					member = declType
						.GetFields(_BindingFlagsAll)
						.FirstOrDefault(m => mref.Is(m));
				else
					member = declType
						.GetMembers(_BindingFlagsAll)
						.FirstOrDefault(m => mref.Is(m));
			}

			if (member == null && !refetchingModules)
				goto RefetchModules;

			return _Cache(cacheKey, member);
		}

		public static SignatureHelper ResolveReflection(this Mono.Cecil.CallSite csite, Module context)
			=> ResolveReflectionSignature(csite, context);
		public static SignatureHelper ResolveReflectionSignature(this IMethodSignature csite, Module context)
		{
			SignatureHelper shelper;
			switch (csite.CallingConvention)
			{
#if !NETSTANDARD
				case MethodCallingConvention.C:
					shelper = SignatureHelper.GetMethodSigHelper(context, CallingConvention.Cdecl, csite.ReturnType.ResolveReflection());
					break;

				case MethodCallingConvention.StdCall:
					shelper = SignatureHelper.GetMethodSigHelper(context, CallingConvention.StdCall, csite.ReturnType.ResolveReflection());
					break;

				case MethodCallingConvention.ThisCall:
					shelper = SignatureHelper.GetMethodSigHelper(context, CallingConvention.ThisCall, csite.ReturnType.ResolveReflection());
					break;

				case MethodCallingConvention.FastCall:
					shelper = SignatureHelper.GetMethodSigHelper(context, CallingConvention.FastCall, csite.ReturnType.ResolveReflection());
					break;

				case MethodCallingConvention.VarArg:
					shelper = SignatureHelper.GetMethodSigHelper(context, CallingConventions.VarArgs, csite.ReturnType.ResolveReflection());
					break;

#else
                case MethodCallingConvention.C:
                case MethodCallingConvention.StdCall:
                case MethodCallingConvention.ThisCall:
                case MethodCallingConvention.FastCall:
                case MethodCallingConvention.VarArg:
                    throw new NotSupportedException("Unmanaged calling conventions for callsites not supported on .NET Standard");

#endif

				default:
					if (csite.ExplicitThis)
					{
						shelper = SignatureHelper.GetMethodSigHelper(context, CallingConventions.ExplicitThis, csite.ReturnType.ResolveReflection());
					}
					else
					{
						shelper = SignatureHelper.GetMethodSigHelper(context, CallingConventions.Standard, csite.ReturnType.ResolveReflection());
					}
					break;
			}

			if (context != null)
			{
				List<Type> modReq = new List<Type>();
				List<Type> modOpt = new List<Type>();

				foreach (ParameterDefinition param in csite.Parameters)
				{
					if (param.ParameterType.IsSentinel)
						shelper.AddSentinel();

					if (param.ParameterType.IsPinned)
					{
						shelper.AddArgument(param.ParameterType.ResolveReflection(), true);
						continue;
					}

					modOpt.Clear();
					modReq.Clear();

					for (
						TypeReference paramTypeRef = param.ParameterType;
						paramTypeRef is TypeSpecification paramTypeSpec;
						paramTypeRef = paramTypeSpec.ElementType
					)
					{
						switch (paramTypeRef)
						{
							case RequiredModifierType paramTypeModReq:
								modReq.Add(paramTypeModReq.ModifierType.ResolveReflection());
								break;

							case OptionalModifierType paramTypeOptReq:
								modOpt.Add(paramTypeOptReq.ModifierType.ResolveReflection());
								break;
						}
					}

					shelper.AddArgument(param.ParameterType.ResolveReflection(), modReq.ToArray(), modOpt.ToArray());
				}

			}
			else
			{
				foreach (ParameterDefinition param in csite.Parameters)
				{
					shelper.AddArgument(param.ParameterType.ResolveReflection());
				}
			}

			return shelper;
		}

	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class ReflectionHelper
	{

		// .NET Framework can break member ordering if using Module.Resolve* on certain members.

		private static readonly object[] _CacheGetterArgs = { /* MemberListType.All */ 0, /* name apparently always null? */ null };

		private static Type t_RuntimeType =
			typeof(Type).Assembly
			.GetType("System.RuntimeType");

		private static PropertyInfo p_RuntimeType_Cache =
			typeof(Type).Assembly
			.GetType("System.RuntimeType")
			?.GetProperty("Cache", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

		private static MethodInfo m_RuntimeTypeCache_GetFieldList =
			typeof(Type).Assembly
			.GetType("System.RuntimeType+RuntimeTypeCache")
			?.GetMethod("GetFieldList", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

		private static MethodInfo m_RuntimeTypeCache_GetPropertyList =
			typeof(Type).Assembly
			.GetType("System.RuntimeType+RuntimeTypeCache")
			?.GetMethod("GetPropertyList", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

#if !NETFRAMEWORK3
		private static readonly ConditionalWeakTable<Type, CacheFixEntry> _CacheFixed = new ConditionalWeakTable<Type, CacheFixEntry>();
#else
        private static readonly Dictionary<WeakReference, CacheFixEntry> _CacheFixed = new Dictionary<WeakReference, CacheFixEntry>(new WeakReferenceComparer());
        private static readonly HashSet<WeakReference> _CacheFixedDead = new HashSet<WeakReference>();
#endif

		static ReflectionHelper()
		{
#if NETFRAMEWORK3
            GCListener.OnCollect += () => {
                lock (_CacheFixed) {
                    foreach (KeyValuePair<WeakReference, CacheFixEntry> kvp in _CacheFixed) {
                        if (kvp.Key.SafeGetIsAlive())
                            continue;
                        _CacheFixedDead.Add(kvp.Key);
                    }

                    foreach (WeakReference weak in _CacheFixedDead) {
                        _CacheFixed.Remove(weak);
                    }

                    _CacheFixedDead.Clear();
                }
            };
#endif
		}

		public static void FixReflectionCacheAuto(this Type type)
		{
#if NETFRAMEWORK
            FixReflectionCache(type);
#endif
		}

		public static void FixReflectionCache(this Type type)
		{
			if (t_RuntimeType == null ||
				p_RuntimeType_Cache == null ||
				m_RuntimeTypeCache_GetFieldList == null ||
				m_RuntimeTypeCache_GetPropertyList == null)
				return;

			for (; type != null; type = type.DeclaringType)
			{
				// All types SHOULD inherit RuntimeType, including those built at runtime.
				// One might never know what awaits us in the depths of reflection hell though.
				if (!t_RuntimeType.IsInstanceOfType(type))
					continue;

#if NETFRAMEWORK3
                WeakReference key = new WeakReference(type);
                CacheFixEntry entry;
                lock (_CacheFixed) {
                    if (!_CacheFixed.TryGetValue(key, out entry)) {
                        _CacheFixed.Add(key, entry = new CacheFixEntry());
                        // All RuntimeTypes MUST have a cache, the getter is non-virtual, it creates on demand and asserts non-null.
                        object cache;
                        entry.Cache = cache = p_RuntimeType_Cache.GetValue(type, _NoArgs);
                        entry.Properties = _GetArray(cache, m_RuntimeTypeCache_GetPropertyList);
                        entry.Fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList);
                    } else if (!_Verify(entry, type)) {
                        continue;
                    }
                }

                lock (entry) {
                    _FixReflectionCacheOrder<PropertyInfo>(entry.Properties);
                    _FixReflectionCacheOrder<FieldInfo>(entry.Fields);
                }

#else
				CacheFixEntry entry = _CacheFixed.GetValue(type, rt => {
					CacheFixEntry entryNew = new CacheFixEntry();
					object cache;
					Array properties, fields;

					// All RuntimeTypes MUST have a cache, the getter is non-virtual, it creates on demand and asserts non-null.
					entryNew.Cache = cache = p_RuntimeType_Cache.GetValue(rt, _NoArgs);
					entryNew.Properties = properties = _GetArray(cache, m_RuntimeTypeCache_GetPropertyList);
					entryNew.Fields = fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList);

					_FixReflectionCacheOrder<PropertyInfo>(properties);
					_FixReflectionCacheOrder<FieldInfo>(fields);

					entryNew.NeedsVerify = false;
					return entryNew;
				});

				if (entry.NeedsVerify && !_Verify(entry, type))
				{
					lock (entry)
					{
						_FixReflectionCacheOrder<PropertyInfo>(entry.Properties);
						_FixReflectionCacheOrder<FieldInfo>(entry.Fields);
					}
				}

				entry.NeedsVerify = true;
#endif
			}
		}

		private static bool _Verify(CacheFixEntry entry, Type type)
		{
			object cache;
			Array properties, fields;

			// The cache can sometimes be invalidated.
			// TODO: Figure out if only the arrays get replaced or if the entire cache object gets replaced!
			if (entry.Cache != (cache = p_RuntimeType_Cache.GetValue(type, _NoArgs)))
			{
				entry.Cache = cache;
				entry.Properties = _GetArray(cache, m_RuntimeTypeCache_GetPropertyList);
				entry.Fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList);
				return false;

			}
			else if (entry.Properties != (properties = _GetArray(cache, m_RuntimeTypeCache_GetPropertyList)))
			{
				entry.Properties = properties;
				entry.Fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList);
				return false;

			}
			else if (entry.Fields != (fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList)))
			{
				entry.Fields = fields;
				return false;

			}
			else
			{
				// Cache should still be the same, no re-fix necessary.
				return true;
			}
		}

		private static Array _GetArray(object cache, MethodInfo getter)
		{
			// Get and discard once, otherwise we might not be getting the actual backing array.
			getter.Invoke(cache, _CacheGetterArgs);
			return (Array)getter.Invoke(cache, _CacheGetterArgs);
		}

		private static void _FixReflectionCacheOrder<T>(Array orig) where T : MemberInfo
		{
			// Sort using a short-lived list.
			List<T> list = new List<T>(orig.Length);
			for (int i = 0; i < orig.Length; i++)
				list.Add((T)orig.GetValue(i));

			list.Sort((a, b) => a.MetadataToken - b.MetadataToken);

			for (int i = orig.Length - 1; i >= 0; --i)
				orig.SetValue(list[i], i);
		}

		private class CacheFixEntry
		{
			public object Cache;
			public Array Properties;
			public Array Fields;
#if !NETFRAMEWORK3
			public bool NeedsVerify;
#endif
		}

	}
}














namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	static partial class ReflectionHelper
	{

		private static Type t_RuntimeModule =
			typeof(Module).Assembly
			.GetType("System.Reflection.RuntimeModule");

		private static PropertyInfo p_RuntimeModule_RuntimeType =
			typeof(Module).Assembly
			.GetType("System.Reflection.RuntimeModule")
			?.GetProperty("RuntimeType", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

		private static FieldInfo f_RuntimeModule__impl =
			typeof(Module).Assembly
			.GetType("System.Reflection.RuntimeModule")
			?.GetField("_impl", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

		private static MethodInfo m_RuntimeModule_GetGlobalType =
			typeof(Module).Assembly
			.GetType("System.Reflection.RuntimeModule")
			?.GetMethod("GetGlobalType", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);

		public static Type GetModuleType(this Module module)
		{
			// Sadly we can't blindly resolve type 0x02000001 as the runtime throws ArgumentException.

			if (module == null || t_RuntimeModule == null || !t_RuntimeModule.IsInstanceOfType(module))
				return null;

			// .NET
			if (p_RuntimeModule_RuntimeType != null)
				return (Type)p_RuntimeModule_RuntimeType.GetValue(module, _NoArgs);

			// Mono
			if (f_RuntimeModule__impl != null &&
				m_RuntimeModule_GetGlobalType != null)
				return (Type)m_RuntimeModule_GetGlobalType.Invoke(null, new object[] { f_RuntimeModule__impl.GetValue(module) });

			return null;
		}

		public static Type GetRealDeclaringType(this MemberInfo member)
			=> member.DeclaringType ?? member.Module?.GetModuleType();

	}
}












namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	// If you've thought DMDEmit.EmitCallSite.cs was bad enough, look away.
	static partial class ReflectionHelper
	{

		// https://github.com/dotnet/runtime/blob/10717887317beb824e57cdb29417663615211e99/src/coreclr/src/System.Private.CoreLib/src/System/Reflection/Emit/SignatureHelper.cs#L191
		// https://github.com/mono/mono/blob/1317cf06da06682419f8f4b0c9810ad5d5d3ac3a/mcs/class/corlib/System.Reflection.Emit/SignatureHelper.cs#L55
		private static readonly FieldInfo f_SignatureHelper_module =
			typeof(SignatureHelper).GetField("m_module", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance) ??
			typeof(SignatureHelper).GetField("module", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);

		public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, ICallSiteGenerator signature)
			=> signature.ToCallSite(moduleTo);
		public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, SignatureHelper signature)
			=> moduleTo.ImportCallSite(f_SignatureHelper_module.GetValue(signature) as Module, signature.GetSignature());
		public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, Module moduleFrom, int token)
			=> moduleTo.ImportCallSite(moduleFrom, moduleFrom.ResolveSignature(token));
		public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, Module moduleFrom, byte[] data)
		{
			Mono.Cecil.CallSite callsite = new Mono.Cecil.CallSite(moduleTo.TypeSystem.Void);

			// Based on https://github.com/jbevain/cecil/blob/96026325ee1cb6627a3e4a32b924ab2905f02553/Mono.Cecil/AssemblyReader.cs#L3448

			using (MemoryStream stream = new MemoryStream(data, false))
			using (BinaryReader reader = new BinaryReader(stream))
			{
				ReadMethodSignature(callsite);
				return callsite;

				void ReadMethodSignature(IMethodSignature method)
				{
					byte callConv = reader.ReadByte();

					if ((callConv & 0x20) != 0)
					{
						method.HasThis = true;
						callConv = (byte)(callConv & ~0x20);
					}

					if ((callConv & 0x40) != 0)
					{
						method.ExplicitThis = true;
						callConv = (byte)(callConv & ~0x40);
					}

					method.CallingConvention = (MethodCallingConvention)callConv;

					if ((callConv & 0x10) != 0)
					{
						uint arity = ReadCompressedUInt32();
						// Shouldn't apply to CallSites.
					}

					uint paramCount = ReadCompressedUInt32();

					method.MethodReturnType.ReturnType = ReadTypeSignature();

					for (int i = 0; i < paramCount; i++)
						method.Parameters.Add(new ParameterDefinition(ReadTypeSignature()));
				}

				uint ReadCompressedUInt32()
				{
					byte first = reader.ReadByte();
					if ((first & 0x80) == 0)
						return first;

					if ((first & 0x40) == 0)
						return ((uint)(first & ~0x80) << 8)
							| reader.ReadByte();

					return ((uint)(first & ~0xc0) << 24)
						| (uint)reader.ReadByte() << 16
						| (uint)reader.ReadByte() << 8
						| reader.ReadByte();
				}

				int ReadCompressedInt32()
				{
					byte b = reader.ReadByte();
					reader.BaseStream.Seek(-1, SeekOrigin.Current);
					int u = (int)ReadCompressedUInt32();
					int v = u >> 1;
					if ((u & 1) == 0)
						return v;

					switch (b & 0xc0)
					{
						case 0:
						case 0x40:
							return v - 0x40;

						case 0x80:
							return v - 0x2000;

						default:
							return v - 0x10000000;
					}
				}

				TypeReference GetTypeDefOrRef()
				{
					uint tokenData = ReadCompressedUInt32();

					uint rid = tokenData >> 2;
					uint token;
					switch (tokenData & 3)
					{
						case 0:
							token = (uint)TokenType.TypeDef | rid;
							break;

						case 1:
							token = (uint)TokenType.TypeRef | rid;
							break;

						case 2:
							token = (uint)TokenType.TypeSpec | rid;
							break;

						default:
							token = 0;
							break;
					}

					return moduleTo.ImportReference(moduleFrom.ResolveType((int)token));
				}

				TypeReference ReadTypeSignature()
				{
					MetadataType etype = (MetadataType)reader.ReadByte();
					switch (etype)
					{
						case MetadataType.ValueType:
						case MetadataType.Class:
							return GetTypeDefOrRef();

						case MetadataType.Pointer:
							return new PointerType(ReadTypeSignature());

						case MetadataType.FunctionPointer:
							FunctionPointerType fptr = new FunctionPointerType();
							ReadMethodSignature(fptr);
							return fptr;

						case MetadataType.ByReference:
							return new ByReferenceType(ReadTypeSignature());

						case MetadataType.Pinned:
							return new PinnedType(ReadTypeSignature());

						case (MetadataType)0x1d: // SzArray
							return new ArrayType(ReadTypeSignature());

						case MetadataType.Array:
							ArrayType array = new ArrayType(ReadTypeSignature());

							uint rank = ReadCompressedUInt32();

							uint[] sizes = new uint[ReadCompressedUInt32()];
							for (int i = 0; i < sizes.Length; i++)
								sizes[i] = ReadCompressedUInt32();

							int[] lowBounds = new int[ReadCompressedUInt32()];
							for (int i = 0; i < lowBounds.Length; i++)
								lowBounds[i] = ReadCompressedInt32();

							array.Dimensions.Clear();

							for (int i = 0; i < rank; i++)
							{
								int? lower = null, upper = null;

								if (i < lowBounds.Length)
									lower = lowBounds[i];

								if (i < sizes.Length)
									upper = lower + (int)sizes[i] - 1;

								array.Dimensions.Add(new ArrayDimension(lower, upper));
							}

							return array;

						case MetadataType.OptionalModifier:
							return new OptionalModifierType(GetTypeDefOrRef(), ReadTypeSignature());

						case MetadataType.RequiredModifier:
							return new RequiredModifierType(GetTypeDefOrRef(), ReadTypeSignature());

						case MetadataType.Sentinel:
							return new SentinelType(ReadTypeSignature());

						case MetadataType.Var:
						case MetadataType.MVar:
						case MetadataType.GenericInstance:
							throw new NotSupportedException($"Unsupported generic callsite element: {etype}");

						case MetadataType.Object:
							return moduleTo.TypeSystem.Object;

						case MetadataType.Void:
							return moduleTo.TypeSystem.Void;

						case MetadataType.TypedByReference:
							return moduleTo.TypeSystem.TypedReference;

						case MetadataType.IntPtr:
							return moduleTo.TypeSystem.IntPtr;

						case MetadataType.UIntPtr:
							return moduleTo.TypeSystem.UIntPtr;

						case MetadataType.Boolean:
							return moduleTo.TypeSystem.Boolean;

						case MetadataType.Char:
							return moduleTo.TypeSystem.Char;

						case MetadataType.SByte:
							return moduleTo.TypeSystem.SByte;

						case MetadataType.Byte:
							return moduleTo.TypeSystem.Byte;

						case MetadataType.Int16:
							return moduleTo.TypeSystem.Int16;

						case MetadataType.UInt16:
							return moduleTo.TypeSystem.UInt16;

						case MetadataType.Int32:
							return moduleTo.TypeSystem.Int32;

						case MetadataType.UInt32:
							return moduleTo.TypeSystem.UInt32;

						case MetadataType.Int64:
							return moduleTo.TypeSystem.Int64;

						case MetadataType.UInt64:
							return moduleTo.TypeSystem.UInt64;

						case MetadataType.Single:
							return moduleTo.TypeSystem.Single;

						case MetadataType.Double:
							return moduleTo.TypeSystem.Double;

						case MetadataType.String:
							return moduleTo.TypeSystem.String;

						default:
							throw new NotSupportedException($"Unsupported callsite element: {etype}");
					}
				}

			}
		}

	}
}






namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	class RelinkFailedException : Exception
	{

		public const string DefaultMessage = "MonoMod failed relinking";

		public IMetadataTokenProvider MTP;
		public IMetadataTokenProvider Context;

		public RelinkFailedException(IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: this(_Format(DefaultMessage, mtp, context), mtp, context)
		{
		}

		public RelinkFailedException(string message,
			IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: base(message)
		{
			MTP = mtp;
			Context = context;
		}

		public RelinkFailedException(string message, Exception innerException,
			IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: base(message ?? _Format(DefaultMessage, mtp, context), innerException)
		{
			MTP = mtp;
			Context = context;
		}

		protected static string _Format(string message,
			IMetadataTokenProvider mtp, IMetadataTokenProvider context)
		{
			if (mtp == null && context == null)
				return message;

			StringBuilder builder = new StringBuilder(message);
			builder.Append(" ");

			if (mtp != null)
				builder.Append(mtp.ToString());

			if (context != null)
				builder.Append(" ");

			if (context != null)
				builder.Append("(context: ").Append(context.ToString()).Append(")");

			return builder.ToString();
		}

	}
}






namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	class RelinkTargetNotFoundException : RelinkFailedException
	{

		public new const string DefaultMessage = "MonoMod relinker failed finding";

		public RelinkTargetNotFoundException(IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: base(_Format(DefaultMessage, mtp, context), mtp, context)
		{
		}

		public RelinkTargetNotFoundException(string message,
			IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: base(message ?? DefaultMessage, mtp, context)
		{
		}

		public RelinkTargetNotFoundException(string message, Exception innerException,
			IMetadataTokenProvider mtp, IMetadataTokenProvider context = null)
			: base(message ?? DefaultMessage, innerException, mtp, context)
		{
		}

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum ResourceType
	{
		Linked,
		Embedded,
		AssemblyLinked,
	}

	public abstract class Resource
	{

		string name;
		uint attributes;

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public ManifestResourceAttributes Attributes
		{
			get { return (ManifestResourceAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public abstract ResourceType ResourceType
		{
			get;
		}

		#region ManifestResourceAttributes

		public bool IsPublic
		{
			get { return attributes.GetMaskedAttributes((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Public, value); }
		}

		public bool IsPrivate
		{
			get { return attributes.GetMaskedAttributes((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Private, value); }
		}

		#endregion

		internal Resource(string name, ManifestResourceAttributes attributes)
		{
			this.name = name;
			this.attributes = (uint)attributes;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Metadata
{

	struct Row<T1, T2>
	{
		internal T1 Col1;
		internal T2 Col2;

		public Row(T1 col1, T2 col2)
		{
			Col1 = col1;
			Col2 = col2;
		}
	}

	struct Row<T1, T2, T3>
	{
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;

		public Row(T1 col1, T2 col2, T3 col3)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
		}
	}

	struct Row<T1, T2, T3, T4>
	{
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
		}
	}

	struct Row<T1, T2, T3, T4, T5>
	{
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
		}
	}

	struct Row<T1, T2, T3, T4, T5, T6>
	{
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;
		internal T6 Col6;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
		}
	}

	struct Row<T1, T2, T3, T4, T5, T6, T7, T8, T9>
	{
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;
		internal T6 Col6;
		internal T7 Col7;
		internal T8 Col8;
		internal T9 Col9;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
			Col7 = col7;
			Col8 = col8;
			Col9 = col9;
		}
	}

	sealed class RowEqualityComparer : IEqualityComparer<Row<string, string>>, IEqualityComparer<Row<uint, uint>>, IEqualityComparer<Row<uint, uint, uint>>
	{

		public bool Equals(Row<string, string> x, Row<string, string> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2;
		}

		public int GetHashCode(Row<string, string> obj)
		{
			string x = obj.Col1, y = obj.Col2;
			return (x != null ? x.GetHashCode() : 0) ^ (y != null ? y.GetHashCode() : 0);
		}

		public bool Equals(Row<uint, uint> x, Row<uint, uint> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2;
		}

		public int GetHashCode(Row<uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2);
		}

		public bool Equals(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2
				&& x.Col3 == y.Col3;
		}

		public int GetHashCode(Row<uint, uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2 ^ obj.Col3);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.PE
{

	sealed class Section
	{
		public string Name;
		public RVA VirtualAddress;
		public uint VirtualSize;
		public uint SizeOfRawData;
		public uint PointerToRawData;
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public enum SecurityAction : ushort
	{
		Request = 1,
		Demand = 2,
		Assert = 3,
		Deny = 4,
		PermitOnly = 5,
		LinkDemand = 6,
		InheritDemand = 7,
		RequestMinimum = 8,
		RequestOptional = 9,
		RequestRefuse = 10,
		PreJitGrant = 11,
		PreJitDeny = 12,
		NonCasDemand = 13,
		NonCasLinkDemand = 14,
		NonCasInheritance = 15
	}

	public interface ISecurityDeclarationProvider : IMetadataTokenProvider
	{

		bool HasSecurityDeclarations { get; }
		Collection<SecurityDeclaration> SecurityDeclarations { get; }
	}

	[DebuggerDisplay("{AttributeType}")]
	public sealed class SecurityAttribute : ICustomAttribute
	{

		TypeReference attribute_type;

		internal Collection<CustomAttributeNamedArgument> fields;
		internal Collection<CustomAttributeNamedArgument> properties;

		public TypeReference AttributeType
		{
			get { return attribute_type; }
			set { attribute_type = value; }
		}

		public bool HasFields
		{
			get { return !fields.IsNullOrEmpty(); }
		}

		public Collection<CustomAttributeNamedArgument> Fields
		{
			get
			{
				if (fields == null)
					Interlocked.CompareExchange(ref fields, new Collection<CustomAttributeNamedArgument>(), null);

				return fields;
			}
		}

		public bool HasProperties
		{
			get { return !properties.IsNullOrEmpty(); }
		}

		public Collection<CustomAttributeNamedArgument> Properties
		{
			get
			{
				if (properties == null)
					Interlocked.CompareExchange(ref properties, new Collection<CustomAttributeNamedArgument>(), null);

				return properties;
			}
		}

		public SecurityAttribute(TypeReference attributeType)
		{
			this.attribute_type = attributeType;
		}

		bool ICustomAttribute.HasConstructorArguments
		{
			get { return false; }
		}

		Collection<CustomAttributeArgument> ICustomAttribute.ConstructorArguments
		{
			get { throw new NotSupportedException(); }
		}
	}

	public sealed class SecurityDeclaration
	{

		readonly internal uint signature;
		byte[] blob;
		readonly ModuleDefinition module;

		internal bool resolved;
		SecurityAction action;
		internal Collection<SecurityAttribute> security_attributes;

		public SecurityAction Action
		{
			get { return action; }
			set { action = value; }
		}

		public bool HasSecurityAttributes
		{
			get
			{
				Resolve();

				return !security_attributes.IsNullOrEmpty();
			}
		}

		public Collection<SecurityAttribute> SecurityAttributes
		{
			get
			{
				Resolve();

				if (security_attributes == null)
					Interlocked.CompareExchange(ref security_attributes, new Collection<SecurityAttribute>(), null);

				return security_attributes;
			}
		}

		internal bool HasImage
		{
			get { return module != null && module.HasImage; }
		}

		internal SecurityDeclaration(SecurityAction action, uint signature, ModuleDefinition module)
		{
			this.action = action;
			this.signature = signature;
			this.module = module;
		}

		public SecurityDeclaration(SecurityAction action)
		{
			this.action = action;
			this.resolved = true;
		}

		public SecurityDeclaration(SecurityAction action, byte[] blob)
		{
			this.action = action;
			this.resolved = false;
			this.blob = blob;
		}

		public byte[] GetBlob()
		{
			if (blob != null)
				return blob;

			if (!HasImage || signature == 0)
				throw new NotSupportedException();

			return module.Read(ref blob, this, (declaration, reader) => reader.ReadSecurityDeclarationBlob(declaration.signature));
		}

		void Resolve()
		{
			if (resolved || !HasImage)
				return;

			lock (module.SyncRoot)
			{

				if (resolved)
					return;

				module.Read(this, (declaration, reader) => reader.ReadSecurityDeclarationSignature(declaration));
				resolved = true;
			}
		}
	}

	static partial class Mixin
	{

		public static bool GetHasSecurityDeclarations(
			this ISecurityDeclarationProvider self,
			ModuleDefinition module)
		{
			return module.HasImage() && module.Read(self, (provider, reader) => reader.HasSecurityDeclarations(provider));
		}

		public static Collection<SecurityDeclaration> GetSecurityDeclarations(
			this ISecurityDeclarationProvider self,
			ref Collection<SecurityDeclaration> variable,
			ModuleDefinition module)
		{
			if (module.HasImage)
				return module.Read(ref variable, self, (provider, reader) => reader.ReadSecurityDeclarations(provider));

			Interlocked.CompareExchange(ref variable, new Collection<SecurityDeclaration>(), null);
			return variable;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

#if !NET_CORE





namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class SecurityDeclarationRocks
	{

		public static PermissionSet ToPermissionSet(this SecurityDeclaration self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			PermissionSet set;
			if (TryProcessPermissionSetAttribute(self, out set))
				return set;

			return CreatePermissionSet(self);
		}

		static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, out PermissionSet set)
		{
			set = null;

			if (!declaration.HasSecurityAttributes && declaration.SecurityAttributes.Count != 1)
				return false;

			var security_attribute = declaration.SecurityAttributes[0];
			if (!security_attribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
				return false;

			var attribute = new SSP.PermissionSetAttribute((SSP.SecurityAction)declaration.Action);

			var named_argument = security_attribute.Properties[0];
			string value = (string)named_argument.Argument.Value;
			switch (named_argument.Name)
			{
				case "XML":
					attribute.XML = value;
					break;
				case "Name":
					attribute.Name = value;
					break;
				default:
					throw new NotImplementedException(named_argument.Name);
			}

			set = attribute.CreatePermissionSet();
			return true;
		}

		static PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
		{
			var set = new PermissionSet(SSP.PermissionState.None);

			foreach (var attribute in declaration.SecurityAttributes)
			{
				var permission = CreatePermission(declaration, attribute);
				set.AddPermission(permission);
			}

			return set;
		}

		static IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute)
		{
			var attribute_type = Type.GetType(attribute.AttributeType.FullName);
			if (attribute_type == null)
				throw new ArgumentException("attribute");

			var security_attribute = CreateSecurityAttribute(attribute_type, declaration);
			if (security_attribute == null)
				throw new InvalidOperationException();

			CompleteSecurityAttribute(security_attribute, attribute);

			return security_attribute.CreatePermission();
		}

		static void CompleteSecurityAttribute(SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			if (attribute.HasFields)
				CompleteSecurityAttributeFields(security_attribute, attribute);

			if (attribute.HasProperties)
				CompleteSecurityAttributeProperties(security_attribute, attribute);
		}

		static void CompleteSecurityAttributeFields(SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			var type = security_attribute.GetType();

			foreach (var named_argument in attribute.Fields)
				type.GetField(named_argument.Name).SetValue(security_attribute, named_argument.Argument.Value);
		}

		static void CompleteSecurityAttributeProperties(SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			var type = security_attribute.GetType();

			foreach (var named_argument in attribute.Properties)
				type.GetProperty(named_argument.Name).SetValue(security_attribute, named_argument.Argument.Value, null);
		}

		static SSP.SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
		{
			SSP.SecurityAttribute security_attribute;
			try
			{
				security_attribute = (SSP.SecurityAttribute)Activator.CreateInstance(
					attribute_type, new object[] { (SSP.SecurityAction)declaration.Action });
			}
			catch (MissingMethodException)
			{
				security_attribute = (SSP.SecurityAttribute)Activator.CreateInstance(attribute_type, new object[0]);
			}

			return security_attribute;
		}

		public static SecurityDeclaration ToSecurityDeclaration(this PermissionSet self, SecurityAction action, ModuleDefinition module)
		{
			if (self == null)
				throw new ArgumentNullException("self");
			if (module == null)
				throw new ArgumentNullException("module");

			var declaration = new SecurityDeclaration(action);

			var attribute = new SecurityAttribute(
				module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"));

			attribute.Properties.Add(
				new CustomAttributeNamedArgument(
					"XML",
					new CustomAttributeArgument(
						module.TypeSystem.String, self.ToXml().ToString())));

			declaration.SecurityAttributes.Add(attribute);

			return declaration;
		}
	}
}

#endif
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public sealed class SentinelType : TypeSpecification
	{

		public override bool IsValueType
		{
			get { return false; }
			set { throw new InvalidOperationException(); }
		}

		public override bool IsSentinel
		{
			get { return true; }
		}

		public SentinelType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			this.etype = MD.ElementType.Sentinel;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Cil
{

	public sealed class SequencePoint
	{

		internal InstructionOffset offset;
		Document document;

		int start_line;
		int start_column;
		int end_line;
		int end_column;

		public int Offset
		{
			get { return offset.Offset; }
		}

		public int StartLine
		{
			get { return start_line; }
			set { start_line = value; }
		}

		public int StartColumn
		{
			get { return start_column; }
			set { start_column = value; }
		}

		public int EndLine
		{
			get { return end_line; }
			set { end_line = value; }
		}

		public int EndColumn
		{
			get { return end_column; }
			set { end_column = value; }
		}

		public bool IsHidden
		{
			get { return start_line == 0xfeefee && start_line == end_line; }
		}

		public Document Document
		{
			get { return document; }
			set { document = value; }
		}

		internal SequencePoint(int offset, Document document)
		{
			if (document == null)
				throw new ArgumentNullException("document");

			this.offset = new InstructionOffset(offset);
			this.document = document;
		}

		public SequencePoint(Instruction instruction, Document document)
		{
			if (document == null)
				throw new ArgumentNullException("document");

			this.offset = new InstructionOffset(instruction);
			this.document = document;
		}
	}
}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.





#pragma warning disable 1591 // TODO: doc comments

namespace Microsoft.Cci.Pdb
{

	internal sealed class PdbIteratorScope : ILocalScope
	{

		internal PdbIteratorScope(uint offset, uint length)
		{
			this.offset = offset;
			this.length = length;
		}

		public uint Offset
		{
			get { return this.offset; }
		}
		uint offset;

		public uint Length
		{
			get { return this.length; }
		}
		uint length;
	}
}//
 // SourceMethodBuilder.cs
 //
 // Authors:
 //   Martin Baulig (martin@ximian.com)
 //   Marek Safar (marek.safar@gmail.com)
 //
 // (C) 2002 Ximian, Inc.  http://www.ximian.com
 // Copyright (C) 2012 Xamarin Inc (http://www.xamarin.com)
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
 // without limitation the rights to use, copy, modify, merge, publish,
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
 //
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
 //
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //




namespace Mono.CompilerServices.SymbolWriter
{
	public class SourceMethodBuilder
	{
		List<LocalVariableEntry> _locals;
		List<CodeBlockEntry> _blocks;
		List<ScopeVariable> _scope_vars;
		Stack<CodeBlockEntry> _block_stack;
		readonly List<LineNumberEntry> method_lines;

		readonly ICompileUnit _comp_unit;
		readonly int ns_id;
		readonly IMethodDef method;

		public SourceMethodBuilder(ICompileUnit comp_unit)
		{
			this._comp_unit = comp_unit;
			method_lines = new List<LineNumberEntry>();
		}

		public SourceMethodBuilder(ICompileUnit comp_unit, int ns_id, IMethodDef method)
			: this(comp_unit)
		{
			this.ns_id = ns_id;
			this.method = method;
		}

		public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden)
		{
			MarkSequencePoint(offset, file, line, column, -1, -1, is_hidden);
		}

		public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden)
		{
			int file_idx = file != null ? file.Index : 0;
			var lne = new LineNumberEntry(file_idx, line, column, end_line, end_column, offset, is_hidden);

			if (method_lines.Count > 0)
			{
				var prev = method_lines[method_lines.Count - 1];

				//
				// Same offset cannot be used for multiple lines
				//
				if (prev.Offset == offset)
				{
					//
					// Use the new location because debugger will adjust
					// the breakpoint to next line with sequence point
					//
					if (LineNumberEntry.LocationComparer.Default.Compare(lne, prev) > 0)
						method_lines[method_lines.Count - 1] = lne;

					return;
				}
			}

			method_lines.Add(lne);
		}

		public void StartBlock(CodeBlockEntry.Type type, int start_offset)
		{
			StartBlock(type, start_offset, _blocks == null ? 1 : _blocks.Count + 1);
		}

		public void StartBlock(CodeBlockEntry.Type type, int start_offset, int scopeIndex)
		{
			if (_block_stack == null)
			{
				_block_stack = new Stack<CodeBlockEntry>();
			}

			if (_blocks == null)
				_blocks = new List<CodeBlockEntry>();

			int parent = CurrentBlock != null ? CurrentBlock.Index : -1;

			CodeBlockEntry block = new CodeBlockEntry(
				scopeIndex, parent, type, start_offset);

			_block_stack.Push(block);
			_blocks.Add(block);
		}

		public void EndBlock(int end_offset)
		{
			CodeBlockEntry block = (CodeBlockEntry)_block_stack.Pop();
			block.Close(end_offset);
		}

		public CodeBlockEntry[] Blocks
		{
			get
			{
				if (_blocks == null)
					return new CodeBlockEntry[0];

				CodeBlockEntry[] retval = new CodeBlockEntry[_blocks.Count];
				_blocks.CopyTo(retval, 0);
				return retval;
			}
		}

		public CodeBlockEntry CurrentBlock
		{
			get
			{
				if ((_block_stack != null) && (_block_stack.Count > 0))
					return (CodeBlockEntry)_block_stack.Peek();
				else
					return null;
			}
		}

		public LocalVariableEntry[] Locals
		{
			get
			{
				if (_locals == null)
					return new LocalVariableEntry[0];
				else
				{
					return _locals.ToArray();
				}
			}
		}

		public ICompileUnit SourceFile
		{
			get
			{
				return _comp_unit;
			}
		}

		public void AddLocal(int index, string name)
		{
			if (_locals == null)
				_locals = new List<LocalVariableEntry>();
			int block_idx = CurrentBlock != null ? CurrentBlock.Index : 0;
			_locals.Add(new LocalVariableEntry(index, name, block_idx));
		}

		public ScopeVariable[] ScopeVariables
		{
			get
			{
				if (_scope_vars == null)
					return new ScopeVariable[0];

				return _scope_vars.ToArray();
			}
		}

		public void AddScopeVariable(int scope, int index)
		{
			if (_scope_vars == null)
				_scope_vars = new List<ScopeVariable>();
			_scope_vars.Add(
				new ScopeVariable(scope, index));
		}

		public void DefineMethod(MonoSymbolFile file)
		{
			DefineMethod(file, method.Token);
		}

		public void DefineMethod(MonoSymbolFile file, int token)
		{
			var blocks = Blocks;
			if (blocks.Length > 0)
			{
				//
				// When index is provided by user it can be inserted in
				// any order but mdb format does not store its value. It
				// uses stored order as the index instead.
				//
				var sorted = new List<CodeBlockEntry>(blocks.Length);
				int max_index = 0;
				for (int i = 0; i < blocks.Length; ++i)
				{
					max_index = System.Math.Max(max_index, blocks[i].Index);
				}

				for (int i = 0; i < max_index; ++i)
				{
					var scope_index = i + 1;

					//
					// Common fast path
					//
					if (i < blocks.Length && blocks[i].Index == scope_index)
					{
						sorted.Add(blocks[i]);
						continue;
					}

					bool found = false;
					for (int ii = 0; ii < blocks.Length; ++ii)
					{
						if (blocks[ii].Index == scope_index)
						{
							sorted.Add(blocks[ii]);
							found = true;
							break;
						}
					}

					if (found)
						continue;

					//
					// Ideally this should never happen but with current design we can
					// generate scope index for unreachable code before reachable code
					//
					sorted.Add(new CodeBlockEntry(scope_index, -1, CodeBlockEntry.Type.CompilerGenerated, 0));
				}

				blocks = sorted.ToArray();
				//for (int i = 0; i < blocks.Length; ++i) {
				//	if (blocks [i].Index - 1 != i)
				//			throw new ArgumentException ("CodeBlocks cannot be converted to mdb format");
				//}
			}

			var entry = new MethodEntry(
				file, _comp_unit.Entry, token, ScopeVariables,
				Locals, method_lines.ToArray(), blocks, null, MethodEntry.Flags.ColumnsInfoIncluded, ns_id);

			file.AddMethod(entry);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Metadata
{

	class StringHeap : Heap
	{

		readonly Dictionary<uint, string> strings = new Dictionary<uint, string>();

		public StringHeap(byte[] data)
			: base(data)
		{
		}

		public string Read(uint index)
		{
			if (index == 0)
				return string.Empty;

			string @string;
			if (strings.TryGetValue(index, out @string))
				return @string;

			if (index > data.Length - 1)
				return string.Empty;

			@string = ReadStringAt(index);
			if (@string.Length != 0)
				strings.Add(index, @string);

			return @string;
		}

		protected virtual string ReadStringAt(uint index)
		{
			int length = 0;
			int start = (int)index;

			for (int i = start; ; i++)
			{
				if (data[i] == 0)
					break;

				length++;
			}

			return Encoding.UTF8.GetString(data, start, length);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//












namespace Mono.Cecil.Cil
{

	[StructLayout(LayoutKind.Sequential)]
	public struct ImageDebugDirectory
	{
		public const int Size = 28;

		public int Characteristics;
		public int TimeDateStamp;
		public short MajorVersion;
		public short MinorVersion;
		public ImageDebugType Type;
		public int SizeOfData;
		public int AddressOfRawData;
		public int PointerToRawData;
	}

	public enum ImageDebugType
	{
		CodeView = 2,
		Deterministic = 16,
		EmbeddedPortablePdb = 17,
	}

	public sealed class ImageDebugHeader
	{

		readonly ImageDebugHeaderEntry[] entries;

		public bool HasEntries
		{
			get { return !entries.IsNullOrEmpty(); }
		}

		public ImageDebugHeaderEntry[] Entries
		{
			get { return entries; }
		}

		public ImageDebugHeader(ImageDebugHeaderEntry[] entries)
		{
			this.entries = entries ?? Empty<ImageDebugHeaderEntry>.Array;
		}

		public ImageDebugHeader()
			: this(Empty<ImageDebugHeaderEntry>.Array)
		{
		}

		public ImageDebugHeader(ImageDebugHeaderEntry entry)
			: this(new[] { entry })
		{
		}
	}

	public sealed class ImageDebugHeaderEntry
	{

		ImageDebugDirectory directory;
		readonly byte[] data;

		public ImageDebugDirectory Directory
		{
			get { return directory; }
			internal set { directory = value; }
		}

		public byte[] Data
		{
			get { return data; }
		}

		public ImageDebugHeaderEntry(ImageDebugDirectory directory, byte[] data)
		{
			this.directory = directory;
			this.data = data ?? Empty<byte>.Array;
		}
	}

	public sealed class ScopeDebugInformation : DebugInformation
	{

		internal InstructionOffset start;
		internal InstructionOffset end;
		internal ImportDebugInformation import;
		internal Collection<ScopeDebugInformation> scopes;
		internal Collection<VariableDebugInformation> variables;
		internal Collection<ConstantDebugInformation> constants;

		public InstructionOffset Start
		{
			get { return start; }
			set { start = value; }
		}

		public InstructionOffset End
		{
			get { return end; }
			set { end = value; }
		}

		public ImportDebugInformation Import
		{
			get { return import; }
			set { import = value; }
		}

		public bool HasScopes
		{
			get { return !scopes.IsNullOrEmpty(); }
		}

		public Collection<ScopeDebugInformation> Scopes
		{
			get
			{
				if (scopes == null)
					Interlocked.CompareExchange(ref scopes, new Collection<ScopeDebugInformation>(), null);

				return scopes;
			}
		}

		public bool HasVariables
		{
			get { return !variables.IsNullOrEmpty(); }
		}

		public Collection<VariableDebugInformation> Variables
		{
			get
			{
				if (variables == null)
					Interlocked.CompareExchange(ref variables, new Collection<VariableDebugInformation>(), null);

				return variables;
			}
		}

		public bool HasConstants
		{
			get { return !constants.IsNullOrEmpty(); }
		}

		public Collection<ConstantDebugInformation> Constants
		{
			get
			{
				if (constants == null)
					Interlocked.CompareExchange(ref constants, new Collection<ConstantDebugInformation>(), null);

				return constants;
			}
		}

		internal ScopeDebugInformation()
		{
			this.token = new MetadataToken(TokenType.LocalScope);
		}

		public ScopeDebugInformation(Instruction start, Instruction end)
			: this()
		{
			if (start == null)
				throw new ArgumentNullException("start");

			this.start = new InstructionOffset(start);

			if (end != null)
				this.end = new InstructionOffset(end);
		}

		public bool TryGetName(VariableDefinition variable, out string name)
		{
			name = null;
			if (variables == null || variables.Count == 0)
				return false;

			for (int i = 0; i < variables.Count; i++)
			{
				if (variables[i].Index == variable.Index)
				{
					name = variables[i].Name;
					return true;
				}
			}

			return false;
		}
	}

	public struct InstructionOffset
	{

		readonly Instruction instruction;
		readonly int? offset;

		public int Offset
		{
			get
			{
				if (instruction != null)
					return instruction.Offset;
				if (offset.HasValue)
					return offset.Value;

				throw new NotSupportedException();
			}
		}

		public bool IsEndOfMethod
		{
			get { return instruction == null && !offset.HasValue; }
		}

		internal bool IsResolved => instruction != null || !offset.HasValue;

		internal Instruction ResolvedInstruction => instruction;

		public InstructionOffset(Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException("instruction");

			this.instruction = instruction;
			this.offset = null;
		}

		public InstructionOffset(int offset)
		{
			this.instruction = null;
			this.offset = offset;
		}
	}

	[Flags]
	public enum VariableAttributes : ushort
	{
		None = 0,
		DebuggerHidden = 1,
	}

	public struct VariableIndex
	{
		readonly VariableDefinition variable;
		readonly int? index;

		public int Index
		{
			get
			{
				if (variable != null)
					return variable.Index;
				if (index.HasValue)
					return index.Value;

				throw new NotSupportedException();
			}
		}

		internal bool IsResolved => variable != null;

		internal VariableDefinition ResolvedVariable => variable;

		public VariableIndex(VariableDefinition variable)
		{
			if (variable == null)
				throw new ArgumentNullException("variable");

			this.variable = variable;
			this.index = null;
		}

		public VariableIndex(int index)
		{
			this.variable = null;
			this.index = index;
		}
	}

	public abstract class DebugInformation : ICustomDebugInformationProvider
	{

		internal MetadataToken token;
		internal Collection<CustomDebugInformation> custom_infos;

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		public bool HasCustomDebugInformations
		{
			get { return !custom_infos.IsNullOrEmpty(); }
		}

		public Collection<CustomDebugInformation> CustomDebugInformations
		{
			get
			{
				if (custom_infos == null)
					Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);

				return custom_infos;
			}
		}

		internal DebugInformation()
		{
		}
	}

	public sealed class VariableDebugInformation : DebugInformation
	{

		string name;
		ushort attributes;
		internal VariableIndex index;

		public int Index
		{
			get { return index.Index; }
		}

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public VariableAttributes Attributes
		{
			get { return (VariableAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public bool IsDebuggerHidden
		{
			get { return attributes.GetAttributes((ushort)VariableAttributes.DebuggerHidden); }
			set { attributes = attributes.SetAttributes((ushort)VariableAttributes.DebuggerHidden, value); }
		}

		internal VariableDebugInformation(int index, string name)
		{
			if (name == null)
				throw new ArgumentNullException("name");

			this.index = new VariableIndex(index);
			this.name = name;
		}

		public VariableDebugInformation(VariableDefinition variable, string name)
		{
			if (variable == null)
				throw new ArgumentNullException("variable");
			if (name == null)
				throw new ArgumentNullException("name");

			this.index = new VariableIndex(variable);
			this.name = name;
			this.token = new MetadataToken(TokenType.LocalVariable);
		}
	}

	public sealed class ConstantDebugInformation : DebugInformation
	{

		string name;
		TypeReference constant_type;
		object value;

		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public TypeReference ConstantType
		{
			get { return constant_type; }
			set { constant_type = value; }
		}

		public object Value
		{
			get { return value; }
			set { this.value = value; }
		}

		public ConstantDebugInformation(string name, TypeReference constant_type, object value)
		{
			if (name == null)
				throw new ArgumentNullException("name");

			this.name = name;
			this.constant_type = constant_type;
			this.value = value;
			this.token = new MetadataToken(TokenType.LocalConstant);
		}
	}

	public enum ImportTargetKind : byte
	{
		ImportNamespace = 1,
		ImportNamespaceInAssembly = 2,
		ImportType = 3,
		ImportXmlNamespaceWithAlias = 4,
		ImportAlias = 5,
		DefineAssemblyAlias = 6,
		DefineNamespaceAlias = 7,
		DefineNamespaceInAssemblyAlias = 8,
		DefineTypeAlias = 9,
	}

	public sealed class ImportTarget
	{

		internal ImportTargetKind kind;

		internal string @namespace;
		internal TypeReference type;
		internal AssemblyNameReference reference;
		internal string alias;

		public string Namespace
		{
			get { return @namespace; }
			set { @namespace = value; }
		}

		public TypeReference Type
		{
			get { return type; }
			set { type = value; }
		}

		public AssemblyNameReference AssemblyReference
		{
			get { return reference; }
			set { reference = value; }
		}

		public string Alias
		{
			get { return alias; }
			set { alias = value; }
		}

		public ImportTargetKind Kind
		{
			get { return kind; }
			set { kind = value; }
		}

		public ImportTarget(ImportTargetKind kind)
		{
			this.kind = kind;
		}
	}

	public sealed class ImportDebugInformation : DebugInformation
	{

		internal ImportDebugInformation parent;
		internal Collection<ImportTarget> targets;

		public bool HasTargets
		{
			get { return !targets.IsNullOrEmpty(); }
		}

		public Collection<ImportTarget> Targets
		{
			get
			{
				if (targets == null)
					Interlocked.CompareExchange(ref targets, new Collection<ImportTarget>(), null);

				return targets;
			}
		}

		public ImportDebugInformation Parent
		{
			get { return parent; }
			set { parent = value; }
		}

		public ImportDebugInformation()
		{
			this.token = new MetadataToken(TokenType.ImportScope);
		}
	}

	public interface ICustomDebugInformationProvider : IMetadataTokenProvider
	{
		bool HasCustomDebugInformations { get; }
		Collection<CustomDebugInformation> CustomDebugInformations { get; }
	}

	public enum CustomDebugInformationKind
	{
		Binary,
		StateMachineScope,
		DynamicVariable,
		DefaultNamespace,
		AsyncMethodBody,
		EmbeddedSource,
		SourceLink,
	}

	public abstract class CustomDebugInformation : DebugInformation
	{

		Guid identifier;

		public Guid Identifier
		{
			get { return identifier; }
		}

		public abstract CustomDebugInformationKind Kind { get; }

		internal CustomDebugInformation(Guid identifier)
		{
			this.identifier = identifier;
			this.token = new MetadataToken(TokenType.CustomDebugInformation);
		}
	}

	public sealed class BinaryCustomDebugInformation : CustomDebugInformation
	{

		byte[] data;

		public byte[] Data
		{
			get { return data; }
			set { data = value; }
		}

		public override CustomDebugInformationKind Kind
		{
			get { return CustomDebugInformationKind.Binary; }
		}

		public BinaryCustomDebugInformation(Guid identifier, byte[] data)
			: base(identifier)
		{
			this.data = data;
		}
	}

	public sealed class AsyncMethodBodyDebugInformation : CustomDebugInformation
	{

		internal InstructionOffset catch_handler;
		internal Collection<InstructionOffset> yields;
		internal Collection<InstructionOffset> resumes;
		internal Collection<MethodDefinition> resume_methods;

		public InstructionOffset CatchHandler
		{
			get { return catch_handler; }
			set { catch_handler = value; }
		}

		public Collection<InstructionOffset> Yields
		{
			get
			{
				if (yields == null)
					Interlocked.CompareExchange(ref yields, new Collection<InstructionOffset>(), null);

				return yields;
			}
		}

		public Collection<InstructionOffset> Resumes
		{
			get
			{
				if (resumes == null)
					Interlocked.CompareExchange(ref resumes, new Collection<InstructionOffset>(), null);

				return resumes;
			}
		}

		public Collection<MethodDefinition> ResumeMethods
		{
			get { return resume_methods ?? (resume_methods = new Collection<MethodDefinition>()); }
		}

		public override CustomDebugInformationKind Kind
		{
			get { return CustomDebugInformationKind.AsyncMethodBody; }
		}

		public static Guid KindIdentifier = new Guid("{54FD2AC5-E925-401A-9C2A-F94F171072F8}");

		internal AsyncMethodBodyDebugInformation(int catchHandler)
			: base(KindIdentifier)
		{
			this.catch_handler = new InstructionOffset(catchHandler);
		}

		public AsyncMethodBodyDebugInformation(Instruction catchHandler)
			: base(KindIdentifier)
		{
			this.catch_handler = new InstructionOffset(catchHandler);
		}

		public AsyncMethodBodyDebugInformation()
			: base(KindIdentifier)
		{
			this.catch_handler = new InstructionOffset(-1);
		}
	}

	public sealed class StateMachineScope
	{

		internal InstructionOffset start;
		internal InstructionOffset end;

		public InstructionOffset Start
		{
			get { return start; }
			set { start = value; }
		}

		public InstructionOffset End
		{
			get { return end; }
			set { end = value; }
		}

		internal StateMachineScope(int start, int end)
		{
			this.start = new InstructionOffset(start);
			this.end = new InstructionOffset(end);
		}

		public StateMachineScope(Instruction start, Instruction end)
		{
			this.start = new InstructionOffset(start);
			this.end = end != null ? new InstructionOffset(end) : new InstructionOffset();
		}
	}

	public sealed class StateMachineScopeDebugInformation : CustomDebugInformation
	{

		internal Collection<StateMachineScope> scopes;

		public Collection<StateMachineScope> Scopes
		{
			get { return scopes ?? (scopes = new Collection<StateMachineScope>()); }
		}

		public override CustomDebugInformationKind Kind
		{
			get { return CustomDebugInformationKind.StateMachineScope; }
		}

		public static Guid KindIdentifier = new Guid("{6DA9A61E-F8C7-4874-BE62-68BC5630DF71}");

		public StateMachineScopeDebugInformation()
			: base(KindIdentifier)
		{
		}
	}

	public sealed class EmbeddedSourceDebugInformation : CustomDebugInformation
	{

		internal uint index;
		internal MetadataReader debug_reader;
		internal bool resolved;
		internal byte[] content;
		internal bool compress;

		public byte[] Content
		{
			get
			{
				if (!resolved)
					Resolve();

				return content;
			}
			set
			{
				content = value;
				resolved = true;
			}
		}

		public bool Compress
		{
			get
			{
				if (!resolved)
					Resolve();

				return compress;
			}
			set
			{
				compress = value;
				resolved = true;
			}
		}

		public override CustomDebugInformationKind Kind
		{
			get { return CustomDebugInformationKind.EmbeddedSource; }
		}

		public static Guid KindIdentifier = new Guid("{0E8A571B-6926-466E-B4AD-8AB04611F5FE}");

		internal EmbeddedSourceDebugInformation(uint index, MetadataReader debug_reader)
			: base(KindIdentifier)
		{
			this.index = index;
			this.debug_reader = debug_reader;
		}

		public EmbeddedSourceDebugInformation(byte[] content, bool compress)
			: base(KindIdentifier)
		{
			this.resolved = true;
			this.content = content;
			this.compress = compress;
		}

		internal byte[] ReadRawEmbeddedSourceDebugInformation()
		{
			if (debug_reader == null)
				throw new InvalidOperationException();

			return debug_reader.ReadRawEmbeddedSourceDebugInformation(index);
		}

		void Resolve()
		{
			if (resolved)
				return;

			if (debug_reader == null)
				throw new InvalidOperationException();

			var row = debug_reader.ReadEmbeddedSourceDebugInformation(index);
			content = row.Col1;
			compress = row.Col2;
			resolved = true;
		}
	}

	public sealed class SourceLinkDebugInformation : CustomDebugInformation
	{

		internal string content;

		public string Content
		{
			get { return content; }
			set { content = value; }
		}

		public override CustomDebugInformationKind Kind
		{
			get { return CustomDebugInformationKind.SourceLink; }
		}

		public static Guid KindIdentifier = new Guid("{CC110556-A091-4D38-9FEC-25AB9A351A6A}");

		public SourceLinkDebugInformation(string content)
			: base(KindIdentifier)
		{
			this.content = content;
		}
	}

	public sealed class MethodDebugInformation : DebugInformation
	{

		internal MethodDefinition method;
		internal Collection<SequencePoint> sequence_points;
		internal ScopeDebugInformation scope;
		internal MethodDefinition kickoff_method;
		internal int code_size;
		internal MetadataToken local_var_token;

		public MethodDefinition Method
		{
			get { return method; }
		}

		public bool HasSequencePoints
		{
			get { return !sequence_points.IsNullOrEmpty(); }
		}

		public Collection<SequencePoint> SequencePoints
		{
			get
			{
				if (sequence_points == null)
					Interlocked.CompareExchange(ref sequence_points, new Collection<SequencePoint>(), null);

				return sequence_points;
			}
		}

		public ScopeDebugInformation Scope
		{
			get { return scope; }
			set { scope = value; }
		}

		public MethodDefinition StateMachineKickOffMethod
		{
			get { return kickoff_method; }
			set { kickoff_method = value; }
		}

		internal MethodDebugInformation(MethodDefinition method)
		{
			if (method == null)
				throw new ArgumentNullException("method");

			this.method = method;
			this.token = new MetadataToken(TokenType.MethodDebugInformation, method.MetadataToken.RID);
		}

		public SequencePoint GetSequencePoint(Instruction instruction)
		{
			if (!HasSequencePoints)
				return null;

			for (int i = 0; i < sequence_points.Count; i++)
				if (sequence_points[i].Offset == instruction.Offset)
					return sequence_points[i];

			return null;
		}

		public IDictionary<Instruction, SequencePoint> GetSequencePointMapping()
		{
			var instruction_mapping = new Dictionary<Instruction, SequencePoint>();
			if (!HasSequencePoints || !method.HasBody)
				return instruction_mapping;

			var offset_mapping = new Dictionary<int, SequencePoint>(sequence_points.Count);

			for (int i = 0; i < sequence_points.Count; i++)
			{
				if (!offset_mapping.ContainsKey(sequence_points[i].Offset))
					offset_mapping.Add(sequence_points[i].Offset, sequence_points[i]);
			}

			var instructions = method.Body.Instructions;

			for (int i = 0; i < instructions.Count; i++)
			{
				SequencePoint sequence_point;
				if (offset_mapping.TryGetValue(instructions[i].Offset, out sequence_point))
					instruction_mapping.Add(instructions[i], sequence_point);
			}

			return instruction_mapping;
		}

		public IEnumerable<ScopeDebugInformation> GetScopes()
		{
			if (scope == null)
				return Empty<ScopeDebugInformation>.Array;

			return GetScopes(new[] { scope });
		}

		static IEnumerable<ScopeDebugInformation> GetScopes(IList<ScopeDebugInformation> scopes)
		{
			for (int i = 0; i < scopes.Count; i++)
			{
				var scope = scopes[i];

				yield return scope;

				if (!scope.HasScopes)
					continue;

				foreach (var sub_scope in GetScopes(scope.Scopes))
					yield return sub_scope;
			}
		}

		public bool TryGetName(VariableDefinition variable, out string name)
		{
			name = null;

			var has_name = false;
			var unique_name = "";

			foreach (var scope in GetScopes())
			{
				string slot_name;
				if (!scope.TryGetName(variable, out slot_name))
					continue;

				if (!has_name)
				{
					has_name = true;
					unique_name = slot_name;
					continue;
				}

				if (unique_name != slot_name)
					return false;
			}

			name = unique_name;
			return has_name;
		}
	}

	public interface ISymbolReader : IDisposable
	{

		ISymbolWriterProvider GetWriterProvider();
		bool ProcessDebugHeader(ImageDebugHeader header);
		MethodDebugInformation Read(MethodDefinition method);
	}

	public interface ISymbolReaderProvider
	{
		ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
		ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class SymbolsNotFoundException : FileNotFoundException
	{

		public SymbolsNotFoundException(string message) : base(message)
		{
		}

#if !NET_CORE
		SymbolsNotFoundException(
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base(info, context)
		{
		}
#endif
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class SymbolsNotMatchingException : InvalidOperationException
	{

		public SymbolsNotMatchingException(string message) : base(message)
		{
		}

#if !NET_CORE
		SymbolsNotMatchingException(
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base(info, context)
		{
		}
#endif
	}

	public class DefaultSymbolReaderProvider : ISymbolReaderProvider
	{

		readonly bool throw_if_no_symbol;

		public DefaultSymbolReaderProvider()
			: this(throwIfNoSymbol: true)
		{
		}

		public DefaultSymbolReaderProvider(bool throwIfNoSymbol)
		{
			throw_if_no_symbol = throwIfNoSymbol;
		}

		public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
		{
			if (module.Image.HasDebugTables())
				return null;

			if (module.HasDebugHeader)
			{
				var header = module.GetDebugHeader();
				var entry = header.GetEmbeddedPortablePdbEntry();
				if (entry != null)
					return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, fileName);
			}

			var pdb_file_name = Mixin.GetPdbFileName(fileName);

			if (File.Exists(pdb_file_name))
			{
				if (Mixin.IsPortablePdb(Mixin.GetPdbFileName(fileName)))
					return new PortablePdbReaderProvider().GetSymbolReader(module, fileName);

				try
				{
					return SymbolProvider.GetReaderProvider(SymbolKind.NativePdb).GetSymbolReader(module, fileName);
				}
				catch (Exception)
				{
					// We might not include support for native pdbs.
				}
			}

			var mdb_file_name = Mixin.GetMdbFileName(fileName);
			if (File.Exists(mdb_file_name))
			{
				try
				{
					return SymbolProvider.GetReaderProvider(SymbolKind.Mdb).GetSymbolReader(module, fileName);
				}
				catch (Exception)
				{
					// We might not include support for mdbs.
				}
			}

			if (throw_if_no_symbol)
				throw new SymbolsNotFoundException(string.Format("No symbol found for file: {0}", fileName));

			return null;
		}

		public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
		{
			if (module.Image.HasDebugTables())
				return null;

			if (module.HasDebugHeader)
			{
				var header = module.GetDebugHeader();
				var entry = header.GetEmbeddedPortablePdbEntry();
				if (entry != null)
					return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, "");
			}

			Mixin.CheckStream(symbolStream);
			Mixin.CheckReadSeek(symbolStream);

			var position = symbolStream.Position;

			const int portablePdbHeader = 0x424a5342;

			var reader = new BinaryStreamReader(symbolStream);
			var intHeader = reader.ReadInt32();
			symbolStream.Position = position;

			if (intHeader == portablePdbHeader)
			{
				return new PortablePdbReaderProvider().GetSymbolReader(module, symbolStream);
			}

			const string nativePdbHeader = "Microsoft C/C++ MSF 7.00";

			var bytesHeader = reader.ReadBytes(nativePdbHeader.Length);
			symbolStream.Position = position;
			var isNativePdb = true;

			for (var i = 0; i < bytesHeader.Length; i++)
			{
				if (bytesHeader[i] != (byte)nativePdbHeader[i])
				{
					isNativePdb = false;
					break;
				}
			}

			if (isNativePdb)
			{
				try
				{
					return SymbolProvider.GetReaderProvider(SymbolKind.NativePdb).GetSymbolReader(module, symbolStream);
				}
				catch (Exception)
				{
					// We might not include support for native pdbs.
				}
			}

			const long mdbHeader = 0x45e82623fd7fa614;

			var longHeader = reader.ReadInt64();
			symbolStream.Position = position;

			if (longHeader == mdbHeader)
			{
				try
				{
					return SymbolProvider.GetReaderProvider(SymbolKind.Mdb).GetSymbolReader(module, symbolStream);
				}
				catch (Exception)
				{
					// We might not include support for mdbs.
				}
			}

			if (throw_if_no_symbol)
				throw new SymbolsNotFoundException(string.Format("No symbols found in stream"));

			return null;
		}
	}

	enum SymbolKind
	{
		NativePdb,
		PortablePdb,
		EmbeddedPortablePdb,
		Mdb,
	}

	static class SymbolProvider
	{

		static SR.AssemblyName GetSymbolAssemblyName(SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb)
				throw new ArgumentException();

			var suffix = GetSymbolNamespace(kind);

			var cecil_name = typeof(SymbolProvider).Assembly.GetName();

			var name = new SR.AssemblyName
			{
				Name = cecil_name.Name + "." + suffix,
				Version = cecil_name.Version,
#if NET_CORE
				CultureName = cecil_name.CultureName,
#else
				CultureInfo = cecil_name.CultureInfo,
#endif
			};

			name.SetPublicKeyToken(cecil_name.GetPublicKeyToken());

			return name;
		}

		static Type GetSymbolType(SymbolKind kind, string fullname)
		{
			var type = Type.GetType(fullname);
			if (type != null)
				return type;

			var assembly_name = GetSymbolAssemblyName(kind);

			type = Type.GetType(fullname + ", " + assembly_name.FullName);
			if (type != null)
				return type;

			try
			{
				var assembly = SR.Assembly.Load(assembly_name);
				if (assembly != null)
					return assembly.GetType(fullname);
			}
			catch (FileNotFoundException)
			{
			}
			catch (FileLoadException)
			{
			}

			return null;
		}

		public static ISymbolReaderProvider GetReaderProvider(SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb)
				return new PortablePdbReaderProvider();
			if (kind == SymbolKind.EmbeddedPortablePdb)
				return new EmbeddedPortablePdbReaderProvider();

			var provider_name = GetSymbolTypeName(kind, "ReaderProvider");
			var type = GetSymbolType(kind, provider_name);
			if (type == null)
				throw new TypeLoadException("Could not find symbol provider type " + provider_name);

			return (ISymbolReaderProvider)Activator.CreateInstance(type);
		}

		static string GetSymbolTypeName(SymbolKind kind, string name)
		{
			return "Mono.Cecil" + "." + GetSymbolNamespace(kind) + "." + kind + name;
		}

		static string GetSymbolNamespace(SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb || kind == SymbolKind.EmbeddedPortablePdb)
				return "Cil";
			if (kind == SymbolKind.NativePdb)
				return "Pdb";
			if (kind == SymbolKind.Mdb)
				return "Mdb";

			throw new ArgumentException();
		}
	}

	public interface ISymbolWriter : IDisposable
	{

		ISymbolReaderProvider GetReaderProvider();
		ImageDebugHeader GetDebugHeader();
		void Write(MethodDebugInformation info);
	}

	public interface ISymbolWriterProvider
	{

		ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
		ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
	}

	public class DefaultSymbolWriterProvider : ISymbolWriterProvider
	{

		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
		{
			var reader = module.SymbolReader;
			if (reader == null)
				throw new InvalidOperationException();

			if (module.Image != null && module.Image.HasDebugTables())
				return null;

			return reader.GetWriterProvider().GetSymbolWriter(module, fileName);
		}

		public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException();
		}
	}
}

namespace Mono.Cecil
{

	static partial class Mixin
	{

		public static ImageDebugHeaderEntry GetCodeViewEntry(this ImageDebugHeader header)
		{
			return GetEntry(header, ImageDebugType.CodeView);
		}

		public static ImageDebugHeaderEntry GetDeterministicEntry(this ImageDebugHeader header)
		{
			return GetEntry(header, ImageDebugType.Deterministic);
		}

		public static ImageDebugHeader AddDeterministicEntry(this ImageDebugHeader header)
		{
			var entry = new ImageDebugHeaderEntry(new ImageDebugDirectory { Type = ImageDebugType.Deterministic }, Empty<byte>.Array);
			if (header == null)
				return new ImageDebugHeader(entry);

			var entries = new ImageDebugHeaderEntry[header.Entries.Length + 1];
			Array.Copy(header.Entries, entries, header.Entries.Length);
			entries[entries.Length - 1] = entry;
			return new ImageDebugHeader(entries);
		}

		public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(this ImageDebugHeader header)
		{
			return GetEntry(header, ImageDebugType.EmbeddedPortablePdb);
		}

		private static ImageDebugHeaderEntry GetEntry(this ImageDebugHeader header, ImageDebugType type)
		{
			if (!header.HasEntries)
				return null;

			for (var i = 0; i < header.Entries.Length; i++)
			{
				var entry = header.Entries[i];
				if (entry.Directory.Type == type)
					return entry;
			}

			return null;
		}

		public static string GetPdbFileName(string assemblyFileName)
		{
			return Path.ChangeExtension(assemblyFileName, ".pdb");
		}

		public static string GetMdbFileName(string assemblyFileName)
		{
			return assemblyFileName + ".mdb";
		}

		public static bool IsPortablePdb(string fileName)
		{
			using (var file = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
				return IsPortablePdb(file);
		}

		public static bool IsPortablePdb(Stream stream)
		{
			const uint ppdb_signature = 0x424a5342;

			if (stream.Length < 4) return false;
			var position = stream.Position;
			try
			{
				var reader = new BinaryReader(stream);
				return reader.ReadUInt32() == ppdb_signature;
			}
			finally
			{
				stream.Position = position;
			}
		}
	}
}
//
// SymbolWriterImpl.cs
//
// Author:
//   Lluis Sanchez Gual (lluis@novell.com)
//
// (C) 2005 Novell, Inc.  http://www.novell.com
//
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if !NET_CORE









namespace Mono.CompilerServices.SymbolWriter
{
	public class SymbolWriterImpl : Mono.Cecil.Cil.ISymbolWriter
	{
		public void Write(MethodDebugInformation mdi) { return; }
		public ISymbolReaderProvider GetReaderProvider() { return default(ISymbolReaderProvider); }
		public ImageDebugHeader GetDebugHeader() { return default(ImageDebugHeader); }
		public void Dispose() { return; }
		MonoSymbolWriter msw;

		int nextLocalIndex;
		int currentToken;
		string methodName;
		Stack namespaceStack = new Stack();
		bool methodOpened;

		Hashtable documents = new Hashtable();

#if !CECIL
		ModuleBuilder mb;
		delegate Guid GetGuidFunc(ModuleBuilder mb);
		GetGuidFunc get_guid_func;

		public SymbolWriterImpl(ModuleBuilder mb)
		{
			this.mb = mb;
		}

		public void Close()
		{
			MethodInfo mi = typeof(ModuleBuilder).GetMethod(
				"Mono_GetGuid",
				BindingFlags.Static | BindingFlags.NonPublic);
			if (mi == null)
				return;

			get_guid_func = (GetGuidFunc)System.Delegate.CreateDelegate(
				typeof(GetGuidFunc), mi);

			msw.WriteSymbolFile(get_guid_func(mb));
		}
#else
		Guid guid;

		public SymbolWriterImpl (Guid guid)
		{
			this.guid = guid;
		}

		public void Close ()
		{
			msw.WriteSymbolFile (guid);
		}
#endif

		public void CloseMethod()
		{
			if (methodOpened)
			{
				methodOpened = false;
				nextLocalIndex = 0;
				msw.CloseMethod();
			}
		}

		public void CloseNamespace()
		{
			namespaceStack.Pop();
			msw.CloseNamespace();
		}

		public void CloseScope(int endOffset)
		{
			msw.CloseScope(endOffset);
		}

		public ISymbolDocumentWriter DefineDocument(
			string url,
			Guid language,
			Guid languageVendor,
			Guid documentType)
		{
			SymbolDocumentWriterImpl doc = (SymbolDocumentWriterImpl)documents[url];
			if (doc == null)
			{
				SourceFileEntry entry = msw.DefineDocument(url);
				CompileUnitEntry comp_unit = msw.DefineCompilationUnit(entry);
				doc = new SymbolDocumentWriterImpl(comp_unit);
				documents[url] = doc;
			}
			return doc;
		}

		public void DefineField(
			SymbolToken parent,
			string name,
			FieldAttributes attributes,
			byte[] signature,
			SymAddressKind addrKind,
			int addr1,
			int addr2,
			int addr3)
		{
		}

		public void DefineGlobalVariable(
			string name,
			FieldAttributes attributes,
			byte[] signature,
			SymAddressKind addrKind,
			int addr1,
			int addr2,
			int addr3)
		{
		}

		public void DefineLocalVariable(
			string name,
			FieldAttributes attributes,
			byte[] signature,
			SymAddressKind addrKind,
			int addr1,
			int addr2,
			int addr3,
			int startOffset,
			int endOffset)
		{
			msw.DefineLocalVariable(nextLocalIndex++, name);
		}

		public void DefineParameter(
			string name,
			Mono.Cecil.ParameterAttributes attributes,
			int sequence,
			SymAddressKind addrKind,
			int addr1,
			int addr2,
			int addr3)
		{
		}

		public void DefineSequencePoints(
			ISymbolDocumentWriter document,
			int[] offsets,
			int[] lines,
			int[] columns,
			int[] endLines,
			int[] endColumns)
		{
			SymbolDocumentWriterImpl doc = (SymbolDocumentWriterImpl)document;
			SourceFileEntry file = doc != null ? doc.Entry.SourceFile : null;

			for (int n = 0; n < offsets.Length; n++)
			{
				if (n > 0 && offsets[n] == offsets[n - 1] && lines[n] == lines[n - 1] && columns[n] == columns[n - 1])
					continue;
				msw.MarkSequencePoint(offsets[n], file, lines[n], columns[n], false);
			}
		}

		public void Initialize(IntPtr emitter, string filename, bool fFullBuild)
		{
			msw = new MonoSymbolWriter(filename);
		}

		public void OpenMethod(SymbolToken method)
		{
			currentToken = method.GetToken();
		}

		public void OpenNamespace(string name)
		{
			NamespaceInfo n = new NamespaceInfo();
			n.NamespaceID = -1;
			n.Name = name;
			namespaceStack.Push(n);
		}

		public int OpenScope(int startOffset)
		{
			return msw.OpenScope(startOffset);
		}

		public void SetMethodSourceRange(
			ISymbolDocumentWriter startDoc,
			int startLine,
			int startColumn,
			ISymbolDocumentWriter endDoc,
			int endLine,
			int endColumn)
		{
			int nsId = GetCurrentNamespace(startDoc);
			SourceMethodImpl sm = new SourceMethodImpl(methodName, currentToken, nsId);
			msw.OpenMethod(((ICompileUnit)startDoc).Entry, nsId, sm);
			methodOpened = true;
		}

		public void SetScopeRange(int scopeID, int startOffset, int endOffset)
		{
		}

		public void SetSymAttribute(SymbolToken parent, string name, byte[] data)
		{
			// This is a hack! but MonoSymbolWriter needs the method name
			// and ISymbolWriter does not have any method for providing it
			if (name == "__name")
				methodName = System.Text.Encoding.UTF8.GetString(data);
		}

		public void SetUnderlyingWriter(IntPtr underlyingWriter)
		{
		}

		public void SetUserEntryPoint(SymbolToken entryMethod)
		{
		}

		public void UsingNamespace(string fullName)
		{
			if (namespaceStack.Count == 0)
			{
				OpenNamespace("");
			}

			NamespaceInfo ni = (NamespaceInfo)namespaceStack.Peek();
			if (ni.NamespaceID != -1)
			{
				NamespaceInfo old = ni;
				CloseNamespace();
				OpenNamespace(old.Name);
				ni = (NamespaceInfo)namespaceStack.Peek();
				ni.UsingClauses = old.UsingClauses;
			}
			ni.UsingClauses.Add(fullName);
		}

		int GetCurrentNamespace(ISymbolDocumentWriter doc)
		{
			if (namespaceStack.Count == 0)
			{
				OpenNamespace("");
			}

			NamespaceInfo ni = (NamespaceInfo)namespaceStack.Peek();
			if (ni.NamespaceID == -1)
			{
				string[] usings = (string[])ni.UsingClauses.ToArray(typeof(string));

				int parentId = 0;
				if (namespaceStack.Count > 1)
				{
					namespaceStack.Pop();
					parentId = ((NamespaceInfo)namespaceStack.Peek()).NamespaceID;
					namespaceStack.Push(ni);
				}

				ni.NamespaceID = msw.DefineNamespace(ni.Name, ((ICompileUnit)doc).Entry, usings, parentId);
			}
			return ni.NamespaceID;
		}

	}

	class SymbolDocumentWriterImpl : ISymbolDocumentWriter, ISourceFile, ICompileUnit
	{
		CompileUnitEntry comp_unit;

		public SymbolDocumentWriterImpl(CompileUnitEntry comp_unit)
		{
			this.comp_unit = comp_unit;
		}

		public void SetCheckSum(Guid algorithmId, byte[] checkSum)
		{
		}

		public void SetSource(byte[] source)
		{
		}

		SourceFileEntry ISourceFile.Entry
		{
			get { return comp_unit.SourceFile; }
		}

		public CompileUnitEntry Entry
		{
			get { return comp_unit; }
		}
	}

	class SourceMethodImpl : IMethodDef
	{
		string name;
		int token;
		int namespaceID;

		public SourceMethodImpl(string name, int token, int namespaceID)
		{
			this.name = name;
			this.token = token;
			this.namespaceID = namespaceID;
		}

		public string Name
		{
			get { return name; }
		}

		public int NamespaceID
		{
			get { return namespaceID; }
		}

		public int Token
		{
			get { return token; }
		}
	}

	class NamespaceInfo
	{
		public string Name;
		public int NamespaceID;
		public ArrayList UsingClauses = new ArrayList();
	}
}

#endif
//
// Author:
//   Juerg Billeter (j@bitron.ch)
//
// (C) 2008 Juerg Billeter
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil.Pdb
{
	internal class SymDocumentWriter
	{
		readonly ISymUnmanagedDocumentWriter writer;

		public ISymUnmanagedDocumentWriter Writer
		{
			get { return writer; }
		}

		public SymDocumentWriter(ISymUnmanagedDocumentWriter writer)
		{
			this.writer = writer;
		}

		public void SetSource(byte[] source)
		{
			writer.SetSource((uint)source.Length, source);
		}

		public void SetCheckSum(Guid hashAlgo, byte[] checkSum)
		{
			writer.SetCheckSum(hashAlgo, (uint)checkSum.Length, checkSum);
		}
	}
}
//
// Author:
//   Juerg Billeter (j@bitron.ch)
//
// (C) 2008 Juerg Billeter
//
// Licensed under the MIT/X11 license.
//







namespace Mono.Cecil.Pdb
{
	internal class SymWriter
	{
		[DllImport("ole32.dll")]
		static extern int CoCreateInstance(
			[In] ref Guid rclsid,
			[In, MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter,
			[In] uint dwClsContext,
			[In] ref Guid riid,
			[Out, MarshalAs(UnmanagedType.Interface)] out object ppv);

		static Guid s_symUnmangedWriterIID = new Guid("0b97726e-9e6d-4f05-9a26-424022093caa");
		static Guid s_CorSymWriter_SxS_ClassID = new Guid("108296c1-281e-11d3-bd22-0000f80849bd");

		readonly ISymUnmanagedWriter2 writer;
		readonly Collection<ISymUnmanagedDocumentWriter> documents;

		public SymWriter()
		{
			object objWriter;
			CoCreateInstance(ref s_CorSymWriter_SxS_ClassID, null, 1, ref s_symUnmangedWriterIID, out objWriter);

			writer = (ISymUnmanagedWriter2)objWriter;
			documents = new Collection<ISymUnmanagedDocumentWriter>();
		}

		public byte[] GetDebugInfo(out ImageDebugDirectory idd)
		{
			int size;

			// get size of debug info
			writer.GetDebugInfo(out idd, 0, out size, null);

			byte[] debug_info = new byte[size];
			writer.GetDebugInfo(out idd, size, out size, debug_info);

			return debug_info;
		}

		public void DefineLocalVariable2(
			string name,
			VariableAttributes attributes,
			int sigToken,
			int addr1,
			int addr2,
			int addr3,
			int startOffset,
			int endOffset)
		{
			writer.DefineLocalVariable2(name, (int)attributes, sigToken, 1 /* ILOffset*/, addr1, addr2, addr3, startOffset, endOffset);
		}

		public void DefineConstant2(string name, object value, int sigToken)
		{
			if (value == null)
			{
				writer.DefineConstant2(name, 0, sigToken);
				return;
			}

			writer.DefineConstant2(name, value, sigToken);
		}

		public void Close()
		{
			writer.Close();
			Marshal.ReleaseComObject(writer);

			foreach (var document in documents)
				Marshal.ReleaseComObject(document);
		}

		public void CloseMethod()
		{
			writer.CloseMethod();
		}

		public void CloseNamespace()
		{
			writer.CloseNamespace();
		}

		public void CloseScope(int endOffset)
		{
			writer.CloseScope(endOffset);
		}

		public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
		{
			ISymUnmanagedDocumentWriter doc_writer;
			writer.DefineDocument(url, ref language, ref languageVendor, ref documentType, out doc_writer);

			documents.Add(doc_writer);
			return new SymDocumentWriter(doc_writer);
		}

		public void DefineSequencePoints(SymDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns)
		{
			writer.DefineSequencePoints(document.Writer, offsets.Length, offsets, lines, columns, endLines, endColumns);
		}

		public void Initialize(object emitter, string filename, bool fFullBuild)
		{
			writer.Initialize(emitter, filename, null, fFullBuild);
		}

		public void SetUserEntryPoint(int methodToken)
		{
			writer.SetUserEntryPoint(methodToken);
		}

		public void OpenMethod(int methodToken)
		{
			writer.OpenMethod(methodToken);
		}

		public void OpenNamespace(string name)
		{
			writer.OpenNamespace(name);
		}

		public int OpenScope(int startOffset)
		{
			int result;
			writer.OpenScope(startOffset, out result);
			return result;
		}

		public void UsingNamespace(string fullName)
		{
			writer.UsingNamespace(fullName);
		}

		public void DefineCustomMetadata(string name, byte[] metadata)
		{
			var handle = GCHandle.Alloc(metadata, GCHandleType.Pinned);
			writer.SetSymAttribute(0, name, (uint)metadata.Length, handle.AddrOfPinnedObject());
			handle.Free();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//




namespace Mono.Cecil.Metadata
{

	enum Table : byte
	{
		Module = 0x00,
		TypeRef = 0x01,
		TypeDef = 0x02,
		FieldPtr = 0x03,
		Field = 0x04,
		MethodPtr = 0x05,
		Method = 0x06,
		ParamPtr = 0x07,
		Param = 0x08,
		InterfaceImpl = 0x09,
		MemberRef = 0x0a,
		Constant = 0x0b,
		CustomAttribute = 0x0c,
		FieldMarshal = 0x0d,
		DeclSecurity = 0x0e,
		ClassLayout = 0x0f,
		FieldLayout = 0x10,
		StandAloneSig = 0x11,
		EventMap = 0x12,
		EventPtr = 0x13,
		Event = 0x14,
		PropertyMap = 0x15,
		PropertyPtr = 0x16,
		Property = 0x17,
		MethodSemantics = 0x18,
		MethodImpl = 0x19,
		ModuleRef = 0x1a,
		TypeSpec = 0x1b,
		ImplMap = 0x1c,
		FieldRVA = 0x1d,
		EncLog = 0x1e,
		EncMap = 0x1f,
		Assembly = 0x20,
		AssemblyProcessor = 0x21,
		AssemblyOS = 0x22,
		AssemblyRef = 0x23,
		AssemblyRefProcessor = 0x24,
		AssemblyRefOS = 0x25,
		File = 0x26,
		ExportedType = 0x27,
		ManifestResource = 0x28,
		NestedClass = 0x29,
		GenericParam = 0x2a,
		MethodSpec = 0x2b,
		GenericParamConstraint = 0x2c,

		Document = 0x30,
		MethodDebugInformation = 0x31,
		LocalScope = 0x32,
		LocalVariable = 0x33,
		LocalConstant = 0x34,
		ImportScope = 0x35,
		StateMachineMethod = 0x36,
		CustomDebugInformation = 0x37,
	}

	struct TableInformation
	{
		public uint Offset;
		public uint Length;
		public uint RowSize;

		public bool IsLarge
		{
			get { return Length > ushort.MaxValue; }
		}
	}

	sealed class TableHeap : Heap
	{

		public long Valid;
		public long Sorted;

		public readonly TableInformation[] Tables = new TableInformation[Mixin.TableCount];

		public TableInformation this[Table table]
		{
			get { return Tables[(int)table]; }
		}

		public TableHeap(byte[] data)
			: base(data)
		{
		}

		public bool HasTable(Table table)
		{
			return (Valid & (1L << (int)table)) != 0;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum TargetRuntime
	{
		Net_1_0,
		Net_1_1,
		Net_2_0,
		Net_4_0,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.PE
{

	enum TextSegment
	{
		ImportAddressTable,
		CLIHeader,
		Code,
		Resources,
		Data,
		StrongNameSignature,

		// Metadata
		MetadataHeader,
		TableHeap,
		StringHeap,
		UserStringHeap,
		GuidHeap,
		BlobHeap,
		PdbHeap,
		// End Metadata

		DebugDirectory,
		ImportDirectory,
		ImportHintNameTable,
		StartupStub,
	}

	sealed class TextMap
	{

		readonly Range[] map = new Range[17 /*Enum.GetValues (typeof (TextSegment)).Length*/];

		public void AddMap(TextSegment segment, int length)
		{
			map[(int)segment] = new Range(GetStart(segment), (uint)length);
		}

		public void AddMap(TextSegment segment, int length, int align)
		{
			align--;

			AddMap(segment, (length + align) & ~align);
		}

		public void AddMap(TextSegment segment, Range range)
		{
			map[(int)segment] = range;
		}

		public Range GetRange(TextSegment segment)
		{
			return map[(int)segment];
		}

		public DataDirectory GetDataDirectory(TextSegment segment)
		{
			var range = map[(int)segment];

			return new DataDirectory(range.Length == 0 ? 0 : range.Start, range.Length);
		}

		public RVA GetRVA(TextSegment segment)
		{
			return map[(int)segment].Start;
		}

		public RVA GetNextRVA(TextSegment segment)
		{
			var i = (int)segment;
			return map[i].Start + map[i].Length;
		}

		public int GetLength(TextSegment segment)
		{
			return (int)map[(int)segment].Length;
		}

		RVA GetStart(TextSegment segment)
		{
			var index = (int)segment;
			return index == 0 ? ImageWriter.text_rva : ComputeStart(index);
		}

		RVA ComputeStart(int index)
		{
			index--;
			return map[index].Start + map[index].Length;
		}

		public uint GetLength()
		{
			var range = map[(int)TextSegment.StartupStub];
			return range.Start - ImageWriter.text_rva + range.Length;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum TokenType : uint
	{
		Module = 0x00000000,
		TypeRef = 0x01000000,
		TypeDef = 0x02000000,
		Field = 0x04000000,
		Method = 0x06000000,
		Param = 0x08000000,
		InterfaceImpl = 0x09000000,
		MemberRef = 0x0a000000,
		CustomAttribute = 0x0c000000,
		Permission = 0x0e000000,
		Signature = 0x11000000,
		Event = 0x14000000,
		Property = 0x17000000,
		ModuleRef = 0x1a000000,
		TypeSpec = 0x1b000000,
		Assembly = 0x20000000,
		AssemblyRef = 0x23000000,
		File = 0x26000000,
		ExportedType = 0x27000000,
		ManifestResource = 0x28000000,
		GenericParam = 0x2a000000,
		MethodSpec = 0x2b000000,
		GenericParamConstraint = 0x2c000000,

		Document = 0x30000000,
		MethodDebugInformation = 0x31000000,
		LocalScope = 0x32000000,
		LocalVariable = 0x33000000,
		LocalConstant = 0x34000000,
		ImportScope = 0x35000000,
		StateMachineMethod = 0x36000000,
		CustomDebugInformation = 0x37000000,

		String = 0x70000000,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	enum TypeDefinitionTreatment
	{
		None = 0x0,

		KindMask = 0xf,
		NormalType = 0x1,
		NormalAttribute = 0x2,
		UnmangleWindowsRuntimeName = 0x3,
		PrefixWindowsRuntimeName = 0x4,
		RedirectToClrType = 0x5,
		RedirectToClrAttribute = 0x6,
		RedirectImplementedMethods = 0x7,

		Abstract = 0x10,
		Internal = 0x20,
	}

	enum TypeReferenceTreatment
	{
		None = 0x0,
		SystemDelegate = 0x1,
		SystemAttribute = 0x2,
		UseProjectionInfo = 0x3,
	}

	[Flags]
	enum MethodDefinitionTreatment
	{
		None = 0x0,
		Abstract = 0x2,
		Private = 0x4,
		Public = 0x8,
		Runtime = 0x10,
		InternalCall = 0x20,
	}

	enum FieldDefinitionTreatment
	{
		None = 0x0,
		Public = 0x1,
	}

	enum CustomAttributeValueTreatment
	{
		None = 0x0,
		AllowSingle = 0x1,
		AllowMultiple = 0x2,
		VersionAttribute = 0x3,
		DeprecatedAttribute = 0x4,
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//



namespace Mono.Cecil
{

	[Flags]
	public enum TypeAttributes : uint
	{
		// Visibility attributes
		VisibilityMask = 0x00000007,    // Use this mask to retrieve visibility information
		NotPublic = 0x00000000, // Class has no public scope
		Public = 0x00000001,    // Class has public scope
		NestedPublic = 0x00000002,  // Class is nested with public visibility
		NestedPrivate = 0x00000003, // Class is nested with private visibility
		NestedFamily = 0x00000004,  // Class is nested with family visibility
		NestedAssembly = 0x00000005,    // Class is nested with assembly visibility
		NestedFamANDAssem = 0x00000006, // Class is nested with family and assembly visibility
		NestedFamORAssem = 0x00000007,  // Class is nested with family or assembly visibility

		// Class layout attributes
		LayoutMask = 0x00000018,    // Use this mask to retrieve class layout information
		AutoLayout = 0x00000000,    // Class fields are auto-laid out
		SequentialLayout = 0x00000008,  // Class fields are laid out sequentially
		ExplicitLayout = 0x00000010,    // Layout is supplied explicitly

		// Class semantics attributes
		ClassSemanticMask = 0x00000020, // Use this mask to retrieve class semantics information
		Class = 0x00000000, // Type is a class
		Interface = 0x00000020, // Type is an interface

		// Special semantics in addition to class semantics
		Abstract = 0x00000080,  // Class is abstract
		Sealed = 0x00000100,    // Class cannot be extended
		SpecialName = 0x00000400,   // Class name is special

		// Implementation attributes
		Import = 0x00001000,    // Class/Interface is imported
		Serializable = 0x00002000,  // Class is serializable
		WindowsRuntime = 0x00004000,    // Windows Runtime type

		// String formatting attributes
		StringFormatMask = 0x00030000,  // Use this mask to retrieve string information for native interop
		AnsiClass = 0x00000000, // LPSTR is interpreted as ANSI
		UnicodeClass = 0x00010000,  // LPSTR is interpreted as Unicode
		AutoClass = 0x00020000, // LPSTR is interpreted automatically

		// Class initialization attributes
		BeforeFieldInit = 0x00100000,   // Initialize the class before first static field access

		// Additional flags
		RTSpecialName = 0x00000800, // CLI provides 'special' behavior, depending upon the name of the Type
		HasSecurity = 0x00040000,   // Type has security associate with it
		Forwarder = 0x00200000,   // Exported type is a type forwarder
	}
}
namespace Mono.Cecil
{
	internal enum TypeComparisonMode
	{
		Exact,
		SignatureOnly,

		/// <summary>
		/// Types can be in different assemblies, as long as the module, assembly, and type names match they will be considered equal
		/// </summary>
		SignatureOnlyLoose
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public sealed class TypeDefinition : TypeReference, IMemberDefinition, ISecurityDeclarationProvider
	{

		uint attributes;
		TypeReference base_type;
		internal Range fields_range;
		internal Range methods_range;

		short packing_size = Mixin.NotResolvedMarker;
		int class_size = Mixin.NotResolvedMarker;

		InterfaceImplementationCollection interfaces;
		Collection<TypeDefinition> nested_types;
		Collection<MethodDefinition> methods;
		Collection<FieldDefinition> fields;
		Collection<EventDefinition> events;
		Collection<PropertyDefinition> properties;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		public TypeAttributes Attributes
		{
			get { return (TypeAttributes)attributes; }
			set
			{
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException();

				attributes = (uint)value;
			}
		}

		public TypeReference BaseType
		{
			get { return base_type; }
			set { base_type = value; }
		}

		public override string Name
		{
			get { return base.Name; }
			set
			{
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException();

				base.Name = value;
			}
		}

		void ResolveLayout()
		{
			if (!HasImage)
			{
				packing_size = Mixin.NoDataMarker;
				class_size = Mixin.NoDataMarker;
				return;
			}

			lock (Module.SyncRoot)
			{
				if (packing_size != Mixin.NotResolvedMarker || class_size != Mixin.NotResolvedMarker)
					return;

				var row = Module.Read(this, (type, reader) => reader.ReadTypeLayout(type));

				packing_size = row.Col1;
				class_size = row.Col2;
			}
		}

		public bool HasLayoutInfo
		{
			get
			{
				if (packing_size >= 0 || class_size >= 0)
					return true;

				ResolveLayout();

				return packing_size >= 0 || class_size >= 0;
			}
		}

		public short PackingSize
		{
			get
			{
				if (packing_size >= 0)
					return packing_size;

				ResolveLayout();

				return packing_size >= 0 ? packing_size : (short)-1;
			}
			set { packing_size = value; }
		}

		public int ClassSize
		{
			get
			{
				if (class_size >= 0)
					return class_size;

				ResolveLayout();

				return class_size >= 0 ? class_size : -1;
			}
			set { class_size = value; }
		}

		public bool HasInterfaces
		{
			get
			{
				if (interfaces != null)
					return interfaces.Count > 0;

				return HasImage && Module.Read(this, (type, reader) => reader.HasInterfaces(type));
			}
		}

		public Collection<InterfaceImplementation> Interfaces
		{
			get
			{
				if (interfaces != null)
					return interfaces;

				if (HasImage)
					return Module.Read(ref interfaces, this, (type, reader) => reader.ReadInterfaces(type));

				Interlocked.CompareExchange(ref interfaces, new InterfaceImplementationCollection(this), null);
				return interfaces;
			}
		}

		public bool HasNestedTypes
		{
			get
			{
				if (nested_types != null)
					return nested_types.Count > 0;

				return HasImage && Module.Read(this, (type, reader) => reader.HasNestedTypes(type));
			}
		}

		public Collection<TypeDefinition> NestedTypes
		{
			get
			{
				if (nested_types != null)
					return nested_types;

				if (HasImage)
					return Module.Read(ref nested_types, this, (type, reader) => reader.ReadNestedTypes(type));

				Interlocked.CompareExchange(ref nested_types, new MemberDefinitionCollection<TypeDefinition>(this), null);
				return nested_types;
			}
		}

		public bool HasMethods
		{
			get
			{
				if (methods != null)
					return methods.Count > 0;

				return HasImage && methods_range.Length > 0;
			}
		}

		public Collection<MethodDefinition> Methods
		{
			get
			{
				if (methods != null)
					return methods;

				if (HasImage)
					return Module.Read(ref methods, this, (type, reader) => reader.ReadMethods(type));

				Interlocked.CompareExchange(ref methods, new MemberDefinitionCollection<MethodDefinition>(this), null);
				return methods;
			}
		}

		public bool HasFields
		{
			get
			{
				if (fields != null)
					return fields.Count > 0;

				return HasImage && fields_range.Length > 0;
			}
		}

		public Collection<FieldDefinition> Fields
		{
			get
			{
				if (fields != null)
					return fields;

				if (HasImage)
					return Module.Read(ref fields, this, (type, reader) => reader.ReadFields(type));

				Interlocked.CompareExchange(ref fields, new MemberDefinitionCollection<FieldDefinition>(this), null);
				return fields;
			}
		}

		public bool HasEvents
		{
			get
			{
				if (events != null)
					return events.Count > 0;

				return HasImage && Module.Read(this, (type, reader) => reader.HasEvents(type));
			}
		}

		public Collection<EventDefinition> Events
		{
			get
			{
				if (events != null)
					return events;

				if (HasImage)
					return Module.Read(ref events, this, (type, reader) => reader.ReadEvents(type));

				Interlocked.CompareExchange(ref events, new MemberDefinitionCollection<EventDefinition>(this), null);
				return events;
			}
		}

		public bool HasProperties
		{
			get
			{
				if (properties != null)
					return properties.Count > 0;

				return HasImage && Module.Read(this, (type, reader) => reader.HasProperties(type));
			}
		}

		public Collection<PropertyDefinition> Properties
		{
			get
			{
				if (properties != null)
					return properties;

				if (HasImage)
					return Module.Read(ref properties, this, (type, reader) => reader.ReadProperties(type));

				Interlocked.CompareExchange(ref properties, new MemberDefinitionCollection<PropertyDefinition>(this), null);
				return properties;
			}
		}

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations(Module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations
		{
			get { return security_declarations ?? (this.GetSecurityDeclarations(ref security_declarations, Module)); }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes(Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get { return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, Module)); }
		}

		public override bool HasGenericParameters
		{
			get
			{
				if (generic_parameters != null)
					return generic_parameters.Count > 0;

				return this.GetHasGenericParameters(Module);
			}
		}

		public override Collection<GenericParameter> GenericParameters
		{
			get { return generic_parameters ?? (this.GetGenericParameters(ref generic_parameters, Module)); }
		}

		#region TypeAttributes

		public bool IsNotPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic, value); }
		}

		public bool IsPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public, value); }
		}

		public bool IsNestedPublic
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic, value); }
		}

		public bool IsNestedPrivate
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate, value); }
		}

		public bool IsNestedFamily
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily, value); }
		}

		public bool IsNestedAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly, value); }
		}

		public bool IsNestedFamilyAndAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem, value); }
		}

		public bool IsNestedFamilyOrAssembly
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem, value); }
		}

		public bool IsAutoLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout, value); }
		}

		public bool IsSequentialLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout, value); }
		}

		public bool IsExplicitLayout
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout, value); }
		}

		public bool IsClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class, value); }
		}

		public bool IsInterface
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface, value); }
		}

		public bool IsAbstract
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Abstract); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Abstract, value); }
		}

		public bool IsSealed
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Sealed); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Sealed, value); }
		}

		public bool IsSpecialName
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.SpecialName, value); }
		}

		public bool IsImport
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Import); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Import, value); }
		}

		public bool IsSerializable
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.Serializable); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.Serializable, value); }
		}

		public bool IsWindowsRuntime
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.WindowsRuntime); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.WindowsRuntime, value); }
		}

		public bool IsAnsiClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass, value); }
		}

		public bool IsUnicodeClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass, value); }
		}

		public bool IsAutoClass
		{
			get { return attributes.GetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass); }
			set { attributes = attributes.SetMaskedAttributes((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass, value); }
		}

		public bool IsBeforeFieldInit
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.BeforeFieldInit); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.BeforeFieldInit, value); }
		}

		public bool IsRuntimeSpecialName
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity
		{
			get { return attributes.GetAttributes((uint)TypeAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes((uint)TypeAttributes.HasSecurity, value); }
		}

		#endregion

		public bool IsEnum
		{
			get { return base_type != null && base_type.IsTypeOf("System", "Enum"); }
		}

		public override bool IsValueType
		{
			get
			{
				if (base_type == null)
					return false;

				return base_type.IsTypeOf("System", "Enum") || (base_type.IsTypeOf("System", "ValueType") && !this.IsTypeOf("System", "Enum"));
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public override bool IsPrimitive
		{
			get
			{
				ElementType primitive_etype;
				return MetadataSystem.TryGetPrimitiveElementType(this, out primitive_etype) && primitive_etype.IsPrimitive();
			}
		}

		public override MetadataType MetadataType
		{
			get
			{
				ElementType primitive_etype;
				if (MetadataSystem.TryGetPrimitiveElementType(this, out primitive_etype))
					return (MetadataType)primitive_etype;

				return base.MetadataType;
			}
		}

		public override bool IsDefinition
		{
			get { return true; }
		}

		public new TypeDefinition DeclaringType
		{
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		internal new TypeDefinitionProjection WindowsRuntimeProjection
		{
			get { return (TypeDefinitionProjection)projection; }
			set { projection = value; }
		}

		public TypeDefinition(string @namespace, string name, TypeAttributes attributes)
			: base(@namespace, name)
		{
			this.attributes = (uint)attributes;
			this.token = new MetadataToken(TokenType.TypeDef);
		}

		public TypeDefinition(string @namespace, string name, TypeAttributes attributes, TypeReference baseType) :
			this(@namespace, name, attributes)
		{
			this.BaseType = baseType;
		}

		protected override void ClearFullName()
		{
			base.ClearFullName();

			if (!HasNestedTypes)
				return;

			var nested_types = this.NestedTypes;

			for (int i = 0; i < nested_types.Count; i++)
				nested_types[i].ClearFullName();
		}

		public override TypeDefinition Resolve()
		{
			return this;
		}
	}

	public sealed class InterfaceImplementation : ICustomAttributeProvider
	{
		internal TypeDefinition type;
		internal MetadataToken token;

		TypeReference interface_type;
		Collection<CustomAttribute> custom_attributes;

		public TypeReference InterfaceType
		{
			get { return interface_type; }
			set { interface_type = value; }
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				if (type == null)
					return false;

				return this.GetHasCustomAttributes(type.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes
		{
			get
			{
				if (type == null)
				{
					if (custom_attributes == null)
						Interlocked.CompareExchange(ref custom_attributes, new Collection<CustomAttribute>(), null);
					return custom_attributes;
				}

				return custom_attributes ?? (this.GetCustomAttributes(ref custom_attributes, type.Module));
			}
		}

		public MetadataToken MetadataToken
		{
			get { return token; }
			set { token = value; }
		}

		internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token)
		{
			this.interface_type = interfaceType;
			this.token = token;
		}

		public InterfaceImplementation(TypeReference interfaceType)
		{
			Mixin.CheckType(interfaceType, Mixin.Argument.interfaceType);

			this.interface_type = interfaceType;
			this.token = new MetadataToken(TokenType.InterfaceImpl);
		}
	}

	class InterfaceImplementationCollection : Collection<InterfaceImplementation>
	{
		readonly TypeDefinition type;

		internal InterfaceImplementationCollection(TypeDefinition type)
		{
			this.type = type;
		}

		internal InterfaceImplementationCollection(TypeDefinition type, int length)
			: base(length)
		{
			this.type = type;
		}

		protected override void OnAdd(InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnInsert(InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnSet(InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnRemove(InterfaceImplementation item, int index)
		{
			item.type = null;
		}
	}

	static partial class Mixin
	{

		public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
		{
			var fields = self.Fields;

			for (int i = 0; i < fields.Count; i++)
			{
				var field = fields[i];
				if (!field.IsStatic)
					return field.FieldType;
			}

			throw new ArgumentException();
		}

		public static TypeDefinition GetNestedType(this TypeDefinition self, string fullname)
		{
			if (!self.HasNestedTypes)
				return null;

			var nested_types = self.NestedTypes;

			for (int i = 0; i < nested_types.Count; i++)
			{
				var nested_type = nested_types[i];

				if (nested_type.TypeFullName() == fullname)
					return nested_type;
			}

			return null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//








namespace Mono.Cecil
{



	sealed class TypeDefinitionCollection : Collection<TypeDefinition>
	{

		readonly ModuleDefinition container;
		readonly Dictionary<Slot, TypeDefinition> name_cache;

		internal TypeDefinitionCollection(ModuleDefinition container)
		{
			this.container = container;
			this.name_cache = new Dictionary<Slot, TypeDefinition>(new RowEqualityComparer());
		}

		internal TypeDefinitionCollection(ModuleDefinition container, int capacity)
			: base(capacity)
		{
			this.container = container;
			this.name_cache = new Dictionary<Slot, TypeDefinition>(capacity, new RowEqualityComparer());
		}

		protected override void OnAdd(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnSet(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnInsert(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnRemove(TypeDefinition item, int index)
		{
			Detach(item);
		}

		protected override void OnClear()
		{
			foreach (var type in this)
				Detach(type);
		}

		void Attach(TypeDefinition type)
		{
			if (type.Module != null && type.Module != container)
				throw new ArgumentException("Type already attached");

			type.module = container;
			type.scope = container;
			name_cache[new Slot(type.Namespace, type.Name)] = type;
		}

		void Detach(TypeDefinition type)
		{
			type.module = null;
			type.scope = null;
			name_cache.Remove(new Slot(type.Namespace, type.Name));
		}

		public TypeDefinition GetType(string fullname)
		{
			string @namespace, name;
			TypeParser.SplitFullName(fullname, out @namespace, out name);

			return GetType(@namespace, name);
		}

		public TypeDefinition GetType(string @namespace, string name)
		{
			TypeDefinition type;
			if (name_cache.TryGetValue(new Slot(@namespace, name), out type))
				return type;

			return null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class TypeDefinitionRocks
	{

		public static IEnumerable<MethodDefinition> GetConstructors(this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			if (!self.HasMethods)
				return Empty<MethodDefinition>.Array;

			return self.Methods.Where(method => method.IsConstructor);
		}

		public static MethodDefinition GetStaticConstructor(this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			if (!self.HasMethods)
				return null;

			return self.GetConstructors().FirstOrDefault(ctor => ctor.IsStatic);
		}

		public static IEnumerable<MethodDefinition> GetMethods(this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");

			if (!self.HasMethods)
				return Empty<MethodDefinition>.Array;

			return self.Methods.Where(method => !method.IsConstructor);
		}

		public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException("self");
			if (!self.IsEnum)
				throw new ArgumentException();

			return Mixin.GetEnumUnderlyingType(self);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	class TypeParser
	{

		class Type
		{
			public const int Ptr = -1;
			public const int ByRef = -2;
			public const int SzArray = -3;

			public string type_fullname;
			public string[] nested_names;
			public int arity;
			public int[] specs;
			public Type[] generic_arguments;
			public string assembly;
		}

		readonly string fullname;
		readonly int length;

		int position;

		TypeParser(string fullname)
		{
			this.fullname = fullname;
			this.length = fullname.Length;
		}

		Type ParseType(bool fq_name)
		{
			var type = new Type();
			type.type_fullname = ParsePart();

			type.nested_names = ParseNestedNames();

			if (TryGetArity(type))
				type.generic_arguments = ParseGenericArguments(type.arity);

			type.specs = ParseSpecs();

			if (fq_name)
				type.assembly = ParseAssemblyName();

			return type;
		}

		static bool TryGetArity(Type type)
		{
			int arity = 0;

			TryAddArity(type.type_fullname, ref arity);

			var nested_names = type.nested_names;
			if (!nested_names.IsNullOrEmpty())
			{
				for (int i = 0; i < nested_names.Length; i++)
					TryAddArity(nested_names[i], ref arity);
			}

			type.arity = arity;
			return arity > 0;
		}

		static bool TryGetArity(string name, out int arity)
		{
			arity = 0;
			var index = name.LastIndexOf('`');
			if (index == -1)
				return false;

			return ParseInt32(name.Substring(index + 1), out arity);
		}

		static bool ParseInt32(string value, out int result)
		{
			return int.TryParse(value, out result);
		}

		static void TryAddArity(string name, ref int arity)
		{
			int type_arity;
			if (!TryGetArity(name, out type_arity))
				return;

			arity += type_arity;
		}

		string ParsePart()
		{
			var part = new StringBuilder();
			while (position < length && !IsDelimiter(fullname[position]))
			{
				if (fullname[position] == '\\')
					position++;

				part.Append(fullname[position++]);
			}

			return part.ToString();
		}

		static bool IsDelimiter(char chr)
		{
			return "+,[]*&".IndexOf(chr) != -1;
		}

		void TryParseWhiteSpace()
		{
			while (position < length && Char.IsWhiteSpace(fullname[position]))
				position++;
		}

		string[] ParseNestedNames()
		{
			string[] nested_names = null;
			while (TryParse('+'))
				Add(ref nested_names, ParsePart());

			return nested_names;
		}

		bool TryParse(char chr)
		{
			if (position < length && fullname[position] == chr)
			{
				position++;
				return true;
			}

			return false;
		}

		static void Add<T>(ref T[] array, T item)
		{
			array = array.Add(item);
		}

		int[] ParseSpecs()
		{
			int[] specs = null;

			while (position < length)
			{
				switch (fullname[position])
				{
					case '*':
						position++;
						Add(ref specs, Type.Ptr);
						break;
					case '&':
						position++;
						Add(ref specs, Type.ByRef);
						break;
					case '[':
						position++;
						switch (fullname[position])
						{
							case ']':
								position++;
								Add(ref specs, Type.SzArray);
								break;
							case '*':
								position++;
								Add(ref specs, 1);
								break;
							default:
								var rank = 1;
								while (TryParse(','))
									rank++;

								Add(ref specs, rank);

								TryParse(']');
								break;
						}
						break;
					default:
						return specs;
				}
			}

			return specs;
		}

		Type[] ParseGenericArguments(int arity)
		{
			Type[] generic_arguments = null;

			if (position == length || fullname[position] != '[')
				return generic_arguments;

			TryParse('[');

			for (int i = 0; i < arity; i++)
			{
				var fq_argument = TryParse('[');
				Add(ref generic_arguments, ParseType(fq_argument));
				if (fq_argument)
					TryParse(']');

				TryParse(',');
				TryParseWhiteSpace();
			}

			TryParse(']');

			return generic_arguments;
		}

		string ParseAssemblyName()
		{
			if (!TryParse(','))
				return string.Empty;

			TryParseWhiteSpace();

			var start = position;
			while (position < length)
			{
				var chr = fullname[position];
				if (chr == '[' || chr == ']')
					break;

				position++;
			}

			return fullname.Substring(start, position - start);
		}

		public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly = false)
		{
			if (string.IsNullOrEmpty(fullname))
				return null;

			var parser = new TypeParser(fullname);
			return GetTypeReference(module, parser.ParseType(true), typeDefinitionOnly);
		}

		static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only)
		{
			TypeReference type;
			if (!TryGetDefinition(module, type_info, out type))
			{
				if (type_def_only)
					return null;

				type = CreateReference(type_info, module, GetMetadataScope(module, type_info));
			}

			return CreateSpecs(type, type_info);
		}

		static TypeReference CreateSpecs(TypeReference type, Type type_info)
		{
			type = TryCreateGenericInstanceType(type, type_info);

			var specs = type_info.specs;
			if (specs.IsNullOrEmpty())
				return type;

			for (int i = 0; i < specs.Length; i++)
			{
				switch (specs[i])
				{
					case Type.Ptr:
						type = new PointerType(type);
						break;
					case Type.ByRef:
						type = new ByReferenceType(type);
						break;
					case Type.SzArray:
						type = new ArrayType(type);
						break;
					default:
						var array = new ArrayType(type);
						array.Dimensions.Clear();

						for (int j = 0; j < specs[i]; j++)
							array.Dimensions.Add(new ArrayDimension());

						type = array;
						break;
				}
			}

			return type;
		}

		static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
		{
			var generic_arguments = type_info.generic_arguments;
			if (generic_arguments.IsNullOrEmpty())
				return type;

			var instance = new GenericInstanceType(type, generic_arguments.Length);
			var instance_arguments = instance.GenericArguments;

			for (int i = 0; i < generic_arguments.Length; i++)
				instance_arguments.Add(GetTypeReference(type.Module, generic_arguments[i], false));

			return instance;
		}

		public static void SplitFullName(string fullname, out string @namespace, out string name)
		{
			var last_dot = fullname.LastIndexOf('.');

			if (last_dot == -1)
			{
				@namespace = string.Empty;
				name = fullname;
			}
			else
			{
				@namespace = fullname.Substring(0, last_dot);
				name = fullname.Substring(last_dot + 1);
			}
		}

		static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
		{
			string @namespace, name;
			SplitFullName(type_info.type_fullname, out @namespace, out name);

			var type = new TypeReference(@namespace, name, module, scope);
			MetadataSystem.TryProcessPrimitiveTypeReference(type);

			AdjustGenericParameters(type);

			var nested_names = type_info.nested_names;
			if (nested_names.IsNullOrEmpty())
				return type;

			for (int i = 0; i < nested_names.Length; i++)
			{
				type = new TypeReference(string.Empty, nested_names[i], module, null)
				{
					DeclaringType = type,
				};

				AdjustGenericParameters(type);
			}

			return type;
		}

		static void AdjustGenericParameters(TypeReference type)
		{
			int arity;
			if (!TryGetArity(type.Name, out arity))
				return;

			for (int i = 0; i < arity; i++)
				type.GenericParameters.Add(new GenericParameter(type));
		}

		static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty(type_info.assembly))
				return module.TypeSystem.CoreLibrary;

			AssemblyNameReference match;
			var reference = AssemblyNameReference.Parse(type_info.assembly);

			return module.TryGetAssemblyNameReference(reference, out match)
				? match
				: reference;
		}

		static bool TryGetDefinition(ModuleDefinition module, Type type_info, out TypeReference type)
		{
			type = null;
			if (!TryCurrentModule(module, type_info))
				return false;

			var typedef = module.GetType(type_info.type_fullname);
			if (typedef == null)
				return false;

			var nested_names = type_info.nested_names;
			if (!nested_names.IsNullOrEmpty())
			{
				for (int i = 0; i < nested_names.Length; i++)
				{
					var nested_type = typedef.GetNestedType(nested_names[i]);
					if (nested_type == null)
						return false;

					typedef = nested_type;
				}
			}

			type = typedef;
			return true;
		}

		static bool TryCurrentModule(ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty(type_info.assembly))
				return true;

			if (module.assembly != null && module.assembly.Name.FullName == type_info.assembly)
				return true;

			return false;
		}

		public static string ToParseable(TypeReference type, bool top_level = true)
		{
			if (type == null)
				return null;

			var name = new StringBuilder();
			AppendType(type, name, true, top_level);
			return name.ToString();
		}

		static void AppendNamePart(string part, StringBuilder name)
		{
			foreach (var c in part)
			{
				if (IsDelimiter(c))
					name.Append('\\');

				name.Append(c);
			}
		}

		static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
		{
			var element_type = type.GetElementType();

			var declaring_type = element_type.DeclaringType;
			if (declaring_type != null)
			{
				AppendType(declaring_type, name, false, top_level);
				name.Append('+');
			}

			var @namespace = type.Namespace;
			if (!string.IsNullOrEmpty(@namespace))
			{
				AppendNamePart(@namespace, name);
				name.Append('.');
			}

			AppendNamePart(element_type.Name, name);

			if (!fq_name)
				return;

			if (type.IsTypeSpecification())
				AppendTypeSpecification((TypeSpecification)type, name);

			if (RequiresFullyQualifiedName(type, top_level))
			{
				name.Append(", ");
				name.Append(GetScopeFullName(type));
			}
		}

		static string GetScopeFullName(TypeReference type)
		{
			var scope = type.Scope;
			switch (scope.MetadataScopeType)
			{
				case MetadataScopeType.AssemblyNameReference:
					return ((AssemblyNameReference)scope).FullName;
				case MetadataScopeType.ModuleDefinition:
					return ((ModuleDefinition)scope).Assembly.Name.FullName;
			}

			throw new ArgumentException();
		}

		static void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
		{
			if (type.ElementType.IsTypeSpecification())
				AppendTypeSpecification((TypeSpecification)type.ElementType, name);

			switch (type.etype)
			{
				case ElementType.Ptr:
					name.Append('*');
					break;
				case ElementType.ByRef:
					name.Append('&');
					break;
				case ElementType.SzArray:
				case ElementType.Array:
					var array = (ArrayType)type;
					if (array.IsVector)
					{
						name.Append("[]");
					}
					else
					{
						name.Append('[');
						for (int i = 1; i < array.Rank; i++)
							name.Append(',');
						name.Append(']');
					}
					break;
				case ElementType.GenericInst:
					var instance = (GenericInstanceType)type;
					var arguments = instance.GenericArguments;

					name.Append('[');

					for (int i = 0; i < arguments.Count; i++)
					{
						if (i > 0)
							name.Append(',');

						var argument = arguments[i];
						var requires_fqname = argument.Scope != argument.Module;

						if (requires_fqname)
							name.Append('[');

						AppendType(argument, name, true, false);

						if (requires_fqname)
							name.Append(']');
					}

					name.Append(']');
					break;
				default:
					return;
			}
		}

		static bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
		{
			if (type.Scope == type.Module)
				return false;

			if (type.Scope.Name == "mscorlib" && top_level)
				return false;

			return true;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	public enum MetadataType : byte
	{
		Void = ElementType.Void,
		Boolean = ElementType.Boolean,
		Char = ElementType.Char,
		SByte = ElementType.I1,
		Byte = ElementType.U1,
		Int16 = ElementType.I2,
		UInt16 = ElementType.U2,
		Int32 = ElementType.I4,
		UInt32 = ElementType.U4,
		Int64 = ElementType.I8,
		UInt64 = ElementType.U8,
		Single = ElementType.R4,
		Double = ElementType.R8,
		String = ElementType.String,
		Pointer = ElementType.Ptr,
		ByReference = ElementType.ByRef,
		ValueType = ElementType.ValueType,
		Class = ElementType.Class,
		Var = ElementType.Var,
		Array = ElementType.Array,
		GenericInstance = ElementType.GenericInst,
		TypedByReference = ElementType.TypedByRef,
		IntPtr = ElementType.I,
		UIntPtr = ElementType.U,
		FunctionPointer = ElementType.FnPtr,
		Object = ElementType.Object,
		MVar = ElementType.MVar,
		RequiredModifier = ElementType.CModReqD,
		OptionalModifier = ElementType.CModOpt,
		Sentinel = ElementType.Sentinel,
		Pinned = ElementType.Pinned,
	}

	public class TypeReference : MemberReference, IGenericParameterProvider, IGenericContext
	{

		string @namespace;
		bool value_type;
		internal IMetadataScope scope;
		internal ModuleDefinition module;

		internal ElementType etype = ElementType.None;

		string fullname;

		protected Collection<GenericParameter> generic_parameters;

		public override string Name
		{
			get { return base.Name; }
			set
			{
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException("Projected type reference name can't be changed.");
				base.Name = value;
				ClearFullName();
			}
		}

		public virtual string Namespace
		{
			get { return @namespace; }
			set
			{
				if (IsWindowsRuntimeProjection && value != @namespace)
					throw new InvalidOperationException("Projected type reference namespace can't be changed.");
				@namespace = value;
				ClearFullName();
			}
		}

		public virtual bool IsValueType
		{
			get { return value_type; }
			set { value_type = value; }
		}

		public override ModuleDefinition Module
		{
			get
			{
				if (module != null)
					return module;

				var declaring_type = this.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Module;

				return null;
			}
		}

		internal TypeReferenceProjection WindowsRuntimeProjection
		{
			get { return (TypeReferenceProjection)projection; }
			set { projection = value; }
		}

		IGenericParameterProvider IGenericContext.Type
		{
			get { return this; }
		}

		IGenericParameterProvider IGenericContext.Method
		{
			get { return null; }
		}

		GenericParameterType IGenericParameterProvider.GenericParameterType
		{
			get { return GenericParameterType.Type; }
		}

		public virtual bool HasGenericParameters
		{
			get { return !generic_parameters.IsNullOrEmpty(); }
		}

		public virtual Collection<GenericParameter> GenericParameters
		{
			get
			{
				if (generic_parameters == null)
					Interlocked.CompareExchange(ref generic_parameters, new GenericParameterCollection(this), null);

				return generic_parameters;
			}
		}

		public virtual IMetadataScope Scope
		{
			get
			{
				var declaring_type = this.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Scope;

				return scope;
			}
			set
			{
				var declaring_type = this.DeclaringType;
				if (declaring_type != null)
				{
					if (IsWindowsRuntimeProjection && value != declaring_type.Scope)
						throw new InvalidOperationException("Projected type scope can't be changed.");
					declaring_type.Scope = value;
					return;
				}

				if (IsWindowsRuntimeProjection && value != scope)
					throw new InvalidOperationException("Projected type scope can't be changed.");
				scope = value;
			}
		}

		public bool IsNested
		{
			get { return this.DeclaringType != null; }
		}

		public override TypeReference DeclaringType
		{
			get { return base.DeclaringType; }
			set
			{
				if (IsWindowsRuntimeProjection && value != base.DeclaringType)
					throw new InvalidOperationException("Projected type declaring type can't be changed.");
				base.DeclaringType = value;
				ClearFullName();
			}
		}

		public override string FullName
		{
			get
			{
				if (fullname != null)
					return fullname;

				var new_fullname = this.TypeFullName();

				if (IsNested)
					new_fullname = DeclaringType.FullName + "/" + new_fullname;
				Interlocked.CompareExchange(ref fullname, new_fullname, null);
				return fullname;
			}
		}

		public virtual bool IsByReference
		{
			get { return false; }
		}

		public virtual bool IsPointer
		{
			get { return false; }
		}

		public virtual bool IsSentinel
		{
			get { return false; }
		}

		public virtual bool IsArray
		{
			get { return false; }
		}

		public virtual bool IsGenericParameter
		{
			get { return false; }
		}

		public virtual bool IsGenericInstance
		{
			get { return false; }
		}

		public virtual bool IsRequiredModifier
		{
			get { return false; }
		}

		public virtual bool IsOptionalModifier
		{
			get { return false; }
		}

		public virtual bool IsPinned
		{
			get { return false; }
		}

		public virtual bool IsFunctionPointer
		{
			get { return false; }
		}

		public virtual bool IsPrimitive
		{
			get { return etype.IsPrimitive(); }
		}

		public virtual MetadataType MetadataType
		{
			get
			{
				switch (etype)
				{
					case ElementType.None:
						return IsValueType ? MetadataType.ValueType : MetadataType.Class;
					default:
						return (MetadataType)etype;
				}
			}
		}

		protected TypeReference(string @namespace, string name)
			: base(name)
		{
			this.@namespace = @namespace ?? string.Empty;
			this.token = new MetadataToken(TokenType.TypeRef, 0);
		}

		public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
			: this(@namespace, name)
		{
			this.module = module;
			this.scope = scope;
		}

		public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType) :
			this(@namespace, name, module, scope)
		{
			value_type = valueType;
		}

		protected virtual void ClearFullName()
		{
			this.fullname = null;
		}

		public virtual TypeReference GetElementType()
		{
			return this;
		}

		protected override IMemberDefinition ResolveDefinition()
		{
			return this.Resolve();
		}

		public new virtual TypeDefinition Resolve()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException();

			return module.Resolve(this);
		}
	}

	static partial class Mixin
	{

		public static bool IsPrimitive(this ElementType self)
		{
			switch (self)
			{
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I:
				case ElementType.U:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
					return true;
				default:
					return false;
			}
		}

		public static string TypeFullName(this TypeReference self)
		{
			return string.IsNullOrEmpty(self.Namespace)
				? self.Name
				: self.Namespace + '.' + self.Name;
		}

		public static bool IsTypeOf(this TypeReference self, string @namespace, string name)
		{
			return self.Name == name
				&& self.Namespace == @namespace;
		}

		public static bool IsTypeSpecification(this TypeReference type)
		{
			switch (type.etype)
			{
				case ElementType.Array:
				case ElementType.ByRef:
				case ElementType.CModOpt:
				case ElementType.CModReqD:
				case ElementType.FnPtr:
				case ElementType.GenericInst:
				case ElementType.MVar:
				case ElementType.Pinned:
				case ElementType.Ptr:
				case ElementType.SzArray:
				case ElementType.Sentinel:
				case ElementType.Var:
					return true;
			}

			return false;
		}

		public static TypeDefinition CheckedResolve(this TypeReference self)
		{
			var type = self.Resolve();
			if (type == null)
				throw new ResolutionException(self);

			return type;
		}
	}
}



namespace Mono.Cecil
{
	internal sealed class TypeReferenceEqualityComparer : EqualityComparer<TypeReference>
	{
		public override bool Equals(TypeReference x, TypeReference y)
		{
			return AreEqual(x, y);
		}

		public override int GetHashCode(TypeReference obj)
		{
			return GetHashCodeFor(obj);
		}

		public static bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals(a, b))
				return true;

			if (a == null || b == null)
				return false;

			var aMetadataType = a.MetadataType;
			var bMetadataType = b.MetadataType;

			if (aMetadataType == MetadataType.GenericInstance || bMetadataType == MetadataType.GenericInstance)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual((GenericInstanceType)a, (GenericInstanceType)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.Array || bMetadataType == MetadataType.Array)
			{
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (ArrayType)a;
				var b1 = (ArrayType)b;
				if (a1.Rank != b1.Rank)
					return false;

				return AreEqual(a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Var || bMetadataType == MetadataType.Var)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual((GenericParameter)a, (GenericParameter)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.MVar || bMetadataType == MetadataType.MVar)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual((GenericParameter)a, (GenericParameter)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.ByReference || bMetadataType == MetadataType.ByReference)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual(((ByReferenceType)a).ElementType, ((ByReferenceType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Pointer || bMetadataType == MetadataType.Pointer)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual(((PointerType)a).ElementType, ((PointerType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.RequiredModifier || bMetadataType == MetadataType.RequiredModifier)
			{
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (RequiredModifierType)a;
				var b1 = (RequiredModifierType)b;

				return AreEqual(a1.ModifierType, b1.ModifierType, comparisonMode) && AreEqual(a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.OptionalModifier || bMetadataType == MetadataType.OptionalModifier)
			{
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (OptionalModifierType)a;
				var b1 = (OptionalModifierType)b;

				return AreEqual(a1.ModifierType, b1.ModifierType, comparisonMode) && AreEqual(a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Pinned || bMetadataType == MetadataType.Pinned)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual(((PinnedType)a).ElementType, ((PinnedType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Sentinel || bMetadataType == MetadataType.Sentinel)
			{
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual(((SentinelType)a).ElementType, ((SentinelType)b).ElementType, comparisonMode);
			}

			if (!a.Name.Equals(b.Name) || !a.Namespace.Equals(b.Namespace))
				return false;

			var xDefinition = a.Resolve();
			var yDefinition = b.Resolve();

			// For loose signature the types could be in different assemblies, as long as the type names match we will consider them equal
			if (comparisonMode == TypeComparisonMode.SignatureOnlyLoose)
			{
				if (xDefinition.Module.Name != yDefinition.Module.Name)
					return false;

				if (xDefinition.Module.Assembly.Name.Name != yDefinition.Module.Assembly.Name.Name)
					return false;

				return xDefinition.FullName == yDefinition.FullName;
			}

			return xDefinition == yDefinition;
		}

		static bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals(a, b))
				return true;

			if (a.Position != b.Position)
				return false;

			if (a.Type != b.Type)
				return false;

			var aOwnerType = a.Owner as TypeReference;
			if (aOwnerType != null && AreEqual(aOwnerType, b.Owner as TypeReference, comparisonMode))
				return true;

			var aOwnerMethod = a.Owner as MethodReference;
			if (aOwnerMethod != null && comparisonMode != TypeComparisonMode.SignatureOnlyLoose && MethodReferenceComparer.AreEqual(aOwnerMethod, b.Owner as MethodReference))
				return true;

			return comparisonMode == TypeComparisonMode.SignatureOnly || comparisonMode == TypeComparisonMode.SignatureOnlyLoose;
		}

		static bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals(a, b))
				return true;

			var aGenericArgumentsCount = a.GenericArguments.Count;
			if (aGenericArgumentsCount != b.GenericArguments.Count)
				return false;

			if (!AreEqual(a.ElementType, b.ElementType, comparisonMode))
				return false;

			for (int i = 0; i < aGenericArgumentsCount; i++)
				if (!AreEqual(a.GenericArguments[i], b.GenericArguments[i], comparisonMode))
					return false;

			return true;
		}

		public static int GetHashCodeFor(TypeReference obj)
		{
			// a very good prime number
			const int hashCodeMultiplier = 486187739;
			// prime numbers
			const int genericInstanceTypeMultiplier = 31;
			const int byReferenceMultiplier = 37;
			const int pointerMultiplier = 41;
			const int requiredModifierMultiplier = 43;
			const int optionalModifierMultiplier = 47;
			const int pinnedMultiplier = 53;
			const int sentinelMultiplier = 59;

			var metadataType = obj.MetadataType;

			if (metadataType == MetadataType.GenericInstance)
			{
				var genericInstanceType = (GenericInstanceType)obj;
				var hashCode = GetHashCodeFor(genericInstanceType.ElementType) * hashCodeMultiplier + genericInstanceTypeMultiplier;
				for (var i = 0; i < genericInstanceType.GenericArguments.Count; i++)
					hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor(genericInstanceType.GenericArguments[i]);
				return hashCode;
			}

			if (metadataType == MetadataType.Array)
			{
				var arrayType = (ArrayType)obj;
				return GetHashCodeFor(arrayType.ElementType) * hashCodeMultiplier + arrayType.Rank.GetHashCode();
			}

			if (metadataType == MetadataType.Var || metadataType == MetadataType.MVar)
			{
				var genericParameter = (GenericParameter)obj;
				var hashCode = genericParameter.Position.GetHashCode() * hashCodeMultiplier + ((int)metadataType).GetHashCode();

				var ownerTypeReference = genericParameter.Owner as TypeReference;
				if (ownerTypeReference != null)
					return hashCode * hashCodeMultiplier + GetHashCodeFor(ownerTypeReference);

				var ownerMethodReference = genericParameter.Owner as MethodReference;
				if (ownerMethodReference != null)
					return hashCode * hashCodeMultiplier + MethodReferenceComparer.GetHashCodeFor(ownerMethodReference);

				throw new InvalidOperationException("Generic parameter encountered with invalid owner");
			}

			if (metadataType == MetadataType.ByReference)
			{
				var byReferenceType = (ByReferenceType)obj;
				return GetHashCodeFor(byReferenceType.ElementType) * hashCodeMultiplier * byReferenceMultiplier;
			}

			if (metadataType == MetadataType.Pointer)
			{
				var pointerType = (PointerType)obj;
				return GetHashCodeFor(pointerType.ElementType) * hashCodeMultiplier * pointerMultiplier;
			}

			if (metadataType == MetadataType.RequiredModifier)
			{
				var requiredModifierType = (RequiredModifierType)obj;
				var hashCode = GetHashCodeFor(requiredModifierType.ElementType) * requiredModifierMultiplier;
				hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor(requiredModifierType.ModifierType);
				return hashCode;
			}

			if (metadataType == MetadataType.OptionalModifier)
			{
				var optionalModifierType = (OptionalModifierType)obj;
				var hashCode = GetHashCodeFor(optionalModifierType.ElementType) * optionalModifierMultiplier;
				hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor(optionalModifierType.ModifierType);
				return hashCode;
			}

			if (metadataType == MetadataType.Pinned)
			{
				var pinnedType = (PinnedType)obj;
				return GetHashCodeFor(pinnedType.ElementType) * hashCodeMultiplier * pinnedMultiplier;
			}

			if (metadataType == MetadataType.Sentinel)
			{
				var sentinelType = (SentinelType)obj;
				return GetHashCodeFor(sentinelType.ElementType) * hashCodeMultiplier * sentinelMultiplier;
			}

			if (metadataType == MetadataType.FunctionPointer)
			{
				throw new NotImplementedException("We currently don't handle function pointer types.");
			}

			return obj.Namespace.GetHashCode() * hashCodeMultiplier + obj.FullName.GetHashCode();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil.Rocks
{

#if INSIDE_ROCKS
	public
#endif
	static class TypeReferenceRocks
	{

		public static ArrayType MakeArrayType(this TypeReference self)
		{
			return new ArrayType(self);
		}

		public static ArrayType MakeArrayType(this TypeReference self, int rank)
		{
			if (rank == 0)
				throw new ArgumentOutOfRangeException("rank");

			var array = new ArrayType(self);

			for (int i = 1; i < rank; i++)
				array.Dimensions.Add(new ArrayDimension());

			return array;
		}

		public static PointerType MakePointerType(this TypeReference self)
		{
			return new PointerType(self);
		}

		public static ByReferenceType MakeByReferenceType(this TypeReference self)
		{
			return new ByReferenceType(self);
		}

		public static OptionalModifierType MakeOptionalModifierType(this TypeReference self, TypeReference modifierType)
		{
			return new OptionalModifierType(modifierType, self);
		}

		public static RequiredModifierType MakeRequiredModifierType(this TypeReference self, TypeReference modifierType)
		{
			return new RequiredModifierType(modifierType, self);
		}

		public static GenericInstanceType MakeGenericInstanceType(this TypeReference self, params TypeReference[] arguments)
		{
			if (self == null)
				throw new ArgumentNullException("self");
			if (arguments == null)
				throw new ArgumentNullException("arguments");
			if (arguments.Length == 0)
				throw new ArgumentException();
			if (self.GenericParameters.Count != arguments.Length)
				throw new ArgumentException();

			var instance = new GenericInstanceType(self, arguments.Length);

			foreach (var argument in arguments)
				instance.GenericArguments.Add(argument);

			return instance;
		}

		public static PinnedType MakePinnedType(this TypeReference self)
		{
			return new PinnedType(self);
		}

		public static SentinelType MakeSentinelType(this TypeReference self)
		{
			return new SentinelType(self);
		}
	}
}



namespace Mono.Cecil
{
	internal sealed class TypeResolver
	{
		private readonly IGenericInstance _typeDefinitionContext;
		private readonly IGenericInstance _methodDefinitionContext;

		public static TypeResolver For(TypeReference typeReference)
		{
			return typeReference.IsGenericInstance ? new TypeResolver((GenericInstanceType)typeReference) : new TypeResolver();
		}

		public static TypeResolver For(TypeReference typeReference, MethodReference methodReference)
		{
			return new TypeResolver(typeReference as GenericInstanceType, methodReference as GenericInstanceMethod);
		}

		public TypeResolver()
		{

		}

		public TypeResolver(GenericInstanceType typeDefinitionContext)
		{
			_typeDefinitionContext = typeDefinitionContext;
		}

		public TypeResolver(GenericInstanceMethod methodDefinitionContext)
		{
			_methodDefinitionContext = methodDefinitionContext;
		}

		public TypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext)
		{
			_typeDefinitionContext = typeDefinitionContext;
			_methodDefinitionContext = methodDefinitionContext;
		}

		public MethodReference Resolve(MethodReference method)
		{
			var methodReference = method;
			if (IsDummy())
				return methodReference;

			var declaringType = Resolve(method.DeclaringType);

			var genericInstanceMethod = method as GenericInstanceMethod;
			if (genericInstanceMethod != null)
			{
				methodReference = new MethodReference(method.Name, method.ReturnType, declaringType);

				foreach (var p in method.Parameters)
					methodReference.Parameters.Add(new ParameterDefinition(p.Name, p.Attributes, p.ParameterType));

				foreach (var gp in genericInstanceMethod.ElementMethod.GenericParameters)
					methodReference.GenericParameters.Add(new GenericParameter(gp.Name, methodReference));

				methodReference.HasThis = method.HasThis;

				var m = new GenericInstanceMethod(methodReference);
				foreach (var ga in genericInstanceMethod.GenericArguments)
				{
					m.GenericArguments.Add(Resolve(ga));
				}

				methodReference = m;
			}
			else
			{
				methodReference = new MethodReference(method.Name, method.ReturnType, declaringType);

				foreach (var gp in method.GenericParameters)
					methodReference.GenericParameters.Add(new GenericParameter(gp.Name, methodReference));

				foreach (var p in method.Parameters)
					methodReference.Parameters.Add(new ParameterDefinition(p.Name, p.Attributes, p.ParameterType));

				methodReference.HasThis = method.HasThis;
			}


			return methodReference;
		}

		public FieldReference Resolve(FieldReference field)
		{
			var declaringType = Resolve(field.DeclaringType);

			if (declaringType == field.DeclaringType)
				return field;

			return new FieldReference(field.Name, field.FieldType, declaringType);
		}

		public TypeReference ResolveReturnType(MethodReference method)
		{
			return Resolve(GenericParameterResolver.ResolveReturnTypeIfNeeded(method));
		}

		public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter)
		{
			return Resolve(GenericParameterResolver.ResolveParameterTypeIfNeeded(method, parameter));
		}

		public TypeReference ResolveVariableType(MethodReference method, VariableReference variable)
		{
			return Resolve(GenericParameterResolver.ResolveVariableTypeIfNeeded(method, variable));
		}

		public TypeReference ResolveFieldType(FieldReference field)
		{
			return Resolve(GenericParameterResolver.ResolveFieldTypeIfNeeded(field));
		}

		public TypeReference Resolve(TypeReference typeReference)
		{
			return Resolve(typeReference, true);
		}

		public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions)
		{
			if (IsDummy())
				return typeReference;

			if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains(typeReference))
				return typeReference;
			if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains(typeReference))
				return typeReference;

			var genericParameter = typeReference as GenericParameter;
			if (genericParameter != null)
			{
				if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains(genericParameter))
					return genericParameter;
				if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains(genericParameter))
					return genericParameter;
				return ResolveGenericParameter(genericParameter);
			}

			var arrayType = typeReference as ArrayType;
			if (arrayType != null)
				return new ArrayType(Resolve(arrayType.ElementType), arrayType.Rank);

			var pointerType = typeReference as PointerType;
			if (pointerType != null)
				return new PointerType(Resolve(pointerType.ElementType));

			var byReferenceType = typeReference as ByReferenceType;
			if (byReferenceType != null)
				return new ByReferenceType(Resolve(byReferenceType.ElementType));

			var pinnedType = typeReference as PinnedType;
			if (pinnedType != null)
				return new PinnedType(Resolve(pinnedType.ElementType));

			var genericInstanceType = typeReference as GenericInstanceType;
			if (genericInstanceType != null)
			{
				var newGenericInstanceType = new GenericInstanceType(genericInstanceType.ElementType);
				foreach (var genericArgument in genericInstanceType.GenericArguments)
					newGenericInstanceType.GenericArguments.Add(Resolve(genericArgument));
				return newGenericInstanceType;
			}

			var requiredModType = typeReference as RequiredModifierType;
			if (requiredModType != null)
				return Resolve(requiredModType.ElementType, includeTypeDefinitions);


			if (includeTypeDefinitions)
			{
				var typeDefinition = typeReference as TypeDefinition;
				if (typeDefinition != null && typeDefinition.HasGenericParameters)
				{
					var newGenericInstanceType = new GenericInstanceType(typeDefinition);
					foreach (var gp in typeDefinition.GenericParameters)
						newGenericInstanceType.GenericArguments.Add(Resolve(gp));
					return newGenericInstanceType;
				}
			}

			if (typeReference is TypeSpecification)
				throw new NotSupportedException(string.Format("The type {0} cannot be resolved correctly.", typeReference.FullName));

			return typeReference;
		}

		internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod)
		{
			return new TypeResolver(_typeDefinitionContext as GenericInstanceType, genericInstanceMethod);
		}

		private TypeReference ResolveGenericParameter(GenericParameter genericParameter)
		{
			if (genericParameter.Owner == null)
				return HandleOwnerlessInvalidILCode(genericParameter);

			var memberReference = genericParameter.Owner as MemberReference;
			if (memberReference == null)
				throw new NotSupportedException();

			return genericParameter.Type == GenericParameterType.Type
				? _typeDefinitionContext.GenericArguments[genericParameter.Position]
				: (_methodDefinitionContext != null ? _methodDefinitionContext.GenericArguments[genericParameter.Position] : genericParameter);
		}

		private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter)
		{
			// NOTE: If owner is null and we have a method parameter, then we'll assume that the method parameter
			// is actually a type parameter, and we'll use the type parameter from the corresponding position. I think
			// this assumption is valid, but if you're visiting this code then I might have been proven wrong.
			if (genericParameter.Type == GenericParameterType.Method && (_typeDefinitionContext != null && genericParameter.Position < _typeDefinitionContext.GenericArguments.Count))
				return _typeDefinitionContext.GenericArguments[genericParameter.Position];

			// NOTE: Owner cannot be null, but sometimes the Mono compiler generates invalid IL and we
			// end up in this situation.
			// When we do, we assume that the runtime doesn't care about the resolved type of the GenericParameter,
			// thus we return a reference to System.Object.
			return genericParameter.Module.TypeSystem.Object;
		}

		private bool IsDummy()
		{
			return _typeDefinitionContext == null && _methodDefinitionContext == null;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public abstract class TypeSpecification : TypeReference
	{

		readonly TypeReference element_type;

		public TypeReference ElementType
		{
			get { return element_type; }
		}

		public override string Name
		{
			get { return element_type.Name; }
			set { throw new InvalidOperationException(); }
		}

		public override string Namespace
		{
			get { return element_type.Namespace; }
			set { throw new InvalidOperationException(); }
		}

		public override IMetadataScope Scope
		{
			get { return element_type.Scope; }
			set { throw new InvalidOperationException(); }
		}

		public override ModuleDefinition Module
		{
			get { return element_type.Module; }
		}

		public override string FullName
		{
			get { return element_type.FullName; }
		}

		public override bool ContainsGenericParameter
		{
			get { return element_type.ContainsGenericParameter; }
		}

		public override MetadataType MetadataType
		{
			get { return (MetadataType)etype; }
		}

		internal TypeSpecification(TypeReference type)
			: base(null, null)
		{
			this.element_type = type;
			this.token = new MetadataToken(TokenType.TypeSpec);
		}

		public override TypeReference GetElementType()
		{
			return element_type.GetElementType();
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	public abstract class TypeSystem
	{

		sealed class CoreTypeSystem : TypeSystem
		{

			public CoreTypeSystem(ModuleDefinition module)
				: base(module)
			{
			}

			internal override TypeReference LookupType(string @namespace, string name)
			{
				var type = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
				if (type != null)
					return type;

				throw new NotSupportedException();
			}

			TypeReference LookupTypeDefinition(string @namespace, string name)
			{
				var metadata = module.MetadataSystem;
				if (metadata.Types == null)
					Initialize(module.Types);

				return module.Read(new Row<string, string>(@namespace, name), (row, reader) => {
					var types = reader.metadata.Types;

					for (int i = 0; i < types.Length; i++)
					{
						if (types[i] == null)
							types[i] = reader.GetTypeDefinition((uint)i + 1);

						var type = types[i];

						if (type.Name == row.Col2 && type.Namespace == row.Col1)
							return type;
					}

					return null;
				});
			}

			TypeReference LookupTypeForwarded(string @namespace, string name)
			{
				if (!module.HasExportedTypes)
					return null;

				var exported_types = module.ExportedTypes;
				for (int i = 0; i < exported_types.Count; i++)
				{
					var exported_type = exported_types[i];

					if (exported_type.Name == name && exported_type.Namespace == @namespace)
						return exported_type.CreateReference();
				}

				return null;
			}

			static void Initialize(object obj)
			{
			}
		}

		sealed class CommonTypeSystem : TypeSystem
		{

			AssemblyNameReference core_library;

			public CommonTypeSystem(ModuleDefinition module)
				: base(module)
			{
			}

			internal override TypeReference LookupType(string @namespace, string name)
			{
				return CreateTypeReference(@namespace, name);
			}

			public AssemblyNameReference GetCoreLibraryReference()
			{
				if (core_library != null)
					return core_library;

				if (module.TryGetCoreLibraryReference(out core_library))
					return core_library;

				core_library = new AssemblyNameReference
				{
					Name = Mixin.mscorlib,
					Version = GetCorlibVersion(),
					PublicKeyToken = new byte[] { 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89 },
				};

				module.AssemblyReferences.Add(core_library);

				return core_library;
			}

			Version GetCorlibVersion()
			{
				switch (module.Runtime)
				{
					case TargetRuntime.Net_1_0:
					case TargetRuntime.Net_1_1:
						return new Version(1, 0, 0, 0);
					case TargetRuntime.Net_2_0:
						return new Version(2, 0, 0, 0);
					case TargetRuntime.Net_4_0:
						return new Version(4, 0, 0, 0);
					default:
						throw new NotSupportedException();
				}
			}

			TypeReference CreateTypeReference(string @namespace, string name)
			{
				return new TypeReference(@namespace, name, module, GetCoreLibraryReference());
			}
		}

		readonly ModuleDefinition module;

		TypeReference type_object;
		TypeReference type_void;
		TypeReference type_bool;
		TypeReference type_char;
		TypeReference type_sbyte;
		TypeReference type_byte;
		TypeReference type_int16;
		TypeReference type_uint16;
		TypeReference type_int32;
		TypeReference type_uint32;
		TypeReference type_int64;
		TypeReference type_uint64;
		TypeReference type_single;
		TypeReference type_double;
		TypeReference type_intptr;
		TypeReference type_uintptr;
		TypeReference type_string;
		TypeReference type_typedref;

		TypeSystem(ModuleDefinition module)
		{
			this.module = module;
		}

		internal static TypeSystem CreateTypeSystem(ModuleDefinition module)
		{
			if (module.IsCoreLibrary())
				return new CoreTypeSystem(module);

			return new CommonTypeSystem(module);
		}

		internal abstract TypeReference LookupType(string @namespace, string name);

		TypeReference LookupSystemType(ref TypeReference reference, string name, ElementType element_type)
		{
			lock (module.SyncRoot)
			{
				if (reference != null)
					return reference;
				var type = LookupType("System", name);
				type.etype = element_type;
				return reference = type;
			}
		}

		TypeReference LookupSystemValueType(ref TypeReference typeRef, string name, ElementType element_type)
		{
			lock (module.SyncRoot)
			{
				if (typeRef != null)
					return typeRef;
				var type = LookupType("System", name);
				type.etype = element_type;
				type.KnownValueType();
				return typeRef = type;
			}
		}

		[Obsolete("Use CoreLibrary")]
		public IMetadataScope Corlib
		{
			get { return CoreLibrary; }
		}

		public IMetadataScope CoreLibrary
		{
			get
			{
				var common = this as CommonTypeSystem;
				if (common == null)
					return module;

				return common.GetCoreLibraryReference();
			}
		}

		public TypeReference Object
		{
			get { return type_object ?? (LookupSystemType(ref type_object, "Object", ElementType.Object)); }
		}

		public TypeReference Void
		{
			get { return type_void ?? (LookupSystemType(ref type_void, "Void", ElementType.Void)); }
		}

		public TypeReference Boolean
		{
			get { return type_bool ?? (LookupSystemValueType(ref type_bool, "Boolean", ElementType.Boolean)); }
		}

		public TypeReference Char
		{
			get { return type_char ?? (LookupSystemValueType(ref type_char, "Char", ElementType.Char)); }
		}

		public TypeReference SByte
		{
			get { return type_sbyte ?? (LookupSystemValueType(ref type_sbyte, "SByte", ElementType.I1)); }
		}

		public TypeReference Byte
		{
			get { return type_byte ?? (LookupSystemValueType(ref type_byte, "Byte", ElementType.U1)); }
		}

		public TypeReference Int16
		{
			get { return type_int16 ?? (LookupSystemValueType(ref type_int16, "Int16", ElementType.I2)); }
		}

		public TypeReference UInt16
		{
			get { return type_uint16 ?? (LookupSystemValueType(ref type_uint16, "UInt16", ElementType.U2)); }
		}

		public TypeReference Int32
		{
			get { return type_int32 ?? (LookupSystemValueType(ref type_int32, "Int32", ElementType.I4)); }
		}

		public TypeReference UInt32
		{
			get { return type_uint32 ?? (LookupSystemValueType(ref type_uint32, "UInt32", ElementType.U4)); }
		}

		public TypeReference Int64
		{
			get { return type_int64 ?? (LookupSystemValueType(ref type_int64, "Int64", ElementType.I8)); }
		}

		public TypeReference UInt64
		{
			get { return type_uint64 ?? (LookupSystemValueType(ref type_uint64, "UInt64", ElementType.U8)); }
		}

		public TypeReference Single
		{
			get { return type_single ?? (LookupSystemValueType(ref type_single, "Single", ElementType.R4)); }
		}

		public TypeReference Double
		{
			get { return type_double ?? (LookupSystemValueType(ref type_double, "Double", ElementType.R8)); }
		}

		public TypeReference IntPtr
		{
			get { return type_intptr ?? (LookupSystemValueType(ref type_intptr, "IntPtr", ElementType.I)); }
		}

		public TypeReference UIntPtr
		{
			get { return type_uintptr ?? (LookupSystemValueType(ref type_uintptr, "UIntPtr", ElementType.U)); }
		}

		public TypeReference String
		{
			get { return type_string ?? (LookupSystemType(ref type_string, "String", ElementType.String)); }
		}

		public TypeReference TypedReference
		{
			get { return type_typedref ?? (LookupSystemValueType(ref type_typedref, "TypedReference", ElementType.TypedByRef)); }
		}
	}

	static partial class Mixin
	{

		public const string mscorlib = "mscorlib";
		public const string system_runtime = "System.Runtime";
		public const string system_private_corelib = "System.Private.CoreLib";
		public const string netstandard = "netstandard";

		public static bool TryGetCoreLibraryReference(this ModuleDefinition module, out AssemblyNameReference reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++)
			{
				reference = references[i];
				if (IsCoreLibrary(reference))
					return true;
			}

			reference = null;
			return false;

		}

		public static bool IsCoreLibrary(this ModuleDefinition module)
		{
			if (module.Assembly == null)
				return false;

			if (!IsCoreLibrary(module.Assembly.Name))
				return false;

			if (module.HasImage && module.Read(module, (m, reader) => reader.image.GetTableLength(Table.AssemblyRef) > 0))
				return false;

			return true;
		}

		public static void KnownValueType(this TypeReference type)
		{
			if (!type.IsDefinition)
				type.IsValueType = true;
		}

		static bool IsCoreLibrary(AssemblyNameReference reference)
		{
			var name = reference.Name;
			return name == mscorlib
				|| name == system_runtime
				|| name == system_private_corelib
				|| name == netstandard;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Metadata
{

	sealed class UserStringHeap : StringHeap
	{

		public UserStringHeap(byte[] data)
			: base(data)
		{
		}

		protected override string ReadStringAt(uint index)
		{
			int start = (int)index;

			uint length = (uint)(data.ReadCompressedUInt32(ref start) & ~1);
			if (length < 1)
				return string.Empty;

			var chars = new char[length / 2];

			for (int i = start, j = 0; i < start + length; i += 2)
				chars[j++] = (char)(data[i] | (data[i + 1] << 8));

			return new string(chars);
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//





namespace Mono.Cecil
{

	static partial class Mixin
	{

		public const int TableCount = 58;
		public const int CodedIndexCount = 14;

		public static uint ReadCompressedUInt32(this byte[] data, ref int position)
		{
			uint integer;
			if ((data[position] & 0x80) == 0)
			{
				integer = data[position];
				position++;
			}
			else if ((data[position] & 0x40) == 0)
			{
				integer = (uint)(data[position] & ~0x80) << 8;
				integer |= data[position + 1];
				position += 2;
			}
			else
			{
				integer = (uint)(data[position] & ~0xc0) << 24;
				integer |= (uint)data[position + 1] << 16;
				integer |= (uint)data[position + 2] << 8;
				integer |= (uint)data[position + 3];
				position += 4;
			}
			return integer;
		}

		public static MetadataToken GetMetadataToken(this CodedIndex self, uint data)
		{
			uint rid;
			TokenType token_type;
			switch (self)
			{
				case CodedIndex.TypeDefOrRef:
					rid = data >> 2;
					switch (data & 3)
					{
						case 0:
							token_type = TokenType.TypeDef; goto ret;
						case 1:
							token_type = TokenType.TypeRef; goto ret;
						case 2:
							token_type = TokenType.TypeSpec; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.HasConstant:
					rid = data >> 2;
					switch (data & 3)
					{
						case 0:
							token_type = TokenType.Field; goto ret;
						case 1:
							token_type = TokenType.Param; goto ret;
						case 2:
							token_type = TokenType.Property; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.HasCustomAttribute:
					rid = data >> 5;
					switch (data & 31)
					{
						case 0:
							token_type = TokenType.Method; goto ret;
						case 1:
							token_type = TokenType.Field; goto ret;
						case 2:
							token_type = TokenType.TypeRef; goto ret;
						case 3:
							token_type = TokenType.TypeDef; goto ret;
						case 4:
							token_type = TokenType.Param; goto ret;
						case 5:
							token_type = TokenType.InterfaceImpl; goto ret;
						case 6:
							token_type = TokenType.MemberRef; goto ret;
						case 7:
							token_type = TokenType.Module; goto ret;
						case 8:
							token_type = TokenType.Permission; goto ret;
						case 9:
							token_type = TokenType.Property; goto ret;
						case 10:
							token_type = TokenType.Event; goto ret;
						case 11:
							token_type = TokenType.Signature; goto ret;
						case 12:
							token_type = TokenType.ModuleRef; goto ret;
						case 13:
							token_type = TokenType.TypeSpec; goto ret;
						case 14:
							token_type = TokenType.Assembly; goto ret;
						case 15:
							token_type = TokenType.AssemblyRef; goto ret;
						case 16:
							token_type = TokenType.File; goto ret;
						case 17:
							token_type = TokenType.ExportedType; goto ret;
						case 18:
							token_type = TokenType.ManifestResource; goto ret;
						case 19:
							token_type = TokenType.GenericParam; goto ret;
						case 20:
							token_type = TokenType.GenericParamConstraint; goto ret;
						case 21:
							token_type = TokenType.MethodSpec; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.HasFieldMarshal:
					rid = data >> 1;
					switch (data & 1)
					{
						case 0:
							token_type = TokenType.Field; goto ret;
						case 1:
							token_type = TokenType.Param; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.HasDeclSecurity:
					rid = data >> 2;
					switch (data & 3)
					{
						case 0:
							token_type = TokenType.TypeDef; goto ret;
						case 1:
							token_type = TokenType.Method; goto ret;
						case 2:
							token_type = TokenType.Assembly; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.MemberRefParent:
					rid = data >> 3;
					switch (data & 7)
					{
						case 0:
							token_type = TokenType.TypeDef; goto ret;
						case 1:
							token_type = TokenType.TypeRef; goto ret;
						case 2:
							token_type = TokenType.ModuleRef; goto ret;
						case 3:
							token_type = TokenType.Method; goto ret;
						case 4:
							token_type = TokenType.TypeSpec; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.HasSemantics:
					rid = data >> 1;
					switch (data & 1)
					{
						case 0:
							token_type = TokenType.Event; goto ret;
						case 1:
							token_type = TokenType.Property; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.MethodDefOrRef:
					rid = data >> 1;
					switch (data & 1)
					{
						case 0:
							token_type = TokenType.Method; goto ret;
						case 1:
							token_type = TokenType.MemberRef; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.MemberForwarded:
					rid = data >> 1;
					switch (data & 1)
					{
						case 0:
							token_type = TokenType.Field; goto ret;
						case 1:
							token_type = TokenType.Method; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.Implementation:
					rid = data >> 2;
					switch (data & 3)
					{
						case 0:
							token_type = TokenType.File; goto ret;
						case 1:
							token_type = TokenType.AssemblyRef; goto ret;
						case 2:
							token_type = TokenType.ExportedType; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.CustomAttributeType:
					rid = data >> 3;
					switch (data & 7)
					{
						case 2:
							token_type = TokenType.Method; goto ret;
						case 3:
							token_type = TokenType.MemberRef; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.ResolutionScope:
					rid = data >> 2;
					switch (data & 3)
					{
						case 0:
							token_type = TokenType.Module; goto ret;
						case 1:
							token_type = TokenType.ModuleRef; goto ret;
						case 2:
							token_type = TokenType.AssemblyRef; goto ret;
						case 3:
							token_type = TokenType.TypeRef; goto ret;
						default:
							goto exit;
					}
				case CodedIndex.TypeOrMethodDef:
					rid = data >> 1;
					switch (data & 1)
					{
						case 0:
							token_type = TokenType.TypeDef; goto ret;
						case 1:
							token_type = TokenType.Method; goto ret;
						default: goto exit;
					}
				case CodedIndex.HasCustomDebugInformation:
					rid = data >> 5;
					switch (data & 31)
					{
						case 0:
							token_type = TokenType.Method; goto ret;
						case 1:
							token_type = TokenType.Field; goto ret;
						case 2:
							token_type = TokenType.TypeRef; goto ret;
						case 3:
							token_type = TokenType.TypeDef; goto ret;
						case 4:
							token_type = TokenType.Param; goto ret;
						case 5:
							token_type = TokenType.InterfaceImpl; goto ret;
						case 6:
							token_type = TokenType.MemberRef; goto ret;
						case 7:
							token_type = TokenType.Module; goto ret;
						case 8:
							token_type = TokenType.Permission; goto ret;
						case 9:
							token_type = TokenType.Property; goto ret;
						case 10:
							token_type = TokenType.Event; goto ret;
						case 11:
							token_type = TokenType.Signature; goto ret;
						case 12:
							token_type = TokenType.ModuleRef; goto ret;
						case 13:
							token_type = TokenType.TypeSpec; goto ret;
						case 14:
							token_type = TokenType.Assembly; goto ret;
						case 15:
							token_type = TokenType.AssemblyRef; goto ret;
						case 16:
							token_type = TokenType.File; goto ret;
						case 17:
							token_type = TokenType.ExportedType; goto ret;
						case 18:
							token_type = TokenType.ManifestResource; goto ret;
						case 19:
							token_type = TokenType.GenericParam; goto ret;
						case 20:
							token_type = TokenType.GenericParamConstraint; goto ret;
						case 21:
							token_type = TokenType.MethodSpec; goto ret;
						case 22:
							token_type = TokenType.Document; goto ret;
						case 23:
							token_type = TokenType.LocalScope; goto ret;
						case 24:
							token_type = TokenType.LocalVariable; goto ret;
						case 25:
							token_type = TokenType.LocalConstant; goto ret;
						case 26:
							token_type = TokenType.ImportScope; goto ret;
						default:
							goto exit;
					}
				default:
					goto exit;
			}
		ret:
			return new MetadataToken(token_type, rid);
		exit:
			return MetadataToken.Zero;
		}

		public static uint CompressMetadataToken(this CodedIndex self, MetadataToken token)
		{
			uint ret = 0;
			if (token.RID == 0)
				return ret;
			switch (self)
			{
				case CodedIndex.TypeDefOrRef:
					ret = token.RID << 2;
					switch (token.TokenType)
					{
						case TokenType.TypeDef:
							return ret | 0;
						case TokenType.TypeRef:
							return ret | 1;
						case TokenType.TypeSpec:
							return ret | 2;
						default:
							goto exit;
					}
				case CodedIndex.HasConstant:
					ret = token.RID << 2;
					switch (token.TokenType)
					{
						case TokenType.Field:
							return ret | 0;
						case TokenType.Param:
							return ret | 1;
						case TokenType.Property:
							return ret | 2;
						default:
							goto exit;
					}
				case CodedIndex.HasCustomAttribute:
					ret = token.RID << 5;
					switch (token.TokenType)
					{
						case TokenType.Method:
							return ret | 0;
						case TokenType.Field:
							return ret | 1;
						case TokenType.TypeRef:
							return ret | 2;
						case TokenType.TypeDef:
							return ret | 3;
						case TokenType.Param:
							return ret | 4;
						case TokenType.InterfaceImpl:
							return ret | 5;
						case TokenType.MemberRef:
							return ret | 6;
						case TokenType.Module:
							return ret | 7;
						case TokenType.Permission:
							return ret | 8;
						case TokenType.Property:
							return ret | 9;
						case TokenType.Event:
							return ret | 10;
						case TokenType.Signature:
							return ret | 11;
						case TokenType.ModuleRef:
							return ret | 12;
						case TokenType.TypeSpec:
							return ret | 13;
						case TokenType.Assembly:
							return ret | 14;
						case TokenType.AssemblyRef:
							return ret | 15;
						case TokenType.File:
							return ret | 16;
						case TokenType.ExportedType:
							return ret | 17;
						case TokenType.ManifestResource:
							return ret | 18;
						case TokenType.GenericParam:
							return ret | 19;
						case TokenType.GenericParamConstraint:
							return ret | 20;
						case TokenType.MethodSpec:
							return ret | 21;
						default:
							goto exit;
					}
				case CodedIndex.HasFieldMarshal:
					ret = token.RID << 1;
					switch (token.TokenType)
					{
						case TokenType.Field:
							return ret | 0;
						case TokenType.Param:
							return ret | 1;
						default:
							goto exit;
					}
				case CodedIndex.HasDeclSecurity:
					ret = token.RID << 2;
					switch (token.TokenType)
					{
						case TokenType.TypeDef:
							return ret | 0;
						case TokenType.Method:
							return ret | 1;
						case TokenType.Assembly:
							return ret | 2;
						default:
							goto exit;
					}
				case CodedIndex.MemberRefParent:
					ret = token.RID << 3;
					switch (token.TokenType)
					{
						case TokenType.TypeDef:
							return ret | 0;
						case TokenType.TypeRef:
							return ret | 1;
						case TokenType.ModuleRef:
							return ret | 2;
						case TokenType.Method:
							return ret | 3;
						case TokenType.TypeSpec:
							return ret | 4;
						default:
							goto exit;
					}
				case CodedIndex.HasSemantics:
					ret = token.RID << 1;
					switch (token.TokenType)
					{
						case TokenType.Event:
							return ret | 0;
						case TokenType.Property:
							return ret | 1;
						default:
							goto exit;
					}
				case CodedIndex.MethodDefOrRef:
					ret = token.RID << 1;
					switch (token.TokenType)
					{
						case TokenType.Method:
							return ret | 0;
						case TokenType.MemberRef:
							return ret | 1;
						default:
							goto exit;
					}
				case CodedIndex.MemberForwarded:
					ret = token.RID << 1;
					switch (token.TokenType)
					{
						case TokenType.Field:
							return ret | 0;
						case TokenType.Method:
							return ret | 1;
						default:
							goto exit;
					}
				case CodedIndex.Implementation:
					ret = token.RID << 2;
					switch (token.TokenType)
					{
						case TokenType.File:
							return ret | 0;
						case TokenType.AssemblyRef:
							return ret | 1;
						case TokenType.ExportedType:
							return ret | 2;
						default:
							goto exit;
					}
				case CodedIndex.CustomAttributeType:
					ret = token.RID << 3;
					switch (token.TokenType)
					{
						case TokenType.Method:
							return ret | 2;
						case TokenType.MemberRef:
							return ret | 3;
						default:
							goto exit;
					}
				case CodedIndex.ResolutionScope:
					ret = token.RID << 2;
					switch (token.TokenType)
					{
						case TokenType.Module:
							return ret | 0;
						case TokenType.ModuleRef:
							return ret | 1;
						case TokenType.AssemblyRef:
							return ret | 2;
						case TokenType.TypeRef:
							return ret | 3;
						default:
							goto exit;
					}
				case CodedIndex.TypeOrMethodDef:
					ret = token.RID << 1;
					switch (token.TokenType)
					{
						case TokenType.TypeDef:
							return ret | 0;
						case TokenType.Method:
							return ret | 1;
						default:
							goto exit;
					}
				case CodedIndex.HasCustomDebugInformation:
					ret = token.RID << 5;
					switch (token.TokenType)
					{
						case TokenType.Method:
							return ret | 0;
						case TokenType.Field:
							return ret | 1;
						case TokenType.TypeRef:
							return ret | 2;
						case TokenType.TypeDef:
							return ret | 3;
						case TokenType.Param:
							return ret | 4;
						case TokenType.InterfaceImpl:
							return ret | 5;
						case TokenType.MemberRef:
							return ret | 6;
						case TokenType.Module:
							return ret | 7;
						case TokenType.Permission:
							return ret | 8;
						case TokenType.Property:
							return ret | 9;
						case TokenType.Event:
							return ret | 10;
						case TokenType.Signature:
							return ret | 11;
						case TokenType.ModuleRef:
							return ret | 12;
						case TokenType.TypeSpec:
							return ret | 13;
						case TokenType.Assembly:
							return ret | 14;
						case TokenType.AssemblyRef:
							return ret | 15;
						case TokenType.File:
							return ret | 16;
						case TokenType.ExportedType:
							return ret | 17;
						case TokenType.ManifestResource:
							return ret | 18;
						case TokenType.GenericParam:
							return ret | 19;
						case TokenType.GenericParamConstraint:
							return ret | 20;
						case TokenType.MethodSpec:
							return ret | 21;
						case TokenType.Document:
							return ret | 22;
						case TokenType.LocalScope:
							return ret | 23;
						case TokenType.LocalVariable:
							return ret | 24;
						case TokenType.LocalConstant:
							return ret | 25;
						case TokenType.ImportScope:
							return ret | 26;
						default:
							goto exit;
					}
				default:
					goto exit;
			}
		exit:
			throw new ArgumentException();
		}

		public static int GetSize(this CodedIndex self, Func<Table, int> counter)
		{
			int bits;
			Table[] tables;

			switch (self)
			{
				case CodedIndex.TypeDefOrRef:
					bits = 2;
					tables = new[] { Table.TypeDef, Table.TypeRef, Table.TypeSpec };
					break;
				case CodedIndex.HasConstant:
					bits = 2;
					tables = new[] { Table.Field, Table.Param, Table.Property };
					break;
				case CodedIndex.HasCustomAttribute:
					bits = 5;
					tables = new[] {
					Table.Method, Table.Field, Table.TypeRef, Table.TypeDef, Table.Param, Table.InterfaceImpl, Table.MemberRef,
					Table.Module, Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig, Table.ModuleRef,
					Table.TypeSpec, Table.Assembly, Table.AssemblyRef, Table.File, Table.ExportedType,
					Table.ManifestResource, Table.GenericParam, Table.GenericParamConstraint, Table.MethodSpec,
				};
					break;
				case CodedIndex.HasFieldMarshal:
					bits = 1;
					tables = new[] { Table.Field, Table.Param };
					break;
				case CodedIndex.HasDeclSecurity:
					bits = 2;
					tables = new[] { Table.TypeDef, Table.Method, Table.Assembly };
					break;
				case CodedIndex.MemberRefParent:
					bits = 3;
					tables = new[] { Table.TypeDef, Table.TypeRef, Table.ModuleRef, Table.Method, Table.TypeSpec };
					break;
				case CodedIndex.HasSemantics:
					bits = 1;
					tables = new[] { Table.Event, Table.Property };
					break;
				case CodedIndex.MethodDefOrRef:
					bits = 1;
					tables = new[] { Table.Method, Table.MemberRef };
					break;
				case CodedIndex.MemberForwarded:
					bits = 1;
					tables = new[] { Table.Field, Table.Method };
					break;
				case CodedIndex.Implementation:
					bits = 2;
					tables = new[] { Table.File, Table.AssemblyRef, Table.ExportedType };
					break;
				case CodedIndex.CustomAttributeType:
					bits = 3;
					tables = new[] { Table.Method, Table.MemberRef };
					break;
				case CodedIndex.ResolutionScope:
					bits = 2;
					tables = new[] { Table.Module, Table.ModuleRef, Table.AssemblyRef, Table.TypeRef };
					break;
				case CodedIndex.TypeOrMethodDef:
					bits = 1;
					tables = new[] { Table.TypeDef, Table.Method };
					break;
				case CodedIndex.HasCustomDebugInformation:
					bits = 5;
					tables = new[] {
					Table.Method, Table.Field, Table.TypeRef, Table.TypeDef, Table.Param, Table.InterfaceImpl, Table.MemberRef,
					Table.Module, Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig, Table.ModuleRef,
					Table.TypeSpec, Table.Assembly, Table.AssemblyRef, Table.File, Table.ExportedType,
					Table.ManifestResource, Table.GenericParam, Table.GenericParamConstraint, Table.MethodSpec,
					Table.Document, Table.LocalScope, Table.LocalVariable, Table.LocalConstant, Table.ImportScope,
				};
					break;
				default:
					throw new ArgumentException();
			}

			int max = 0;

			for (int i = 0; i < tables.Length; i++)
			{
				max = System.Math.Max(counter(tables[i]), max);
			}

			return max < (1 << (16 - bits)) ? 2 : 4;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Cil
{

	public sealed class VariableDefinition : VariableReference
	{

		public bool IsPinned
		{
			get { return variable_type.IsPinned; }
		}

		public VariableDefinition(TypeReference variableType)
			: base(variableType)
		{
		}

		public override VariableDefinition Resolve()
		{
			return this;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil.Cil
{

	public abstract class VariableReference
	{

		internal int index = -1;
		protected TypeReference variable_type;

		public TypeReference VariableType
		{
			get { return variable_type; }
			set { variable_type = value; }
		}

		public int Index
		{
			get { return index; }
		}

		internal VariableReference(TypeReference variable_type)
		{
			this.variable_type = variable_type;
		}

		public abstract VariableDefinition Resolve();

		public override string ToString()
		{
			if (index >= 0)
				return "V_" + index;

			return string.Empty;
		}
	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace Mono.Cecil
{

	public enum VariantType
	{
		None = 0,
		I2 = 2,
		I4 = 3,
		R4 = 4,
		R8 = 5,
		CY = 6,
		Date = 7,
		BStr = 8,
		Dispatch = 9,
		Error = 10,
		Bool = 11,
		Variant = 12,
		Unknown = 13,
		Decimal = 14,
		I1 = 16,
		UI1 = 17,
		UI2 = 18,
		UI4 = 19,
		I8 = 20,
		UI8 = 21,
		Int = 22,
		UInt = 23
	}
}






namespace MonoMod.Utils
{
#if !MONOMOD_INTERNAL
	public
#endif
	sealed class WeakReferenceComparer : EqualityComparer<WeakReference>
	{

		public override bool Equals(WeakReference x, WeakReference y)
			=> ReferenceEquals(x.SafeGetTarget(), y.SafeGetTarget()) && x.SafeGetIsAlive() == y.SafeGetIsAlive();

		public override int GetHashCode(WeakReference obj)
			=> obj.SafeGetTarget()?.GetHashCode() ?? 0;

	}
}
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//






namespace Mono.Cecil
{

	sealed class TypeDefinitionProjection
	{

		public readonly TypeAttributes Attributes;
		public readonly string Name;
		public readonly TypeDefinitionTreatment Treatment;
		public readonly Collection<MethodDefinition> RedirectedMethods;
		public readonly Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;

		public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment, Collection<MethodDefinition> redirectedMethods, Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
		{
			Attributes = type.Attributes;
			Name = type.Name;
			Treatment = treatment;
			RedirectedMethods = redirectedMethods;
			RedirectedInterfaces = redirectedInterfaces;
		}
	}

	sealed class TypeReferenceProjection
	{

		public readonly string Name;
		public readonly string Namespace;
		public readonly IMetadataScope Scope;
		public readonly TypeReferenceTreatment Treatment;

		public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment)
		{
			Name = type.Name;
			Namespace = type.Namespace;
			Scope = type.Scope;
			Treatment = treatment;
		}
	}

	sealed class MethodDefinitionProjection
	{

		public readonly MethodAttributes Attributes;
		public readonly MethodImplAttributes ImplAttributes;
		public readonly string Name;
		public readonly MethodDefinitionTreatment Treatment;

		public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment)
		{
			Attributes = method.Attributes;
			ImplAttributes = method.ImplAttributes;
			Name = method.Name;
			Treatment = treatment;
		}
	}

	sealed class FieldDefinitionProjection
	{

		public readonly FieldAttributes Attributes;
		public readonly FieldDefinitionTreatment Treatment;

		public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment)
		{
			Attributes = field.Attributes;
			Treatment = treatment;
		}
	}

	sealed class CustomAttributeValueProjection
	{

		public readonly AttributeTargets Targets;
		public readonly CustomAttributeValueTreatment Treatment;

		public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment)
		{
			Targets = targets;
			Treatment = treatment;
		}
	}

	sealed class WindowsRuntimeProjections
	{

		struct ProjectionInfo
		{

			public readonly string WinRTNamespace;
			public readonly string ClrNamespace;
			public readonly string ClrName;
			public readonly string ClrAssembly;
			public readonly bool Attribute;

			public ProjectionInfo(string winrt_namespace, string clr_namespace, string clr_name, string clr_assembly, bool attribute = false)
			{
				WinRTNamespace = winrt_namespace;
				ClrNamespace = clr_namespace;
				ClrName = clr_name;
				ClrAssembly = clr_assembly;
				Attribute = attribute;
			}
		}

		static readonly Version version = new Version(4, 0, 0, 0);

		static readonly byte[] contract_pk_token = {
			0xB0, 0x3F, 0x5F, 0x7F, 0x11, 0xD5, 0x0A, 0x3A
		};

		static readonly byte[] contract_pk = {
			0x00, 0x24, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00,
			0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
			0x07, 0xD1, 0xFA, 0x57, 0xC4, 0xAE, 0xD9, 0xF0, 0xA3, 0x2E, 0x84, 0xAA, 0x0F, 0xAE, 0xFD, 0x0D,
			0xE9, 0xE8, 0xFD, 0x6A, 0xEC, 0x8F, 0x87, 0xFB, 0x03, 0x76, 0x6C, 0x83, 0x4C, 0x99, 0x92, 0x1E,
			0xB2, 0x3B, 0xE7, 0x9A, 0xD9, 0xD5, 0xDC, 0xC1, 0xDD, 0x9A, 0xD2, 0x36, 0x13, 0x21, 0x02, 0x90,
			0x0B, 0x72, 0x3C, 0xF9, 0x80, 0x95, 0x7F, 0xC4, 0xE1, 0x77, 0x10, 0x8F, 0xC6, 0x07, 0x77, 0x4F,
			0x29, 0xE8, 0x32, 0x0E, 0x92, 0xEA, 0x05, 0xEC, 0xE4, 0xE8, 0x21, 0xC0, 0xA5, 0xEF, 0xE8, 0xF1,
			0x64, 0x5C, 0x4C, 0x0C, 0x93, 0xC1, 0xAB, 0x99, 0x28, 0x5D, 0x62, 0x2C, 0xAA, 0x65, 0x2C, 0x1D,
			0xFA, 0xD6, 0x3D, 0x74, 0x5D, 0x6F, 0x2D, 0xE5, 0xF1, 0x7E, 0x5E, 0xAF, 0x0F, 0xC4, 0x96, 0x3D,
			0x26, 0x1C, 0x8A, 0x12, 0x43, 0x65, 0x18, 0x20, 0x6D, 0xC0, 0x93, 0x34, 0x4D, 0x5A, 0xD2, 0x93
		};

		static Dictionary<string, ProjectionInfo> projections;

		static Dictionary<string, ProjectionInfo> Projections
		{
			get
			{
				if (projections != null)
					return projections;


				var new_projections = new Dictionary<string, ProjectionInfo> {
					{ "AttributeTargets", new ProjectionInfo ("Windows.Foundation.Metadata", "System", "AttributeTargets", "System.Runtime") },
					{ "AttributeUsageAttribute", new ProjectionInfo ("Windows.Foundation.Metadata", "System", "AttributeUsageAttribute", "System.Runtime", attribute: true) },
					{ "Color", new ProjectionInfo ("Windows.UI", "Windows.UI", "Color", "System.Runtime.WindowsRuntime") },
					{ "CornerRadius", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "CornerRadius", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "DateTime", new ProjectionInfo ("Windows.Foundation", "System", "DateTimeOffset", "System.Runtime") },
					{ "Duration", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "Duration", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "DurationType", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "DurationType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "EventHandler`1", new ProjectionInfo ("Windows.Foundation", "System", "EventHandler`1", "System.Runtime") },
					{ "EventRegistrationToken", new ProjectionInfo ("Windows.Foundation", "System.Runtime.InteropServices.WindowsRuntime", "EventRegistrationToken", "System.Runtime.InteropServices.WindowsRuntime") },
					{ "GeneratorPosition", new ProjectionInfo ("Windows.UI.Xaml.Controls.Primitives", "Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "GridLength", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "GridLength", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "GridUnitType", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "GridUnitType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "HResult", new ProjectionInfo ("Windows.Foundation", "System", "Exception", "System.Runtime") },
					{ "IBindableIterable", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections", "IEnumerable", "System.Runtime") },
					{ "IBindableVector", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections", "IList", "System.Runtime") },
					{ "IClosable", new ProjectionInfo ("Windows.Foundation", "System", "IDisposable", "System.Runtime") },
					{ "ICommand", new ProjectionInfo ("Windows.UI.Xaml.Input", "System.Windows.Input", "ICommand", "System.ObjectModel") },
					{ "IIterable`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IEnumerable`1", "System.Runtime") },
					{ "IKeyValuePair`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "KeyValuePair`2", "System.Runtime") },
					{ "IMapView`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyDictionary`2", "System.Runtime") },
					{ "IMap`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IDictionary`2", "System.Runtime") },
					{ "INotifyCollectionChanged", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "INotifyCollectionChanged", "System.ObjectModel") },
					{ "INotifyPropertyChanged", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "INotifyPropertyChanged", "System.ObjectModel") },
					{ "IReference`1", new ProjectionInfo ("Windows.Foundation", "System", "Nullable`1", "System.Runtime") },
					{ "IVectorView`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyList`1", "System.Runtime") },
					{ "IVector`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IList`1", "System.Runtime") },
					{ "KeyTime", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "KeyTime", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix", new ProjectionInfo ("Windows.UI.Xaml.Media", "Windows.UI.Xaml.Media", "Matrix", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix3D", new ProjectionInfo ("Windows.UI.Xaml.Media.Media3D", "Windows.UI.Xaml.Media.Media3D", "Matrix3D", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix3x2", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Matrix3x2", "System.Numerics.Vectors") },
					{ "Matrix4x4", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Matrix4x4", "System.Numerics.Vectors") },
					{ "NotifyCollectionChangedAction", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedAction", "System.ObjectModel") },
					{ "NotifyCollectionChangedEventArgs", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventArgs", "System.ObjectModel") },
					{ "NotifyCollectionChangedEventHandler", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventHandler", "System.ObjectModel") },
					{ "Plane", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Plane", "System.Numerics.Vectors") },
					{ "Point", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Point", "System.Runtime.WindowsRuntime") },
					{ "PropertyChangedEventArgs", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventArgs", "System.ObjectModel") },
					{ "PropertyChangedEventHandler", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventHandler", "System.ObjectModel") },
					{ "Quaternion", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Quaternion", "System.Numerics.Vectors") },
					{ "Rect", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Rect", "System.Runtime.WindowsRuntime") },
					{ "RepeatBehavior", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehavior", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "RepeatBehaviorType", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Size", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Size", "System.Runtime.WindowsRuntime") },
					{ "Thickness", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "Thickness", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "TimeSpan", new ProjectionInfo ("Windows.Foundation", "System", "TimeSpan", "System.Runtime") },
					{ "TypeName", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System", "Type", "System.Runtime") },
					{ "Uri", new ProjectionInfo ("Windows.Foundation", "System", "Uri", "System.Runtime") },
					{ "Vector2", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector2", "System.Numerics.Vectors") },
					{ "Vector3", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector3", "System.Numerics.Vectors") },
					{ "Vector4", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector4", "System.Numerics.Vectors") },
				};

				Interlocked.CompareExchange(ref projections, new_projections, null);
				return projections;
			}
		}

		readonly ModuleDefinition module;
		Version corlib_version = new Version(255, 255, 255, 255);
		AssemblyNameReference[] virtual_references;

		AssemblyNameReference[] VirtualReferences
		{
			get
			{
				if (virtual_references == null)
				{
					// force module to read its assembly references. that will in turn initialize virtual_references
					Mixin.Read(module.AssemblyReferences);
				}

				return virtual_references;
			}
		}

		public WindowsRuntimeProjections(ModuleDefinition module)
		{
			this.module = module;
		}

		public static void Project(TypeDefinition type)
		{
			var treatment = TypeDefinitionTreatment.None;
			var metadata_kind = type.Module.MetadataKind;
			Collection<MethodDefinition> redirectedMethods = null;
			Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces = null;

			if (type.IsWindowsRuntime)
			{
				if (metadata_kind == MetadataKind.WindowsMetadata)
				{
					treatment = GetWellKnownTypeDefinitionTreatment(type);
					if (treatment != TypeDefinitionTreatment.None)
					{
						ApplyProjection(type, new TypeDefinitionProjection(type, treatment, redirectedMethods, redirectedInterfaces));
						return;
					}

					var base_type = type.BaseType;
					if (base_type != null && IsAttribute(base_type))
					{
						treatment = TypeDefinitionTreatment.NormalAttribute;
					}
					else
					{
						treatment = GenerateRedirectionInformation(type, out redirectedMethods, out redirectedInterfaces);
					}
				}
				else if (metadata_kind == MetadataKind.ManagedWindowsMetadata && NeedsWindowsRuntimePrefix(type))
					treatment = TypeDefinitionTreatment.PrefixWindowsRuntimeName;

				if (treatment == TypeDefinitionTreatment.PrefixWindowsRuntimeName || treatment == TypeDefinitionTreatment.NormalType)
					if (!type.IsInterface && HasAttribute(type, "Windows.UI.Xaml", "TreatAsAbstractComposableClassAttribute"))
						treatment |= TypeDefinitionTreatment.Abstract;
			}
			else if (metadata_kind == MetadataKind.ManagedWindowsMetadata && IsClrImplementationType(type))
				treatment = TypeDefinitionTreatment.UnmangleWindowsRuntimeName;

			if (treatment != TypeDefinitionTreatment.None)
				ApplyProjection(type, new TypeDefinitionProjection(type, treatment, redirectedMethods, redirectedInterfaces));
		}

		static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type)
		{
			ProjectionInfo info;
			if (!Projections.TryGetValue(type.Name, out info))
				return TypeDefinitionTreatment.None;

			var treatment = info.Attribute ? TypeDefinitionTreatment.RedirectToClrAttribute : TypeDefinitionTreatment.RedirectToClrType;

			if (type.Namespace == info.ClrNamespace)
				return treatment;

			if (type.Namespace == info.WinRTNamespace)
				return treatment | TypeDefinitionTreatment.Internal;

			return TypeDefinitionTreatment.None;
		}

		private static TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, out Collection<MethodDefinition> redirectedMethods, out Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
		{
			bool implementsProjectedInterface = false;
			redirectedMethods = null;
			redirectedInterfaces = null;

			foreach (var implementedInterface in type.Interfaces)
			{
				if (IsRedirectedType(implementedInterface.InterfaceType))
				{
					implementsProjectedInterface = true;
					break;
				}
			}

			if (!implementsProjectedInterface)
				return TypeDefinitionTreatment.NormalType;

			var allImplementedInterfaces = new HashSet<TypeReference>(new TypeReferenceEqualityComparer());
			redirectedMethods = new Collection<MethodDefinition>();
			redirectedInterfaces = new Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>>();

			foreach (var @interface in type.Interfaces)
			{
				var interfaceType = @interface.InterfaceType;

				if (IsRedirectedType(interfaceType))
				{
					allImplementedInterfaces.Add(interfaceType);
					CollectImplementedInterfaces(interfaceType, allImplementedInterfaces);
				}
			}

			foreach (var implementedInterface in type.Interfaces)
			{
				var interfaceType = implementedInterface.InterfaceType;
				if (IsRedirectedType(implementedInterface.InterfaceType))
				{
					var etype = interfaceType.GetElementType();
					var unprojectedType = new TypeReference(etype.Namespace, etype.Name, etype.Module, etype.Scope)
					{
						DeclaringType = etype.DeclaringType,
						projection = etype.projection
					};

					RemoveProjection(unprojectedType);

					var genericInstanceType = interfaceType as GenericInstanceType;
					if (genericInstanceType != null)
					{
						var genericUnprojectedType = new GenericInstanceType(unprojectedType);
						foreach (var genericArgument in genericInstanceType.GenericArguments)
							genericUnprojectedType.GenericArguments.Add(genericArgument);

						unprojectedType = genericUnprojectedType;
					}

					var unprojectedInterface = new InterfaceImplementation(unprojectedType);
					redirectedInterfaces.Add(new KeyValuePair<InterfaceImplementation, InterfaceImplementation>(implementedInterface, unprojectedInterface));
				}
			}

			// Interfaces don't inherit methods of the interfaces they implement
			if (!type.IsInterface)
			{
				foreach (var implementedInterface in allImplementedInterfaces)
				{
					RedirectInterfaceMethods(implementedInterface, redirectedMethods);
				}
			}

			return TypeDefinitionTreatment.RedirectImplementedMethods;
		}

		private static void CollectImplementedInterfaces(TypeReference type, HashSet<TypeReference> results)
		{
			var typeResolver = TypeResolver.For(type);
			var typeDef = type.Resolve();

			foreach (var implementedInterface in typeDef.Interfaces)
			{
				var interfaceType = typeResolver.Resolve(implementedInterface.InterfaceType);
				results.Add(interfaceType);
				CollectImplementedInterfaces(interfaceType, results);
			}
		}

		private static void RedirectInterfaceMethods(TypeReference interfaceType, Collection<MethodDefinition> redirectedMethods)
		{
			var typeResolver = TypeResolver.For(interfaceType);
			var typeDef = interfaceType.Resolve();

			foreach (var method in typeDef.Methods)
			{
				var redirectedMethod = new MethodDefinition(method.Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, typeResolver.Resolve(method.ReturnType));
				redirectedMethod.ImplAttributes = MethodImplAttributes.Runtime;

				foreach (var parameter in method.Parameters)
				{
					redirectedMethod.Parameters.Add(new ParameterDefinition(parameter.Name, parameter.Attributes, typeResolver.Resolve(parameter.ParameterType)));
				}

				redirectedMethod.Overrides.Add(typeResolver.Resolve(method));
				redirectedMethods.Add(redirectedMethod);
			}
		}

		private static bool IsRedirectedType(TypeReference type)
		{
			var typeRefProjection = type.GetElementType().projection as TypeReferenceProjection;
			return typeRefProjection != null && typeRefProjection.Treatment == TypeReferenceTreatment.UseProjectionInfo;
		}

		static bool NeedsWindowsRuntimePrefix(TypeDefinition type)
		{
			if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.Interface)) != TypeAttributes.Public)
				return false;

			var base_type = type.BaseType;
			if (base_type == null || base_type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;

			if (base_type.Namespace == "System")
				switch (base_type.Name)
				{
					case "Attribute":
					case "MulticastDelegate":
					case "ValueType":
						return false;
				}

			return true;
		}

		public static bool IsClrImplementationType(TypeDefinition type)
		{
			if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.SpecialName)) != TypeAttributes.SpecialName)
				return false;
			return type.Name.StartsWith("<CLR>");
		}

		public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection)
		{
			if (projection == null)
				return;

			var treatment = projection.Treatment;

			switch (treatment & TypeDefinitionTreatment.KindMask)
			{
				case TypeDefinitionTreatment.NormalType:
					type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Import;
					break;

				case TypeDefinitionTreatment.NormalAttribute:
					type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Sealed;
					break;

				case TypeDefinitionTreatment.UnmangleWindowsRuntimeName:
					type.Attributes = type.Attributes & ~TypeAttributes.SpecialName | TypeAttributes.Public;
					type.Name = type.Name.Substring("<CLR>".Length);
					break;

				case TypeDefinitionTreatment.PrefixWindowsRuntimeName:
					type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;
					type.Name = "<WinRT>" + type.Name;
					break;

				case TypeDefinitionTreatment.RedirectToClrType:
					type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;
					break;

				case TypeDefinitionTreatment.RedirectToClrAttribute:
					type.Attributes = type.Attributes & ~TypeAttributes.Public;
					break;

				case TypeDefinitionTreatment.RedirectImplementedMethods:
					{
						type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Import;

						foreach (var redirectedInterfacePair in projection.RedirectedInterfaces)
						{
							type.Interfaces.Add(redirectedInterfacePair.Value);

							foreach (var customAttribute in redirectedInterfacePair.Key.CustomAttributes)
								redirectedInterfacePair.Value.CustomAttributes.Add(customAttribute);

							redirectedInterfacePair.Key.CustomAttributes.Clear();

							foreach (var method in type.Methods)
							{
								foreach (var @override in method.Overrides)
								{
									if (TypeReferenceEqualityComparer.AreEqual(@override.DeclaringType, redirectedInterfacePair.Key.InterfaceType))
									{
										@override.DeclaringType = redirectedInterfacePair.Value.InterfaceType;
									}
								}
							}
						}

						foreach (var method in projection.RedirectedMethods)
						{
							type.Methods.Add(method);
						}
					}
					break;
			}

			if ((treatment & TypeDefinitionTreatment.Abstract) != 0)
				type.Attributes |= TypeAttributes.Abstract;

			if ((treatment & TypeDefinitionTreatment.Internal) != 0)
				type.Attributes &= ~TypeAttributes.Public;

			type.WindowsRuntimeProjection = projection;
		}

		public static TypeDefinitionProjection RemoveProjection(TypeDefinition type)
		{
			if (!type.IsWindowsRuntimeProjection)
				return null;

			var projection = type.WindowsRuntimeProjection;
			type.WindowsRuntimeProjection = null;

			type.Attributes = projection.Attributes;
			type.Name = projection.Name;

			if (projection.Treatment == TypeDefinitionTreatment.RedirectImplementedMethods)
			{
				foreach (var method in projection.RedirectedMethods)
				{
					type.Methods.Remove(method);
				}

				foreach (var redirectedInterfacePair in projection.RedirectedInterfaces)
				{
					foreach (var method in type.Methods)
					{
						foreach (var @override in method.Overrides)
						{
							if (TypeReferenceEqualityComparer.AreEqual(@override.DeclaringType, redirectedInterfacePair.Value.InterfaceType))
							{
								@override.DeclaringType = redirectedInterfacePair.Key.InterfaceType;
							}
						}
					}

					foreach (var customAttribute in redirectedInterfacePair.Value.CustomAttributes)
						redirectedInterfacePair.Key.CustomAttributes.Add(customAttribute);

					redirectedInterfacePair.Value.CustomAttributes.Clear();
					type.Interfaces.Remove(redirectedInterfacePair.Value);
				}
			}

			return projection;
		}

		public static void Project(TypeReference type)
		{
			TypeReferenceTreatment treatment;

			ProjectionInfo info;
			if (Projections.TryGetValue(type.Name, out info) && info.WinRTNamespace == type.Namespace)
				treatment = TypeReferenceTreatment.UseProjectionInfo;
			else
				treatment = GetSpecialTypeReferenceTreatment(type);

			if (treatment != TypeReferenceTreatment.None)
				ApplyProjection(type, new TypeReferenceProjection(type, treatment));
		}

		static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type)
		{
			if (type.Namespace == "System")
			{
				if (type.Name == "MulticastDelegate")
					return TypeReferenceTreatment.SystemDelegate;
				if (type.Name == "Attribute")
					return TypeReferenceTreatment.SystemAttribute;
			}

			return TypeReferenceTreatment.None;
		}

		static bool IsAttribute(TypeReference type)
		{
			if (type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;
			return type.Name == "Attribute" && type.Namespace == "System";
		}

		static bool IsEnum(TypeReference type)
		{
			if (type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;
			return type.Name == "Enum" && type.Namespace == "System";
		}

		public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection)
		{
			if (projection == null)
				return;

			switch (projection.Treatment)
			{
				case TypeReferenceTreatment.SystemDelegate:
				case TypeReferenceTreatment.SystemAttribute:
					type.Scope = type.Module.Projections.GetAssemblyReference("System.Runtime");
					break;

				case TypeReferenceTreatment.UseProjectionInfo:
					var info = Projections[type.Name];
					type.Name = info.ClrName;
					type.Namespace = info.ClrNamespace;
					type.Scope = type.Module.Projections.GetAssemblyReference(info.ClrAssembly);
					break;
			}

			type.WindowsRuntimeProjection = projection;
		}

		public static TypeReferenceProjection RemoveProjection(TypeReference type)
		{
			if (!type.IsWindowsRuntimeProjection)
				return null;

			var projection = type.WindowsRuntimeProjection;
			type.WindowsRuntimeProjection = null;

			type.Name = projection.Name;
			type.Namespace = projection.Namespace;
			type.Scope = projection.Scope;

			return projection;
		}

		public static void Project(MethodDefinition method)
		{
			var treatment = MethodDefinitionTreatment.None;
			var other = false;
			var declaring_type = method.DeclaringType;

			if (declaring_type.IsWindowsRuntime)
			{
				if (IsClrImplementationType(declaring_type))
					treatment = MethodDefinitionTreatment.None;
				else if (declaring_type.IsNested)
					treatment = MethodDefinitionTreatment.None;
				else if (declaring_type.IsInterface)
					treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
				else if (declaring_type.Module.MetadataKind == MetadataKind.ManagedWindowsMetadata && !method.IsPublic)
					treatment = MethodDefinitionTreatment.None;
				else
				{
					other = true;

					var base_type = declaring_type.BaseType;
					if (base_type != null && base_type.MetadataToken.TokenType == TokenType.TypeRef)
					{
						switch (GetSpecialTypeReferenceTreatment(base_type))
						{
							case TypeReferenceTreatment.SystemDelegate:
								treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.Public;
								other = false;
								break;

							case TypeReferenceTreatment.SystemAttribute:
								treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
								other = false;
								break;
						}
					}
				}
			}

			if (other)
			{
				var seen_redirected = false;
				var seen_non_redirected = false;

				foreach (var @override in method.Overrides)
				{
					if (@override.MetadataToken.TokenType == TokenType.MemberRef && ImplementsRedirectedInterface(@override))
					{
						seen_redirected = true;
					}
					else
					{
						seen_non_redirected = true;
					}
				}

				if (seen_redirected && !seen_non_redirected)
				{
					treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall | MethodDefinitionTreatment.Private;
					other = false;
				}
			}

			if (other)
				treatment |= GetMethodDefinitionTreatmentFromCustomAttributes(method);

			if (treatment != MethodDefinitionTreatment.None)
				ApplyProjection(method, new MethodDefinitionProjection(method, treatment));
		}

		static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method)
		{
			var treatment = MethodDefinitionTreatment.None;

			foreach (var attribute in method.CustomAttributes)
			{
				var type = attribute.AttributeType;
				if (type.Namespace != "Windows.UI.Xaml")
					continue;
				if (type.Name == "TreatAsPublicMethodAttribute")
					treatment |= MethodDefinitionTreatment.Public;
				else if (type.Name == "TreatAsAbstractMethodAttribute")
					treatment |= MethodDefinitionTreatment.Abstract;
			}

			return treatment;
		}

		public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection)
		{
			if (projection == null)
				return;

			var treatment = projection.Treatment;

			if ((treatment & MethodDefinitionTreatment.Abstract) != 0)
				method.Attributes |= MethodAttributes.Abstract;

			if ((treatment & MethodDefinitionTreatment.Private) != 0)
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Private;

			if ((treatment & MethodDefinitionTreatment.Public) != 0)
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Public;

			if ((treatment & MethodDefinitionTreatment.Runtime) != 0)
				method.ImplAttributes |= MethodImplAttributes.Runtime;

			if ((treatment & MethodDefinitionTreatment.InternalCall) != 0)
				method.ImplAttributes |= MethodImplAttributes.InternalCall;

			method.WindowsRuntimeProjection = projection;
		}

		public static MethodDefinitionProjection RemoveProjection(MethodDefinition method)
		{
			if (!method.IsWindowsRuntimeProjection)
				return null;

			var projection = method.WindowsRuntimeProjection;
			method.WindowsRuntimeProjection = null;

			method.Attributes = projection.Attributes;
			method.ImplAttributes = projection.ImplAttributes;
			method.Name = projection.Name;

			return projection;
		}

		public static void Project(FieldDefinition field)
		{
			var treatment = FieldDefinitionTreatment.None;
			var declaring_type = field.DeclaringType;

			if (declaring_type.Module.MetadataKind == MetadataKind.WindowsMetadata && field.IsRuntimeSpecialName && field.Name == "value__")
			{
				var base_type = declaring_type.BaseType;
				if (base_type != null && IsEnum(base_type))
					treatment = FieldDefinitionTreatment.Public;
			}

			if (treatment != FieldDefinitionTreatment.None)
				ApplyProjection(field, new FieldDefinitionProjection(field, treatment));
		}

		public static void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection)
		{
			if (projection == null)
				return;

			if (projection.Treatment == FieldDefinitionTreatment.Public)
				field.Attributes = (field.Attributes & ~FieldAttributes.FieldAccessMask) | FieldAttributes.Public;

			field.WindowsRuntimeProjection = projection;
		}

		public static FieldDefinitionProjection RemoveProjection(FieldDefinition field)
		{
			if (!field.IsWindowsRuntimeProjection)
				return null;

			var projection = field.WindowsRuntimeProjection;
			field.WindowsRuntimeProjection = null;

			field.Attributes = projection.Attributes;

			return projection;
		}

		static bool ImplementsRedirectedInterface(MemberReference member)
		{
			var declaring_type = member.DeclaringType;
			TypeReference type;
			switch (declaring_type.MetadataToken.TokenType)
			{
				case TokenType.TypeRef:
					type = declaring_type;
					break;

				case TokenType.TypeSpec:
					if (!declaring_type.IsGenericInstance)
						return false;

					type = ((TypeSpecification)declaring_type).ElementType;
					if (type.MetadataType != MetadataType.Class || type.MetadataToken.TokenType != TokenType.TypeRef)
						return false;

					break;

				default:
					return false;
			}

			var projection = RemoveProjection(type);

			var found = false;

			ProjectionInfo info;
			if (Projections.TryGetValue(type.Name, out info) && type.Namespace == info.WinRTNamespace)
			{
				found = true;
			}

			ApplyProjection(type, projection);

			return found;
		}


		public void AddVirtualReferences(Collection<AssemblyNameReference> references)
		{
			var corlib = GetCoreLibrary(references);
			corlib_version = corlib.Version;
			corlib.Version = version;

			if (virtual_references == null)
			{
				var winrt_references = GetAssemblyReferences(corlib);
				Interlocked.CompareExchange(ref virtual_references, winrt_references, null);
			}

			foreach (var reference in virtual_references)
				references.Add(reference);
		}

		public void RemoveVirtualReferences(Collection<AssemblyNameReference> references)
		{
			var corlib = GetCoreLibrary(references);
			corlib.Version = corlib_version;

			foreach (var reference in VirtualReferences)
				references.Remove(reference);
		}

		static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib)
		{
			var system_runtime = new AssemblyNameReference("System.Runtime", version);
			var system_runtime_interopservices_windowsruntime = new AssemblyNameReference("System.Runtime.InteropServices.WindowsRuntime", version);
			var system_objectmodel = new AssemblyNameReference("System.ObjectModel", version);
			var system_runtime_windowsruntime = new AssemblyNameReference("System.Runtime.WindowsRuntime", version);
			var system_runtime_windowsruntime_ui_xaml = new AssemblyNameReference("System.Runtime.WindowsRuntime.UI.Xaml", version);
			var system_numerics_vectors = new AssemblyNameReference("System.Numerics.Vectors", version);

			if (corlib.HasPublicKey)
			{
				system_runtime_windowsruntime.PublicKey =
				system_runtime_windowsruntime_ui_xaml.PublicKey = corlib.PublicKey;

				system_runtime.PublicKey =
				system_runtime_interopservices_windowsruntime.PublicKey =
				system_objectmodel.PublicKey =
				system_numerics_vectors.PublicKey = contract_pk;
			}
			else
			{
				system_runtime_windowsruntime.PublicKeyToken =
				system_runtime_windowsruntime_ui_xaml.PublicKeyToken = corlib.PublicKeyToken;

				system_runtime.PublicKeyToken =
				system_runtime_interopservices_windowsruntime.PublicKeyToken =
				system_objectmodel.PublicKeyToken =
				system_numerics_vectors.PublicKeyToken = contract_pk_token;
			}

			return new[] {
				system_runtime,
				system_runtime_interopservices_windowsruntime,
				system_objectmodel,
				system_runtime_windowsruntime,
				system_runtime_windowsruntime_ui_xaml,
				system_numerics_vectors,
			};
		}

		static AssemblyNameReference GetCoreLibrary(Collection<AssemblyNameReference> references)
		{
			foreach (var reference in references)
				if (reference.Name == "mscorlib")
					return reference;

			throw new BadImageFormatException("Missing mscorlib reference in AssemblyRef table.");
		}

		AssemblyNameReference GetAssemblyReference(string name)
		{
			foreach (var assembly in VirtualReferences)
				if (assembly.Name == name)
					return assembly;

			throw new Exception();
		}

		public static void Project(ICustomAttributeProvider owner, CustomAttribute attribute)
		{
			if (!IsWindowsAttributeUsageAttribute(owner, attribute))
				return;

			var treatment = CustomAttributeValueTreatment.None;
			var type = (TypeDefinition)owner;

			if (type.Namespace == "Windows.Foundation.Metadata")
			{
				if (type.Name == "VersionAttribute")
					treatment = CustomAttributeValueTreatment.VersionAttribute;
				else if (type.Name == "DeprecatedAttribute")
					treatment = CustomAttributeValueTreatment.DeprecatedAttribute;
			}

			if (treatment == CustomAttributeValueTreatment.None)
			{
				var multiple = HasAttribute(type, "Windows.Foundation.Metadata", "AllowMultipleAttribute");
				treatment = multiple ? CustomAttributeValueTreatment.AllowMultiple : CustomAttributeValueTreatment.AllowSingle;
			}

			if (treatment != CustomAttributeValueTreatment.None)
			{
				var attribute_targets = (AttributeTargets)attribute.ConstructorArguments[0].Value;
				ApplyProjection(attribute, new CustomAttributeValueProjection(attribute_targets, treatment));
			}
		}

		static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute)
		{
			if (owner.MetadataToken.TokenType != TokenType.TypeDef)
				return false;

			var constructor = attribute.Constructor;

			if (constructor.MetadataToken.TokenType != TokenType.MemberRef)
				return false;

			var declaring_type = constructor.DeclaringType;

			if (declaring_type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;

			// declaring type is already projected
			return declaring_type.Name == "AttributeUsageAttribute" && declaring_type.Namespace == /*"Windows.Foundation.Metadata"*/"System";
		}

		static bool HasAttribute(TypeDefinition type, string @namespace, string name)
		{
			foreach (var attribute in type.CustomAttributes)
			{
				var attribute_type = attribute.AttributeType;
				if (attribute_type.Name == name && attribute_type.Namespace == @namespace)
					return true;
			}
			return false;
		}

		public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection)
		{
			if (projection == null)
				return;

			bool version_or_deprecated;
			bool multiple;

			switch (projection.Treatment)
			{
				case CustomAttributeValueTreatment.AllowSingle:
					version_or_deprecated = false;
					multiple = false;
					break;

				case CustomAttributeValueTreatment.AllowMultiple:
					version_or_deprecated = false;
					multiple = true;
					break;

				case CustomAttributeValueTreatment.VersionAttribute:
				case CustomAttributeValueTreatment.DeprecatedAttribute:
					version_or_deprecated = true;
					multiple = true;
					break;

				default:
					throw new ArgumentException();
			}

			var attribute_targets = (AttributeTargets)attribute.ConstructorArguments[0].Value;
			if (version_or_deprecated)
				attribute_targets |= AttributeTargets.Constructor | AttributeTargets.Property;
			attribute.ConstructorArguments[0] = new CustomAttributeArgument(attribute.ConstructorArguments[0].Type, attribute_targets);

			attribute.Properties.Add(new CustomAttributeNamedArgument("AllowMultiple", new CustomAttributeArgument(attribute.Module.TypeSystem.Boolean, multiple)));

			attribute.projection = projection;
		}

		public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute)
		{
			if (attribute.projection == null)
				return null;

			var projection = attribute.projection;
			attribute.projection = null;

			attribute.ConstructorArguments[0] = new CustomAttributeArgument(attribute.ConstructorArguments[0].Type, projection.Targets);
			attribute.Properties.Clear();

			return projection;
		}
	}
}
